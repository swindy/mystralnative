var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};

// ../../src/core/debug/components/Panel.ts
class Panel {
  element;
  summary;
  content;
  title;
  isOpen = false;
  constructor(title, options = {}) {
    this.title = title;
    this.isOpen = options.defaultOpen ?? false;
    this.element = document.createElement("details");
    this.element.style.marginTop = "8px";
    this.element.style.borderTop = "1px solid #555";
    this.element.style.paddingTop = "4px";
    if (this.isOpen) {
      this.element.open = true;
    }
    this.summary = document.createElement("summary");
    this.summary.style.cursor = "pointer";
    this.summary.style.fontWeight = "bold";
    this.summary.style.marginBottom = "4px";
    this.summary.style.outline = "none";
    this.summary.style.display = "flex";
    this.summary.style.justifyContent = "space-between";
    this.summary.style.alignItems = "center";
    this.summary.style.userSelect = "none";
    const titleSpan = document.createElement("span");
    titleSpan.innerText = title;
    this.summary.appendChild(titleSpan);
    if (options.showRefresh && options.onRefresh) {
      const refreshBtn = document.createElement("button");
      refreshBtn.innerText = "Refresh";
      refreshBtn.style.fontSize = "10px";
      refreshBtn.style.marginLeft = "10px";
      refreshBtn.style.padding = "2px 6px";
      refreshBtn.style.cursor = "pointer";
      refreshBtn.onclick = (e) => {
        e.stopPropagation();
        options.onRefresh?.();
      };
      this.summary.appendChild(refreshBtn);
    }
    this.element.appendChild(this.summary);
    this.content = document.createElement("div");
    this.content.style.marginTop = "5px";
    this.content.style.fontSize = "11px";
    this.content.style.paddingLeft = "4px";
    this.element.appendChild(this.content);
    this.element.addEventListener("toggle", () => {
      this.isOpen = this.element.open;
      this.onToggle(this.isOpen);
    });
  }
  onToggle(isOpen) {}
  getElement() {
    return this.element;
  }
  setOpen(open) {
    this.element.open = open;
    this.isOpen = open;
  }
  update() {}
  cleanup() {}
}

// ../../src/core/debug/panels/PerformancePanel.ts
class PerformancePanel extends Panel {
  canvas;
  ctx;
  triangleInfo;
  history = [];
  maxHistory = 60;
  currentFps = 0;
  frameTriangles = 0;
  sceneTriangles = 0;
  gpuDraws = 0;
  gpuTriangles = 0;
  constructor() {
    super("Performance", { defaultOpen: false });
    this.canvas = document.createElement("canvas");
    this.canvas.width = 120;
    this.canvas.height = 40;
    this.canvas.style.display = "block";
    this.canvas.style.backgroundColor = "#222";
    this.canvas.style.marginBottom = "5px";
    this.canvas.style.borderRadius = "3px";
    this.content.appendChild(this.canvas);
    this.ctx = this.canvas.getContext("2d");
    this.triangleInfo = document.createElement("div");
    this.content.appendChild(this.triangleInfo);
    this.updateStats();
  }
  setFps(fps) {
    this.currentFps = fps;
    this.history.push(fps);
    if (this.history.length > this.maxHistory) {
      this.history.shift();
    }
  }
  setFrameTriangles(count) {
    this.frameTriangles = count;
  }
  setSceneTriangles(count) {
    this.sceneTriangles = count;
  }
  setGpuStats(draws, triangles) {
    this.gpuDraws = draws;
    this.gpuTriangles = triangles;
  }
  update() {
    if (!this.isOpen)
      return;
    this.drawGraph();
    this.updateStats();
  }
  drawGraph() {
    if (!this.ctx)
      return;
    const ctx = this.ctx;
    const w = this.canvas.width;
    const h = this.canvas.height;
    ctx.clearRect(0, 0, w, h);
    const maxFps = Math.max(60, ...this.history);
    ctx.fillStyle = "#4CAF50";
    const barWidth = w / this.maxHistory;
    for (let i = 0;i < this.history.length; i++) {
      const fps = this.history[i];
      const height = fps / maxFps * h;
      const x = i * barWidth;
      const y = h - height;
      if (fps < 30) {
        ctx.fillStyle = "#f44336";
      } else if (fps < 50) {
        ctx.fillStyle = "#ff9800";
      } else {
        ctx.fillStyle = "#4CAF50";
      }
      ctx.fillRect(x, y, barWidth - 1, height);
    }
    ctx.strokeStyle = "#666";
    ctx.setLineDash([2, 2]);
    ctx.beginPath();
    const y60 = h - 60 / maxFps * h;
    ctx.moveTo(0, y60);
    ctx.lineTo(w, y60);
    ctx.stroke();
    ctx.setLineDash([]);
  }
  updateStats() {
    this.triangleInfo.innerHTML = `
      <div style="margin-bottom: 2px;">CPU Tris: ${this.formatNumber(this.frameTriangles)}</div>
      <div style="margin-bottom: 2px;">Scene Tris: ${this.formatNumber(this.sceneTriangles)}</div>
      <div style="border-top: 1px solid #444; margin-top: 2px; padding-top: 2px;">
        <div style="color: #8f8;">GPU Draws: ${this.formatNumber(this.gpuDraws)}</div>
        <div style="color: #8f8;">GPU Tris: ${this.formatNumber(this.gpuTriangles)}</div>
      </div>
    `;
  }
  formatNumber(num) {
    if (num >= 1e6)
      return (num / 1e6).toFixed(1) + "M";
    if (num >= 1000)
      return (num / 1000).toFixed(1) + "k";
    return num.toString();
  }
  getFps() {
    return this.currentFps;
  }
}

// ../../src/core/debug/components/CopyButton.ts
function createCopyButton(label, getText, options = {}) {
  const btn = document.createElement("button");
  btn.innerText = label;
  btn.style.fontSize = "9px";
  btn.style.padding = "2px 6px";
  btn.style.cursor = "pointer";
  btn.style.backgroundColor = "#333";
  btn.style.color = "#fff";
  btn.style.border = "1px solid #555";
  btn.style.borderRadius = "3px";
  if (options.fullWidth) {
    btn.style.width = "100%";
  }
  btn.onmouseenter = () => {
    btn.style.backgroundColor = "#444";
  };
  btn.onmouseleave = () => {
    btn.style.backgroundColor = "#333";
  };
  btn.onclick = (e) => {
    e.stopPropagation();
    const text = getText();
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(text).then(() => {
        showSuccess();
      }).catch(() => {
        fallbackCopy(text);
      });
    } else {
      fallbackCopy(text);
    }
  };
  function fallbackCopy(text) {
    const textArea = document.createElement("textarea");
    textArea.value = text;
    textArea.style.position = "fixed";
    textArea.style.left = "-9999px";
    document.body.appendChild(textArea);
    textArea.select();
    try {
      document.execCommand("copy");
      showSuccess();
    } catch (err) {
      console.error("Copy failed:", err);
      showError();
    }
    document.body.removeChild(textArea);
  }
  function showSuccess() {
    const originalText = btn.innerText;
    btn.innerText = "✓";
    btn.style.color = "#4f4";
    setTimeout(() => {
      btn.innerText = originalText;
      btn.style.color = "#fff";
    }, 1500);
  }
  function showError() {
    const originalText = btn.innerText;
    btn.innerText = "✗";
    btn.style.color = "#f44";
    setTimeout(() => {
      btn.innerText = originalText;
      btn.style.color = "#fff";
    }, 1500);
  }
  return btn;
}

// ../../src/math/Vector3.ts
class Vector3 {
  x;
  y;
  z;
  constructor(x = 0, y = 0, z = 0) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  static get zero() {
    return new Vector3(0, 0, 0);
  }
  static get one() {
    return new Vector3(1, 1, 1);
  }
  static get up() {
    return new Vector3(0, 1, 0);
  }
  static get down() {
    return new Vector3(0, -1, 0);
  }
  static get right() {
    return new Vector3(1, 0, 0);
  }
  static get left() {
    return new Vector3(-1, 0, 0);
  }
  static get forward() {
    return new Vector3(0, 0, -1);
  }
  static get back() {
    return new Vector3(0, 0, 1);
  }
  static min(a, b) {
    return new Vector3(Math.min(a.x, b.x), Math.min(a.y, b.y), Math.min(a.z, b.z));
  }
  static max(a, b) {
    return new Vector3(Math.max(a.x, b.x), Math.max(a.y, b.y), Math.max(a.z, b.z));
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    return this;
  }
  add(v) {
    return new Vector3(this.x + v.x, this.y + v.y, this.z + v.z);
  }
  subtract(v) {
    return new Vector3(this.x - v.x, this.y - v.y, this.z - v.z);
  }
  multiply(scalar) {
    return new Vector3(this.x * scalar, this.y * scalar, this.z * scalar);
  }
  multiplyScalar(scalar) {
    return this.multiply(scalar);
  }
  divide(scalar) {
    if (scalar === 0) {
      throw new Error("Cannot divide by zero");
    }
    return new Vector3(this.x / scalar, this.y / scalar, this.z / scalar);
  }
  magnitude() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  magnitudeSquared() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  normalize() {
    const mag = this.magnitude();
    if (mag === 0) {
      return Vector3.zero;
    }
    return this.divide(mag);
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  }
  cross(v) {
    return new Vector3(this.y * v.z - this.z * v.y, this.z * v.x - this.x * v.z, this.x * v.y - this.y * v.x);
  }
  distanceTo(v) {
    return this.subtract(v).magnitude();
  }
  distanceToSquared(v) {
    return this.subtract(v).magnitudeSquared();
  }
  clampMagnitude(maxMagnitude) {
    const mag = this.magnitude();
    if (mag > maxMagnitude) {
      return this.normalize().multiply(maxMagnitude);
    }
    return this.clone();
  }
  lerp(v, t) {
    return this.add(v.subtract(this).multiply(t));
  }
  slerp(v, t) {
    const dot = this.dot(v);
    const theta = Math.acos(Math.max(-1, Math.min(1, dot)));
    const sinTheta = Math.sin(theta);
    if (sinTheta === 0) {
      return this.lerp(v, t);
    }
    const a = Math.sin((1 - t) * theta) / sinTheta;
    const b = Math.sin(t * theta) / sinTheta;
    return this.multiply(a).add(v.multiply(b));
  }
  reflect(normal) {
    return this.subtract(normal.multiply(2 * this.dot(normal)));
  }
  projectOn(v) {
    const vMagSq = v.magnitudeSquared();
    if (vMagSq === 0) {
      return Vector3.zero;
    }
    return v.multiply(this.dot(v) / vMagSq);
  }
  angleTo(v) {
    const dotProduct = this.dot(v);
    const magProduct = this.magnitude() * v.magnitude();
    if (magProduct === 0) {
      return 0;
    }
    return Math.acos(Math.max(-1, Math.min(1, dotProduct / magProduct)));
  }
  equals(v, epsilon = 0.000001) {
    return Math.abs(this.x - v.x) < epsilon && Math.abs(this.y - v.y) < epsilon && Math.abs(this.z - v.z) < epsilon;
  }
  clone() {
    return new Vector3(this.x, this.y, this.z);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
  }
  set(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }
  toString() {
    return `Vector3(${this.x.toFixed(3)}, ${this.y.toFixed(3)}, ${this.z.toFixed(3)})`;
  }
  toArray() {
    return [this.x, this.y, this.z];
  }
  static fromArray(array) {
    return new Vector3(array[0], array[1], array[2]);
  }
  applyMatrix4(m) {
    const x = this.x, y = this.y, z = this.z;
    const e = m.elements;
    const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
    return this;
  }
}

// ../../src/core/debug/components/NumberInput.ts
function createNumberInput(initialValue, options = {}) {
  const {
    min = -Infinity,
    max = Infinity,
    step = 0.1,
    precision = 2,
    label,
    width = "60px",
    onChange
  } = options;
  const container = document.createElement("div");
  container.style.display = "flex";
  container.style.alignItems = "center";
  container.style.gap = "4px";
  if (label) {
    const labelEl = document.createElement("span");
    labelEl.innerText = label;
    labelEl.style.fontSize = "10px";
    labelEl.style.color = "#aaa";
    labelEl.style.minWidth = "20px";
    container.appendChild(labelEl);
  }
  const input = document.createElement("input");
  input.type = "number";
  input.value = initialValue.toFixed(precision);
  input.style.width = width;
  input.style.fontSize = "10px";
  input.style.padding = "2px 4px";
  input.style.backgroundColor = "#222";
  input.style.color = "#fff";
  input.style.border = "1px solid #555";
  input.style.borderRadius = "3px";
  input.step = step.toString();
  if (min !== -Infinity)
    input.min = min.toString();
  if (max !== Infinity)
    input.max = max.toString();
  let currentValue = initialValue;
  input.oninput = () => {
    const val = parseFloat(input.value);
    if (!isNaN(val)) {
      currentValue = Math.max(min, Math.min(max, val));
      onChange?.(currentValue);
    }
  };
  input.onblur = () => {
    input.value = currentValue.toFixed(precision);
  };
  input.onkeydown = (e) => {
    if (e.key === "ArrowUp") {
      e.preventDefault();
      currentValue = Math.min(max, currentValue + step);
      input.value = currentValue.toFixed(precision);
      onChange?.(currentValue);
    } else if (e.key === "ArrowDown") {
      e.preventDefault();
      currentValue = Math.max(min, currentValue - step);
      input.value = currentValue.toFixed(precision);
      onChange?.(currentValue);
    }
  };
  container.appendChild(input);
  return {
    element: container,
    getValue: () => currentValue,
    setValue: (v) => {
      currentValue = Math.max(min, Math.min(max, v));
      input.value = currentValue.toFixed(precision);
    }
  };
}

// ../../src/core/debug/components/Vector3Input.ts
function createVector3Input(initialValue, options = {}) {
  const {
    precision = 2,
    step = 0.1,
    labels = { x: "X", y: "Y", z: "Z" },
    colors = { x: "#ff6666", y: "#66ff66", z: "#6666ff" },
    onChange
  } = options;
  const container = document.createElement("div");
  container.style.display = "flex";
  container.style.gap = "4px";
  container.style.alignItems = "center";
  const currentValue = new Vector3(initialValue.x, initialValue.y, initialValue.z);
  const createAxisInput = (axis) => {
    const axisContainer = document.createElement("div");
    axisContainer.style.display = "flex";
    axisContainer.style.alignItems = "center";
    axisContainer.style.gap = "2px";
    const label = document.createElement("span");
    label.innerText = labels[axis] || axis.toUpperCase();
    label.style.fontSize = "10px";
    label.style.color = colors[axis] || "#fff";
    label.style.fontWeight = "bold";
    label.style.minWidth = "12px";
    axisContainer.appendChild(label);
    const inputOpts = {
      precision,
      step,
      width: "55px",
      onChange: (val) => {
        currentValue[axis] = val;
        onChange?.(currentValue.clone());
      }
    };
    const input = createNumberInput(initialValue[axis], inputOpts);
    axisContainer.appendChild(input.element);
    return { container: axisContainer, input };
  };
  const xInput = createAxisInput("x");
  const yInput = createAxisInput("y");
  const zInput = createAxisInput("z");
  container.appendChild(xInput.container);
  container.appendChild(yInput.container);
  container.appendChild(zInput.container);
  return {
    element: container,
    getValue: () => currentValue.clone(),
    setValue: (v) => {
      currentValue.x = v.x;
      currentValue.y = v.y;
      currentValue.z = v.z;
      xInput.input.setValue(v.x);
      yInput.input.setValue(v.y);
      zInput.input.setValue(v.z);
    }
  };
}

// ../../src/math/Matrix4.ts
class Matrix4 {
  elements;
  constructor(elements) {
    this.elements = new Float32Array(elements || [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ]);
  }
  static get identity() {
    return new Matrix4;
  }
  static zero() {
    return new Matrix4([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
  }
  copy(m) {
    this.elements.set(m.elements);
    return this;
  }
  clone() {
    return new Matrix4(Array.from(this.elements));
  }
  multiply(m) {
    return this.multiplyMatrices(this, m);
  }
  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
    const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
    const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
    const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
    const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
    const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
    const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
    const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }
  transpose() {
    const te = this.elements;
    let tmp;
    tmp = te[1];
    te[1] = te[4];
    te[4] = tmp;
    tmp = te[2];
    te[2] = te[8];
    te[8] = tmp;
    tmp = te[3];
    te[3] = te[12];
    te[12] = tmp;
    tmp = te[6];
    te[6] = te[9];
    te[9] = tmp;
    tmp = te[7];
    te[7] = te[13];
    te[13] = tmp;
    tmp = te[11];
    te[11] = te[14];
    te[14] = tmp;
    return this;
  }
  determinant() {
    const te = this.elements;
    const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
    const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
    const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
    const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  }
  inverse() {
    const te = this.elements;
    const n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3];
    const n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7];
    const n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11];
    const n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15];
    const t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
    const t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
    const t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
    const t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (Math.abs(det) < 0.0000000001) {
      console.warn("Matrix4.inverse(): Can not invert matrix, determinant is too small:", det);
      return this.identity();
    }
    const detInv = 1 / det;
    const out = this.elements;
    out[0] = t11 * detInv;
    out[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    out[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    out[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    out[4] = t12 * detInv;
    out[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    out[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    out[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    out[8] = t13 * detInv;
    out[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    out[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    out[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    out[12] = t14 * detInv;
    out[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    out[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    out[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  }
  invert() {
    return this.inverse();
  }
  identity() {
    this.elements.set([
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ]);
    return this;
  }
  makeTranslation(v) {
    this.elements.set([
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      v.x,
      v.y,
      v.z,
      1
    ]);
    return this;
  }
  makeRotationFromAxisAngle(axis, angle) {
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    const t = 1 - c;
    const { x, y, z } = axis;
    const tx = t * x, ty = t * y;
    this.elements.set([
      tx * x + c,
      tx * y - s * z,
      tx * z + s * y,
      0,
      tx * y + s * z,
      ty * y + c,
      ty * z - s * x,
      0,
      tx * z - s * y,
      ty * z + s * x,
      t * z * z + c,
      0,
      0,
      0,
      0,
      1
    ]);
    return this;
  }
  makeRotationX(angle) {
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    this.elements.set([
      1,
      0,
      0,
      0,
      0,
      c,
      -s,
      0,
      0,
      s,
      c,
      0,
      0,
      0,
      0,
      1
    ]);
    return this;
  }
  makeRotationY(angle) {
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    this.elements.set([
      c,
      0,
      s,
      0,
      0,
      1,
      0,
      0,
      -s,
      0,
      c,
      0,
      0,
      0,
      0,
      1
    ]);
    return this;
  }
  makeRotationZ(angle) {
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    this.elements.set([
      c,
      -s,
      0,
      0,
      s,
      c,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ]);
    return this;
  }
  makeScale(v) {
    this.elements.set([
      v.x,
      0,
      0,
      0,
      0,
      v.y,
      0,
      0,
      0,
      0,
      v.z,
      0,
      0,
      0,
      0,
      1
    ]);
    return this;
  }
  makePerspective(fov, aspect, near, far) {
    const f = 1 / Math.tan(fov / 2);
    this.elements.set([
      f / aspect,
      0,
      0,
      0,
      0,
      f,
      0,
      0,
      0,
      0,
      far / (near - far),
      -1,
      0,
      0,
      far * near / (near - far),
      0
    ]);
    return this;
  }
  makeOrthographic(left, right, top, bottom, near, far) {
    const te = this.elements;
    const w = 1 / (right - left);
    const h = 1 / (top - bottom);
    const p = 1 / (far - near);
    te[0] = 2 * w;
    te[1] = 0;
    te[2] = 0;
    te[3] = 0;
    te[4] = 0;
    te[5] = 2 * h;
    te[6] = 0;
    te[7] = 0;
    te[8] = 0;
    te[9] = 0;
    te[10] = -p;
    te[11] = 0;
    te[12] = -(right + left) * w;
    te[13] = -(top + bottom) * h;
    te[14] = -near * p;
    te[15] = 1;
    return this;
  }
  lookAt(eye, target, up) {
    const ze = eye.subtract(target).normalize();
    let xe = up.cross(ze);
    if (xe.magnitudeSquared() < 0.000001) {
      if (Math.abs(up.z) < 0.999) {
        xe = new Vector3(0, 0, 1).cross(ze);
      } else {
        xe = new Vector3(1, 0, 0).cross(ze);
      }
    }
    xe = xe.normalize();
    const ye = ze.cross(xe);
    const te = this.elements;
    te[0] = xe.x;
    te[4] = xe.y;
    te[8] = xe.z;
    te[12] = -xe.dot(eye);
    te[1] = ye.x;
    te[5] = ye.y;
    te[9] = ye.z;
    te[13] = -ye.dot(eye);
    te[2] = ze.x;
    te[6] = ze.y;
    te[10] = ze.z;
    te[14] = -ze.dot(eye);
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  }
  decompose() {
    const te = this.elements;
    const sx = Math.sqrt(te[0] * te[0] + te[1] * te[1] + te[2] * te[2]);
    const sy = Math.sqrt(te[4] * te[4] + te[5] * te[5] + te[6] * te[6]);
    const sz = Math.sqrt(te[8] * te[8] + te[9] * te[9] + te[10] * te[10]);
    const scale = new Vector3(sx, sy, sz);
    const position = new Vector3(te[12], te[13], te[14]);
    const rotation = this.clone();
    const invScaleX = 1 / sx;
    const invScaleY = 1 / sy;
    const invScaleZ = 1 / sz;
    rotation.elements[0] *= invScaleX;
    rotation.elements[1] *= invScaleX;
    rotation.elements[2] *= invScaleX;
    rotation.elements[4] *= invScaleY;
    rotation.elements[5] *= invScaleY;
    rotation.elements[6] *= invScaleY;
    rotation.elements[8] *= invScaleZ;
    rotation.elements[9] *= invScaleZ;
    rotation.elements[10] *= invScaleZ;
    return { position, rotation, scale };
  }
  compose(position, rotation, scale) {
    const te = this.elements;
    te[0] = rotation.elements[0] * scale.x;
    te[1] = rotation.elements[1] * scale.x;
    te[2] = rotation.elements[2] * scale.x;
    te[3] = 0;
    te[4] = rotation.elements[4] * scale.y;
    te[5] = rotation.elements[5] * scale.y;
    te[6] = rotation.elements[6] * scale.y;
    te[7] = 0;
    te[8] = rotation.elements[8] * scale.z;
    te[9] = rotation.elements[9] * scale.z;
    te[10] = rotation.elements[10] * scale.z;
    te[11] = 0;
    te[12] = position.x;
    te[13] = position.y;
    te[14] = position.z;
    te[15] = 1;
    return this;
  }
  equals(m, epsilon = 0.000001) {
    const te = this.elements;
    const me = m.elements;
    for (let i = 0;i < 16; i++) {
      if (Math.abs(te[i] - me[i]) > epsilon) {
        return false;
      }
    }
    return true;
  }
  toString() {
    const te = this.elements;
    return `Matrix4(
  ${te[0].toFixed(3)}, ${te[4].toFixed(3)}, ${te[8].toFixed(3)}, ${te[12].toFixed(3)},
  ${te[1].toFixed(3)}, ${te[5].toFixed(3)}, ${te[9].toFixed(3)}, ${te[13].toFixed(3)},
  ${te[2].toFixed(3)}, ${te[6].toFixed(3)}, ${te[10].toFixed(3)}, ${te[14].toFixed(3)},
  ${te[3].toFixed(3)}, ${te[7].toFixed(3)}, ${te[11].toFixed(3)}, ${te[15].toFixed(3)}
)`;
  }
  transformVector(v) {
    const te = this.elements;
    const { x, y, z } = v;
    return new Vector3(te[0] * x + te[4] * y + te[8] * z + te[12], te[1] * x + te[5] * y + te[9] * z + te[13], te[2] * x + te[6] * y + te[10] * z + te[14]);
  }
  transformDirection(v) {
    const te = this.elements;
    const { x, y, z } = v;
    return new Vector3(te[0] * x + te[4] * y + te[8] * z, te[1] * x + te[5] * y + te[9] * z, te[2] * x + te[6] * y + te[10] * z);
  }
  toArray() {
    return this.elements.slice();
  }
}

// ../../src/math/Quaternion.ts
class Quaternion {
  x;
  y;
  z;
  w;
  constructor(x = 0, y = 0, z = 0, w = 1) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  static get identity() {
    return new Quaternion(0, 0, 0, 1);
  }
  copy(q) {
    this.x = q.x;
    this.y = q.y;
    this.z = q.z;
    this.w = q.w;
    return this;
  }
  clone() {
    return new Quaternion(this.x, this.y, this.z, this.w);
  }
  multiply(q) {
    return this.multiplyQuaternions(this.clone(), q);
  }
  multiplyQuaternions(a, b) {
    const { x: qax, y: qay, z: qaz, w: qaw } = a;
    const { x: qbx, y: qby, z: qbz, w: qbw } = b;
    this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    return this;
  }
  slerp(qb, t) {
    if (t === 0)
      return this;
    if (t === 1) {
      this.x = qb.x;
      this.y = qb.y;
      this.z = qb.z;
      this.w = qb.w;
      return this;
    }
    const x = this.x, y = this.y, z = this.z, w = this.w;
    let cosHalfTheta = w * qb.w + x * qb.x + y * qb.y + z * qb.z;
    let { w: qbw, x: qbx, y: qby, z: qbz } = qb;
    if (cosHalfTheta < 0) {
      qbw = -qb.w;
      qbx = -qb.x;
      qby = -qb.y;
      qbz = -qb.z;
      cosHalfTheta = -cosHalfTheta;
    }
    if (cosHalfTheta >= 1) {
      return this;
    }
    const sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta;
    const ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    this.x = x * ratioA + qbx * ratioB;
    this.y = y * ratioA + qby * ratioB;
    this.z = z * ratioA + qbz * ratioB;
    this.w = w * ratioA + qbw * ratioB;
    return this;
  }
  lerp(qb, t) {
    return new Quaternion(this.x + (qb.x - this.x) * t, this.y + (qb.y - this.y) * t, this.z + (qb.z - this.z) * t, this.w + (qb.w - this.w) * t);
  }
  equals(q, epsilon = 0.000001) {
    const directMatch = Math.abs(this.x - q.x) < epsilon && Math.abs(this.y - q.y) < epsilon && Math.abs(this.z - q.z) < epsilon && Math.abs(this.w - q.w) < epsilon;
    const inverseMatch = Math.abs(this.x + q.x) < epsilon && Math.abs(this.y + q.y) < epsilon && Math.abs(this.z + q.z) < epsilon && Math.abs(this.w + q.w) < epsilon;
    return directMatch || inverseMatch;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  lengthSquared() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  normalize() {
    let length = this.length();
    if (length === 0) {
      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.w = 1;
    } else {
      length = 1 / length;
      this.x *= length;
      this.y *= length;
      this.z *= length;
      this.w *= length;
    }
    return this;
  }
  inverse() {
    return new Quaternion(-this.x, -this.y, -this.z, this.w).normalize();
  }
  conjugate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
  }
  setFromAxisAngle(axis, angle) {
    const normAxis = axis.normalize();
    const halfAngle = angle / 2;
    const s = Math.sin(halfAngle);
    this.x = normAxis.x * s;
    this.y = normAxis.y * s;
    this.z = normAxis.z * s;
    this.w = Math.cos(halfAngle);
    return this;
  }
  setFromEuler(xOrEuler, yOrOrder, z, order) {
    let x, y, zVal, eulerOrder;
    if (typeof xOrEuler === "object") {
      x = xOrEuler.x;
      y = xOrEuler.y;
      zVal = xOrEuler.z;
      eulerOrder = yOrOrder ?? "XYZ";
    } else {
      x = xOrEuler;
      y = yOrOrder;
      zVal = z;
      eulerOrder = order ?? "XYZ";
    }
    const c1 = Math.cos(x / 2);
    const c2 = Math.cos(y / 2);
    const c3 = Math.cos(zVal / 2);
    const s1 = Math.sin(x / 2);
    const s2 = Math.sin(y / 2);
    const s3 = Math.sin(zVal / 2);
    switch (eulerOrder) {
      case "XYZ":
        this.x = s1 * c2 * c3 + c1 * s2 * s3;
        this.y = c1 * s2 * c3 - s1 * c2 * s3;
        this.z = c1 * c2 * s3 + s1 * s2 * c3;
        this.w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "YXZ":
        this.x = s1 * c2 * c3 + c1 * s2 * s3;
        this.y = c1 * s2 * c3 - s1 * c2 * s3;
        this.z = c1 * c2 * s3 - s1 * s2 * c3;
        this.w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "ZXY":
        this.x = s1 * c2 * c3 - c1 * s2 * s3;
        this.y = c1 * s2 * c3 + s1 * c2 * s3;
        this.z = c1 * c2 * s3 + s1 * s2 * c3;
        this.w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "ZYX":
        this.x = s1 * c2 * c3 - c1 * s2 * s3;
        this.y = c1 * s2 * c3 + s1 * c2 * s3;
        this.z = c1 * c2 * s3 - s1 * s2 * c3;
        this.w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "YZX":
        this.x = s1 * c2 * c3 + c1 * s2 * s3;
        this.y = c1 * s2 * c3 + s1 * c2 * s3;
        this.z = c1 * c2 * s3 - s1 * s2 * c3;
        this.w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "XZY":
        this.x = s1 * c2 * c3 - c1 * s2 * s3;
        this.y = c1 * s2 * c3 - s1 * c2 * s3;
        this.z = c1 * c2 * s3 + s1 * s2 * c3;
        this.w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      default:
        throw new Error(`Euler order ${eulerOrder} not supported`);
    }
    return this;
  }
  static fromAxisAngle(axis, angle) {
    const normAxis = axis.normalize();
    const halfAngle = angle / 2;
    const s = Math.sin(halfAngle);
    return new Quaternion(normAxis.x * s, normAxis.y * s, normAxis.z * s, Math.cos(halfAngle));
  }
  static fromEuler(euler, order = "XYZ") {
    const x = euler.x;
    const y = euler.y;
    const z = euler.z;
    const c1 = Math.cos(x / 2);
    const c2 = Math.cos(y / 2);
    const c3 = Math.cos(z / 2);
    const s1 = Math.sin(x / 2);
    const s2 = Math.sin(y / 2);
    const s3 = Math.sin(z / 2);
    let qx, qy, qz, qw;
    switch (order) {
      case "XYZ":
        qx = s1 * c2 * c3 + c1 * s2 * s3;
        qy = c1 * s2 * c3 - s1 * c2 * s3;
        qz = c1 * c2 * s3 + s1 * s2 * c3;
        qw = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "YXZ":
        qx = s1 * c2 * c3 + c1 * s2 * s3;
        qy = c1 * s2 * c3 - s1 * c2 * s3;
        qz = c1 * c2 * s3 - s1 * s2 * c3;
        qw = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "ZXY":
        qx = s1 * c2 * c3 - c1 * s2 * s3;
        qy = c1 * s2 * c3 + s1 * c2 * s3;
        qz = c1 * c2 * s3 + s1 * s2 * c3;
        qw = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "ZYX":
        qx = s1 * c2 * c3 - c1 * s2 * s3;
        qy = c1 * s2 * c3 + s1 * c2 * s3;
        qz = c1 * c2 * s3 - s1 * s2 * c3;
        qw = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "YZX":
        qx = s1 * c2 * c3 + c1 * s2 * s3;
        qy = c1 * s2 * c3 + s1 * c2 * s3;
        qz = c1 * c2 * s3 - s1 * s2 * c3;
        qw = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "XZY":
        qx = s1 * c2 * c3 - c1 * s2 * s3;
        qy = c1 * s2 * c3 - s1 * c2 * s3;
        qz = c1 * c2 * s3 + s1 * s2 * c3;
        qw = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      default:
        throw new Error(`Euler order ${order} not supported`);
    }
    return new Quaternion(qx, qy, qz, qw);
  }
  static fromRotationMatrix(m) {
    const te = m.elements;
    const m11 = te[0], m12 = te[4], m13 = te[8];
    const m21 = te[1], m22 = te[5], m23 = te[9];
    const m31 = te[2], m32 = te[6], m33 = te[10];
    const trace = m11 + m22 + m33;
    let q;
    if (trace > 0) {
      const s = 0.5 / Math.sqrt(trace + 1);
      q = new Quaternion((m32 - m23) * s, (m13 - m31) * s, (m21 - m12) * s, 0.25 / s);
    } else if (m11 > m22 && m11 > m33) {
      const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
      q = new Quaternion(0.25 * s, (m12 + m21) / s, (m13 + m31) / s, (m32 - m23) / s);
    } else if (m22 > m33) {
      const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
      q = new Quaternion((m12 + m21) / s, 0.25 * s, (m23 + m32) / s, (m13 - m31) / s);
    } else {
      const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
      q = new Quaternion((m13 + m31) / s, (m23 + m32) / s, 0.25 * s, (m21 - m12) / s);
    }
    return q.normalize();
  }
  toMatrix4() {
    const te = new Matrix4().elements;
    const x = this.x, y = this.y, z = this.z, w = this.w;
    const x2 = x + x, y2 = y + y, z2 = z + z;
    const xx = x * x2, xy = x * y2, xz = x * z2;
    const yy = y * y2, yz = y * z2, zz = z * z2;
    const wx = w * x2, wy = w * y2, wz = w * z2;
    te[0] = 1 - (yy + zz);
    te[4] = xy - wz;
    te[8] = xz + wy;
    te[12] = 0;
    te[1] = xy + wz;
    te[5] = 1 - (xx + zz);
    te[9] = yz - wx;
    te[13] = 0;
    te[2] = xz - wy;
    te[6] = yz + wx;
    te[10] = 1 - (xx + yy);
    te[14] = 0;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return new Matrix4(Array.from(te));
  }
  angleTo(q) {
    return 2 * Math.acos(Math.abs(Math.max(-1, Math.min(1, this.dot(q)))));
  }
  rotateTowards(q, step) {
    const angle = this.angleTo(q);
    if (angle === 0)
      return this;
    const t = Math.min(1, step / angle);
    return this.slerp(q, t);
  }
  invert() {
    return this.conjugate().normalize();
  }
  toString() {
    return `Quaternion(${this.x.toFixed(3)}, ${this.y.toFixed(3)}, ${this.z.toFixed(3)}, ${this.w.toFixed(3)})`;
  }
  toArray() {
    return [this.x, this.y, this.z, this.w];
  }
  static fromArray(array) {
    return new Quaternion(array[0], array[1], array[2], array[3]);
  }
  toEuler(order = "YXZ") {
    const x = this.x, y = this.y, z = this.z, w = this.w;
    const x2 = x * x, y2 = y * y, z2 = z * z, w2 = w * w;
    let ex, ey, ez;
    switch (order) {
      case "XYZ": {
        const sinp = 2 * (w * x - y * z);
        if (Math.abs(sinp) >= 1) {
          ex = Math.sign(sinp) * Math.PI / 2;
        } else {
          ex = Math.asin(sinp);
        }
        ey = Math.atan2(2 * (w * y + x * z), 1 - 2 * (x2 + y2));
        ez = Math.atan2(2 * (w * z + x * y), 1 - 2 * (x2 + z2));
        break;
      }
      case "YXZ": {
        const sinp = 2 * (w * x - y * z);
        if (Math.abs(sinp) >= 1) {
          ex = Math.sign(sinp) * Math.PI / 2;
        } else {
          ex = Math.asin(sinp);
        }
        ey = Math.atan2(2 * (w * y + x * z), w2 - x2 - y2 + z2);
        ez = Math.atan2(2 * (w * z + x * y), w2 - x2 + y2 - z2);
        break;
      }
      default: {
        const sinp = 2 * (w * x - y * z);
        if (Math.abs(sinp) >= 1) {
          ex = Math.sign(sinp) * Math.PI / 2;
        } else {
          ex = Math.asin(sinp);
        }
        ey = Math.atan2(2 * (w * y + x * z), w2 - x2 - y2 + z2);
        ez = Math.atan2(2 * (w * z + x * y), w2 - x2 + y2 - z2);
        break;
      }
    }
    return new Vector3(ex, ey, ez);
  }
  toEulerDegrees(order = "YXZ") {
    const euler = this.toEuler(order);
    const rad2deg = 180 / Math.PI;
    return new Vector3(euler.x * rad2deg, euler.y * rad2deg, euler.z * rad2deg);
  }
}

// ../../src/math/Transform.ts
class Transform {
  _position;
  _rotation;
  _scale;
  _matrix;
  _matrixDirty = true;
  _parent = null;
  _children = [];
  _worldMatrix;
  _worldMatrixDirty = true;
  constructor(position = Vector3.zero, rotation = Quaternion.identity, scale = Vector3.one) {
    this._position = position.clone();
    this._rotation = rotation.clone();
    this._scale = scale.clone();
    this._matrix = Matrix4.identity;
    this._worldMatrix = Matrix4.identity;
  }
  get position() {
    return this._position;
  }
  set position(value) {
    if (!this._position.equals(value)) {
      this._position = value.clone();
      this._markDirty();
    }
  }
  get rotation() {
    return this._rotation;
  }
  set rotation(value) {
    if (!this._rotation.equals(value)) {
      this._rotation = value.clone();
      this._markDirty();
    }
  }
  get scale() {
    return this._scale;
  }
  set scale(value) {
    if (!this._scale.equals(value)) {
      this._scale = value.clone();
      this._markDirty();
    }
  }
  get matrix() {
    if (this._matrixDirty) {
      this._matrix = new Matrix4().compose(this._position, this._rotation.toMatrix4(), this._scale);
      this._matrixDirty = false;
    }
    return this._matrix;
  }
  get worldMatrix() {
    if (this._worldMatrixDirty) {
      if (this._parent) {
        this._worldMatrix = new Matrix4().multiplyMatrices(this._parent.worldMatrix, this.matrix);
      } else {
        this._worldMatrix = this.matrix.clone();
      }
      this._worldMatrixDirty = false;
    }
    return this._worldMatrix;
  }
  get parent() {
    return this._parent;
  }
  get children() {
    return this._children.slice();
  }
  set parent(parent) {
    if (this._parent === parent)
      return;
    if (this._parent) {
      const index = this._parent._children.indexOf(this);
      if (index !== -1) {
        this._parent._children.splice(index, 1);
      }
    }
    this._parent = parent;
    if (this._parent) {
      this._parent._children.push(this);
    }
    this._markWorldMatrixDirty();
  }
  addChild(child) {
    child.parent = this;
  }
  removeChild(child) {
    if (child.parent === this) {
      child.parent = null;
    }
  }
  translate(translation, space = "local") {
    if (space === "local") {
      const rotationMatrix = this.rotation.toMatrix4();
      this.position = this.position.add(rotationMatrix.transformDirection(translation));
    } else {
      this.position = this.position.add(translation);
    }
  }
  rotate(axis, angle, space = "local") {
    if (space === "local") {
      const rotation = Quaternion.fromAxisAngle(axis.normalize(), angle);
      this.rotation = this.rotation.multiply(rotation).normalize();
    } else {
      const worldRotation = Quaternion.fromAxisAngle(axis.normalize(), angle);
      const currentWorldRotation = this.getWorldRotation();
      const newWorldRotation = worldRotation.multiply(currentWorldRotation).normalize();
      this.setWorldRotation(newWorldRotation);
    }
  }
  lookAt(target, up = Vector3.up) {
    const matrix = Matrix4.identity.lookAt(this.position, target, up);
    const { rotation } = matrix.decompose();
    this.rotation = Quaternion.fromRotationMatrix(rotation).invert();
    this._markDirty();
  }
  setWorldPosition(position) {
    if (this._parent) {
      const parentWorldMatrixInverse = this._parent.worldMatrix.clone().inverse();
      this.position = parentWorldMatrixInverse.transformVector(position);
    } else {
      this.position = position.clone();
    }
  }
  setWorldRotation(rotation) {
    if (this._parent) {
      const parentRotation = this._parent.worldMatrix.decompose().rotation;
      const parentQuaternion = Quaternion.fromRotationMatrix(parentRotation);
      this.rotation = parentQuaternion.invert().multiply(rotation).normalize();
    } else {
      this.rotation = rotation.clone();
    }
    this._markDirty();
  }
  setWorldScale(scale) {
    if (this._parent) {
      const parentScale = this._parent.worldMatrix.decompose().scale;
      this.scale = new Vector3(scale.x / parentScale.x, scale.y / parentScale.y, scale.z / parentScale.z);
    } else {
      this.scale = scale.clone();
    }
    this._markDirty();
  }
  getWorldPosition() {
    const { position } = this.worldMatrix.decompose();
    return position;
  }
  getWorldRotation() {
    const { rotation } = this.worldMatrix.decompose();
    return Quaternion.fromRotationMatrix(rotation);
  }
  getWorldScale() {
    const { scale } = this.worldMatrix.decompose();
    return scale;
  }
  getForwardVector() {
    const rotationMatrix = this.rotation.toMatrix4();
    return rotationMatrix.transformDirection(Vector3.forward).normalize();
  }
  getRightVector() {
    const rotationMatrix = this.rotation.toMatrix4();
    return rotationMatrix.transformDirection(Vector3.right).normalize();
  }
  getUpVector() {
    const rotationMatrix = this.rotation.toMatrix4();
    return rotationMatrix.transformDirection(Vector3.up).normalize();
  }
  transformPoint(point) {
    return this.worldMatrix.transformVector(point);
  }
  transformDirection(direction) {
    return this.worldMatrix.transformDirection(direction).normalize();
  }
  inverseTransformPoint(point) {
    const worldPos = this.getWorldPosition();
    const worldScale = this.getWorldScale();
    const worldRot = this.getWorldRotation();
    const translated = point.subtract(worldPos);
    const inverseRot = worldRot.invert();
    const rotated = inverseRot.toMatrix4().transformDirection(translated);
    return new Vector3(rotated.x / worldScale.x, rotated.y / worldScale.y, rotated.z / worldScale.z);
  }
  inverseTransformDirection(direction) {
    const worldMatrixInverse = this.worldMatrix.clone().inverse();
    return worldMatrixInverse.transformDirection(direction).normalize();
  }
  copy(transform) {
    this.position.copy(transform.position);
    this.rotation.copy(transform.rotation);
    this.scale.copy(transform.scale);
    this._markDirty();
    return this;
  }
  clone() {
    return new Transform(this.position, this.rotation, this.scale);
  }
  equals(transform, epsilon = 0.000001) {
    return this.position.equals(transform.position, epsilon) && this.rotation.equals(transform.rotation, epsilon) && this.scale.equals(transform.scale, epsilon);
  }
  reset() {
    this.position.copy(Vector3.zero);
    this.rotation.copy(Quaternion.identity);
    this.scale.copy(Vector3.one);
    this._markDirty();
  }
  _markDirty() {
    this._matrixDirty = true;
    this._markWorldMatrixDirty();
  }
  _markWorldMatrixDirty() {
    this._worldMatrixDirty = true;
    for (const child of this._children) {
      child._markWorldMatrixDirty();
    }
  }
  toString() {
    return `Transform(
  Position: ${this.position.toString()},
  Rotation: ${this.rotation.toString()},
  Scale: ${this.scale.toString()}
)`;
  }
  toJSON() {
    return {
      position: this.position.toArray(),
      rotation: this.rotation.toArray(),
      scale: this.scale.toArray()
    };
  }
  static fromJSON(json) {
    return new Transform(Vector3.fromArray(json.position), Quaternion.fromArray(json.rotation), Vector3.fromArray(json.scale));
  }
}

// ../../src/core/Node.ts
class Node {
  transform;
  name;
  children = [];
  parent = null;
  visible = true;
  renderOrder = 0;
  _initState = "ready";
  _needsUpdate = false;
  get initState() {
    return this._initState;
  }
  get needsInit() {
    return this._initState === "pending";
  }
  get needsUpdate() {
    return this._needsUpdate;
  }
  async onInit(device) {}
  onUpdate(deltaTime) {}
  constructor(name = "Node") {
    this.name = name;
    this.transform = new Transform;
  }
  addChild(child) {
    if (child.parent) {
      child.parent.removeChild(child);
    }
    child.parent = this;
    this.children.push(child);
    this.transform.addChild(child.transform);
  }
  removeChild(child) {
    const index = this.children.indexOf(child);
    if (index !== -1) {
      this.children.splice(index, 1);
      child.parent = null;
      this.transform.removeChild(child.transform);
    }
  }
  traverse(callback) {
    const result = callback(this);
    if (result === false)
      return;
    for (const child of this.children) {
      child.traverse(callback);
    }
  }
}

// ../../src/core/Geometry.ts
class AABB {
  min;
  max;
  constructor(min = new Vector3(Infinity, Infinity, Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
    this.min = min;
    this.max = max;
  }
  get center() {
    return this.min.clone().add(this.max).multiply(0.5);
  }
  get size() {
    return this.max.subtract(this.min);
  }
}

class Geometry {
  attributes = {};
  indices = null;
  vertexCount = 0;
  indexCount = 0;
  vertexBuffers = {};
  indexBuffer = null;
  aabb = new AABB;
  boundingSphere = { center: new Vector3, radius: 0 };
  _buffersDirty = true;
  setAttribute(name, data) {
    this.attributes[name] = data;
    this._buffersDirty = true;
    if (name === "position") {
      this.vertexCount = data.length / 3;
      this.computeBounds();
    }
  }
  setIndices(data) {
    this.indices = data;
    this.indexCount = data.length;
    this._buffersDirty = true;
  }
  get buffersDirty() {
    return this._buffersDirty;
  }
  markBuffersClean() {
    this._buffersDirty = false;
  }
  markBuffersDirty() {
    this._buffersDirty = true;
  }
  destroyBuffers() {
    for (const key in this.vertexBuffers) {
      this.vertexBuffers[key]?.destroy();
    }
    this.vertexBuffers = {};
    this.indexBuffer?.destroy();
    this.indexBuffer = null;
    this._buffersDirty = true;
  }
  get triangleCount() {
    if (this.indices) {
      return this.indexCount / 3;
    }
    return this.vertexCount / 3;
  }
  computeBounds() {
    const positions = this.attributes["position"];
    if (!positions)
      return;
    this.aabb.min = new Vector3(Infinity, Infinity, Infinity);
    this.aabb.max = new Vector3(-Infinity, -Infinity, -Infinity);
    const v = new Vector3;
    for (let i = 0;i < positions.length; i += 3) {
      v.set(positions[i], positions[i + 1], positions[i + 2]);
      this.aabb.min.min(v);
      this.aabb.max.max(v);
    }
    this.boundingSphere.center = this.aabb.center;
    let maxRadiusSq = 0;
    for (let i = 0;i < positions.length; i += 3) {
      v.set(positions[i], positions[i + 1], positions[i + 2]);
      maxRadiusSq = Math.max(maxRadiusSq, v.distanceToSquared(this.boundingSphere.center));
    }
    this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
  }
}

// ../../src/core/Material.ts
class Material {
  vertexShaderCode;
  fragmentShaderCode;
  pipeline = null;
  constructor(vertexShaderCode = "", fragmentShaderCode = "") {
    this.vertexShaderCode = vertexShaderCode;
    this.fragmentShaderCode = fragmentShaderCode;
  }
  getVertexShader(pass) {
    return this.vertexShaderCode;
  }
  getRenderingPath() {
    return "forward";
  }
  getFragmentShader(pass) {
    return this.fragmentShaderCode;
  }
  getBindGroupEntries(device, uniformBuffer, shadowMap = null, shadowSampler = null) {
    return [
      {
        binding: 0,
        resource: {
          buffer: uniformBuffer
        }
      }
    ];
  }
}

// ../../src/core/materials/legacy/BasicMaterial.ts
class BasicMaterial extends Material {
  color;
  constructor(color = new Vector3(1, 0, 0)) {
    const vertexShader = `
      struct Uniforms {
        modelViewProjectionMatrix : mat4x4<f32>,
        color : vec3f,
      }
      @group(0) @binding(0) var<uniform> uniforms : Uniforms;

      struct VertexOutput {
        @builtin(position) position : vec4f,
        @location(0) color : vec3f,
      }

      @vertex
      fn vs_main(@location(0) position : vec3f) -> VertexOutput {
        var output : VertexOutput;
        output.position = uniforms.modelViewProjectionMatrix * vec4f(position, 1.0);
        output.color = uniforms.color;
        return output;
      }
    `;
    const fragmentShader = `
      @fragment
      fn fs_main(@location(0) color : vec3f) -> @location(0) vec4f {
        return vec4f(color, 1.0);
      }
    `;
    super(vertexShader, fragmentShader);
    this.color = color;
  }
  getUniformBufferSize() {
    return 80;
  }
  updateUniforms(device, buffer, offset, context) {
    const { camera, modelMatrix } = context;
    const viewMatrix = camera.viewMatrix;
    const projectionMatrix = camera.projectionMatrix;
    const mvpMatrix = new Matrix4().multiplyMatrices(projectionMatrix, viewMatrix).multiply(modelMatrix);
    const uniformData = new Float32Array(20);
    uniformData.set(mvpMatrix.elements, 0);
    uniformData[16] = this.color.x;
    uniformData[17] = this.color.y;
    uniformData[18] = this.color.z;
    uniformData[19] = 0;
    device.queue.writeBuffer(buffer, offset, uniformData);
  }
}

// ../../src/core/Mesh.ts
class Mesh extends Node {
  geometry;
  material;
  uniformBuffer = null;
  bindGroup = null;
  worldBounds = new AABB;
  worldBoundingSphere = { center: new Vector3, radius: 0 };
  renderIndex = -1;
  previousWorldMatrix = new Matrix4;
  constructor(geometry, material) {
    super("Mesh");
    this.geometry = geometry;
    this.material = material || new BasicMaterial;
  }
  updateWorldBounds() {
    const min = this.geometry.aabb.min;
    const max = this.geometry.aabb.max;
    const corners = [
      new Vector3(min.x, min.y, min.z),
      new Vector3(min.x, min.y, max.z),
      new Vector3(min.x, max.y, min.z),
      new Vector3(min.x, max.y, max.z),
      new Vector3(max.x, min.y, min.z),
      new Vector3(max.x, min.y, max.z),
      new Vector3(max.x, max.y, min.z),
      new Vector3(max.x, max.y, max.z)
    ];
    this.worldBounds.min.set(Infinity, Infinity, Infinity);
    this.worldBounds.max.set(-Infinity, -Infinity, -Infinity);
    for (const corner of corners) {
      corner.applyMatrix4(this.transform.worldMatrix);
      this.worldBounds.min.min(corner);
      this.worldBounds.max.max(corner);
    }
    this.worldBoundingSphere.center = this.geometry.boundingSphere.center.clone().applyMatrix4(this.transform.worldMatrix);
    const scale = this.transform.scale;
    const maxScale = Math.max(Math.abs(scale.x), Math.max(Math.abs(scale.y), Math.abs(scale.z)));
    this.worldBoundingSphere.radius = this.geometry.boundingSphere.radius * maxScale;
  }
}

// ../../src/core/Light.ts
var DEFAULT_LIGHT_SHADOW_CONFIG = {
  castShadow: false,
  bias: 0.002,
  normalBias: 0.01,
  radius: 0.05,
  intensity: 0.7
};

class Light extends Node {
  color;
  intensity;
  shadow;
  shadowAtlasIndex = -1;
  constructor(name = "Light", color = new Vector3(1, 1, 1), intensity = 1) {
    super(name);
    this.color = color;
    this.intensity = intensity;
    this.shadow = { ...DEFAULT_LIGHT_SHADOW_CONFIG };
  }
}

class DirectionalLight extends Light {
  static _counter = 0;
  type = 0 /* Directional */;
  constructor(color = new Vector3(1, 1, 1), intensity = 1, name) {
    super(name ?? `DirectionalLight_${DirectionalLight._counter++}`, color, intensity);
  }
}
class AmbientLight extends Light {
  static _counter = 0;
  type = 3 /* Ambient */;
  constructor(color = new Vector3(1, 1, 1), intensity = 0.1, name) {
    super(name ?? `AmbientLight_${AmbientLight._counter++}`, color, intensity);
  }
}

// ../../src/core/ui/UIElement.ts
class UIElement {
  id = "";
  name = "";
  parent = null;
  children = [];
  style = {};
  _bounds = { x: 0, y: 0, width: 0, height: 0 };
  _contentSize = { width: 0, height: 0 };
  _dirty = true;
  _visible = true;
  _interactive = true;
  _hovered = false;
  _pressed = false;
  _focused = false;
  onClick;
  onPointerDown;
  onPointerUp;
  onPointerEnter;
  onPointerLeave;
  onFocus;
  onBlur;
  onKeyDown;
  constructor(style) {
    if (style) {
      this.style = { ...style };
    }
    this.id = `ui_${Math.random().toString(36).substr(2, 9)}`;
  }
  get bounds() {
    return this._bounds;
  }
  get visible() {
    return this._visible && this.style.visible !== false;
  }
  get interactive() {
    return this._interactive && this.style.pointerEvents !== false;
  }
  get hovered() {
    return this._hovered;
  }
  get pressed() {
    return this._pressed;
  }
  get focused() {
    return this._focused;
  }
  set visible(value) {
    this._visible = value;
    this.style.visible = value;
    this.markDirty();
  }
  set interactive(value) {
    this._interactive = value;
  }
  addChild(child) {
    if (child.parent) {
      child.parent.removeChild(child);
    }
    child.parent = this;
    this.children.push(child);
    this.markDirty();
    return this;
  }
  removeChild(child) {
    const index = this.children.indexOf(child);
    if (index !== -1) {
      this.children.splice(index, 1);
      child.parent = null;
      this.markDirty();
      return true;
    }
    return false;
  }
  clearChildren() {
    for (const child of this.children) {
      child.parent = null;
    }
    this.children = [];
    this.markDirty();
  }
  findById(id) {
    if (this.id === id)
      return this;
    for (const child of this.children) {
      const found = child.findById(id);
      if (found)
        return found;
    }
    return null;
  }
  markDirty() {
    this._dirty = true;
    if (this.parent) {
      this.parent.markDirty();
    }
  }
  getPadding() {
    const p = this.style.padding ?? 0;
    if (typeof p === "number") {
      return { top: p, right: p, bottom: p, left: p };
    }
    return p;
  }
  getMargin() {
    const m = this.style.margin ?? 0;
    if (typeof m === "number") {
      return { top: m, right: m, bottom: m, left: m };
    }
    return m;
  }
  resolveSize(value, parentSize, contentSize) {
    if (value === undefined || value === "auto") {
      return contentSize;
    }
    if (value === "fill" || value === "100%") {
      return parentSize;
    }
    if (typeof value === "number") {
      return value;
    }
    if (typeof value === "string" && value.endsWith("%")) {
      const percent = parseFloat(value) / 100;
      return parentSize * percent;
    }
    return contentSize;
  }
  resolveValue(value, parentSize, defaultValue = 0) {
    if (value === undefined) {
      return defaultValue;
    }
    if (typeof value === "number") {
      return value;
    }
    if (typeof value === "string" && value.endsWith("%")) {
      const percent = parseFloat(value) / 100;
      return parentSize * percent;
    }
    return defaultValue;
  }
  layout(parentBounds, screenWidth, screenHeight) {
    const anchor = this.style.anchor ?? "top-left";
    const pivot = this.style.pivot ?? { x: 0, y: 0 };
    let width = this.resolveSize(this.style.width, parentBounds.width, this._contentSize.width);
    let height = this.resolveSize(this.style.height, parentBounds.height, this._contentSize.height);
    const minW = this.resolveValue(this.style.minWidth, parentBounds.width, 0);
    const maxW = this.resolveValue(this.style.maxWidth, parentBounds.width, Infinity);
    const minH = this.resolveValue(this.style.minHeight, parentBounds.height, 0);
    const maxH = this.resolveValue(this.style.maxHeight, parentBounds.height, Infinity);
    width = Math.max(minW, Math.min(maxW, width));
    height = Math.max(minH, Math.min(maxH, height));
    let anchorX = parentBounds.x;
    let anchorY = parentBounds.y;
    switch (anchor) {
      case "top-center":
      case "center":
      case "bottom-center":
        anchorX = parentBounds.x + parentBounds.width / 2;
        break;
      case "top-right":
      case "center-right":
      case "bottom-right":
        anchorX = parentBounds.x + parentBounds.width;
        break;
    }
    switch (anchor) {
      case "center-left":
      case "center":
      case "center-right":
        anchorY = parentBounds.y + parentBounds.height / 2;
        break;
      case "bottom-left":
      case "bottom-center":
      case "bottom-right":
        anchorY = parentBounds.y + parentBounds.height;
        break;
    }
    const offsetX = this.resolveValue(this.style.x, parentBounds.width, 0);
    const offsetY = this.resolveValue(this.style.y, parentBounds.height, 0);
    const x = anchorX + offsetX - width * pivot.x;
    const y = anchorY + offsetY - height * pivot.y;
    this._bounds = { x, y, width, height };
    this.layoutChildren(screenWidth, screenHeight);
    this._dirty = false;
  }
  layoutChildren(screenWidth, screenHeight) {
    const padding = this.getPadding();
    const childBounds = {
      x: this._bounds.x + padding.left,
      y: this._bounds.y + padding.top,
      width: this._bounds.width - padding.left - padding.right,
      height: this._bounds.height - padding.top - padding.bottom
    };
    for (const child of this.children) {
      child.layout(childBounds, screenWidth, screenHeight);
    }
  }
  measureContent() {
    let maxWidth = 0;
    let maxHeight = 0;
    for (const child of this.children) {
      const childSize = child.measureContent();
      const margin = child.getMargin();
      maxWidth = Math.max(maxWidth, childSize.width + margin.left + margin.right);
      maxHeight = Math.max(maxHeight, childSize.height + margin.top + margin.bottom);
    }
    const padding = this.getPadding();
    this._contentSize = {
      width: maxWidth + padding.left + padding.right,
      height: maxHeight + padding.top + padding.bottom
    };
    return this._contentSize;
  }
  containsPoint(x, y) {
    return x >= this._bounds.x && x <= this._bounds.x + this._bounds.width && y >= this._bounds.y && y <= this._bounds.y + this._bounds.height;
  }
  hitTest(x, y) {
    if (!this.visible || !this.containsPoint(x, y)) {
      return null;
    }
    const sortedChildren = [...this.children].sort((a, b) => {
      const aLayer = a.style.renderLayer ?? 0;
      const bLayer = b.style.renderLayer ?? 0;
      if (aLayer !== bLayer) {
        return bLayer - aLayer;
      }
      const aZ = a.style.zIndex ?? 0;
      const bZ = b.style.zIndex ?? 0;
      return bZ - aZ;
    });
    for (const child of sortedChildren) {
      const hit = child.hitTest(x, y);
      if (hit && hit.interactive) {
        return hit;
      }
    }
    return this.interactive ? this : null;
  }
  handlePointerEvent(event) {
    switch (event.type) {
      case "pointerdown":
        this._pressed = true;
        this.onPointerDown?.(event);
        this.bubblePointerDown(event);
        return true;
      case "pointerup":
        if (this._pressed) {
          this._pressed = false;
          this.onPointerUp?.(event);
          if (this.containsPoint(event.x, event.y)) {
            this.onClick?.(event);
            this.bubbleClick(event);
          }
        }
        return true;
      case "pointerenter":
        this._hovered = true;
        this.onPointerEnter?.(event);
        return true;
      case "pointerleave":
        this._hovered = false;
        this._pressed = false;
        this.onPointerLeave?.(event);
        return true;
      case "keydown":
        this.onKeyDown?.(event);
        return true;
    }
    return false;
  }
  bubblePointerDown(event) {
    let current = this.parent;
    while (current) {
      current._pressed = true;
      current.onPointerDown?.(event);
      current = current.parent;
    }
  }
  bubbleClick(event) {
    let current = this.parent;
    while (current) {
      if (current.containsPoint(event.x, event.y) && current.onClick) {
        current.onClick(event);
      }
      current._pressed = false;
      current = current.parent;
    }
  }
  setFocus(focused) {
    if (this._focused !== focused) {
      this._focused = focused;
      if (focused) {
        this.onFocus?.();
      } else {
        this.onBlur?.();
      }
      this.markDirty();
    }
  }
  update(dt) {
    for (const child of this.children) {
      child.update(dt);
    }
  }
  collectRenderData(data, parentZIndex = 0) {
    if (!this.visible)
      return;
    const effectiveZIndex = parentZIndex + (this.style.zIndex ?? 0);
    this.getRenderData(data, effectiveZIndex);
    for (const child of this.children) {
      child.collectRenderData(data, effectiveZIndex);
    }
  }
  destroy() {
    for (const child of this.children) {
      child.destroy();
    }
    this.children = [];
    this.parent = null;
  }
}

// ../../src/core/ui/components/Label.ts
class Label extends UIElement {
  _text = "";
  _lines = [];
  _textWidth = 0;
  _textHeight = 0;
  static metricsCanvas = null;
  static metricsContext = null;
  constructor(text = "", style) {
    super(style);
    this._text = text;
    if (style?.text) {
      this._text = style.text;
    }
    this._interactive = false;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    if (this._text !== value) {
      this._text = value;
      this._lines = [];
      this.markDirty();
    }
  }
  get lines() {
    return this._lines;
  }
  getMetricsContext() {
    if (!Label.metricsCanvas) {
      Label.metricsCanvas = document.createElement("canvas");
      Label.metricsContext = Label.metricsCanvas.getContext("2d");
    }
    return Label.metricsContext;
  }
  wrapText(text, maxWidth, fontSize, fontFamily) {
    if (!text)
      return [];
    const ctx = this.getMetricsContext();
    ctx.font = `${fontSize}px ${fontFamily}`;
    const lines = [];
    const paragraphs = text.split(`
`);
    for (const paragraph of paragraphs) {
      const words = paragraph.split(" ");
      let currentLine = "";
      for (const word of words) {
        const testLine = currentLine ? `${currentLine} ${word}` : word;
        const metrics = ctx.measureText(testLine);
        if (metrics.width > maxWidth && currentLine) {
          lines.push(currentLine);
          currentLine = word;
        } else {
          currentLine = testLine;
        }
      }
      if (currentLine) {
        lines.push(currentLine);
      }
    }
    return lines;
  }
  measureContent() {
    const fontSize = this.style.fontSize ?? 16;
    const fontFamily = this.style.fontFamily ?? "sans-serif";
    const lineHeight = this.style.lineHeight ?? fontSize * 1.4;
    const wordWrap = this.style.wordWrap ?? false;
    const maxWidth = typeof this.style.width === "number" ? this.style.width : Infinity;
    if (wordWrap && maxWidth < Infinity) {
      this._lines = this.wrapText(this._text, maxWidth, fontSize, fontFamily);
    } else {
      this._lines = this._text.split(`
`);
    }
    const maxLines = this.style.maxLines;
    if (maxLines && this._lines.length > maxLines) {
      this._lines = this._lines.slice(0, maxLines);
      if (this._lines.length > 0) {
        this._lines[this._lines.length - 1] += "...";
      }
    }
    let maxLineWidth = 0;
    const ctx = this.getMetricsContext();
    ctx.font = `${fontSize}px ${fontFamily}`;
    for (const line of this._lines) {
      const metrics = ctx.measureText(line);
      maxLineWidth = Math.max(maxLineWidth, metrics.width);
    }
    this._textWidth = maxLineWidth;
    this._textHeight = this._lines.length * lineHeight;
    const padding = this.getPadding();
    this._contentSize = {
      width: this._textWidth + padding.left + padding.right,
      height: this._textHeight + padding.top + padding.bottom
    };
    return this._contentSize;
  }
  getRenderData(data, baseZIndex) {
    const opacity = this.style.opacity ?? 1;
    const renderLayer = this.style.renderLayer ?? 0;
    if (opacity <= 0)
      return;
    if (this.style.backgroundColor) {
      data.push({
        type: "quad",
        bounds: { ...this._bounds },
        zIndex: baseZIndex,
        renderLayer,
        backgroundColor: this.style.backgroundColor,
        backgroundAlpha: (this.style.backgroundAlpha ?? 1) * opacity,
        borderRadius: this.style.borderRadius ?? 0
      });
    }
    if (this._text) {
      const padding = this.getPadding();
      const textBounds = {
        x: this._bounds.x + padding.left,
        y: this._bounds.y + padding.top,
        width: this._bounds.width - padding.left - padding.right,
        height: this._bounds.height - padding.top - padding.bottom
      };
      data.push({
        type: "text",
        bounds: textBounds,
        zIndex: baseZIndex + 0.1,
        renderLayer,
        text: this._text,
        color: this.style.color ?? "#ffffff",
        fontSize: this.style.fontSize ?? 16,
        fontFamily: this.style.fontFamily ?? "sans-serif",
        textAlign: this.style.textAlign ?? "left",
        textAlpha: opacity
      });
    }
  }
}

// ../../src/core/ui/components/Button.ts
class Button extends UIElement {
  _label;
  _disabled = false;
  _icon = null;
  static defaultStyle = {
    backgroundColor: "rgba(0, 0, 0, 0.7)",
    color: "#ffffff",
    borderColor: "rgba(255, 255, 255, 0.3)",
    borderWidth: 1,
    borderRadius: 4,
    padding: { top: 10, right: 20, bottom: 10, left: 20 },
    fontSize: 14,
    fontFamily: "system-ui, -apple-system, sans-serif",
    textAlign: "center",
    cursor: "pointer",
    hoverBackgroundColor: "rgba(40, 40, 40, 0.85)",
    hoverColor: "#ffffff",
    hoverBorderColor: "rgba(255, 255, 255, 0.5)",
    pressedBackgroundColor: "rgba(20, 20, 20, 0.9)",
    pressedColor: "#cccccc",
    pressedBorderColor: "rgba(255, 255, 255, 0.4)",
    disabledBackgroundColor: "rgba(0, 0, 0, 0.4)",
    disabledColor: "rgba(255, 255, 255, 0.4)",
    disabledBorderColor: "rgba(255, 255, 255, 0.15)",
    focusBorderColor: "rgba(100, 180, 255, 0.8)",
    focusBorderWidth: 2
  };
  constructor(text = "Button", style) {
    const mergedStyle = { ...Button.defaultStyle, ...style };
    super(mergedStyle);
    this._label = new Label(text, {
      color: mergedStyle.color,
      fontSize: mergedStyle.fontSize,
      fontFamily: mergedStyle.fontFamily,
      textAlign: mergedStyle.textAlign
    });
    this._label.interactive = false;
    this._interactive = true;
  }
  get text() {
    return this._label.text;
  }
  set text(value) {
    this._label.text = value;
    this.markDirty();
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
    this._interactive = !value;
    this.markDirty();
  }
  get label() {
    return this._label;
  }
  setIcon(icon) {
    this._icon = icon;
    this.markDirty();
  }
  getVisualState() {
    if (this._disabled)
      return "disabled";
    if (this._pressed)
      return "pressed";
    if (this._hovered)
      return "hover";
    if (this._focused)
      return "focused";
    return "normal";
  }
  getStateStyle() {
    const style = this.style;
    const state = this.getVisualState();
    switch (state) {
      case "hover":
        return {
          backgroundColor: style.hoverBackgroundColor ?? style.backgroundColor ?? "#4a4a4a",
          color: style.hoverColor ?? style.color ?? "#ffffff",
          borderColor: style.hoverBorderColor ?? style.borderColor ?? "#666666",
          borderWidth: style.borderWidth ?? 1,
          backgroundImage: style.hoverBackgroundImage ?? style.backgroundImage,
          tint: style.hoverTint ?? style.tint
        };
      case "pressed":
        return {
          backgroundColor: style.pressedBackgroundColor ?? style.backgroundColor ?? "#2a2a2a",
          color: style.pressedColor ?? style.color ?? "#dddddd",
          borderColor: style.pressedBorderColor ?? style.borderColor ?? "#444444",
          borderWidth: style.borderWidth ?? 1,
          backgroundImage: style.pressedBackgroundImage ?? style.backgroundImage,
          tint: style.pressedTint ?? style.tint
        };
      case "disabled":
        return {
          backgroundColor: style.disabledBackgroundColor ?? style.backgroundColor ?? "#2a2a2a",
          color: style.disabledColor ?? style.color ?? "#666666",
          borderColor: style.disabledBorderColor ?? style.borderColor ?? "#333333",
          borderWidth: style.borderWidth ?? 1,
          backgroundImage: style.disabledBackgroundImage ?? style.backgroundImage,
          tint: style.disabledTint ?? style.tint
        };
      case "focused":
        return {
          backgroundColor: style.backgroundColor ?? "#3a3a3a",
          color: style.color ?? "#ffffff",
          borderColor: style.focusBorderColor ?? "#5599ff",
          borderWidth: style.focusBorderWidth ?? style.borderWidth ?? 2,
          backgroundImage: style.focusedBackgroundImage ?? style.backgroundImage,
          tint: style.focusedTint ?? style.tint
        };
      default:
        return {
          backgroundColor: style.backgroundColor ?? "#3a3a3a",
          color: style.color ?? "#ffffff",
          borderColor: style.borderColor ?? "#555555",
          borderWidth: style.borderWidth ?? 1,
          backgroundImage: style.backgroundImage,
          tint: style.tint
        };
    }
  }
  measureContent() {
    const labelSize = this._label.measureContent();
    const padding = this.getPadding();
    let width = labelSize.width;
    let height = labelSize.height;
    if (this._icon) {
      const iconSize = this._icon.measureContent();
      width += iconSize.width + (this.style.gap ?? 8);
      height = Math.max(height, iconSize.height);
    }
    this._contentSize = {
      width: width + padding.left + padding.right,
      height: height + padding.top + padding.bottom
    };
    return this._contentSize;
  }
  handlePointerEvent(event) {
    if (this._disabled) {
      return false;
    }
    return super.handlePointerEvent(event);
  }
  getImageBounds(texture) {
    const buttonWidth = this._bounds.width;
    const buttonHeight = this._bounds.height;
    const textureWidth = texture.gpuTexture?.width ?? buttonWidth;
    const textureHeight = texture.gpuTexture?.height ?? buttonHeight;
    const buttonAspect = buttonWidth / buttonHeight;
    const textureAspect = textureWidth / textureHeight;
    let displayWidth;
    let displayHeight;
    if (textureAspect > buttonAspect) {
      displayWidth = buttonWidth;
      displayHeight = buttonWidth / textureAspect;
    } else {
      displayHeight = buttonHeight;
      displayWidth = buttonHeight * textureAspect;
    }
    const x = this._bounds.x + (buttonWidth - displayWidth) / 2;
    const y = this._bounds.y + (buttonHeight - displayHeight) / 2;
    return { x, y, width: displayWidth, height: displayHeight };
  }
  getRenderData(data, baseZIndex) {
    const stateStyle = this.getStateStyle();
    const style = this.style;
    const renderLayer = this.style.renderLayer ?? 0;
    const opacity = this.style.opacity ?? 1;
    if (opacity <= 0)
      return;
    const bgImage = stateStyle.backgroundImage;
    if (bgImage && bgImage.gpuTexture && bgImage.view) {
      const imageBounds = this.getImageBounds(bgImage);
      const imageRenderLayer = style.backgroundImageRenderLayer ?? renderLayer;
      data.push({
        type: "image",
        bounds: imageBounds,
        zIndex: baseZIndex,
        renderLayer: imageRenderLayer,
        texture: bgImage.gpuTexture,
        textureView: bgImage.view,
        uvRect: { u0: 0, v0: 0, u1: 1, v1: 1 },
        backgroundAlpha: (this.style.backgroundAlpha ?? 1) * opacity,
        tint: stateStyle.tint
      });
      if (stateStyle.borderColor && stateStyle.borderWidth > 0) {
        data.push({
          type: "quad",
          bounds: { ...this._bounds },
          zIndex: baseZIndex + 0.05,
          renderLayer,
          borderColor: stateStyle.borderColor,
          borderWidth: stateStyle.borderWidth,
          borderRadius: style.borderRadius ?? 4
        });
      }
    } else {
      data.push({
        type: "quad",
        bounds: { ...this._bounds },
        zIndex: baseZIndex,
        renderLayer,
        backgroundColor: stateStyle.backgroundColor,
        backgroundAlpha: (this.style.backgroundAlpha ?? 1) * opacity,
        borderColor: stateStyle.borderColor,
        borderWidth: stateStyle.borderWidth,
        borderRadius: style.borderRadius ?? 4,
        tint: stateStyle.tint
      });
    }
    const padding = this.getPadding();
    const textBounds = {
      x: this._bounds.x + padding.left,
      y: this._bounds.y + padding.top,
      width: this._bounds.width - padding.left - padding.right,
      height: this._bounds.height - padding.top - padding.bottom
    };
    data.push({
      type: "text",
      bounds: textBounds,
      zIndex: baseZIndex + 0.1,
      renderLayer,
      text: this._label.text,
      color: stateStyle.color,
      fontSize: style.fontSize ?? 14,
      fontFamily: style.fontFamily ?? "sans-serif",
      textAlign: style.textAlign ?? "center"
    });
    if (this._icon) {
      this._icon.collectRenderData(data, baseZIndex);
    }
  }
  destroy() {
    this._label.destroy();
    if (this._icon) {
      this._icon.destroy();
    }
    super.destroy();
  }
}

// ../../src/core/ui/components/Image.ts
class Image2 extends UIElement {
  _texture = null;
  _gpuTexture = null;
  _textureView = null;
  _uvRect = { u0: 0, v0: 0, u1: 1, v1: 1 };
  _sourceWidth = 0;
  _sourceHeight = 0;
  constructor(texture, style) {
    super(style);
    if (texture) {
      this.setTexture(texture);
    }
    this._interactive = false;
  }
  setTexture(texture) {
    this._texture = texture;
    if (texture && texture.gpuTexture) {
      this._gpuTexture = texture.gpuTexture;
      this._textureView = texture.view;
      this._sourceWidth = texture.gpuTexture.width;
      this._sourceHeight = texture.gpuTexture.height;
    } else {
      this._gpuTexture = null;
      this._textureView = null;
      this._sourceWidth = 0;
      this._sourceHeight = 0;
    }
    this.markDirty();
  }
  setGPUTexture(texture, width, height) {
    this._texture = null;
    this._gpuTexture = texture;
    this._textureView = texture?.createView() ?? null;
    this._sourceWidth = width ?? texture?.width ?? 0;
    this._sourceHeight = height ?? texture?.height ?? 0;
    this.markDirty();
  }
  setUVRect(u0, v0, u1, v1) {
    this._uvRect = { u0, v0, u1, v1 };
    this.markDirty();
  }
  setSpriteFrame(x, y, width, height, atlasWidth, atlasHeight) {
    this._uvRect = {
      u0: x / atlasWidth,
      v0: y / atlasHeight,
      u1: (x + width) / atlasWidth,
      v1: (y + height) / atlasHeight
    };
    this._sourceWidth = width;
    this._sourceHeight = height;
    this.markDirty();
  }
  get texture() {
    return this._texture;
  }
  get gpuTexture() {
    return this._gpuTexture;
  }
  get textureView() {
    return this._textureView;
  }
  get sourceWidth() {
    return this._sourceWidth;
  }
  get sourceHeight() {
    return this._sourceHeight;
  }
  measureContent() {
    if (typeof this.style.width === "number" && typeof this.style.height === "number") {
      this._contentSize = {
        width: this.style.width,
        height: this.style.height
      };
      return this._contentSize;
    }
    let width = this._sourceWidth;
    let height = this._sourceHeight;
    width *= this._uvRect.u1 - this._uvRect.u0;
    height *= this._uvRect.v1 - this._uvRect.v0;
    if (typeof this.style.width === "number") {
      const scale = this.style.width / width;
      width = this.style.width;
      height *= scale;
    } else if (typeof this.style.height === "number") {
      const scale = this.style.height / height;
      height = this.style.height;
      width *= scale;
    }
    const padding = this.getPadding();
    this._contentSize = {
      width: width + padding.left + padding.right,
      height: height + padding.top + padding.bottom
    };
    return this._contentSize;
  }
  getDisplayBounds() {
    const style = this.style;
    const scaleMode = style.scaleMode ?? "stretch";
    const padding = this.getPadding();
    const contentX = this._bounds.x + padding.left;
    const contentY = this._bounds.y + padding.top;
    const contentWidth = this._bounds.width - padding.left - padding.right;
    const contentHeight = this._bounds.height - padding.top - padding.bottom;
    if (scaleMode === "stretch" || this._sourceWidth === 0 || this._sourceHeight === 0) {
      return { x: contentX, y: contentY, width: contentWidth, height: contentHeight };
    }
    const sourceAspect = this._sourceWidth / this._sourceHeight;
    const containerAspect = contentWidth / contentHeight;
    let displayWidth;
    let displayHeight;
    switch (scaleMode) {
      case "contain":
        if (sourceAspect > containerAspect) {
          displayWidth = contentWidth;
          displayHeight = contentWidth / sourceAspect;
        } else {
          displayHeight = contentHeight;
          displayWidth = contentHeight * sourceAspect;
        }
        break;
      case "cover":
        if (sourceAspect > containerAspect) {
          displayHeight = contentHeight;
          displayWidth = contentHeight * sourceAspect;
        } else {
          displayWidth = contentWidth;
          displayHeight = contentWidth / sourceAspect;
        }
        break;
      case "none":
      default:
        displayWidth = this._sourceWidth;
        displayHeight = this._sourceHeight;
        break;
    }
    let displayX = contentX;
    let displayY = contentY;
    const alignX = style.alignX ?? "center";
    const alignY = style.alignY ?? "center";
    switch (alignX) {
      case "center":
        displayX = contentX + (contentWidth - displayWidth) / 2;
        break;
      case "right":
        displayX = contentX + contentWidth - displayWidth;
        break;
    }
    switch (alignY) {
      case "center":
        displayY = contentY + (contentHeight - displayHeight) / 2;
        break;
      case "bottom":
        displayY = contentY + contentHeight - displayHeight;
        break;
    }
    return { x: displayX, y: displayY, width: displayWidth, height: displayHeight };
  }
  getRenderData(data, baseZIndex) {
    const style = this.style;
    const renderLayer = this.style.renderLayer ?? 0;
    const opacity = this.style.opacity ?? 1;
    if (opacity <= 0)
      return;
    if (this.style.backgroundColor) {
      data.push({
        type: "quad",
        bounds: { ...this._bounds },
        zIndex: baseZIndex,
        renderLayer,
        backgroundColor: this.style.backgroundColor,
        backgroundAlpha: (this.style.backgroundAlpha ?? 1) * opacity,
        borderRadius: style.borderRadius ?? 0
      });
    }
    if (this._gpuTexture && this._textureView) {
      const displayBounds = this.getDisplayBounds();
      const renderType = style.nineSlice ? "nine-slice" : "image";
      data.push({
        type: renderType,
        bounds: displayBounds,
        zIndex: baseZIndex + 0.1,
        renderLayer,
        texture: this._gpuTexture,
        textureView: this._textureView,
        uvRect: this._uvRect,
        color: style.tint,
        backgroundAlpha: (style.tintAlpha ?? 1) * opacity
      });
    }
    if (style.borderColor && style.borderWidth) {
      data.push({
        type: "quad",
        bounds: { ...this._bounds },
        zIndex: baseZIndex + 0.2,
        renderLayer,
        borderColor: style.borderColor,
        borderWidth: style.borderWidth,
        borderRadius: style.borderRadius ?? 0
      });
    }
  }
}

// ../../src/core/debug/utils/codeGenerator.ts
function formatVector3(v, format, precision = 2) {
  const x = v.x.toFixed(precision);
  const y = v.y.toFixed(precision);
  const z = v.z.toFixed(precision);
  switch (format) {
    case "jsx":
      return `[${x}, ${y}, ${z}]`;
    case "yaml":
      return `[${x}, ${y}, ${z}]`;
    case "typescript":
      return `new Vector3(${x}, ${y}, ${z})`;
  }
}
function formatQuaternion(q, format, precision = 4) {
  const x = q.x.toFixed(precision);
  const y = q.y.toFixed(precision);
  const z = q.z.toFixed(precision);
  const w = q.w.toFixed(precision);
  switch (format) {
    case "jsx":
      return `[${x}, ${y}, ${z}, ${w}]`;
    case "yaml":
      return `[${x}, ${y}, ${z}, ${w}]`;
    case "typescript":
      return `new Quaternion(${x}, ${y}, ${z}, ${w})`;
  }
}
function formatEuler(euler, format, precision = 1) {
  const x = euler.x.toFixed(precision);
  const y = euler.y.toFixed(precision);
  const z = euler.z.toFixed(precision);
  switch (format) {
    case "jsx":
      return `[${x}, ${y}, ${z}]`;
    case "yaml":
      return `[${x}, ${y}, ${z}]`;
    case "typescript":
      return `Quaternion.fromEuler(new Vector3(${x}, ${y}, ${z}))`;
  }
}
function generateCameraCode(camera, format) {
  const pos = camera.transform.position;
  const rot = camera.transform.rotation;
  const euler = rot.toEulerDegrees();
  switch (format) {
    case "jsx":
      return `<PerspectiveCamera
  position={${formatVector3(pos, "jsx")}}
  rotation={${formatEuler(euler, "jsx")}}
  fov={${camera.fov.toFixed(1)}}
  near={${camera.near}}
  far={${camera.far}}
/>`;
    case "yaml":
      return `camera:
  position: ${formatVector3(pos, "yaml")}
  rotation: ${formatEuler(euler, "yaml")}
  fov: ${camera.fov.toFixed(1)}
  near: ${camera.near}
  far: ${camera.far}`;
    case "typescript":
      return `camera.transform.position = ${formatVector3(pos, "typescript")};
camera.transform.rotation = ${formatQuaternion(rot, "typescript")};
camera.fov = ${camera.fov.toFixed(1)};`;
  }
}
function generateNodeCode(node, format) {
  const pos = node.transform.position;
  const rot = node.transform.rotation;
  const euler = rot.toEulerDegrees();
  const scale = node.transform.scale;
  const name = node.name || "unnamed";
  let componentType = "Node";
  if (node instanceof Mesh) {
    componentType = "Mesh";
  } else if (node instanceof Light) {
    const light = node;
    switch (light.type) {
      case 0 /* Directional */:
        componentType = "DirectionalLight";
        break;
      case 1 /* Point */:
        componentType = "PointLight";
        break;
      case 2 /* Spot */:
        componentType = "SpotLight";
        break;
    }
  }
  switch (format) {
    case "jsx":
      return `<${componentType}
  name="${name}"
  position={${formatVector3(pos, "jsx")}}
  rotation={${formatEuler(euler, "jsx")}}
  scale={${formatVector3(scale, "jsx")}}
/>`;
    case "yaml":
      return `- name: ${name}
  type: ${componentType.toLowerCase()}
  position: ${formatVector3(pos, "yaml")}
  rotation: ${formatEuler(euler, "yaml")}
  scale: ${formatVector3(scale, "yaml")}`;
    case "typescript":
      return `${name}.transform.position = ${formatVector3(pos, "typescript")};
${name}.transform.rotation = ${formatQuaternion(rot, "typescript")};
${name}.transform.scale = ${formatVector3(scale, "typescript")};`;
  }
}
function generateLightCode(light, format) {
  const pos = light.transform.position;
  const rot = light.transform.rotation;
  const color = light.color;
  const castShadow = light.shadow.castShadow;
  let typeName = "Light";
  switch (light.type) {
    case 0 /* Directional */:
      typeName = "DirectionalLight";
      break;
    case 1 /* Point */:
      typeName = "PointLight";
      break;
    case 2 /* Spot */:
      typeName = "SpotLight";
      break;
  }
  const euler = rot.toEulerDegrees();
  switch (format) {
    case "jsx":
      if (light.type === 0 /* Directional */) {
        return `<${typeName}
  rotation={${formatEuler(euler, "jsx")}}
  color={${formatVector3(color, "jsx")}}
  intensity={${light.intensity.toFixed(2)}}
  castShadow={${castShadow}}
/>`;
      } else {
        return `<${typeName}
  position={${formatVector3(pos, "jsx")}}
  color={${formatVector3(color, "jsx")}}
  intensity={${light.intensity.toFixed(2)}}
  castShadow={${castShadow}}
/>`;
      }
    case "yaml":
      if (light.type === 0 /* Directional */) {
        return `- type: ${typeName.toLowerCase()}
  rotation: ${formatEuler(euler, "yaml")}
  color: ${formatVector3(color, "yaml")}
  intensity: ${light.intensity.toFixed(2)}
  castShadow: ${castShadow}`;
      } else {
        return `- type: ${typeName.toLowerCase()}
  position: ${formatVector3(pos, "yaml")}
  color: ${formatVector3(color, "yaml")}
  intensity: ${light.intensity.toFixed(2)}
  castShadow: ${castShadow}`;
      }
    case "typescript":
      return `const ${light.name || "light"} = new ${typeName}();
${light.name || "light"}.color = ${formatVector3(color, "typescript")};
${light.name || "light"}.intensity = ${light.intensity.toFixed(2)};
${light.name || "light"}.shadow.castShadow = ${castShadow};`;
  }
}
function generateUIElementCode(element, format) {
  const name = element.name || element.id || "element";
  const x = element.style.x ?? 0;
  const y = element.style.y ?? 0;
  const width = element.style.width;
  const height = element.style.height;
  const visible = element.visible;
  const opacity = element.style.opacity ?? 1;
  let componentType = "UIElement";
  let extraProps = {};
  if (element instanceof Button) {
    componentType = "UIButton";
    extraProps.text = `"${element.text}"`;
  } else if (element instanceof Label) {
    componentType = "UILabel";
    extraProps.text = `"${element.text}"`;
    if (element.style.color) {
      extraProps.color = `"${element.style.color}"`;
    }
    if (element.style.fontSize) {
      extraProps.fontSize = element.style.fontSize.toString();
    }
  } else if (element instanceof Image2) {
    componentType = "UIImage";
    if (element.sourceWidth && element.sourceHeight) {
      extraProps["// sourceSize"] = `${element.sourceWidth}x${element.sourceHeight}`;
    }
  } else {
    componentType = element.constructor.name || "UIElement";
  }
  switch (format) {
    case "jsx":
      let jsxProps = `
  x={${formatStyleValue(x)}}
  y={${formatStyleValue(y)}}`;
      if (width !== undefined) {
        jsxProps += `
  width={${formatStyleValue(width)}}`;
      }
      if (height !== undefined) {
        jsxProps += `
  height={${formatStyleValue(height)}}`;
      }
      if (!visible) {
        jsxProps += `
  visible={false}`;
      }
      if (opacity !== 1) {
        jsxProps += `
  opacity={${opacity.toFixed(2)}}`;
      }
      for (const [key, value] of Object.entries(extraProps)) {
        if (!key.startsWith("//")) {
          jsxProps += `
  ${key}={${value}}`;
        }
      }
      return `<${componentType}${jsxProps}
/>`;
    case "yaml":
      let yamlContent = `- type: ${componentType.toLowerCase()}
  x: ${formatStyleValue(x)}
  y: ${formatStyleValue(y)}`;
      if (width !== undefined) {
        yamlContent += `
  width: ${formatStyleValue(width)}`;
      }
      if (height !== undefined) {
        yamlContent += `
  height: ${formatStyleValue(height)}`;
      }
      if (!visible) {
        yamlContent += `
  visible: false`;
      }
      if (opacity !== 1) {
        yamlContent += `
  opacity: ${opacity.toFixed(2)}`;
      }
      for (const [key, value] of Object.entries(extraProps)) {
        if (!key.startsWith("//")) {
          const yamlValue = value.replace(/^"|"$/g, "");
          yamlContent += `
  ${key}: ${yamlValue}`;
        }
      }
      return yamlContent;
    case "typescript":
      let tsCode = `const ${sanitizeVarName(name)} = new ${componentType}();
`;
      tsCode += `${sanitizeVarName(name)}.style.x = ${formatStyleValue(x)};
`;
      tsCode += `${sanitizeVarName(name)}.style.y = ${formatStyleValue(y)};`;
      if (width !== undefined) {
        tsCode += `
${sanitizeVarName(name)}.style.width = ${formatStyleValue(width)};`;
      }
      if (height !== undefined) {
        tsCode += `
${sanitizeVarName(name)}.style.height = ${formatStyleValue(height)};`;
      }
      if (!visible) {
        tsCode += `
${sanitizeVarName(name)}.visible = false;`;
      }
      if (opacity !== 1) {
        tsCode += `
${sanitizeVarName(name)}.style.opacity = ${opacity.toFixed(2)};`;
      }
      if (element instanceof Button) {
        tsCode += `
${sanitizeVarName(name)}.text = "${element.text}";`;
      } else if (element instanceof Label) {
        tsCode += `
${sanitizeVarName(name)}.text = "${element.text}";`;
      }
      return tsCode;
  }
}
function formatStyleValue(value) {
  if (value === undefined)
    return "0";
  if (typeof value === "number")
    return value.toString();
  if (typeof value === "string")
    return `"${value}"`;
  return "0";
}
function sanitizeVarName(name) {
  let sanitized = name.replace(/[^a-zA-Z0-9_]/g, "_");
  if (/^[0-9]/.test(sanitized)) {
    sanitized = "_" + sanitized;
  }
  return sanitized || "element";
}

// ../../src/core/debug/panels/CameraPanel.ts
class CameraPanel extends Panel {
  camera = null;
  positionInput = null;
  rotationDisplay;
  fovInput = null;
  codeFormatSelect;
  currentFormat = "jsx";
  constructor() {
    super("Camera", { defaultOpen: false });
    const posSection = document.createElement("div");
    posSection.style.marginBottom = "8px";
    const posLabel = document.createElement("div");
    posLabel.innerText = "Position:";
    posLabel.style.fontWeight = "bold";
    posLabel.style.marginBottom = "4px";
    posLabel.style.fontSize = "10px";
    posSection.appendChild(posLabel);
    const posInputContainer = document.createElement("div");
    posInputContainer.id = "camera-pos-input";
    posSection.appendChild(posInputContainer);
    this.content.appendChild(posSection);
    const rotSection = document.createElement("div");
    rotSection.style.marginBottom = "8px";
    const rotLabel = document.createElement("div");
    rotLabel.innerText = "Rotation (degrees):";
    rotLabel.style.fontWeight = "bold";
    rotLabel.style.marginBottom = "4px";
    rotLabel.style.fontSize = "10px";
    rotSection.appendChild(rotLabel);
    this.rotationDisplay = document.createElement("div");
    this.rotationDisplay.style.fontSize = "10px";
    this.rotationDisplay.style.color = "#aaa";
    rotSection.appendChild(this.rotationDisplay);
    this.content.appendChild(rotSection);
    const fovSection = document.createElement("div");
    fovSection.style.marginBottom = "8px";
    fovSection.style.display = "flex";
    fovSection.style.alignItems = "center";
    fovSection.style.gap = "8px";
    const fovLabel = document.createElement("span");
    fovLabel.innerText = "FOV:";
    fovLabel.style.fontWeight = "bold";
    fovLabel.style.fontSize = "10px";
    fovSection.appendChild(fovLabel);
    const fovInputContainer = document.createElement("div");
    fovInputContainer.id = "camera-fov-input";
    fovSection.appendChild(fovInputContainer);
    this.content.appendChild(fovSection);
    const divider = document.createElement("div");
    divider.style.borderTop = "1px solid #444";
    divider.style.margin = "8px 0";
    this.content.appendChild(divider);
    const formatSection = document.createElement("div");
    formatSection.style.marginBottom = "8px";
    formatSection.style.display = "flex";
    formatSection.style.alignItems = "center";
    formatSection.style.gap = "8px";
    const formatLabel = document.createElement("span");
    formatLabel.innerText = "Format:";
    formatLabel.style.fontSize = "10px";
    formatSection.appendChild(formatLabel);
    this.codeFormatSelect = document.createElement("select");
    this.codeFormatSelect.style.fontSize = "10px";
    this.codeFormatSelect.style.padding = "2px 4px";
    this.codeFormatSelect.style.backgroundColor = "#222";
    this.codeFormatSelect.style.color = "#fff";
    this.codeFormatSelect.style.border = "1px solid #555";
    this.codeFormatSelect.style.borderRadius = "3px";
    const formats = [
      { value: "jsx", label: "JSX" },
      { value: "yaml", label: "YAML" },
      { value: "typescript", label: "TypeScript" }
    ];
    formats.forEach(({ value, label }) => {
      const option = document.createElement("option");
      option.value = value;
      option.innerText = label;
      this.codeFormatSelect.appendChild(option);
    });
    this.codeFormatSelect.onchange = () => {
      this.currentFormat = this.codeFormatSelect.value;
    };
    formatSection.appendChild(this.codeFormatSelect);
    this.content.appendChild(formatSection);
    const buttonsDiv = document.createElement("div");
    buttonsDiv.style.display = "flex";
    buttonsDiv.style.flexWrap = "wrap";
    buttonsDiv.style.gap = "4px";
    buttonsDiv.style.marginBottom = "6px";
    buttonsDiv.appendChild(createCopyButton("Position", () => {
      if (!this.camera)
        return "";
      return formatVector3(this.camera.transform.position, this.currentFormat);
    }));
    buttonsDiv.appendChild(createCopyButton("Rotation", () => {
      if (!this.camera)
        return "";
      return formatQuaternion(this.camera.transform.rotation, this.currentFormat);
    }));
    buttonsDiv.appendChild(createCopyButton("Euler", () => {
      if (!this.camera)
        return "";
      const euler = this.camera.transform.rotation.toEuler();
      return formatVector3(euler, this.currentFormat);
    }));
    this.content.appendChild(buttonsDiv);
    const copyAllBtn = createCopyButton("Copy Camera Code", () => {
      if (!this.camera)
        return "";
      return generateCameraCode(this.camera, this.currentFormat);
    }, { fullWidth: true });
    copyAllBtn.style.marginTop = "4px";
    this.content.appendChild(copyAllBtn);
  }
  setCamera(camera) {
    this.camera = camera;
    const posContainer = this.content.querySelector("#camera-pos-input");
    if (posContainer && !this.positionInput) {
      this.positionInput = createVector3Input(camera.transform.position, {
        precision: 2,
        step: 0.5,
        onChange: (v) => {
          if (this.camera) {
            this.camera.transform.position.x = v.x;
            this.camera.transform.position.y = v.y;
            this.camera.transform.position.z = v.z;
          }
        }
      });
      posContainer.appendChild(this.positionInput.element);
    }
    const fovContainer = this.content.querySelector("#camera-fov-input");
    if (fovContainer && !this.fovInput) {
      this.fovInput = createNumberInput(camera.fov, {
        min: 10,
        max: 120,
        step: 1,
        precision: 0,
        width: "50px",
        onChange: (v) => {
          if (this.camera) {
            this.camera.fov = v;
          }
        }
      });
      fovContainer.appendChild(this.fovInput.element);
    }
  }
  update() {
    if (!this.camera || !this.isOpen)
      return;
    if (this.positionInput) {
      const pos = this.camera.transform.position;
      this.positionInput.setValue(pos);
    }
    const euler = this.camera.transform.rotation.toEulerDegrees();
    this.rotationDisplay.innerHTML = `
      <span style="color: #ff6666;">P: ${euler.x.toFixed(1)}°</span>
      <span style="color: #66ff66; margin-left: 8px;">Y: ${euler.y.toFixed(1)}°</span>
      <span style="color: #6666ff; margin-left: 8px;">R: ${euler.z.toFixed(1)}°</span>
    `;
    if (this.fovInput) {
      this.fovInput.setValue(this.camera.fov);
    }
  }
}

// ../../src/core/Atmosphere.ts
var DEFAULT_ATMOSPHERE_CONFIG = {
  enabled: false,
  bottomRadius: 6360000,
  topRadius: 6460000,
  rayleighScattering: new Vector3(0.005802, 0.013558, 0.0331).divide(1000),
  rayleighDensityExpScale: -1 / 8000,
  mieScattering: new Vector3(0.003996, 0.003996, 0.003996).divide(1000),
  mieExtinction: new Vector3(0.00444, 0.00444, 0.00444).divide(1000),
  mieAbsorption: new Vector3(0.000444, 0.000444, 0.000444).divide(1000),
  mieDensityExpScale: -1 / 1200,
  miePhaseG: 0.8,
  absorptionExtinction: new Vector3(0.00065, 0.001881, 0.000085).divide(1000),
  absorptionDensity0LayerWidth: 25000,
  absorptionDensity0ConstantTerm: -0.666666,
  absorptionDensity0LinearTerm: 0.066666 / 1000,
  absorptionDensity1ConstantTerm: 2.666666,
  absorptionDensity1LinearTerm: -0.066666 / 1000,
  sunDirection: new Vector3(0, -1, 0),
  sunIlluminance: new Vector3(10, 10, 10),
  sunDiskHalfAngle: 0.00935,
  groundAlbedo: new Vector3(0.3, 0.3, 0.3),
  sunDiskEnabled: true,
  sunDiskScale: 2.5,
  moonEnabled: true,
  moonDirection: new Vector3(0, 1, 0),
  moonPhase: 0.5,
  moonScale: 1.8,
  moonAngularRadius: 0.009,
  moonColor: new Vector3(0.9, 0.9, 1),
  starsEnabled: true,
  starsIntensity: 1,
  starsTwinkle: 0.3,
  useCustomSkybox: false,
  customSkyboxBlend: 0,
  cloudsEnabled: false,
  cloudQuality: "high",
  cloudCoverage: 0.6,
  cloudDensity: 1.5,
  cloudColor: new Vector3(1, 1, 1),
  cloudAltitude: 3000,
  cloudHeight: 1500,
  cloudSpeed: 20,
  cloudWindDirection: new Vector3(1, 0, 0)
};

// ../../src/core/SubScene.ts
class SubScene extends Node {
  activeCamera = null;
  lights = [];
  enabled = true;
  atmosphere = null;
  priority = 0;
  constructor(name = "SubScene") {
    super(name);
  }
  setActiveCamera(camera) {
    this.activeCamera = camera;
  }
  addLight(light) {
    this.addChild(light);
    if (!this.lights.includes(light)) {
      this.lights.push(light);
    }
  }
  removeLight(light) {
    this.removeChild(light);
    const index = this.lights.indexOf(light);
    if (index > -1) {
      this.lights.splice(index, 1);
    }
  }
  getClosestLights(position, maxLights) {
    const visibleLights = this.lights.filter((l) => l.visible);
    const directional = visibleLights.filter((l) => l.type === 0 /* Directional */);
    const positional = visibleLights.filter((l) => l.type !== 0 /* Directional */);
    positional.sort((a, b) => {
      const distA = Math.max(0.01, a.transform.position.distanceTo(position));
      const distB = Math.max(0.01, b.transform.position.distanceTo(position));
      const scoreA = a.intensity / (distA * distA);
      const scoreB = b.intensity / (distB * distB);
      return scoreB - scoreA;
    });
    const result = [...directional, ...positional];
    return result.slice(0, maxLights);
  }
  isActive() {
    return this.visible && this.enabled && this.activeCamera !== null;
  }
  getEffectiveAtmosphere() {
    return this.atmosphere ?? { ...DEFAULT_ATMOSPHERE_CONFIG };
  }
}

// ../../src/math/Vector2.ts
class Vector2 {
  x;
  y;
  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
  }
  static get zero() {
    return new Vector2(0, 0);
  }
  static get one() {
    return new Vector2(1, 1);
  }
  clone() {
    return new Vector2(this.x, this.y);
  }
  set(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  }
}

// ../../src/core/Camera.ts
class Camera extends Node {
  projectionMatrix;
  viewMatrix;
  projectionJitter = new Vector2(0, 0);
  previousViewMatrix;
  previousProjectionMatrix;
  projectionType = "perspective";
  fov;
  aspect;
  near;
  far;
  orthographic = {
    left: -1,
    right: 1,
    top: 1,
    bottom: -1,
    zoom: 1
  };
  physicalCamera = {
    aperture: 2.8,
    focalLength: 50,
    focusDistance: 10,
    sensorSize: 36,
    shutterSpeed: 250,
    iso: 400
  };
  depthOfField = {
    enabled: false,
    intensity: 1,
    maxBlur: 8,
    samples: 32,
    bokehShape: "circle"
  };
  motionBlur = {
    enabled: false,
    intensity: 1,
    samples: 16,
    maxBlur: 32
  };
  lensEffects = {
    distortionEnabled: false,
    distortionAmount: 0,
    chromaticAberrationEnabled: false,
    chromaticAberrationIntensity: 0.005,
    vignetteEnabled: false,
    vignetteIntensity: 0.3,
    vignetteSmoothness: 0.5
  };
  tiltShift = {
    enabled: false,
    focusPosition: 0.5,
    focusWidth: 0.2,
    blurAmount: 4,
    gradientSize: 0.3,
    direction: "horizontal"
  };
  constructor(fov = 45, aspect = 1, near = 0.1, far = 1000) {
    super("Camera");
    this.fov = fov * (Math.PI / 180);
    this.aspect = aspect;
    this.near = near;
    this.far = far;
    this.projectionMatrix = new Matrix4;
    this.viewMatrix = new Matrix4;
    this.previousViewMatrix = new Matrix4;
    this.previousProjectionMatrix = new Matrix4;
    this.updateProjectionMatrix();
    this.updateViewMatrix();
    this.updatePreviousMatrices();
  }
  getCoCScale() {
    const { aperture, focalLength, focusDistance, sensorSize } = this.physicalCamera;
    const cocScale = focalLength * focalLength / (aperture * focusDistance * sensorSize);
    return cocScale * 0.001;
  }
  getMotionBlurScale() {
    return 60 / this.physicalCamera.shutterSpeed;
  }
  getFovFromPhysical() {
    const { focalLength, sensorSize } = this.physicalCamera;
    return 2 * Math.atan(sensorSize / (2 * focalLength));
  }
  usePhysicalFov() {
    this.fov = this.getFovFromPhysical();
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    if (this.projectionType === "orthographic") {
      const zoom = this.orthographic.zoom;
      const left = this.orthographic.left / zoom;
      const right = this.orthographic.right / zoom;
      const top = this.orthographic.top / zoom;
      const bottom = this.orthographic.bottom / zoom;
      this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
    } else {
      this.projectionMatrix.makePerspective(this.fov, this.aspect, this.near, this.far);
    }
    if (this.projectionJitter.x !== 0 || this.projectionJitter.y !== 0) {
      if (this.projectionType === "orthographic") {
        this.projectionMatrix.elements[12] += this.projectionJitter.x;
        this.projectionMatrix.elements[13] += this.projectionJitter.y;
      } else {
        this.projectionMatrix.elements[8] += this.projectionJitter.x;
        this.projectionMatrix.elements[9] += this.projectionJitter.y;
      }
    }
  }
  setPerspective(fov, aspect) {
    this.projectionType = "perspective";
    if (fov !== undefined)
      this.fov = fov * (Math.PI / 180);
    if (aspect !== undefined)
      this.aspect = aspect;
    this.updateProjectionMatrix();
  }
  setOrthographic(size, aspect) {
    this.projectionType = "orthographic";
    if (aspect !== undefined)
      this.aspect = aspect;
    if (size !== undefined) {
      const halfWidth = size * this.aspect;
      const halfHeight = size;
      this.orthographic.left = -halfWidth;
      this.orthographic.right = halfWidth;
      this.orthographic.top = halfHeight;
      this.orthographic.bottom = -halfHeight;
    }
    this.updateProjectionMatrix();
  }
  setOrthographicBounds(left, right, top, bottom) {
    this.projectionType = "orthographic";
    this.orthographic.left = left;
    this.orthographic.right = right;
    this.orthographic.top = top;
    this.orthographic.bottom = bottom;
    this.updateProjectionMatrix();
  }
  updateOrthographicAspect(aspect) {
    if (this.projectionType !== "orthographic")
      return;
    const halfHeight = (this.orthographic.top - this.orthographic.bottom) / 2;
    this.aspect = aspect;
    this.orthographic.left = -halfHeight * aspect;
    this.orthographic.right = halfHeight * aspect;
    this.updateProjectionMatrix();
  }
  get isOrthographic() {
    return this.projectionType === "orthographic";
  }
  get isPerspective() {
    return this.projectionType === "perspective";
  }
  get viewMatrixInverse() {
    return this.transform.worldMatrix;
  }
  updatePreviousMatrices() {
    this.previousViewMatrix.copy(this.viewMatrix);
    this.previousProjectionMatrix.copy(this.projectionMatrix);
  }
  updateViewMatrix() {
    const eye = this.transform.position;
    const target = this.transform.position.clone().add(this.transform.getForwardVector());
    const up = this.transform.getUpVector();
    this.viewMatrix = new Matrix4().lookAt(eye, target, up);
  }
}

// ../../src/core/ScenePresets.ts
var FOG_PRESETS = {
  none: {
    enabled: false,
    density: 0,
    skyFalloff: 0
  },
  subtle: {
    enabled: true,
    type: "EXP2",
    density: 0.0015,
    skyFalloff: 0.15,
    color: { r: 0.5, g: 0.65, b: 0.85 }
  },
  atmospheric: {
    enabled: true,
    type: "EXP2",
    density: 0.003,
    skyFalloff: 0.25,
    color: { r: 0.5, g: 0.6, b: 0.8 }
  },
  forest: {
    enabled: true,
    type: "EXP2",
    density: 0.0015,
    skyFalloff: 0.2,
    color: { r: 0.45, g: 0.55, b: 0.45 }
  },
  heavy: {
    enabled: true,
    type: "EXP2",
    density: 0.01,
    skyFalloff: 0.4,
    color: { r: 0.6, g: 0.6, b: 0.65 }
  },
  night: {
    enabled: true,
    type: "EXP2",
    density: 0.005,
    skyFalloff: 0.3,
    color: { r: 0.1, g: 0.08, b: 0.15 }
  }
};
var SCENE_PRESETS = {
  "outdoor-day": {
    name: "Outdoor Day",
    description: "Sunny daytime scene with blue sky and subtle fog",
    atmosphere: {
      enabled: true,
      sunDirection: { x: 0.5, y: 0.8, z: 0.3 },
      sunIlluminance: { x: 10, y: 10, z: 9.5 },
      sunDiskEnabled: true,
      sunDiskScale: 1,
      cloudsEnabled: true,
      cloudCoverage: 0.3,
      cloudSpeed: 10
    },
    fog: {
      enabled: true,
      type: "EXP2",
      density: 0.0015,
      color: { r: 0.5, g: 0.65, b: 0.85 },
      skyFalloff: 0.2
    },
    cloudShadows: {
      enabled: true,
      intensity: 0.4,
      scale: 0.02
    },
    postProcessing: {
      bloom: { enabled: true, threshold: 1.5, intensity: 0.6 },
      ssao: { enabled: true, radius: 1.5, bias: 0.025 },
      aa: { enabled: true }
    },
    recommendedLighting: {
      sunIntensity: 4,
      sunColor: { r: 1, g: 0.95, b: 0.9 },
      ambientIntensity: 0.3
    }
  },
  "outdoor-sunset": {
    name: "Outdoor Sunset",
    description: "Golden hour lighting with warm orange tones",
    atmosphere: {
      enabled: true,
      sunDirection: { x: 0.8, y: 0.15, z: 0.3 },
      sunIlluminance: { x: 12, y: 8, z: 5 },
      sunDiskEnabled: true,
      sunDiskScale: 1.5,
      cloudsEnabled: true,
      cloudCoverage: 0.4,
      cloudSpeed: 8
    },
    fog: {
      enabled: true,
      type: "EXP2",
      density: 0.003,
      color: { r: 0.8, g: 0.5, b: 0.4 },
      skyFalloff: 0.35
    },
    cloudShadows: {
      enabled: true,
      intensity: 0.3,
      scale: 0.025
    },
    postProcessing: {
      bloom: { enabled: true, threshold: 1, intensity: 0.8 },
      ssao: { enabled: true },
      aa: { enabled: true }
    },
    recommendedLighting: {
      sunIntensity: 3,
      sunColor: { r: 1, g: 0.7, b: 0.4 },
      ambientIntensity: 0.4
    }
  },
  "outdoor-night": {
    name: "Outdoor Night",
    description: "Moonlit night scene with stars and deep blue fog",
    atmosphere: {
      enabled: true,
      sunDirection: { x: 0, y: -0.3, z: 0.5 },
      sunIlluminance: { x: 0.1, y: 0.1, z: 0.15 },
      sunDiskEnabled: false,
      cloudsEnabled: true,
      cloudCoverage: 0.5,
      cloudSpeed: 5,
      starsEnabled: true,
      moonEnabled: true
    },
    fog: {
      enabled: true,
      type: "EXP2",
      density: 0.005,
      color: { r: 0.1, g: 0.08, b: 0.15 },
      skyFalloff: 0.3
    },
    cloudShadows: {
      enabled: false,
      intensity: 0,
      scale: 0.02
    },
    postProcessing: {
      bloom: { enabled: true, threshold: 0.5, intensity: 1 },
      ssao: { enabled: true },
      aa: { enabled: true }
    },
    recommendedLighting: {
      sunIntensity: 0.5,
      sunColor: { r: 0.7, g: 0.8, b: 1 },
      ambientIntensity: 0.15
    }
  },
  forest: {
    name: "Forest",
    description: "Forest scene with light fog and billboard clouds (performant)",
    atmosphere: {
      enabled: true,
      sunDirection: { x: 0.4, y: 0.6, z: 0.4 },
      sunIlluminance: { x: 8, y: 8, z: 7 },
      sunDiskEnabled: true,
      sunDiskScale: 0.8,
      cloudsEnabled: false,
      cloudCoverage: 0.4,
      cloudSpeed: 12
    },
    fog: {
      enabled: true,
      type: "EXP2",
      density: 0.0015,
      color: { r: 0.45, g: 0.55, b: 0.75 },
      skyFalloff: 0.4
    },
    cloudShadows: {
      enabled: true,
      intensity: 0.4,
      scale: 0.015
    },
    postProcessing: {
      bloom: { enabled: true, threshold: 1.5, intensity: 0.4 },
      ssao: { enabled: true, radius: 2, bias: 0.03 },
      aa: { enabled: false }
    },
    recommendedLighting: {
      sunIntensity: 4,
      sunColor: { r: 1, g: 0.95, b: 0.85 },
      ambientIntensity: 0.4
    }
  },
  "indoor-dungeon": {
    name: "Indoor Dungeon",
    description: "Dark interior with torch lighting and no atmosphere",
    atmosphere: {
      enabled: false,
      sunDirection: { x: 0, y: 1, z: 0 }
    },
    fog: {
      enabled: true,
      type: "EXP2",
      density: 0.008,
      color: { r: 0.15, g: 0.12, b: 0.1 },
      skyFalloff: 0
    },
    cloudShadows: {
      enabled: false,
      intensity: 0,
      scale: 0.02
    },
    postProcessing: {
      bloom: { enabled: true, threshold: 0.8, intensity: 1.2 },
      ssao: { enabled: true, radius: 1, bias: 0.02 },
      aa: { enabled: true }
    },
    recommendedLighting: {
      sunIntensity: 0,
      sunColor: { r: 1, g: 0.8, b: 0.6 },
      ambientIntensity: 0.1
    }
  },
  underwater: {
    name: "Underwater",
    description: "Aquatic scene with caustics and cyan fog",
    atmosphere: {
      enabled: false,
      sunDirection: { x: 0, y: 1, z: 0 }
    },
    fog: {
      enabled: true,
      type: "EXP2",
      density: 0.015,
      color: { r: 0.1, g: 0.3, b: 0.4 },
      skyFalloff: 0.5
    },
    cloudShadows: {
      enabled: false,
      intensity: 0,
      scale: 0.02
    },
    postProcessing: {
      bloom: { enabled: true, threshold: 1.2, intensity: 0.8 },
      ssao: { enabled: true },
      aa: { enabled: true }
    },
    recommendedLighting: {
      sunIntensity: 2,
      sunColor: { r: 0.6, g: 0.8, b: 1 },
      ambientIntensity: 0.4
    }
  }
};
function getScenePresetNames() {
  return Object.keys(SCENE_PRESETS);
}
function getFogPresetNames() {
  return Object.keys(FOG_PRESETS);
}

// ../../src/core/Scene.ts
class Scene extends Node {
  backgroundColor = { r: 0, g: 0, b: 0, a: 1 };
  lights = [];
  _lightScratchGlobal = [];
  _lightScratchPositional = [];
  _lightScratchResult = [];
  shadows = {
    enabled: true,
    resolution: 2048,
    bias: 0.005,
    maxLights: 1
  };
  postProcessing = {
    aa: { enabled: true },
    fxaa: { enabled: false },
    ssr: { enabled: false },
    ssao: { enabled: true, radius: 1.5, bias: 0.025 },
    bloom: { enabled: false, threshold: 0.9, intensity: 1 },
    tonemapping: { enabled: true, exposure: 1 },
    godRays: {
      enabled: false,
      intensity: 0.2,
      decay: 0.97,
      density: 0.5,
      weight: 0.1,
      exposure: 0.3,
      samples: 80,
      maxDistance: 1.5
    }
  };
  globalIllumination = {
    enabled: true,
    intensity: 0.1,
    spatialDenoise: true,
    temporalDenoise: true
  };
  atmosphere = { ...DEFAULT_ATMOSPHERE_CONFIG };
  cloudShadows = {
    enabled: false,
    intensity: 0.5,
    scale: 0.005,
    speed: 1,
    coverage: 0.5,
    softness: 0.3,
    windDirection: 45
  };
  fog = {
    enabled: false,
    type: "EXP2",
    color: new Vector3(0.5, 0.65, 0.85),
    near: 1,
    far: 1000,
    density: 0.002,
    skyFalloff: 0.15
  };
  render = {
    indirectDraw: true,
    frustumCulling: true,
    occlusionCulling: false
  };
  environmentMap = null;
  environmentIntensity = 1;
  constructor() {
    super("Scene");
  }
  get totalTriangleCount() {
    let count = 0;
    this.traverse((node) => {
      if (node instanceof Mesh && node.geometry) {
        count += node.geometry.triangleCount;
      }
    });
    return count;
  }
  addLight(light) {
    this.addChild(light);
    this.lights.push(light);
  }
  removeLight(light) {
    this.removeChild(light);
    const index = this.lights.indexOf(light);
    if (index > -1) {
      this.lights.splice(index, 1);
    }
  }
  getClosestLights(position, maxLights) {
    this._lightScratchGlobal.length = 0;
    this._lightScratchPositional.length = 0;
    this._lightScratchResult.length = 0;
    for (const light of this.lights) {
      if (!light.visible)
        continue;
      if (light.type === 0 /* Directional */ || light.type === 3 /* Ambient */ || light.type === 4 /* Hemisphere */) {
        this._lightScratchGlobal.push(light);
      } else if (light.type === 1 /* Point */ || light.type === 2 /* Spot */) {
        this._lightScratchPositional.push(light);
      }
    }
    this._lightScratchPositional.sort((a, b) => {
      const distA = Math.max(0.01, a.transform.position.distanceTo(position));
      const distB = Math.max(0.01, b.transform.position.distanceTo(position));
      const scoreA = a.intensity / (distA * distA);
      const scoreB = b.intensity / (distB * distB);
      return scoreB - scoreA;
    });
    let count = 0;
    for (const light of this._lightScratchGlobal) {
      if (count >= maxLights)
        break;
      this._lightScratchResult.push(light);
      count++;
    }
    for (const light of this._lightScratchPositional) {
      if (count >= maxLights)
        break;
      this._lightScratchResult.push(light);
      count++;
    }
    return this._lightScratchResult;
  }
  updatePreviousFrame() {
    this.traverse((node) => {
      if (node instanceof Mesh) {
        node.previousWorldMatrix.copy(node.transform.worldMatrix);
      }
    });
  }
  findActiveSubScene() {
    let activeSubScene = null;
    let highestPriority = -Infinity;
    this.traverse((node) => {
      if (node instanceof SubScene && node.isActive()) {
        if (node.priority > highestPriority) {
          highestPriority = node.priority;
          activeSubScene = node;
        }
      }
      return true;
    });
    return activeSubScene;
  }
  getEffectiveCamera() {
    const activeSubScene = this.findActiveSubScene();
    return activeSubScene?.activeCamera ?? null;
  }
  getEffectiveLights() {
    const activeSubScene = this.findActiveSubScene();
    return activeSubScene?.lights ?? this.lights;
  }
  getEffectiveAtmosphere() {
    const activeSubScene = this.findActiveSubScene();
    if (activeSubScene?.atmosphere) {
      return activeSubScene.atmosphere;
    }
    return this.atmosphere;
  }
  usePreset(presetName) {
    const preset = SCENE_PRESETS[presetName];
    if (!preset) {
      const available = getScenePresetNames().join(", ");
      console.warn(`Scene preset '${presetName}' not found. Available presets: ${available}`);
      return;
    }
    this.atmosphere.enabled = preset.atmosphere.enabled;
    if (preset.atmosphere.sunDirection) {
      this.atmosphere.sunDirection.set(preset.atmosphere.sunDirection.x, preset.atmosphere.sunDirection.y, preset.atmosphere.sunDirection.z);
    }
    if (preset.atmosphere.sunIlluminance) {
      this.atmosphere.sunIlluminance.set(preset.atmosphere.sunIlluminance.x, preset.atmosphere.sunIlluminance.y, preset.atmosphere.sunIlluminance.z);
    }
    if (preset.atmosphere.sunDiskEnabled !== undefined) {
      this.atmosphere.sunDiskEnabled = preset.atmosphere.sunDiskEnabled;
    }
    if (preset.atmosphere.sunDiskScale !== undefined) {
      this.atmosphere.sunDiskScale = preset.atmosphere.sunDiskScale;
    }
    if (preset.atmosphere.cloudsEnabled !== undefined) {
      this.atmosphere.cloudsEnabled = preset.atmosphere.cloudsEnabled;
    }
    if (preset.atmosphere.cloudCoverage !== undefined) {
      this.atmosphere.cloudCoverage = preset.atmosphere.cloudCoverage;
    }
    if (preset.atmosphere.cloudSpeed !== undefined) {
      this.atmosphere.cloudSpeed = preset.atmosphere.cloudSpeed;
    }
    if (preset.atmosphere.starsEnabled !== undefined) {
      this.atmosphere.starsEnabled = preset.atmosphere.starsEnabled;
    }
    if (preset.atmosphere.moonEnabled !== undefined) {
      this.atmosphere.moonEnabled = preset.atmosphere.moonEnabled;
    }
    this.fog.enabled = preset.fog.enabled;
    this.fog.type = preset.fog.type;
    this.fog.density = preset.fog.density;
    this.fog.color.set(preset.fog.color.r, preset.fog.color.g, preset.fog.color.b);
    this.fog.skyFalloff = preset.fog.skyFalloff;
    this.cloudShadows.enabled = preset.cloudShadows.enabled;
    this.cloudShadows.intensity = preset.cloudShadows.intensity;
    this.cloudShadows.scale = preset.cloudShadows.scale;
    if (preset.postProcessing.bloom) {
      this.postProcessing.bloom.enabled = preset.postProcessing.bloom.enabled;
      this.postProcessing.bloom.threshold = preset.postProcessing.bloom.threshold;
      this.postProcessing.bloom.intensity = preset.postProcessing.bloom.intensity;
    }
    if (preset.postProcessing.ssr !== undefined) {
      this.postProcessing.ssr.enabled = preset.postProcessing.ssr.enabled;
    }
    if (preset.postProcessing.ssao) {
      this.postProcessing.ssao.enabled = preset.postProcessing.ssao.enabled;
      if (preset.postProcessing.ssao.radius !== undefined) {
        this.postProcessing.ssao.radius = preset.postProcessing.ssao.radius;
      }
      if (preset.postProcessing.ssao.bias !== undefined) {
        this.postProcessing.ssao.bias = preset.postProcessing.ssao.bias;
      }
    }
    if (preset.postProcessing.aa !== undefined) {
      this.postProcessing.aa.enabled = preset.postProcessing.aa.enabled;
    }
    console.log(`Scene: Applied preset '${presetName}' (${preset.description})`);
  }
  useFogPreset(presetName) {
    const preset = FOG_PRESETS[presetName];
    if (!preset) {
      const available = getFogPresetNames().join(", ");
      console.warn(`Fog preset '${presetName}' not found. Available presets: ${available}`);
      return;
    }
    this.fog.enabled = preset.enabled;
    if ("density" in preset) {
      this.fog.density = preset.density;
    }
    if ("skyFalloff" in preset) {
      this.fog.skyFalloff = preset.skyFalloff;
    }
    if ("type" in preset) {
      this.fog.type = preset.type;
    }
    if ("color" in preset && preset.color) {
      this.fog.color.set(preset.color.r, preset.color.g, preset.color.b);
    }
  }
  setFogDensity(density) {
    if (density > 0.02) {
      console.warn(`Fog density ${density} is very high. Typical range: 0.001-0.01. ` + `Did you mean ${(density / 100).toFixed(4)}?`);
    } else if (density < 0 || density > 1) {
      console.warn(`Fog density ${density} is outside valid range. Typical range: 0.001-0.01.`);
    }
    this.fog.density = density;
  }
  static getPresetNames() {
    return getScenePresetNames();
  }
  static getFogPresetNames() {
    return getFogPresetNames();
  }
  static fromPreset(presetName, options) {
    const preset = SCENE_PRESETS[presetName];
    if (!preset) {
      const available = getScenePresetNames().join(", ");
      throw new Error(`Scene preset '${presetName}' not found. Available presets: ${available}`);
    }
    const scene = new Scene;
    scene.usePreset(presetName);
    const sunColor = new Vector3(preset.recommendedLighting.sunColor.r, preset.recommendedLighting.sunColor.g, preset.recommendedLighting.sunColor.b);
    const sun = new DirectionalLight(sunColor, preset.recommendedLighting.sunIntensity);
    sun.shadow.castShadow = true;
    const sunDir = preset.atmosphere.sunDirection;
    sun.transform.position.set(sunDir.x * 100, sunDir.y * 100, sunDir.z * 100);
    const ambient = new AmbientLight(new Vector3(1, 1, 1), preset.recommendedLighting.ambientIntensity);
    scene.addLight(sun);
    scene.addLight(ambient);
    const camera = new Camera(60, 16 / 9, 0.1, 2000);
    if (options?.cameraPosition) {
      camera.transform.position.copy(options.cameraPosition);
    } else {
      if (presetName === "indoor-dungeon") {
        camera.transform.position.set(0, 2, 5);
      } else {
        camera.transform.position.set(50, 15, 50);
      }
    }
    if (options?.cameraTarget) {
      camera.transform.lookAt(options.cameraTarget);
    } else {
      camera.transform.lookAt(new Vector3(0, 0, 0));
    }
    console.log(`Scene.fromPreset('${presetName}'): Created scene with sun, ambient light, and camera`);
    return { scene, sun, ambient, camera };
  }
}

// ../../src/core/debug/panels/ScenePanel.ts
class ScenePanel extends Panel {
  scene = null;
  treeContainer;
  selectedNode = null;
  callbacks;
  nodeElements = new Map;
  constructor(callbacks = {}) {
    super("Scene Graph", { showRefresh: true, onRefresh: () => this.refresh() });
    this.callbacks = callbacks;
    this.treeContainer = document.createElement("div");
    this.treeContainer.style.maxHeight = "200px";
    this.treeContainer.style.overflowY = "auto";
    this.treeContainer.style.fontSize = "11px";
    this.content.appendChild(this.treeContainer);
  }
  onToggle(isOpen) {
    if (isOpen && this.treeContainer.childElementCount === 0) {
      this.refresh();
    }
  }
  setScene(scene) {
    this.scene = scene;
  }
  refresh() {
    if (!this.scene) {
      this.treeContainer.innerHTML = '<i style="color: #888;">No scene registered</i>';
      return;
    }
    this.treeContainer.innerHTML = "";
    this.nodeElements.clear();
    this.treeContainer.appendChild(this.buildNodeTree(this.scene));
  }
  selectNode(node, triggerCallback = true) {
    if (this.selectedNode === node)
      return;
    if (this.selectedNode) {
      const prevEl = this.nodeElements.get(this.selectedNode);
      if (prevEl) {
        prevEl.style.backgroundColor = "transparent";
      }
    }
    this.selectedNode = node;
    if (node) {
      const el = this.nodeElements.get(node);
      if (el) {
        el.style.backgroundColor = "rgba(100, 150, 255, 0.2)";
      }
    }
    if (triggerCallback) {
      this.callbacks.onSelectNode?.(node);
    }
  }
  getSelectedNode() {
    return this.selectedNode;
  }
  buildNodeTree(node, depth = 0) {
    const container = document.createElement("div");
    container.style.marginLeft = `${depth * 12}px`;
    const row = document.createElement("div");
    row.style.display = "flex";
    row.style.alignItems = "center";
    row.style.marginBottom = "2px";
    row.style.padding = "2px 4px";
    row.style.borderRadius = "3px";
    row.style.cursor = "pointer";
    this.nodeElements.set(node, row);
    row.onmouseenter = () => {
      if (node !== this.selectedNode) {
        row.style.backgroundColor = "rgba(255, 255, 255, 0.05)";
      }
    };
    row.onmouseleave = () => {
      if (node !== this.selectedNode) {
        row.style.backgroundColor = "transparent";
      }
    };
    row.onclick = (e) => {
      e.stopPropagation();
      this.selectNode(node);
    };
    row.ondblclick = (e) => {
      e.stopPropagation();
      this.callbacks.onFocusNode?.(node);
    };
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.checked = node.visible;
    checkbox.style.marginRight = "5px";
    checkbox.style.cursor = "pointer";
    checkbox.onclick = (e) => e.stopPropagation();
    checkbox.onchange = () => {
      node.visible = checkbox.checked;
    };
    row.appendChild(checkbox);
    const { typeName, typeColor } = this.getNodeTypeInfo(node);
    const typeSpan = document.createElement("span");
    typeSpan.innerText = `[${typeName}]`;
    typeSpan.style.color = typeColor;
    typeSpan.style.marginRight = "6px";
    typeSpan.style.fontSize = "9px";
    typeSpan.style.fontWeight = "bold";
    row.appendChild(typeSpan);
    const nameSpan = document.createElement("span");
    nameSpan.innerText = node.name || "Unnamed";
    nameSpan.style.flex = "1";
    nameSpan.style.overflow = "hidden";
    nameSpan.style.textOverflow = "ellipsis";
    nameSpan.style.whiteSpace = "nowrap";
    row.appendChild(nameSpan);
    container.appendChild(row);
    if (node.children.length > 0) {
      const childrenContainer = document.createElement("div");
      for (const child of node.children) {
        childrenContainer.appendChild(this.buildNodeTree(child, depth + 1));
      }
      container.appendChild(childrenContainer);
    }
    return container;
  }
  getNodeTypeInfo(node) {
    if (node instanceof Mesh) {
      return { typeName: "Mesh", typeColor: "#aaf" };
    } else if (node instanceof Scene) {
      return { typeName: "Scene", typeColor: "#fff" };
    } else if (node instanceof Light) {
      const light = node;
      switch (light.type) {
        case 0 /* Directional */:
          return { typeName: "Dir", typeColor: "#ffa" };
        case 1 /* Point */:
          return { typeName: "Pt", typeColor: "#aff" };
        case 2 /* Spot */:
          return { typeName: "Spot", typeColor: "#faf" };
        default:
          return { typeName: "Light", typeColor: "#ff8" };
      }
    }
    return { typeName: "Node", typeColor: "#888" };
  }
}

// ../../src/core/debug/panels/InspectorPanel.ts
class InspectorPanel extends Panel {
  selectedNode = null;
  positionInput = null;
  rotationInput = null;
  scaleInput = null;
  contentContainer;
  codeFormatSelect;
  currentFormat = "jsx";
  constructor() {
    super("Inspector", { defaultOpen: false });
    const formatSection = document.createElement("div");
    formatSection.style.marginBottom = "8px";
    formatSection.style.display = "flex";
    formatSection.style.alignItems = "center";
    formatSection.style.gap = "8px";
    const formatLabel = document.createElement("span");
    formatLabel.innerText = "Format:";
    formatLabel.style.fontSize = "10px";
    formatSection.appendChild(formatLabel);
    this.codeFormatSelect = document.createElement("select");
    this.codeFormatSelect.style.fontSize = "10px";
    this.codeFormatSelect.style.padding = "2px 4px";
    this.codeFormatSelect.style.backgroundColor = "#222";
    this.codeFormatSelect.style.color = "#fff";
    this.codeFormatSelect.style.border = "1px solid #555";
    this.codeFormatSelect.style.borderRadius = "3px";
    const formats = [
      { value: "jsx", label: "JSX" },
      { value: "yaml", label: "YAML" },
      { value: "typescript", label: "TypeScript" }
    ];
    formats.forEach(({ value, label }) => {
      const option = document.createElement("option");
      option.value = value;
      option.innerText = label;
      this.codeFormatSelect.appendChild(option);
    });
    this.codeFormatSelect.onchange = () => {
      this.currentFormat = this.codeFormatSelect.value;
    };
    formatSection.appendChild(this.codeFormatSelect);
    this.content.appendChild(formatSection);
    this.contentContainer = document.createElement("div");
    this.content.appendChild(this.contentContainer);
  }
  setSelectedNode(node) {
    this.selectedNode = node;
    this.positionInput = null;
    this.rotationInput = null;
    this.scaleInput = null;
    this.rebuildContent();
  }
  rebuildContent() {
    this.contentContainer.innerHTML = "";
    if (!this.selectedNode) {
      const emptyMsg = document.createElement("div");
      emptyMsg.innerHTML = '<i style="color: #888;">No object selected</i>';
      emptyMsg.style.fontSize = "10px";
      this.contentContainer.appendChild(emptyMsg);
      return;
    }
    const node = this.selectedNode;
    const nameHeader = document.createElement("div");
    nameHeader.style.fontWeight = "bold";
    nameHeader.style.marginBottom = "8px";
    nameHeader.style.padding = "4px";
    nameHeader.style.backgroundColor = "rgba(255, 255, 255, 0.05)";
    nameHeader.style.borderRadius = "3px";
    nameHeader.innerText = node.name || "Unnamed Object";
    this.contentContainer.appendChild(nameHeader);
    this.createSection("Position", () => {
      this.positionInput = createVector3Input(node.transform.position, {
        precision: 2,
        step: 0.5,
        onChange: (v) => {
          if (this.selectedNode) {
            this.selectedNode.transform.position = new Vector3(v.x, v.y, v.z);
          }
        }
      });
      return this.positionInput.element;
    });
    this.createSection("Rotation (degrees)", () => {
      const euler = node.transform.rotation.toEulerDegrees();
      this.rotationInput = createVector3Input(euler, {
        precision: 1,
        step: 5,
        labels: { x: "P", y: "Y", z: "R" },
        colors: { x: "#ff6666", y: "#66ff66", z: "#6666ff" },
        onChange: (v) => {
          if (this.selectedNode) {
            const deg2rad = Math.PI / 180;
            const eulerRad = new Vector3(v.x * deg2rad, v.y * deg2rad, v.z * deg2rad);
            this.selectedNode.transform.rotation = Quaternion.fromEuler(eulerRad, "YXZ");
          }
        }
      });
      return this.rotationInput.element;
    });
    this.createSection("Scale", () => {
      this.scaleInput = createVector3Input(node.transform.scale, {
        precision: 2,
        step: 0.1,
        labels: { x: "X", y: "Y", z: "Z" },
        colors: { x: "#ff9966", y: "#99ff66", z: "#6699ff" },
        onChange: (v) => {
          if (this.selectedNode) {
            this.selectedNode.transform.scale = new Vector3(v.x, v.y, v.z);
          }
        }
      });
      return this.scaleInput.element;
    });
    this.createSection("Visibility", () => {
      const visRow = document.createElement("div");
      visRow.style.display = "flex";
      visRow.style.alignItems = "center";
      visRow.style.gap = "8px";
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.checked = node.visible;
      checkbox.onchange = () => {
        if (this.selectedNode) {
          this.selectedNode.visible = checkbox.checked;
        }
      };
      visRow.appendChild(checkbox);
      const label = document.createElement("span");
      label.innerText = "Visible";
      label.style.fontSize = "10px";
      visRow.appendChild(label);
      return visRow;
    });
    if (node instanceof Light) {
      this.createLightSection(node);
    }
    const divider = document.createElement("div");
    divider.style.borderTop = "1px solid #444";
    divider.style.margin = "8px 0";
    this.contentContainer.appendChild(divider);
    const copyBtn = createCopyButton("Copy Object Code", () => {
      if (!this.selectedNode)
        return "";
      if (this.selectedNode instanceof Light) {
        return generateLightCode(this.selectedNode, this.currentFormat);
      }
      return generateNodeCode(this.selectedNode, this.currentFormat);
    }, { fullWidth: true });
    this.contentContainer.appendChild(copyBtn);
  }
  createSection(title, buildContent) {
    const section = document.createElement("div");
    section.style.marginBottom = "8px";
    const label = document.createElement("div");
    label.innerText = title;
    label.style.fontWeight = "bold";
    label.style.marginBottom = "4px";
    label.style.fontSize = "10px";
    label.style.color = "#aaa";
    section.appendChild(label);
    section.appendChild(buildContent());
    this.contentContainer.appendChild(section);
  }
  createLightSection(light) {
    this.createSection("Light Type", () => {
      const typeDisplay = document.createElement("span");
      typeDisplay.style.fontSize = "10px";
      switch (light.type) {
        case 0 /* Directional */:
          typeDisplay.innerText = "Directional";
          typeDisplay.style.color = "#ffa";
          break;
        case 1 /* Point */:
          typeDisplay.innerText = "Point";
          typeDisplay.style.color = "#aff";
          break;
        case 2 /* Spot */:
          typeDisplay.innerText = "Spot";
          typeDisplay.style.color = "#faf";
          break;
      }
      return typeDisplay;
    });
    this.createSection("Intensity", () => {
      const intensityRow = document.createElement("div");
      intensityRow.style.display = "flex";
      intensityRow.style.alignItems = "center";
      intensityRow.style.gap = "8px";
      const slider = document.createElement("input");
      slider.type = "range";
      slider.min = "0";
      slider.max = "10";
      slider.step = "0.1";
      slider.value = light.intensity.toString();
      slider.style.width = "80px";
      const valueDisplay = document.createElement("span");
      valueDisplay.innerText = light.intensity.toFixed(1);
      valueDisplay.style.fontSize = "10px";
      valueDisplay.style.minWidth = "30px";
      slider.oninput = () => {
        const val = parseFloat(slider.value);
        light.intensity = val;
        valueDisplay.innerText = val.toFixed(1);
      };
      intensityRow.appendChild(slider);
      intensityRow.appendChild(valueDisplay);
      return intensityRow;
    });
    this.createSection("Shadows", () => {
      const shadowRow = document.createElement("div");
      shadowRow.style.display = "flex";
      shadowRow.style.alignItems = "center";
      shadowRow.style.gap = "8px";
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.checked = light.shadow.castShadow;
      checkbox.onchange = () => {
        light.shadow.castShadow = checkbox.checked;
      };
      shadowRow.appendChild(checkbox);
      const label = document.createElement("span");
      label.innerText = "Cast Shadow";
      label.style.fontSize = "10px";
      shadowRow.appendChild(label);
      return shadowRow;
    });
  }
  update() {
    if (!this.selectedNode || !this.isOpen)
      return;
    if (this.positionInput) {
      this.positionInput.setValue(this.selectedNode.transform.position);
    }
    if (this.rotationInput) {
      const euler = this.selectedNode.transform.rotation.toEulerDegrees();
      this.rotationInput.setValue(euler);
    }
    if (this.scaleInput) {
      this.scaleInput.setValue(this.selectedNode.transform.scale);
    }
  }
}

// ../../src/core/debug/panels/RenderSettingsPanel.ts
class RenderSettingsPanel extends Panel {
  scene = null;
  settingsContainer;
  toggleRows = new Map;
  sliderRows = new Map;
  constructor() {
    super("Render Settings", { defaultOpen: false });
    this.settingsContainer = document.createElement("div");
    this.settingsContainer.style.fontSize = "11px";
    this.content.appendChild(this.settingsContainer);
    this.buildSettings();
  }
  setScene(scene) {
    this.scene = scene;
    this.syncFromScene();
  }
  buildSettings() {
    this.createSectionHeader("Post Processing");
    this.createToggle("taa", "TAA", true, (checked) => {
      if (this.scene)
        this.scene.postProcessing.aa.enabled = checked;
    });
    this.createToggle("fxaa", "FXAA", false, (checked) => {
      if (this.scene)
        this.scene.postProcessing.fxaa.enabled = checked;
    });
    this.createToggle("ssao", "SSAO", true, (checked) => {
      if (this.scene)
        this.scene.postProcessing.ssao.enabled = checked;
    });
    this.createSlider("ssaoRadius", "SSAO Radius", 0.1, 5, 0.5, 0.1, (val) => {
      if (this.scene)
        this.scene.postProcessing.ssao.radius = val;
    });
    this.createSlider("ssaoBias", "SSAO Bias", 0.001, 0.1, 0.025, 0.001, (val) => {
      if (this.scene)
        this.scene.postProcessing.ssao.bias = val;
    });
    this.createSectionHeader("Global Illumination");
    this.createToggle("ssgi", "SSGI (Alpha)", true, (checked) => {
      if (this.scene)
        this.scene.globalIllumination.enabled = checked;
    });
    this.createSlider("ssgiIntensity", "SSGI Intensity", 0, 3, 0.1, 0.1, (val) => {
      if (this.scene)
        this.scene.globalIllumination.intensity = val;
    });
    this.createToggle("ssgiSpatial", "SSGI Spatial Denoise", false, (checked) => {
      if (this.scene)
        this.scene.globalIllumination.spatialDenoise = checked;
    });
    this.createToggle("ssgiTemporal", "SSGI Temporal Denoise", true, (checked) => {
      if (this.scene)
        this.scene.globalIllumination.temporalDenoise = checked;
    });
    this.createSectionHeader("Culling & Draw");
    this.createToggle("indirect", "Indirect Draw", true, (checked) => {
      if (this.scene)
        this.scene.render.indirectDraw = checked;
    });
    this.createToggle("frustum", "Frustum Culling", true, (checked) => {
      if (this.scene)
        this.scene.render.frustumCulling = checked;
    });
    this.createToggle("occlusion", "Occlusion Culling", true, (checked) => {
      if (this.scene)
        this.scene.render.occlusionCulling = checked;
    });
  }
  createSectionHeader(title) {
    const header = document.createElement("div");
    header.innerText = title;
    header.style.fontWeight = "bold";
    header.style.marginTop = "8px";
    header.style.marginBottom = "4px";
    header.style.fontSize = "10px";
    header.style.color = "#aaa";
    header.style.borderBottom = "1px solid #444";
    header.style.paddingBottom = "2px";
    this.settingsContainer.appendChild(header);
  }
  createToggle(id, label, defaultValue, onChange) {
    const row = document.createElement("div");
    row.style.display = "flex";
    row.style.alignItems = "center";
    row.style.marginBottom = "3px";
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.checked = defaultValue;
    checkbox.style.marginRight = "6px";
    checkbox.onchange = () => onChange(checkbox.checked);
    row.appendChild(checkbox);
    this.toggleRows.set(id, checkbox);
    const labelSpan = document.createElement("span");
    labelSpan.innerText = label;
    labelSpan.style.fontSize = "10px";
    row.appendChild(labelSpan);
    this.settingsContainer.appendChild(row);
  }
  createSlider(id, label, min, max, defaultValue, step, onChange) {
    const row = document.createElement("div");
    row.style.display = "flex";
    row.style.alignItems = "center";
    row.style.marginBottom = "3px";
    row.style.fontSize = "10px";
    const labelSpan = document.createElement("span");
    labelSpan.innerText = label + ": ";
    labelSpan.style.marginRight = "5px";
    labelSpan.style.minWidth = "80px";
    labelSpan.style.color = "#aaa";
    row.appendChild(labelSpan);
    const slider = document.createElement("input");
    slider.type = "range";
    slider.min = min.toString();
    slider.max = max.toString();
    slider.step = step.toString();
    slider.value = defaultValue.toString();
    slider.style.width = "60px";
    const valueSpan = document.createElement("span");
    valueSpan.innerText = defaultValue.toFixed(3);
    valueSpan.style.marginLeft = "5px";
    valueSpan.style.minWidth = "40px";
    slider.oninput = () => {
      const val = parseFloat(slider.value);
      valueSpan.innerText = val.toFixed(3);
      onChange(val);
    };
    this.sliderRows.set(id, { slider, value: valueSpan });
    row.appendChild(slider);
    row.appendChild(valueSpan);
    this.settingsContainer.appendChild(row);
  }
  syncFromScene() {
    if (!this.scene)
      return;
    this.toggleRows.get("taa").checked = this.scene.postProcessing.aa.enabled;
    this.toggleRows.get("fxaa").checked = this.scene.postProcessing.fxaa.enabled;
    this.toggleRows.get("ssao").checked = this.scene.postProcessing.ssao.enabled;
    this.toggleRows.get("ssgi").checked = this.scene.globalIllumination.enabled;
    this.toggleRows.get("ssgiSpatial").checked = this.scene.globalIllumination.spatialDenoise;
    this.toggleRows.get("ssgiTemporal").checked = this.scene.globalIllumination.temporalDenoise;
    this.toggleRows.get("indirect").checked = this.scene.render.indirectDraw;
    this.toggleRows.get("frustum").checked = this.scene.render.frustumCulling;
    this.toggleRows.get("occlusion").checked = this.scene.render.occlusionCulling;
    const ssaoRadius = this.sliderRows.get("ssaoRadius");
    if (ssaoRadius) {
      ssaoRadius.slider.value = this.scene.postProcessing.ssao.radius.toString();
      ssaoRadius.value.innerText = this.scene.postProcessing.ssao.radius.toFixed(3);
    }
    const ssaoBias = this.sliderRows.get("ssaoBias");
    if (ssaoBias) {
      ssaoBias.slider.value = this.scene.postProcessing.ssao.bias.toString();
      ssaoBias.value.innerText = this.scene.postProcessing.ssao.bias.toFixed(3);
    }
    const ssgiIntensity = this.sliderRows.get("ssgiIntensity");
    if (ssgiIntensity) {
      ssgiIntensity.slider.value = this.scene.globalIllumination.intensity.toString();
      ssgiIntensity.value.innerText = this.scene.globalIllumination.intensity.toFixed(3);
    }
  }
}

// ../../src/core/debug/panels/LightsPanel.ts
class LightsPanel extends Panel {
  scene = null;
  lightsContainer;
  callbacks;
  constructor(callbacks = {}) {
    super("Lights", { showRefresh: true, onRefresh: () => this.refresh() });
    this.callbacks = callbacks;
    this.lightsContainer = document.createElement("div");
    this.lightsContainer.style.maxHeight = "150px";
    this.lightsContainer.style.overflowY = "auto";
    this.lightsContainer.style.fontSize = "11px";
    this.content.appendChild(this.lightsContainer);
  }
  onToggle(isOpen) {
    if (isOpen) {
      this.refresh();
    }
  }
  setScene(scene) {
    this.scene = scene;
  }
  refresh() {
    if (!this.scene) {
      this.lightsContainer.innerHTML = '<i style="color: #888;">No scene registered</i>';
      return;
    }
    this.lightsContainer.innerHTML = "";
    if (this.scene.lights.length === 0) {
      this.lightsContainer.innerHTML = '<i style="color: #888;">No lights in scene</i>';
      return;
    }
    for (const light of this.scene.lights) {
      this.lightsContainer.appendChild(this.createLightRow(light));
    }
  }
  createLightRow(light) {
    const row = document.createElement("div");
    row.style.display = "flex";
    row.style.alignItems = "center";
    row.style.marginBottom = "3px";
    row.style.padding = "3px";
    row.style.backgroundColor = "rgba(255, 255, 255, 0.05)";
    row.style.borderRadius = "3px";
    row.style.cursor = "pointer";
    row.onmouseenter = () => {
      row.style.backgroundColor = "rgba(255, 255, 255, 0.1)";
    };
    row.onmouseleave = () => {
      row.style.backgroundColor = "rgba(255, 255, 255, 0.05)";
    };
    row.onclick = () => {
      this.callbacks.onSelectLight?.(light);
    };
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.checked = light.visible;
    checkbox.style.marginRight = "6px";
    checkbox.onclick = (e) => e.stopPropagation();
    checkbox.onchange = () => {
      light.visible = checkbox.checked;
    };
    row.appendChild(checkbox);
    const { typeLabel, typeColor } = this.getLightTypeInfo(light);
    const typeSpan = document.createElement("span");
    typeSpan.innerText = `[${typeLabel}]`;
    typeSpan.style.color = typeColor;
    typeSpan.style.marginRight = "6px";
    typeSpan.style.fontSize = "9px";
    typeSpan.style.fontWeight = "bold";
    row.appendChild(typeSpan);
    const nameSpan = document.createElement("span");
    nameSpan.innerText = light.name || "Unnamed";
    nameSpan.style.flex = "1";
    nameSpan.style.overflow = "hidden";
    nameSpan.style.textOverflow = "ellipsis";
    nameSpan.style.whiteSpace = "nowrap";
    row.appendChild(nameSpan);
    const intensitySpan = document.createElement("span");
    intensitySpan.innerText = `${light.intensity.toFixed(1)}`;
    intensitySpan.style.color = "#888";
    intensitySpan.style.fontSize = "9px";
    intensitySpan.style.marginLeft = "4px";
    intensitySpan.title = "Intensity";
    row.appendChild(intensitySpan);
    if (light.shadow.castShadow) {
      const shadowIcon = document.createElement("span");
      shadowIcon.innerText = "\uD83C\uDF11";
      shadowIcon.style.marginLeft = "4px";
      shadowIcon.style.fontSize = "10px";
      shadowIcon.title = "Casts Shadow";
      row.appendChild(shadowIcon);
    }
    return row;
  }
  getLightTypeInfo(light) {
    switch (light.type) {
      case 0 /* Directional */:
        return { typeLabel: "Dir", typeColor: "#ffa" };
      case 1 /* Point */:
        return { typeLabel: "Pt", typeColor: "#aff" };
      case 2 /* Spot */:
        return { typeLabel: "Spot", typeColor: "#faf" };
      default:
        return { typeLabel: "Light", typeColor: "#ff8" };
    }
  }
}

// ../../src/core/debug/panels/UIHierarchyPanel.ts
class UIHierarchyPanel extends Panel {
  uiManager = null;
  treeContainer;
  selectedElement = null;
  callbacks;
  elementNodes = new Map;
  constructor(callbacks = {}) {
    super("UI Hierarchy", { showRefresh: true, onRefresh: () => this.refresh() });
    this.callbacks = callbacks;
    this.treeContainer = document.createElement("div");
    this.treeContainer.style.maxHeight = "200px";
    this.treeContainer.style.overflowY = "auto";
    this.treeContainer.style.fontSize = "11px";
    this.content.appendChild(this.treeContainer);
  }
  onToggle(isOpen) {
    if (isOpen && this.treeContainer.childElementCount === 0) {
      this.refresh();
    }
  }
  setUIManager(uiManager) {
    this.uiManager = uiManager;
    this.treeContainer.innerHTML = "";
    this.elementNodes.clear();
  }
  refresh() {
    this.selectElement(null);
    if (!this.uiManager) {
      this.treeContainer.innerHTML = '<i style="color: #888;">No UI Manager registered</i>';
      return;
    }
    const root = this.uiManager.getRoot();
    if (!root) {
      this.treeContainer.innerHTML = '<i style="color: #888;">No UI root element</i>';
      return;
    }
    this.treeContainer.innerHTML = "";
    this.elementNodes.clear();
    this.treeContainer.appendChild(this.buildElementTree(root));
  }
  selectElement(element, triggerCallback = true) {
    if (this.selectedElement === element)
      return;
    if (this.selectedElement) {
      const prevEl = this.elementNodes.get(this.selectedElement);
      if (prevEl) {
        prevEl.style.backgroundColor = "transparent";
      }
    }
    this.selectedElement = element;
    if (element) {
      const el = this.elementNodes.get(element);
      if (el) {
        el.style.backgroundColor = "rgba(255, 100, 100, 0.2)";
      }
    }
    if (triggerCallback) {
      this.callbacks.onSelectElement?.(element);
    }
  }
  getSelectedElement() {
    return this.selectedElement;
  }
  buildElementTree(element, depth = 0) {
    const container = document.createElement("div");
    container.style.marginLeft = `${depth * 12}px`;
    const row = document.createElement("div");
    row.style.display = "flex";
    row.style.alignItems = "center";
    row.style.marginBottom = "2px";
    row.style.padding = "2px 4px";
    row.style.borderRadius = "3px";
    row.style.cursor = "pointer";
    this.elementNodes.set(element, row);
    row.onmouseenter = () => {
      if (element !== this.selectedElement) {
        row.style.backgroundColor = "rgba(255, 255, 255, 0.05)";
      }
    };
    row.onmouseleave = () => {
      if (element !== this.selectedElement) {
        row.style.backgroundColor = "transparent";
      }
    };
    row.onclick = (e) => {
      e.stopPropagation();
      if (this.selectedElement === element) {
        this.selectElement(null);
      } else {
        this.selectElement(element);
      }
    };
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.checked = element.visible;
    checkbox.style.marginRight = "5px";
    checkbox.style.cursor = "pointer";
    checkbox.onclick = (e) => e.stopPropagation();
    checkbox.onchange = () => {
      element.visible = checkbox.checked;
    };
    row.appendChild(checkbox);
    const { typeName, typeColor } = this.getElementTypeInfo(element);
    const typeSpan = document.createElement("span");
    typeSpan.innerText = `[${typeName}]`;
    typeSpan.style.color = typeColor;
    typeSpan.style.marginRight = "6px";
    typeSpan.style.fontSize = "9px";
    typeSpan.style.fontWeight = "bold";
    row.appendChild(typeSpan);
    const nameSpan = document.createElement("span");
    nameSpan.innerText = element.name || element.id || "Unnamed";
    nameSpan.style.flex = "1";
    nameSpan.style.overflow = "hidden";
    nameSpan.style.textOverflow = "ellipsis";
    nameSpan.style.whiteSpace = "nowrap";
    row.appendChild(nameSpan);
    container.appendChild(row);
    if (element.children.length > 0) {
      const childrenContainer = document.createElement("div");
      for (const child of element.children) {
        childrenContainer.appendChild(this.buildElementTree(child, depth + 1));
      }
      container.appendChild(childrenContainer);
    }
    return container;
  }
  getElementTypeInfo(element) {
    if (element instanceof Button) {
      return { typeName: "Btn", typeColor: "#ffaa66" };
    } else if (element instanceof Label) {
      return { typeName: "Lbl", typeColor: "#aaffaa" };
    } else if (element instanceof Image2) {
      return { typeName: "Img", typeColor: "#aaaaff" };
    }
    const constructorName = element.constructor.name;
    switch (constructorName) {
      case "Panel":
        return { typeName: "Pnl", typeColor: "#ffaaff" };
      case "Toggle":
        return { typeName: "Tgl", typeColor: "#aaffff" };
      case "Slider":
        return { typeName: "Sld", typeColor: "#ffffaa" };
      case "TypewriterBox":
        return { typeName: "Txt", typeColor: "#ff88ff" };
      case "DialogueBox":
        return { typeName: "Dlg", typeColor: "#88ffff" };
      case "CharacterDisplay":
        return { typeName: "Chr", typeColor: "#ffff88" };
      default:
        return { typeName: "UI", typeColor: "#888888" };
    }
  }
}

// ../../src/debug/ErrorOverlay.ts
class ErrorOverlay {
  static instance;
  element;
  content;
  header;
  errorList;
  isVisible = false;
  errorCount = 0;
  static MAX_ERRORS = 50;
  constructor() {
    this.element = document.createElement("div");
    this.element.style.position = "fixed";
    this.element.style.top = "50%";
    this.element.style.left = "50%";
    this.element.style.transform = "translate(-50%, -50%)";
    this.element.style.width = "80%";
    this.element.style.maxWidth = "800px";
    this.element.style.maxHeight = "80vh";
    this.element.style.backgroundColor = "rgba(20, 20, 20, 0.95)";
    this.element.style.border = "1px solid #ff4444";
    this.element.style.boxShadow = "0 0 20px rgba(0, 0, 0, 0.8)";
    this.element.style.color = "#fff";
    this.element.style.fontFamily = "monospace";
    this.element.style.zIndex = "10000";
    this.element.style.display = "none";
    this.element.style.flexDirection = "column";
    this.element.style.borderRadius = "8px";
    this.header = document.createElement("div");
    this.header.style.padding = "10px 15px";
    this.header.style.backgroundColor = "#331111";
    this.header.style.borderBottom = "1px solid #552222";
    this.header.style.display = "flex";
    this.header.style.justifyContent = "space-between";
    this.header.style.alignItems = "center";
    this.header.style.borderTopLeftRadius = "8px";
    this.header.style.borderTopRightRadius = "8px";
    const titleContainer = document.createElement("div");
    titleContainer.style.display = "flex";
    titleContainer.style.alignItems = "center";
    titleContainer.style.gap = "10px";
    const title = document.createElement("span");
    title.innerText = "⚠️ Engine Errors";
    title.style.fontWeight = "bold";
    title.style.color = "#ff6666";
    titleContainer.appendChild(title);
    this.header.appendChild(titleContainer);
    const controls = document.createElement("div");
    controls.style.display = "flex";
    controls.style.gap = "10px";
    const copyFirstBtn = document.createElement("button");
    copyFirstBtn.innerText = "Copy first";
    copyFirstBtn.style.background = "#444";
    copyFirstBtn.style.border = "1px solid #666";
    copyFirstBtn.style.color = "#fff";
    copyFirstBtn.style.cursor = "pointer";
    copyFirstBtn.style.fontSize = "12px";
    copyFirstBtn.style.padding = "2px 8px";
    copyFirstBtn.style.borderRadius = "4px";
    copyFirstBtn.onclick = () => this.copyToClipboard(1, copyFirstBtn);
    controls.appendChild(copyFirstBtn);
    const copyFirst3Btn = document.createElement("button");
    copyFirst3Btn.innerText = "Copy first 3";
    copyFirst3Btn.style.background = "#444";
    copyFirst3Btn.style.border = "1px solid #666";
    copyFirst3Btn.style.color = "#fff";
    copyFirst3Btn.style.cursor = "pointer";
    copyFirst3Btn.style.fontSize = "12px";
    copyFirst3Btn.style.padding = "2px 8px";
    copyFirst3Btn.style.borderRadius = "4px";
    copyFirst3Btn.onclick = () => this.copyToClipboard(3, copyFirst3Btn);
    controls.appendChild(copyFirst3Btn);
    const copyBtn = document.createElement("button");
    copyBtn.innerText = "Copy All";
    copyBtn.style.background = "#444";
    copyBtn.style.border = "1px solid #666";
    copyBtn.style.color = "#fff";
    copyBtn.style.cursor = "pointer";
    copyBtn.style.fontSize = "12px";
    copyBtn.style.padding = "2px 8px";
    copyBtn.style.borderRadius = "4px";
    copyBtn.onclick = () => this.copyToClipboard(undefined, copyBtn);
    controls.appendChild(copyBtn);
    const closeBtn = document.createElement("button");
    closeBtn.innerText = "✕";
    closeBtn.style.background = "none";
    closeBtn.style.border = "none";
    closeBtn.style.color = "#fff";
    closeBtn.style.cursor = "pointer";
    closeBtn.style.fontSize = "16px";
    closeBtn.onclick = () => this.hide();
    controls.appendChild(closeBtn);
    this.header.appendChild(controls);
    this.element.appendChild(this.header);
    this.content = document.createElement("div");
    this.content.style.padding = "0";
    this.content.style.overflowY = "auto";
    this.content.style.flex = "1";
    this.element.appendChild(this.content);
    this.errorList = document.createElement("div");
    this.content.appendChild(this.errorList);
    document.body.appendChild(this.element);
  }
  static getInstance() {
    if (!ErrorOverlay.instance) {
      ErrorOverlay.instance = new ErrorOverlay;
    }
    return ErrorOverlay.instance;
  }
  show() {
    if (!this.isVisible) {
      this.element.style.display = "flex";
      this.isVisible = true;
    }
  }
  hide() {
    this.element.style.display = "none";
    this.isVisible = false;
  }
  clear() {
    this.errorList.innerHTML = "";
    this.errorCount = 0;
  }
  reportError(message, source = "General") {
    if (this.errorCount >= ErrorOverlay.MAX_ERRORS)
      return;
    this.show();
    const item = this.createErrorItem(source, message, "error");
    this.errorList.appendChild(item);
    this.errorCount++;
    if (this.errorCount >= ErrorOverlay.MAX_ERRORS) {
      this.addLimitMessage();
    }
  }
  reportWarning(message, source = "General") {
    if (this.errorCount >= ErrorOverlay.MAX_ERRORS)
      return;
    const item = this.createErrorItem(source, message, "warning");
    this.errorList.appendChild(item);
    this.errorCount++;
    if (this.errorCount >= ErrorOverlay.MAX_ERRORS) {
      this.addLimitMessage();
    }
  }
  reportShaderIssues(label, code, messages) {
    if (this.errorCount >= ErrorOverlay.MAX_ERRORS)
      return;
    let hasError = false;
    const messageContainer = document.createElement("div");
    messageContainer.style.padding = "10px";
    messageContainer.style.borderBottom = "1px solid #444";
    const header = document.createElement("div");
    header.innerText = `Shader Compilation: ${label}`;
    header.style.fontWeight = "bold";
    header.style.marginBottom = "5px";
    header.style.color = "#aaa";
    messageContainer.appendChild(header);
    const codeLines = code.split(`
`);
    for (const msg of messages) {
      if (msg.type === "error")
        hasError = true;
      const msgDiv = document.createElement("div");
      msgDiv.style.marginBottom = "8px";
      msgDiv.style.padding = "5px";
      msgDiv.style.backgroundColor = msg.type === "error" ? "rgba(255, 0, 0, 0.1)" : "rgba(255, 255, 0, 0.1)";
      msgDiv.style.borderLeft = `3px solid ${msg.type === "error" ? "#f44" : "#fa0"}`;
      const text = document.createElement("div");
      text.innerText = `[${msg.type.toUpperCase()}] Line ${msg.lineNum}:${msg.linePos} - ${msg.message}`;
      text.style.color = msg.type === "error" ? "#f88" : "#fe8";
      msgDiv.appendChild(text);
      if (msg.lineNum && msg.lineNum <= codeLines.length) {
        const context = document.createElement("pre");
        context.style.margin = "4px 0 0 0";
        context.style.fontSize = "11px";
        context.style.color = "#888";
        context.style.overflowX = "auto";
        const startLine = Math.max(0, msg.lineNum - 2);
        const endLine = Math.min(codeLines.length - 1, msg.lineNum + 2);
        let contextStr = "";
        for (let i = startLine;i <= endLine; i++) {
          const prefix = i + 1 === msg.lineNum ? "> " : "  ";
          contextStr += `${prefix}${i + 1}: ${codeLines[i]}
`;
        }
        context.innerText = contextStr;
        msgDiv.appendChild(context);
      }
      messageContainer.appendChild(msgDiv);
    }
    this.errorList.appendChild(messageContainer);
    this.errorCount++;
    if (hasError) {
      this.show();
    }
    if (this.errorCount >= ErrorOverlay.MAX_ERRORS) {
      this.addLimitMessage();
    }
  }
  addLimitMessage() {
    const div = document.createElement("div");
    div.style.padding = "10px";
    div.style.textAlign = "center";
    div.style.color = "#888";
    div.style.fontStyle = "italic";
    div.innerText = `Error limit reached (${ErrorOverlay.MAX_ERRORS}). Further errors suppressed.`;
    this.errorList.appendChild(div);
  }
  copyToClipboard(count, button) {
    let text;
    if (count === undefined) {
      text = this.errorList.innerText;
    } else {
      const children = this.errorList.children;
      const parts = [];
      for (let i = 0;i < Math.min(count, children.length); i++) {
        parts.push(children[i].innerText);
      }
      text = parts.join(`

`);
    }
    navigator.clipboard.writeText(text).then(() => {
      if (button) {
        const originalText = button.innerText;
        button.innerText = "✓";
        setTimeout(() => {
          button.innerText = originalText;
        }, 2000);
      }
    }).catch((err) => {
      console.error("Failed to copy errors: ", err);
    });
  }
  createErrorItem(source, message, type) {
    const div = document.createElement("div");
    div.style.padding = "10px";
    div.style.borderBottom = "1px solid #444";
    div.style.backgroundColor = type === "error" ? "rgba(50, 0, 0, 0.3)" : "rgba(50, 50, 0, 0.2)";
    const meta = document.createElement("div");
    meta.style.fontSize = "11px";
    meta.style.color = "#aaa";
    meta.style.marginBottom = "4px";
    meta.innerText = `[${type.toUpperCase()}] ${source} - ${new Date().toLocaleTimeString()}`;
    div.appendChild(meta);
    const msg = document.createElement("div");
    msg.innerText = message;
    msg.style.whiteSpace = "pre-wrap";
    msg.style.color = type === "error" ? "#f66" : "#fd8";
    div.appendChild(msg);
    return div;
  }
}

// ../../src/core/renderer/RendererCapabilities.ts
var DEFAULT_SOFTWARE_RENDERING_CONFIG = {
  forceSoftwareMode: false,
  disableSSGI: true,
  disableSSR: true,
  disableSSAO: false,
  disableTAA: false,
  disableBloom: false,
  disableDoF: true,
  disableMotionBlur: true,
  disableAtmosphere: false,
  simpleShadows: true,
  reduceTextureQuality: true
};
var cachedCapabilities = null;
async function detectRendererCapabilities(adapter) {
  if (cachedCapabilities) {
    return cachedCapabilities;
  }
  let info = {
    vendor: "",
    architecture: "",
    device: "",
    description: ""
  };
  const adapterAny = adapter;
  if (typeof adapterAny.requestAdapterInfo === "function") {
    try {
      info = await adapterAny.requestAdapterInfo();
    } catch {
      info = adapterAny.info ?? info;
    }
  } else if (adapterAny.info) {
    info = adapterAny.info;
  }
  const vendor = info.vendor?.toLowerCase() ?? "";
  const architecture = info.architecture?.toLowerCase() ?? "";
  const device = info.device?.toLowerCase() ?? "";
  const description = info.description?.toLowerCase() ?? "";
  const isSoftwareRenderer = vendor.includes("google") && (architecture.includes("swiftshader") || device.includes("swiftshader")) || description.includes("swiftshader") || description.includes("llvmpipe") || description.includes("software") || vendor.includes("mesa") && description.includes("llvmpipe") || description.includes("angle") && description.includes("swiftshader");
  const supportsMappedAtCreation = !isSoftwareRenderer;
  const supportsCompute = true;
  const maxTextureSize = isSoftwareRenderer ? 2048 : adapter.limits.maxTextureDimension2D;
  cachedCapabilities = {
    isSoftwareRenderer,
    vendor: info.vendor ?? "unknown",
    architecture: info.architecture ?? "unknown",
    device: info.device ?? "unknown",
    description: info.description ?? "unknown",
    supportsMappedAtCreation,
    supportsCompute,
    maxTextureSize,
    useReducedQuality: isSoftwareRenderer
  };
  if (isSoftwareRenderer) {
    console.warn("RendererCapabilities: Software renderer detected. Some features will be disabled for compatibility.");
    console.log("RendererCapabilities: Adapter info:", {
      vendor: cachedCapabilities.vendor,
      device: cachedCapabilities.device,
      description: cachedCapabilities.description
    });
  }
  return cachedCapabilities;
}
function getRendererCapabilities() {
  return cachedCapabilities;
}
function isSoftwareRenderingMode(config) {
  if (config?.forceSoftwareMode) {
    return true;
  }
  return cachedCapabilities?.isSoftwareRenderer ?? false;
}
function getEffectiveSoftwareConfig(userConfig) {
  const isSoftware = isSoftwareRenderingMode(userConfig);
  if (!isSoftware) {
    return {};
  }
  return {
    ...DEFAULT_SOFTWARE_RENDERING_CONFIG,
    ...userConfig
  };
}
function createBufferWithData(device, data, usage, label) {
  const capabilities = getRendererCapabilities();
  const alignedSize = Math.ceil(data.byteLength / 4) * 4;
  if (capabilities?.isSoftwareRenderer) {
    const buffer = device.createBuffer({
      label,
      size: alignedSize,
      usage: usage | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(buffer, 0, data.buffer, data.byteOffset, data.byteLength);
    return buffer;
  } else {
    const buffer = device.createBuffer({
      label,
      size: alignedSize,
      usage,
      mappedAtCreation: true
    });
    if (data instanceof Float32Array) {
      new Float32Array(buffer.getMappedRange()).set(data);
    } else if (data instanceof Uint32Array) {
      new Uint32Array(buffer.getMappedRange()).set(data);
    } else if (data instanceof Int32Array) {
      new Int32Array(buffer.getMappedRange()).set(data);
    } else if (data instanceof Uint16Array) {
      new Uint16Array(buffer.getMappedRange()).set(data);
    }
    buffer.unmap();
    return buffer;
  }
}

// ../../src/core/utils/WebGPUUtils.ts
function createShaderModuleSafe(device, descriptor) {
  const module = device.createShaderModule(descriptor);
  const capabilities = getRendererCapabilities();
  if (capabilities?.isSoftwareRenderer) {
    return module;
  }
  if (module.getCompilationInfo) {
    module.getCompilationInfo().then((info) => {
      if (info.messages.length > 0) {
        const errors = info.messages.filter((m) => m.type === "error");
        const warnings = info.messages.filter((m) => m.type === "warning");
        if (errors.length > 0 || warnings.length > 0) {
          ErrorOverlay.getInstance().reportShaderIssues(descriptor.label || "Unknown Shader", descriptor.code, info.messages);
        }
      }
    }).catch((err) => {
      console.error("Failed to get shader compilation info:", err);
      ErrorOverlay.getInstance().reportError("Failed to get shader compilation info: " + err.message, "Internal Error");
    });
  }
  return module;
}

// ../../src/core/Texture.ts
class Texture {
  gpuTexture = null;
  view = null;
  sampler = null;
  label;
  srgb = false;
  premultiplyAlpha = false;
  constructor(label = "Texture", options) {
    this.label = label;
    if (options) {
      this.srgb = options.srgb ?? false;
      this.premultiplyAlpha = options.premultiplyAlpha ?? false;
    }
  }
  async load(device, url) {
    try {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`Failed to fetch texture: ${response.status} ${response.statusText}`);
      }
      const blob = await response.blob();
      const imgBitmap = await createImageBitmap(blob);
      this.createFromImageBitmap(device, imgBitmap);
    } catch (e) {
      console.error(`Failed to load texture: ${url}`, e);
      throw e;
    }
  }
  static fromGPUTexture(device, gpuTexture, label = "GPU Texture") {
    const texture = new Texture(label);
    texture.gpuTexture = gpuTexture;
    texture.view = gpuTexture.createView();
    texture.sampler = device.createSampler({
      magFilter: "linear",
      minFilter: "linear",
      addressModeU: "repeat",
      addressModeV: "repeat"
    });
    return texture;
  }
  createFromImageBitmap(device, imgBitmap) {
    const mipLevelCount = Math.floor(Math.log2(Math.max(imgBitmap.width, imgBitmap.height))) + 1;
    const format = this.srgb ? "rgba8unorm-srgb" : "rgba8unorm";
    this.gpuTexture = device.createTexture({
      label: this.label,
      size: [imgBitmap.width, imgBitmap.height, 1],
      format,
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,
      mipLevelCount
    });
    device.queue.copyExternalImageToTexture({ source: imgBitmap, flipY: false }, { texture: this.gpuTexture, premultipliedAlpha: this.premultiplyAlpha }, [imgBitmap.width, imgBitmap.height]);
    if (mipLevelCount > 1) {
      Texture.generateMipmaps(device, this.gpuTexture, mipLevelCount);
    }
    this.view = this.gpuTexture.createView();
    this.sampler = device.createSampler({
      magFilter: "linear",
      minFilter: "linear",
      mipmapFilter: "linear",
      addressModeU: "repeat",
      addressModeV: "repeat",
      maxAnisotropy: 4
    });
  }
  static generateMipmaps(device, texture, mipLevelCount) {
    const pipeline = Texture.getMipmapPipeline(device, texture.format);
    const commandEncoder = device.createCommandEncoder({ label: "Mipmap Gen" });
    let width = texture.width;
    let height = texture.height;
    for (let i = 1;i < mipLevelCount; i++) {
      const dstWidth = Math.max(1, Math.floor(width / 2));
      const dstHeight = Math.max(1, Math.floor(height / 2));
      const bindGroup = device.createBindGroup({
        layout: pipeline.getBindGroupLayout(0),
        entries: [
          { binding: 0, resource: device.createSampler({ minFilter: "linear" }) },
          { binding: 1, resource: texture.createView({ baseMipLevel: i - 1, mipLevelCount: 1 }) }
        ]
      });
      const pass = commandEncoder.beginRenderPass({
        colorAttachments: [{
          view: texture.createView({ baseMipLevel: i, mipLevelCount: 1 }),
          loadOp: "clear",
          storeOp: "store"
        }]
      });
      pass.setPipeline(pipeline);
      pass.setBindGroup(0, bindGroup);
      pass.draw(3);
      pass.end();
      width = dstWidth;
      height = dstHeight;
    }
    device.queue.submit([commandEncoder.finish()]);
  }
  static mipmapPipelineCache = new WeakMap;
  static getMipmapPipeline(device, format) {
    let deviceCache = this.mipmapPipelineCache.get(device);
    if (!deviceCache) {
      deviceCache = new Map;
      this.mipmapPipelineCache.set(device, deviceCache);
    }
    if (deviceCache.has(format)) {
      return deviceCache.get(format);
    }
    const module2 = createShaderModuleSafe(device, {
      code: `
            struct VertexOutput {
                @builtin(position) position : vec4f,
                @location(0) uv : vec2f,
            }

            @vertex
            fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                var output : VertexOutput;
                let pos = array(
                  vec2f(-1.0, -1.0),
                  vec2f( 3.0, -1.0),
                  vec2f(-1.0,  3.0)
                );
                let p = pos[vertexIndex];
                output.position = vec4f(p, 0.0, 1.0);
                output.uv = p * 0.5 + 0.5;
                output.uv.y = 1.0 - output.uv.y; 
                return output;
            }

            @group(0) @binding(0) var samp : sampler;
            @group(0) @binding(1) var img : texture_2d<f32>;

            @fragment
            fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {
                return textureSample(img, samp, uv);
            }
          `
    });
    const pipeline = device.createRenderPipeline({
      layout: "auto",
      vertex: {
        module: module2,
        entryPoint: "vs_main"
      },
      fragment: {
        module: module2,
        entryPoint: "fs_main",
        targets: [{ format }]
      },
      primitive: { topology: "triangle-list" }
    });
    deviceCache.set(format, pipeline);
    return pipeline;
  }
  static _defaultTextures = new WeakMap;
  static getDefault(device) {
    if (!Texture._defaultTextures.has(device)) {
      const texture = new Texture("Default White Texture");
      texture.gpuTexture = device.createTexture({
        label: "Default White Texture",
        size: [1, 1, 1],
        format: "rgba8unorm",
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
      });
      const data = new Uint8Array([255, 255, 255, 255]);
      device.queue.writeTexture({ texture: texture.gpuTexture }, data, { bytesPerRow: 4, rowsPerImage: 1 }, [1, 1, 1]);
      texture.view = texture.gpuTexture.createView();
      texture.sampler = device.createSampler({
        magFilter: "linear",
        minFilter: "linear"
      });
      Texture._defaultTextures.set(device, texture);
    }
    return Texture._defaultTextures.get(device);
  }
}

// ../../src/core/debug/panels/UIInspectorPanel.ts
class UIInspectorPanel extends Panel {
  selectedElement = null;
  contentContainer;
  codeFormatSelect;
  currentFormat = "jsx";
  device = null;
  constructor() {
    super("UI Inspector", { defaultOpen: false });
    const formatSection = document.createElement("div");
    formatSection.style.marginBottom = "8px";
    formatSection.style.display = "flex";
    formatSection.style.alignItems = "center";
    formatSection.style.gap = "8px";
    const formatLabel = document.createElement("span");
    formatLabel.innerText = "Format:";
    formatLabel.style.fontSize = "10px";
    formatSection.appendChild(formatLabel);
    this.codeFormatSelect = document.createElement("select");
    this.codeFormatSelect.style.fontSize = "10px";
    this.codeFormatSelect.style.padding = "2px 4px";
    this.codeFormatSelect.style.backgroundColor = "#222";
    this.codeFormatSelect.style.color = "#fff";
    this.codeFormatSelect.style.border = "1px solid #555";
    this.codeFormatSelect.style.borderRadius = "3px";
    const formats = [
      { value: "jsx", label: "JSX" },
      { value: "yaml", label: "YAML" },
      { value: "typescript", label: "TypeScript" }
    ];
    formats.forEach(({ value, label }) => {
      const option = document.createElement("option");
      option.value = value;
      option.innerText = label;
      this.codeFormatSelect.appendChild(option);
    });
    this.codeFormatSelect.onchange = () => {
      this.currentFormat = this.codeFormatSelect.value;
    };
    formatSection.appendChild(this.codeFormatSelect);
    this.content.appendChild(formatSection);
    this.contentContainer = document.createElement("div");
    this.content.appendChild(this.contentContainer);
  }
  setDevice(device) {
    this.device = device;
  }
  setSelectedElement(element) {
    this.selectedElement = element;
    this.rebuildContent();
  }
  rebuildContent() {
    this.contentContainer.innerHTML = "";
    if (!this.selectedElement) {
      const emptyMsg = document.createElement("div");
      emptyMsg.innerHTML = '<i style="color: #888;">No UI element selected</i>';
      emptyMsg.style.fontSize = "10px";
      this.contentContainer.appendChild(emptyMsg);
      return;
    }
    const element = this.selectedElement;
    const nameHeader = document.createElement("div");
    nameHeader.style.fontWeight = "bold";
    nameHeader.style.marginBottom = "8px";
    nameHeader.style.padding = "4px";
    nameHeader.style.backgroundColor = "rgba(255, 100, 100, 0.1)";
    nameHeader.style.borderRadius = "3px";
    nameHeader.style.border = "1px solid rgba(255, 100, 100, 0.3)";
    nameHeader.innerText = element.name || element.id || "Unnamed Element";
    this.contentContainer.appendChild(nameHeader);
    this.createSection("Type", () => {
      const typeSpan = document.createElement("span");
      typeSpan.style.fontSize = "10px";
      typeSpan.style.color = "#aaa";
      typeSpan.innerText = element.constructor.name;
      return typeSpan;
    });
    this.createSection("Position", () => {
      const container = document.createElement("div");
      container.style.display = "flex";
      container.style.gap = "8px";
      container.style.alignItems = "center";
      const xLabel = document.createElement("span");
      xLabel.innerText = "X:";
      xLabel.style.color = "#ff6666";
      xLabel.style.fontSize = "10px";
      container.appendChild(xLabel);
      const xInput = this.createNumberInput(this.parseStyleValue(element.style.x), (v) => {
        element.style.x = v;
        element.markDirty();
      });
      container.appendChild(xInput);
      const yLabel = document.createElement("span");
      yLabel.innerText = "Y:";
      yLabel.style.color = "#66ff66";
      yLabel.style.fontSize = "10px";
      container.appendChild(yLabel);
      const yInput = this.createNumberInput(this.parseStyleValue(element.style.y), (v) => {
        element.style.y = v;
        element.markDirty();
      });
      container.appendChild(yInput);
      return container;
    });
    this.createSection("Size", () => {
      const container = document.createElement("div");
      container.style.display = "flex";
      container.style.gap = "8px";
      container.style.alignItems = "center";
      const wLabel = document.createElement("span");
      wLabel.innerText = "W:";
      wLabel.style.color = "#6666ff";
      wLabel.style.fontSize = "10px";
      container.appendChild(wLabel);
      const wInput = this.createNumberInput(this.parseStyleValue(element.style.width), (v) => {
        element.style.width = v;
        element.markDirty();
      });
      container.appendChild(wInput);
      const hLabel = document.createElement("span");
      hLabel.innerText = "H:";
      hLabel.style.color = "#ff66ff";
      hLabel.style.fontSize = "10px";
      container.appendChild(hLabel);
      const hInput = this.createNumberInput(this.parseStyleValue(element.style.height), (v) => {
        element.style.height = v;
        element.markDirty();
      });
      container.appendChild(hInput);
      return container;
    });
    this.createSection("Computed Bounds", () => {
      const bounds = element.bounds;
      const span = document.createElement("span");
      span.style.fontSize = "10px";
      span.style.color = "#888";
      span.innerText = `x: ${bounds.x.toFixed(0)}, y: ${bounds.y.toFixed(0)}, w: ${bounds.width.toFixed(0)}, h: ${bounds.height.toFixed(0)}`;
      return span;
    });
    this.createSection("Visibility", () => {
      const visRow = document.createElement("div");
      visRow.style.display = "flex";
      visRow.style.alignItems = "center";
      visRow.style.gap = "8px";
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.checked = element.visible;
      checkbox.onchange = () => {
        element.visible = checkbox.checked;
      };
      visRow.appendChild(checkbox);
      const label = document.createElement("span");
      label.innerText = "Visible";
      label.style.fontSize = "10px";
      visRow.appendChild(label);
      return visRow;
    });
    this.createSection("Opacity", () => {
      const container = document.createElement("div");
      container.style.display = "flex";
      container.style.alignItems = "center";
      container.style.gap = "8px";
      const slider = document.createElement("input");
      slider.type = "range";
      slider.min = "0";
      slider.max = "1";
      slider.step = "0.05";
      slider.value = (element.style.opacity ?? 1).toString();
      slider.style.width = "80px";
      const valueDisplay = document.createElement("span");
      valueDisplay.innerText = (element.style.opacity ?? 1).toFixed(2);
      valueDisplay.style.fontSize = "10px";
      valueDisplay.style.minWidth = "30px";
      slider.oninput = () => {
        const val = parseFloat(slider.value);
        element.style.opacity = val;
        valueDisplay.innerText = val.toFixed(2);
        element.markDirty();
      };
      container.appendChild(slider);
      container.appendChild(valueDisplay);
      return container;
    });
    if (element instanceof Button) {
      this.createButtonSection(element);
    }
    if (element instanceof Label) {
      this.createLabelSection(element);
    }
    if (element instanceof Image2) {
      this.createImageSection(element);
    }
    if (element instanceof Button && element.style.backgroundImage) {
      this.createButtonImageSection(element);
    }
    const divider = document.createElement("div");
    divider.style.borderTop = "1px solid #444";
    divider.style.margin = "8px 0";
    this.contentContainer.appendChild(divider);
    const copyBtn = createCopyButton("Copy UI Element Code", () => {
      if (!this.selectedElement)
        return "";
      return generateUIElementCode(this.selectedElement, this.currentFormat);
    }, { fullWidth: true });
    this.contentContainer.appendChild(copyBtn);
  }
  createSection(title, buildContent) {
    const section = document.createElement("div");
    section.style.marginBottom = "8px";
    const label = document.createElement("div");
    label.innerText = title;
    label.style.fontWeight = "bold";
    label.style.marginBottom = "4px";
    label.style.fontSize = "10px";
    label.style.color = "#aaa";
    section.appendChild(label);
    section.appendChild(buildContent());
    this.contentContainer.appendChild(section);
  }
  createNumberInput(value, onChange) {
    const input = document.createElement("input");
    input.type = "number";
    input.value = value.toString();
    input.style.width = "50px";
    input.style.fontSize = "10px";
    input.style.padding = "2px 4px";
    input.style.backgroundColor = "#222";
    input.style.color = "#fff";
    input.style.border = "1px solid #555";
    input.style.borderRadius = "3px";
    input.onchange = () => {
      const val = parseFloat(input.value) || 0;
      onChange(val);
    };
    return input;
  }
  parseStyleValue(value) {
    if (value === undefined)
      return 0;
    if (typeof value === "number")
      return value;
    if (typeof value === "string" && value.endsWith("%")) {
      return parseFloat(value) || 0;
    }
    return 0;
  }
  createButtonSection(button) {
    this.createSection("Button Text", () => {
      const container = document.createElement("div");
      const textInput = document.createElement("input");
      textInput.type = "text";
      textInput.value = button.text;
      textInput.style.width = "100%";
      textInput.style.fontSize = "10px";
      textInput.style.padding = "4px";
      textInput.style.backgroundColor = "#222";
      textInput.style.color = "#fff";
      textInput.style.border = "1px solid #555";
      textInput.style.borderRadius = "3px";
      textInput.style.boxSizing = "border-box";
      textInput.oninput = () => {
        button.text = textInput.value;
      };
      container.appendChild(textInput);
      return container;
    });
  }
  createLabelSection(label) {
    this.createSection("Label Text", () => {
      const container = document.createElement("div");
      const textArea = document.createElement("textarea");
      textArea.value = label.text;
      textArea.style.width = "100%";
      textArea.style.height = "60px";
      textArea.style.fontSize = "10px";
      textArea.style.padding = "4px";
      textArea.style.backgroundColor = "#222";
      textArea.style.color = "#fff";
      textArea.style.border = "1px solid #555";
      textArea.style.borderRadius = "3px";
      textArea.style.boxSizing = "border-box";
      textArea.style.resize = "vertical";
      textArea.oninput = () => {
        label.text = textArea.value;
      };
      container.appendChild(textArea);
      return container;
    });
    this.createSection("Font Size", () => {
      const container = document.createElement("div");
      container.style.display = "flex";
      container.style.alignItems = "center";
      container.style.gap = "8px";
      const input = this.createNumberInput(label.style.fontSize ?? 16, (v) => {
        label.style.fontSize = v;
        label.markDirty();
      });
      input.style.width = "60px";
      container.appendChild(input);
      const px = document.createElement("span");
      px.innerText = "px";
      px.style.fontSize = "10px";
      px.style.color = "#888";
      container.appendChild(px);
      return container;
    });
    this.createSection("Color", () => {
      const container = document.createElement("div");
      container.style.display = "flex";
      container.style.alignItems = "center";
      container.style.gap = "8px";
      const colorInput = document.createElement("input");
      colorInput.type = "color";
      colorInput.value = label.style.color || "#ffffff";
      colorInput.style.width = "40px";
      colorInput.style.height = "25px";
      colorInput.style.border = "none";
      colorInput.style.cursor = "pointer";
      colorInput.oninput = () => {
        label.style.color = colorInput.value;
        label.markDirty();
      };
      container.appendChild(colorInput);
      const hexDisplay = document.createElement("span");
      hexDisplay.innerText = colorInput.value;
      hexDisplay.style.fontSize = "10px";
      hexDisplay.style.color = "#888";
      container.appendChild(hexDisplay);
      colorInput.oninput = () => {
        label.style.color = colorInput.value;
        hexDisplay.innerText = colorInput.value;
        label.markDirty();
      };
      return container;
    });
  }
  createImageSection(image) {
    this.createSection("Image Source", () => {
      const container = document.createElement("div");
      const info = document.createElement("div");
      info.style.fontSize = "10px";
      info.style.color = "#888";
      info.style.marginBottom = "4px";
      if (image.gpuTexture) {
        info.innerText = `${image.sourceWidth} x ${image.sourceHeight}`;
      } else {
        info.innerText = "No texture loaded";
      }
      container.appendChild(info);
      const fileLabel = document.createElement("label");
      fileLabel.style.display = "inline-block";
      fileLabel.style.padding = "4px 8px";
      fileLabel.style.backgroundColor = "#333";
      fileLabel.style.color = "#fff";
      fileLabel.style.fontSize = "10px";
      fileLabel.style.borderRadius = "3px";
      fileLabel.style.cursor = "pointer";
      fileLabel.style.border = "1px solid #555";
      fileLabel.innerText = "Load Image...";
      const fileInput = document.createElement("input");
      fileInput.type = "file";
      fileInput.accept = "image/*";
      fileInput.style.display = "none";
      fileInput.onchange = async () => {
        if (fileInput.files && fileInput.files[0]) {
          const file = fileInput.files[0];
          await this.loadImageFromFile(file, image);
          info.innerText = `${image.sourceWidth} x ${image.sourceHeight}`;
        }
      };
      fileLabel.appendChild(fileInput);
      container.appendChild(fileLabel);
      return container;
    });
    this.createSection("Scale Mode", () => {
      const select = document.createElement("select");
      select.style.fontSize = "10px";
      select.style.padding = "2px 4px";
      select.style.backgroundColor = "#222";
      select.style.color = "#fff";
      select.style.border = "1px solid #555";
      select.style.borderRadius = "3px";
      const modes = ["stretch", "contain", "cover", "none"];
      modes.forEach((mode) => {
        const option = document.createElement("option");
        option.value = mode;
        option.innerText = mode;
        option.selected = image.style.scaleMode === mode;
        select.appendChild(option);
      });
      select.onchange = () => {
        image.style.scaleMode = select.value;
        image.markDirty();
      };
      return select;
    });
  }
  createButtonImageSection(button) {
    this.createSection("Background Image", () => {
      const container = document.createElement("div");
      const currentTexture = button.style.backgroundImage;
      const info = document.createElement("div");
      info.style.fontSize = "10px";
      info.style.color = "#888";
      info.style.marginBottom = "4px";
      if (currentTexture?.gpuTexture) {
        info.innerText = `${currentTexture.gpuTexture.width} x ${currentTexture.gpuTexture.height}`;
      } else {
        info.innerText = "No background image";
      }
      container.appendChild(info);
      const fileLabel = document.createElement("label");
      fileLabel.style.display = "inline-block";
      fileLabel.style.padding = "4px 8px";
      fileLabel.style.backgroundColor = "#333";
      fileLabel.style.color = "#fff";
      fileLabel.style.fontSize = "10px";
      fileLabel.style.borderRadius = "3px";
      fileLabel.style.cursor = "pointer";
      fileLabel.style.border = "1px solid #555";
      fileLabel.innerText = "Load Background...";
      const fileInput = document.createElement("input");
      fileInput.type = "file";
      fileInput.accept = "image/*";
      fileInput.style.display = "none";
      fileInput.onchange = async () => {
        if (fileInput.files && fileInput.files[0] && this.device) {
          const file = fileInput.files[0];
          const texture = await this.loadTextureFromFile(file);
          if (texture) {
            button.style.backgroundImage = texture;
            info.innerText = `${texture.gpuTexture?.width ?? 0} x ${texture.gpuTexture?.height ?? 0}`;
            button.markDirty();
          }
        }
      };
      fileLabel.appendChild(fileInput);
      container.appendChild(fileLabel);
      return container;
    });
  }
  async loadImageFromFile(file, image) {
    if (!this.device)
      return;
    const texture = await this.loadTextureFromFile(file);
    if (texture) {
      image.setTexture(texture);
    }
  }
  async loadTextureFromFile(file) {
    if (!this.device)
      return null;
    try {
      const blob = new Blob([await file.arrayBuffer()], { type: file.type });
      const imgBitmap = await createImageBitmap(blob);
      const texture = new Texture(file.name);
      texture.createFromImageBitmap(this.device, imgBitmap);
      return texture;
    } catch (e) {
      console.error("Failed to load texture from file:", e);
      return null;
    }
  }
  update() {}
}

// ../../src/core/debug/UISelectionRenderer.ts
class UISelectionRenderer {
  overlayElement = null;
  selectedElement = null;
  canvas = null;
  constructor() {}
  init(canvas) {
    this.canvas = canvas;
    this.overlayElement = document.createElement("div");
    this.overlayElement.style.position = "absolute";
    this.overlayElement.style.pointerEvents = "none";
    this.overlayElement.style.border = "2px solid #ff4444";
    this.overlayElement.style.boxShadow = "0 0 4px rgba(255, 68, 68, 0.5), inset 0 0 4px rgba(255, 68, 68, 0.3)";
    this.overlayElement.style.backgroundColor = "rgba(255, 68, 68, 0.1)";
    this.overlayElement.style.display = "none";
    this.overlayElement.style.zIndex = "999";
    const label = document.createElement("div");
    label.className = "ui-selection-label";
    label.style.position = "absolute";
    label.style.top = "-20px";
    label.style.left = "0";
    label.style.backgroundColor = "#ff4444";
    label.style.color = "white";
    label.style.padding = "2px 6px";
    label.style.fontSize = "10px";
    label.style.fontFamily = "monospace";
    label.style.whiteSpace = "nowrap";
    label.style.borderRadius = "2px 2px 0 0";
    this.overlayElement.appendChild(label);
    if (canvas.parentElement) {
      canvas.parentElement.style.position = "relative";
      canvas.parentElement.appendChild(this.overlayElement);
    }
  }
  setSelectedElement(element) {
    this.selectedElement = element;
    this.updateOverlay();
  }
  getSelectedElement() {
    return this.selectedElement;
  }
  update() {
    this.updateOverlay();
  }
  updateOverlay() {
    if (!this.overlayElement || !this.canvas)
      return;
    if (!this.selectedElement || !this.selectedElement.visible) {
      this.overlayElement.style.display = "none";
      return;
    }
    const bounds = this.selectedElement.bounds;
    const canvasRect = this.canvas.getBoundingClientRect();
    const scaleX = canvasRect.width / this.canvas.width;
    const scaleY = canvasRect.height / this.canvas.height;
    this.overlayElement.style.display = "block";
    this.overlayElement.style.left = `${bounds.x * scaleX}px`;
    this.overlayElement.style.top = `${bounds.y * scaleY}px`;
    this.overlayElement.style.width = `${bounds.width * scaleX}px`;
    this.overlayElement.style.height = `${bounds.height * scaleY}px`;
    const label = this.overlayElement.querySelector(".ui-selection-label");
    if (label) {
      const typeName = this.selectedElement.constructor.name;
      const name = this.selectedElement.name || this.selectedElement.id || "unnamed";
      label.innerText = `${typeName}: ${name}`;
    }
  }
  cleanup() {
    if (this.overlayElement && this.overlayElement.parentElement) {
      this.overlayElement.parentElement.removeChild(this.overlayElement);
    }
    this.overlayElement = null;
    this.selectedElement = null;
    this.canvas = null;
  }
}

// ../../src/core/debug/utils/cameraFocus.ts
var currentAnimation = null;
function calculateFocusPosition(node, camera) {
  let center = node.transform.position.clone();
  let size = 2;
  if (node instanceof Mesh && node.geometry?.aabb) {
    const aabb = node.geometry.aabb;
    const worldMatrix = node.transform.worldMatrix;
    const corners = [
      new Vector3(aabb.min.x, aabb.min.y, aabb.min.z),
      new Vector3(aabb.max.x, aabb.min.y, aabb.min.z),
      new Vector3(aabb.min.x, aabb.max.y, aabb.min.z),
      new Vector3(aabb.max.x, aabb.max.y, aabb.min.z),
      new Vector3(aabb.min.x, aabb.min.y, aabb.max.z),
      new Vector3(aabb.max.x, aabb.min.y, aabb.max.z),
      new Vector3(aabb.min.x, aabb.max.y, aabb.max.z),
      new Vector3(aabb.max.x, aabb.max.y, aabb.max.z)
    ];
    const worldMin = new Vector3(Infinity, Infinity, Infinity);
    const worldMax = new Vector3(-Infinity, -Infinity, -Infinity);
    for (const corner of corners) {
      const worldCorner = worldMatrix.transformVector(corner);
      worldMin.x = Math.min(worldMin.x, worldCorner.x);
      worldMin.y = Math.min(worldMin.y, worldCorner.y);
      worldMin.z = Math.min(worldMin.z, worldCorner.z);
      worldMax.x = Math.max(worldMax.x, worldCorner.x);
      worldMax.y = Math.max(worldMax.y, worldCorner.y);
      worldMax.z = Math.max(worldMax.z, worldCorner.z);
    }
    center = new Vector3((worldMin.x + worldMax.x) / 2, (worldMin.y + worldMax.y) / 2, (worldMin.z + worldMax.z) / 2);
    size = Math.max(worldMax.x - worldMin.x, worldMax.y - worldMin.y, worldMax.z - worldMin.z);
  }
  const fovRad = camera.fov;
  const screenFraction = 0.4;
  const distance = size / (2 * Math.tan(fovRad / 2) * screenFraction);
  const minDistance = size * 1.5;
  const finalDistance = Math.max(distance, minDistance);
  const elevationAngle = 30 * Math.PI / 180;
  const azimuthAngle = 45 * Math.PI / 180;
  const offsetX = finalDistance * Math.cos(elevationAngle) * Math.cos(azimuthAngle);
  const offsetY = finalDistance * Math.sin(elevationAngle);
  const offsetZ = finalDistance * Math.cos(elevationAngle) * Math.sin(azimuthAngle);
  const targetPosition = new Vector3(center.x + offsetX, center.y + offsetY, center.z + offsetZ);
  return { position: targetPosition, lookAt: center };
}
function focusOnNode(node, camera, duration = 400) {
  const { position: targetPosition, lookAt } = calculateFocusPosition(node, camera);
  currentAnimation = {
    isAnimating: true,
    startPosition: camera.transform.position.clone(),
    targetPosition,
    lookAtTarget: lookAt,
    startTime: performance.now(),
    duration
  };
}
function updateCameraFocus(camera) {
  if (!currentAnimation || !currentAnimation.isAnimating) {
    return false;
  }
  const elapsed = performance.now() - currentAnimation.startTime;
  let t = Math.min(elapsed / currentAnimation.duration, 1);
  t = 1 - Math.pow(1 - t, 3);
  const newPos = currentAnimation.startPosition.lerp(currentAnimation.targetPosition, t);
  camera.transform.position.x = newPos.x;
  camera.transform.position.y = newPos.y;
  camera.transform.position.z = newPos.z;
  const up = new Vector3(0, 1, 0);
  camera.viewMatrix = new Matrix4().lookAt(newPos, currentAnimation.lookAtTarget, up);
  if (t >= 1) {
    currentAnimation.isAnimating = false;
    currentAnimation = null;
    return false;
  }
  return true;
}
function cancelCameraFocus() {
  if (currentAnimation) {
    currentAnimation.isAnimating = false;
    currentAnimation = null;
  }
}

// ../../src/core/debug/Debugger.ts
class Debugger {
  element;
  header;
  content;
  performancePanel;
  cameraPanel;
  scenePanel;
  inspectorPanel;
  renderSettingsPanel;
  lightsPanel;
  uiHierarchyPanel;
  uiInspectorPanel;
  uiSelectionRenderer;
  expanded = false;
  visible = true;
  camera = null;
  selectedNode = null;
  selectedUIElement = null;
  _uiManager = null;
  lastTime = 0;
  frames = 0;
  fps = 0;
  keydownHandler;
  constructor(parent = null, options = {}) {
    const {
      defaultOpen = false,
      position = "top-right",
      panels = ["performance", "camera", "scene", "inspector", "lights", "renderSettings", "uiHierarchy", "uiInspector"],
      visible
    } = options;
    this.expanded = defaultOpen;
    const hideViaEnv = typeof ({ env: {}, url: "" }) !== "undefined" && ({ env: {}, url: "" }).env?.VITE_HIDE_DEBUG_OVERLAY === "true";
    this.visible = visible !== undefined ? visible : !hideViaEnv;
    this.element = document.createElement("div");
    this.element.style.position = "absolute";
    this.element.style.color = "white";
    this.element.style.backgroundColor = "rgba(0, 0, 0, 0.85)";
    this.element.style.padding = "6px";
    this.element.style.fontFamily = "monospace";
    this.element.style.fontSize = "12px";
    this.element.style.zIndex = "1000";
    this.element.style.borderRadius = "6px";
    this.element.style.minWidth = "160px";
    this.element.style.maxWidth = "280px";
    this.element.style.userSelect = "none";
    this.element.style.maxHeight = "90vh";
    this.element.style.overflowY = "auto";
    this.element.style.boxShadow = "0 2px 10px rgba(0, 0, 0, 0.5)";
    this.element.style.display = this.visible ? "block" : "none";
    this.setPosition(position);
    this.header = document.createElement("div");
    this.header.style.cursor = "pointer";
    this.header.style.display = "flex";
    this.header.style.justifyContent = "space-between";
    this.header.style.alignItems = "center";
    this.header.style.padding = "2px 0";
    this.header.onclick = () => this.toggle();
    this.element.appendChild(this.header);
    this.content = document.createElement("div");
    this.content.style.display = defaultOpen ? "block" : "none";
    this.content.style.marginTop = "5px";
    this.element.appendChild(this.content);
    this.performancePanel = new PerformancePanel;
    this.cameraPanel = new CameraPanel;
    this.scenePanel = new ScenePanel({
      onSelectNode: (node) => this.handleNodeSelection(node),
      onFocusNode: (node) => this.handleFocusNode(node)
    });
    this.inspectorPanel = new InspectorPanel;
    this.renderSettingsPanel = new RenderSettingsPanel;
    this.lightsPanel = new LightsPanel({
      onSelectLight: (light) => this.handleNodeSelection(light)
    });
    this.uiHierarchyPanel = new UIHierarchyPanel({
      onSelectElement: (element) => this.handleUIElementSelection(element)
    });
    this.uiInspectorPanel = new UIInspectorPanel;
    this.uiSelectionRenderer = new UISelectionRenderer;
    if (panels.includes("performance")) {
      this.content.appendChild(this.performancePanel.getElement());
    }
    if (panels.includes("camera")) {
      this.content.appendChild(this.cameraPanel.getElement());
    }
    if (panels.includes("scene")) {
      this.content.appendChild(this.scenePanel.getElement());
    }
    if (panels.includes("inspector")) {
      this.content.appendChild(this.inspectorPanel.getElement());
    }
    if (panels.includes("lights")) {
      this.content.appendChild(this.lightsPanel.getElement());
    }
    if (panels.includes("renderSettings")) {
      this.content.appendChild(this.renderSettingsPanel.getElement());
    }
    if (panels.includes("uiHierarchy")) {
      this.content.appendChild(this.uiHierarchyPanel.getElement());
    }
    if (panels.includes("uiInspector")) {
      this.content.appendChild(this.uiInspectorPanel.getElement());
    }
    const hint = document.createElement("div");
    hint.style.fontSize = "9px";
    hint.style.color = "#666";
    hint.style.marginTop = "8px";
    hint.style.textAlign = "center";
    hint.innerText = "Press ` or F3 to toggle";
    this.content.appendChild(hint);
    if (parent) {
      parent.appendChild(this.element);
    } else {
      document.body.appendChild(this.element);
    }
    this.keydownHandler = (e) => {
      if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) {
        return;
      }
      if (e.key === "`" || e.key === "F3") {
        e.preventDefault();
        this.toggle();
      }
    };
    document.addEventListener("keydown", this.keydownHandler);
    this.updateHeader();
  }
  setPosition(position) {
    this.element.style.top = "";
    this.element.style.bottom = "";
    this.element.style.left = "";
    this.element.style.right = "";
    switch (position) {
      case "top-right":
        this.element.style.top = "10px";
        this.element.style.right = "10px";
        break;
      case "top-left":
        this.element.style.top = "10px";
        this.element.style.left = "10px";
        break;
      case "bottom-right":
        this.element.style.bottom = "10px";
        this.element.style.right = "10px";
        break;
      case "bottom-left":
        this.element.style.bottom = "10px";
        this.element.style.left = "10px";
        break;
    }
  }
  toggle() {
    this.expanded = !this.expanded;
    this.content.style.display = this.expanded ? "block" : "none";
    this.updateHeader();
  }
  setOpen(open) {
    this.expanded = open;
    this.content.style.display = open ? "block" : "none";
    this.updateHeader();
  }
  isOpen() {
    return this.expanded;
  }
  setVisible(visible) {
    this.visible = visible;
    this.element.style.display = visible ? "block" : "none";
  }
  isVisible() {
    return this.visible;
  }
  registerScene(scene) {
    this.scenePanel.setScene(scene);
    this.lightsPanel.setScene(scene);
    this.renderSettingsPanel.setScene(scene);
  }
  registerCamera(camera) {
    this.camera = camera;
    this.cameraPanel.setCamera(camera);
  }
  registerUIManager(uiManager) {
    this.handleUIElementSelection(null);
    this._uiManager = uiManager;
    this.uiHierarchyPanel.setUIManager(uiManager);
  }
  registerCanvas(canvas, device) {
    this.uiSelectionRenderer.init(canvas);
    if (device) {
      this.uiInspectorPanel.setDevice(device);
    }
  }
  setGpuStats(draws, triangles) {
    this.performancePanel.setGpuStats(draws, triangles);
  }
  setFrameTriangles(count) {
    this.performancePanel.setFrameTriangles(count);
  }
  setSceneTriangles(count) {
    this.performancePanel.setSceneTriangles(count);
  }
  update(time) {
    this.frames++;
    if (time >= this.lastTime + 1000) {
      this.fps = Math.round(this.frames * 1000 / (time - this.lastTime));
      this.lastTime = time;
      this.frames = 0;
      this.performancePanel.setFps(this.fps);
      this.updateHeader();
    }
    if (this.camera) {
      updateCameraFocus(this.camera);
    }
    if (this.expanded) {
      this.performancePanel.update();
      this.cameraPanel.update();
      this.inspectorPanel.update();
      this.uiInspectorPanel.update();
    }
    this.uiSelectionRenderer.update();
  }
  updateHeader() {
    const fpsColor = this.fps < 30 ? "#f44" : this.fps < 50 ? "#fa0" : "#4f4";
    this.header.innerHTML = `
      <span>FPS: <span style="color: ${fpsColor}; font-weight: bold;">${this.fps}</span></span>
      <span style="font-size: 10px; color: #888;">${this.expanded ? "▼" : "▶"}</span>
    `;
  }
  handleNodeSelection(node) {
    this.selectedNode = node;
    this.scenePanel.selectNode(node, false);
    this.inspectorPanel.setSelectedNode(node);
    if (node) {
      this.inspectorPanel.setOpen(true);
    }
  }
  handleFocusNode(node) {
    if (!this.camera)
      return;
    cancelCameraFocus();
    focusOnNode(node, this.camera, 400);
  }
  handleUIElementSelection(element) {
    this.selectedUIElement = element;
    this.uiHierarchyPanel.selectElement(element, false);
    this.uiInspectorPanel.setSelectedElement(element);
    this.uiSelectionRenderer.setSelectedElement(element);
    if (element) {
      this.uiInspectorPanel.setOpen(true);
    }
  }
  getSelectedNode() {
    return this.selectedNode;
  }
  getSelectedUIElement() {
    return this.selectedUIElement;
  }
  getUIManager() {
    return this._uiManager;
  }
  addSection(title, content) {
    const details = document.createElement("details");
    details.style.marginTop = "8px";
    details.style.borderTop = "1px solid #555";
    details.style.paddingTop = "4px";
    const summary = document.createElement("summary");
    summary.innerText = title;
    summary.style.cursor = "pointer";
    summary.style.fontWeight = "bold";
    summary.style.marginBottom = "4px";
    summary.style.outline = "none";
    details.appendChild(summary);
    details.appendChild(content);
    const hint = this.content.lastElementChild;
    if (hint) {
      this.content.insertBefore(details, hint);
    } else {
      this.content.appendChild(details);
    }
  }
  cleanup() {
    document.removeEventListener("keydown", this.keydownHandler);
    this.uiSelectionRenderer.cleanup();
    if (this.element && this.element.parentNode) {
      this.element.parentNode.removeChild(this.element);
    }
  }
}
// ../../src/core/debug/SelectionRenderer.ts
class SelectionRenderer {
  device = null;
  pipeline = null;
  vertexBuffer = null;
  uniformBuffer = null;
  bindGroup = null;
  bindGroupLayout = null;
  selectedNode = null;
  static BOX_VERTICES = new Float32Array([
    -1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    -1,
    1,
    1,
    -1,
    1,
    1,
    1,
    1,
    1,
    1,
    -1,
    1,
    1,
    -1,
    1,
    1,
    -1,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    1
  ]);
  shaderCode = `
    struct Uniforms {
      mvp: mat4x4<f32>,
      color: vec4<f32>,
    }

    @group(0) @binding(0) var<uniform> uniforms: Uniforms;

    struct VertexOutput {
      @builtin(position) position: vec4<f32>,
    }

    @vertex
    fn vs_main(@location(0) position: vec3<f32>) -> VertexOutput {
      var output: VertexOutput;
      output.position = uniforms.mvp * vec4<f32>(position, 1.0);
      return output;
    }

    @fragment
    fn fs_main() -> @location(0) vec4<f32> {
      return uniforms.color;
    }
  `;
  init(device) {
    this.device = device;
    this.vertexBuffer = device.createBuffer({
      size: SelectionRenderer.BOX_VERTICES.byteLength,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(this.vertexBuffer, 0, SelectionRenderer.BOX_VERTICES);
    this.uniformBuffer = device.createBuffer({
      size: 256,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.bindGroupLayout = device.createBindGroupLayout({
      entries: [
        {
          binding: 0,
          visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
          buffer: { type: "uniform" }
        }
      ]
    });
    this.bindGroup = device.createBindGroup({
      layout: this.bindGroupLayout,
      entries: [
        { binding: 0, resource: { buffer: this.uniformBuffer } }
      ]
    });
    const shaderModule = device.createShaderModule({
      code: this.shaderCode
    });
    this.pipeline = device.createRenderPipeline({
      layout: device.createPipelineLayout({
        bindGroupLayouts: [this.bindGroupLayout]
      }),
      vertex: {
        module: shaderModule,
        entryPoint: "vs_main",
        buffers: [
          {
            arrayStride: 12,
            attributes: [
              { shaderLocation: 0, offset: 0, format: "float32x3" }
            ]
          }
        ]
      },
      fragment: {
        module: shaderModule,
        entryPoint: "fs_main",
        targets: [{ format: navigator.gpu.getPreferredCanvasFormat() }]
      },
      primitive: {
        topology: "line-list"
      },
      depthStencil: {
        format: "depth24plus",
        depthWriteEnabled: false,
        depthCompare: "less-equal"
      }
    });
  }
  setSelectedNode(node) {
    this.selectedNode = node;
  }
  getSelectedNode() {
    return this.selectedNode;
  }
  render(encoder, colorView, depthView, camera) {
    if (!this.device || !this.pipeline || !this.selectedNode || !this.uniformBuffer || !this.bindGroup) {
      return;
    }
    const localBounds = this.getLocalBounds(this.selectedNode);
    if (!localBounds)
      return;
    const { min, max } = localBounds;
    const localCenter = new Vector3((min.x + max.x) / 2, (min.y + max.y) / 2, (min.z + max.z) / 2);
    const halfExtents = new Vector3((max.x - min.x) / 2, (max.y - min.y) / 2, (max.z - min.z) / 2);
    const localModel = new Matrix4().compose(localCenter, Matrix4.identity, halfExtents);
    const model = this.selectedNode.transform.worldMatrix.clone().multiply(localModel);
    const view = camera.viewMatrix;
    const proj = camera.projectionMatrix;
    const mvp = proj.multiply(view).multiply(model);
    const uniformData = new Float32Array(20);
    uniformData.set(mvp.elements, 0);
    uniformData[16] = 0.2;
    uniformData[17] = 0.8;
    uniformData[18] = 1;
    uniformData[19] = 1;
    this.device.queue.writeBuffer(this.uniformBuffer, 0, uniformData);
    const passEncoder = encoder.beginRenderPass({
      colorAttachments: [
        {
          view: colorView,
          loadOp: "load",
          storeOp: "store"
        }
      ],
      depthStencilAttachment: {
        view: depthView,
        depthLoadOp: "load",
        depthStoreOp: "store"
      }
    });
    passEncoder.setPipeline(this.pipeline);
    passEncoder.setBindGroup(0, this.bindGroup);
    passEncoder.setVertexBuffer(0, this.vertexBuffer);
    passEncoder.draw(24);
    passEncoder.end();
  }
  getLocalBounds(node) {
    if (node instanceof Mesh && node.geometry) {
      const aabb = node.geometry.aabb;
      if (aabb) {
        return {
          min: new Vector3(aabb.min.x, aabb.min.y, aabb.min.z),
          max: new Vector3(aabb.max.x, aabb.max.y, aabb.max.z)
        };
      }
    }
    const size = 0.5;
    return {
      min: new Vector3(-size, -size, -size),
      max: new Vector3(size, size, size)
    };
  }
  cleanup() {
    this.vertexBuffer?.destroy();
    this.uniformBuffer?.destroy();
    this.vertexBuffer = null;
    this.uniformBuffer = null;
    this.pipeline = null;
    this.bindGroup = null;
    this.device = null;
  }
}
// ../../src/core/ui/UIRenderPass.ts
class UIRenderPass {
  device = null;
  context = null;
  presentationFormat = null;
  uiManager;
  width = 0;
  height = 0;
  quadPipeline = null;
  _textPipeline = null;
  vertexBuffer = null;
  uniformBuffer = null;
  maxQuads = 4096;
  vertexData;
  uniformBindGroupLayout = null;
  textureBindGroupLayout = null;
  uniformBindGroup = null;
  whiteTexture = null;
  whiteTextureView = null;
  defaultBindGroup = null;
  sampler = null;
  textureBindGroupCache = new Map;
  textCanvas = null;
  textContext = null;
  textTexture = null;
  textTextureView = null;
  textBindGroup = null;
  constructor(uiManager) {
    this.uiManager = uiManager;
    this.vertexData = new Float32Array(this.maxQuads * 6 * 8);
  }
  getUIManager() {
    return this.uiManager;
  }
  getTextPipeline() {
    return this._textPipeline;
  }
  init(device, context, presentationFormat) {
    this.device = device;
    this.context = context;
    this.presentationFormat = presentationFormat;
    const canvas = context.canvas;
    this.width = canvas.width;
    this.height = canvas.height;
    this.createResources();
    this.createPipelines();
    this.createTextCanvas();
  }
  resize(width, height) {
    this.width = width;
    this.height = height;
    this.uiManager.resize(width, height);
    this.updateUniformBuffer();
    this.resizeTextCanvas();
  }
  createResources() {
    if (!this.device)
      return;
    this.vertexBuffer = this.device.createBuffer({
      label: "UI Vertex Buffer",
      size: this.vertexData.byteLength,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
    });
    this.uniformBuffer = this.device.createBuffer({
      label: "UI Uniform Buffer",
      size: 80,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.sampler = this.device.createSampler({
      label: "UI Sampler",
      magFilter: "linear",
      minFilter: "linear",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    });
    this.whiteTexture = this.device.createTexture({
      label: "UI White Texture",
      size: [1, 1],
      format: "rgba8unorm",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
    });
    this.device.queue.writeTexture({ texture: this.whiteTexture }, new Uint8Array([255, 255, 255, 255]), { bytesPerRow: 4 }, [1, 1]);
    this.whiteTextureView = this.whiteTexture.createView();
    this.uniformBindGroupLayout = this.device.createBindGroupLayout({
      label: "UI Uniform Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.VERTEX, buffer: { type: "uniform" } }
      ]
    });
    this.textureBindGroupLayout = this.device.createBindGroupLayout({
      label: "UI Texture Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "filtering" } },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "float" } }
      ]
    });
    this.uniformBindGroup = this.device.createBindGroup({
      label: "UI Uniform Bind Group",
      layout: this.uniformBindGroupLayout,
      entries: [
        { binding: 0, resource: { buffer: this.uniformBuffer } }
      ]
    });
    this.defaultBindGroup = this.device.createBindGroup({
      label: "UI Default Texture Bind Group",
      layout: this.textureBindGroupLayout,
      entries: [
        { binding: 0, resource: this.sampler },
        { binding: 1, resource: this.whiteTextureView }
      ]
    });
    this.updateUniformBuffer();
  }
  createPipelines() {
    if (!this.device || !this.presentationFormat)
      return;
    const shaderCode = `
      struct Uniforms {
        projection: mat4x4<f32>,
        screenSize: vec2<f32>,
        _pad: vec2<f32>,
      }

      @group(0) @binding(0) var<uniform> uniforms: Uniforms;
      @group(1) @binding(0) var texSampler: sampler;
      @group(1) @binding(1) var tex: texture_2d<f32>;

      struct VertexInput {
        @location(0) position: vec2<f32>,
        @location(1) uv: vec2<f32>,
        @location(2) color: vec4<f32>,
      }

      struct VertexOutput {
        @builtin(position) position: vec4<f32>,
        @location(0) uv: vec2<f32>,
        @location(1) color: vec4<f32>,
      }

      @vertex
      fn vs_main(input: VertexInput) -> VertexOutput {
        var output: VertexOutput;
        output.position = uniforms.projection * vec4<f32>(input.position, 0.0, 1.0);
        output.uv = input.uv;
        output.color = input.color;
        return output;
      }

      @fragment
      fn fs_quad(input: VertexOutput) -> @location(0) vec4<f32> {
        let texColor = textureSample(tex, texSampler, input.uv);
        return input.color * texColor;
      }

      @fragment
      fn fs_text(input: VertexOutput) -> @location(0) vec4<f32> {
        let texColor = textureSample(tex, texSampler, input.uv);
        // Use texture alpha for text, color for tint
        return vec4<f32>(input.color.rgb, input.color.a * texColor.a);
      }
    `;
    const shaderModule = createShaderModuleSafe(this.device, {
      label: "UI Shader",
      code: shaderCode
    });
    const pipelineLayout = this.device.createPipelineLayout({
      label: "UI Pipeline Layout",
      bindGroupLayouts: [this.uniformBindGroupLayout, this.textureBindGroupLayout]
    });
    const vertexBufferLayout = {
      arrayStride: 8 * 4,
      attributes: [
        { shaderLocation: 0, offset: 0, format: "float32x2" },
        { shaderLocation: 1, offset: 8, format: "float32x2" },
        { shaderLocation: 2, offset: 16, format: "float32x4" }
      ]
    };
    this.quadPipeline = this.device.createRenderPipeline({
      label: "UI Quad Pipeline",
      layout: pipelineLayout,
      vertex: {
        module: shaderModule,
        entryPoint: "vs_main",
        buffers: [vertexBufferLayout]
      },
      fragment: {
        module: shaderModule,
        entryPoint: "fs_quad",
        targets: [{
          format: this.presentationFormat,
          blend: {
            color: { srcFactor: "src-alpha", dstFactor: "one-minus-src-alpha", operation: "add" },
            alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }
          }
        }]
      },
      primitive: {
        topology: "triangle-list"
      }
    });
    this._textPipeline = this.device.createRenderPipeline({
      label: "UI Text Pipeline",
      layout: pipelineLayout,
      vertex: {
        module: shaderModule,
        entryPoint: "vs_main",
        buffers: [vertexBufferLayout]
      },
      fragment: {
        module: shaderModule,
        entryPoint: "fs_text",
        targets: [{
          format: this.presentationFormat,
          blend: {
            color: { srcFactor: "src-alpha", dstFactor: "one-minus-src-alpha", operation: "add" },
            alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }
          }
        }]
      },
      primitive: {
        topology: "triangle-list"
      }
    });
  }
  createTextCanvas() {
    this.textCanvas = document.createElement("canvas");
    this.textCanvas.width = this.width || 800;
    this.textCanvas.height = this.height || 600;
    this.textContext = this.textCanvas.getContext("2d", { willReadFrequently: true });
    this.createTextTexture();
  }
  resizeTextCanvas() {
    if (this.textCanvas && this.width > 0 && this.height > 0) {
      this.textCanvas.width = this.width;
      this.textCanvas.height = this.height;
      this.createTextTexture();
    }
  }
  createTextTexture() {
    if (!this.device || !this.textCanvas)
      return;
    if (this.textTexture) {
      this.textTexture.destroy();
    }
    this.textTexture = this.device.createTexture({
      label: "UI Text Texture",
      size: [this.textCanvas.width, this.textCanvas.height],
      format: "rgba8unorm",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
    });
    this.textTextureView = this.textTexture.createView();
    const transparentData = new Uint8Array(this.textCanvas.width * this.textCanvas.height * 4);
    this.device.queue.writeTexture({ texture: this.textTexture }, transparentData, { bytesPerRow: this.textCanvas.width * 4, rowsPerImage: this.textCanvas.height }, [this.textCanvas.width, this.textCanvas.height]);
    this.textBindGroup = this.device.createBindGroup({
      label: "UI Text Bind Group",
      layout: this.textureBindGroupLayout,
      entries: [
        { binding: 0, resource: this.sampler },
        { binding: 1, resource: this.textTextureView }
      ]
    });
  }
  updateUniformBuffer() {
    if (!this.device || !this.uniformBuffer)
      return;
    const projection = new Float32Array([
      2 / this.width,
      0,
      0,
      0,
      0,
      -2 / this.height,
      0,
      0,
      0,
      0,
      1,
      0,
      -1,
      1,
      0,
      1
    ]);
    const uniforms = new Float32Array(20);
    uniforms.set(projection, 0);
    uniforms[16] = this.width;
    uniforms[17] = this.height;
    this.device.queue.writeBuffer(this.uniformBuffer, 0, uniforms);
  }
  getTextureBindGroup(texture, textureView) {
    if (!this.device || !this.textureBindGroupLayout || !this.sampler) {
      throw new Error("UIRenderPass not initialized");
    }
    let bindGroup = this.textureBindGroupCache.get(texture);
    if (!bindGroup) {
      bindGroup = this.device.createBindGroup({
        label: "UI Image Bind Group",
        layout: this.textureBindGroupLayout,
        entries: [
          { binding: 0, resource: this.sampler },
          { binding: 1, resource: textureView }
        ]
      });
      this.textureBindGroupCache.set(texture, bindGroup);
    }
    return bindGroup;
  }
  parseColor(color, alpha = 1) {
    if (!color)
      return [1, 1, 1, alpha];
    if (color === "transparent") {
      return [0, 0, 0, 0];
    }
    if (color.startsWith("#")) {
      const hex = color.slice(1);
      if (hex.length === 3) {
        const r = parseInt(hex[0] + hex[0], 16) / 255;
        const g = parseInt(hex[1] + hex[1], 16) / 255;
        const b = parseInt(hex[2] + hex[2], 16) / 255;
        return [r, g, b, alpha];
      } else if (hex.length === 6) {
        const r = parseInt(hex.slice(0, 2), 16) / 255;
        const g = parseInt(hex.slice(2, 4), 16) / 255;
        const b = parseInt(hex.slice(4, 6), 16) / 255;
        return [r, g, b, alpha];
      } else if (hex.length === 8) {
        const r = parseInt(hex.slice(0, 2), 16) / 255;
        const g = parseInt(hex.slice(2, 4), 16) / 255;
        const b = parseInt(hex.slice(4, 6), 16) / 255;
        const a = parseInt(hex.slice(6, 8), 16) / 255;
        return [r, g, b, a * alpha];
      }
    }
    const rgbMatch = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
    if (rgbMatch) {
      const r = parseInt(rgbMatch[1]) / 255;
      const g = parseInt(rgbMatch[2]) / 255;
      const b = parseInt(rgbMatch[3]) / 255;
      const a = rgbMatch[4] ? parseFloat(rgbMatch[4]) : 1;
      return [r, g, b, a * alpha];
    }
    return [1, 1, 1, alpha];
  }
  applyTint(color, tint) {
    if (!tint)
      return color;
    const [tr, tg, tb] = this.parseColor(tint, 1);
    return [
      color[0] * tr,
      color[1] * tg,
      color[2] * tb,
      color[3]
    ];
  }
  addQuad(vertexOffset, x, y, w, h, u0, v0, u1, v1, r, g, b, a) {
    const v = this.vertexData;
    const o = vertexOffset;
    v[o + 0] = x;
    v[o + 1] = y;
    v[o + 2] = u0;
    v[o + 3] = v0;
    v[o + 4] = r;
    v[o + 5] = g;
    v[o + 6] = b;
    v[o + 7] = a;
    v[o + 8] = x + w;
    v[o + 9] = y;
    v[o + 10] = u1;
    v[o + 11] = v0;
    v[o + 12] = r;
    v[o + 13] = g;
    v[o + 14] = b;
    v[o + 15] = a;
    v[o + 16] = x;
    v[o + 17] = y + h;
    v[o + 18] = u0;
    v[o + 19] = v1;
    v[o + 20] = r;
    v[o + 21] = g;
    v[o + 22] = b;
    v[o + 23] = a;
    v[o + 24] = x + w;
    v[o + 25] = y;
    v[o + 26] = u1;
    v[o + 27] = v0;
    v[o + 28] = r;
    v[o + 29] = g;
    v[o + 30] = b;
    v[o + 31] = a;
    v[o + 32] = x + w;
    v[o + 33] = y + h;
    v[o + 34] = u1;
    v[o + 35] = v1;
    v[o + 36] = r;
    v[o + 37] = g;
    v[o + 38] = b;
    v[o + 39] = a;
    v[o + 40] = x;
    v[o + 41] = y + h;
    v[o + 42] = u0;
    v[o + 43] = v1;
    v[o + 44] = r;
    v[o + 45] = g;
    v[o + 46] = b;
    v[o + 47] = a;
    return 48;
  }
  execute(commandEncoder, context, globalResources) {
    if (!this.device || !this.context || !this.quadPipeline || !this.vertexBuffer || !this.uniformBindGroup) {
      return;
    }
    const renderData = this.uiManager.getRenderData();
    if (renderData.length === 0)
      return;
    const dataByLayer = new Map;
    for (const data of renderData) {
      const layer = data.renderLayer ?? 0;
      if (!dataByLayer.has(layer)) {
        dataByLayer.set(layer, []);
      }
      dataByLayer.get(layer).push(data);
    }
    const sortedLayers = Array.from(dataByLayer.keys()).sort((a, b) => a - b);
    let currentTexture;
    try {
      currentTexture = this.context.getCurrentTexture();
    } catch (e) {
      if (this.device && this.presentationFormat) {
        try {
          console.warn("[UIRenderPass] Canvas context not configured, attempting to reconfigure...");
          this.context.configure({
            device: this.device,
            format: this.presentationFormat,
            alphaMode: "opaque"
          });
          currentTexture = this.context.getCurrentTexture();
          console.log("[UIRenderPass] Successfully reconfigured canvas context");
        } catch (reconfigureError) {
          console.warn("[UIRenderPass] Failed to reconfigure canvas context, skipping render");
          return;
        }
      } else {
        console.warn("[UIRenderPass] Cannot reconfigure - missing device or format, skipping render");
        return;
      }
    }
    const textureView = currentTexture.createView();
    let globalVertexOffset = 0;
    const layerRenderInfos = new Map;
    for (const layer of sortedLayers) {
      const layerData = dataByLayer.get(layer);
      const backgroundQuads = [];
      const overlayQuads = [];
      const images = [];
      const texts = [];
      const roundedQuads = [];
      for (const data of layerData) {
        if (data.type === "text") {
          texts.push(data);
        } else if ((data.type === "image" || data.type === "nine-slice") && data.texture && data.textureView) {
          images.push(data);
        } else if (data.backgroundColor) {
          const alpha = data.backgroundAlpha ?? 1;
          const colorHasAlpha = data.backgroundColor.includes("rgba") && !data.backgroundColor.endsWith(", 1)") && !data.backgroundColor.endsWith(",1)");
          const isSemiTransparent = alpha < 1 || colorHasAlpha;
          if (data.borderRadius && data.borderRadius > 0 || isSemiTransparent) {
            roundedQuads.push(data);
          } else {
            backgroundQuads.push(data);
          }
        } else if (data.borderColor && data.borderWidth && data.borderWidth > 0) {
          if (data.borderRadius && data.borderRadius > 0) {
            roundedQuads.push(data);
          } else {
            overlayQuads.push(data);
          }
        }
      }
      const layerInfo = {
        backgroundQuadStart: globalVertexOffset / 48,
        backgroundQuadCount: 0,
        images: new Map,
        overlayQuadStart: 0,
        overlayQuadCount: 0,
        texts,
        roundedQuads,
        canvasOverlayVertexStart: 0
      };
      for (const data of backgroundQuads) {
        if (layerInfo.backgroundQuadCount >= this.maxQuads)
          break;
        let color = this.parseColor(data.backgroundColor, data.backgroundAlpha ?? 1);
        color = this.applyTint(color, data.tint);
        const [r, g, b, a] = color;
        const bounds = data.bounds;
        globalVertexOffset += this.addQuad(globalVertexOffset, bounds.x, bounds.y, bounds.width, bounds.height, 0, 0, 1, 1, r, g, b, a);
        layerInfo.backgroundQuadCount++;
        if (data.borderColor && data.borderWidth && data.borderWidth > 0) {
          overlayQuads.push(data);
        }
      }
      for (const data of images) {
        if (!data.texture)
          continue;
        const bounds = data.bounds;
        const uvRect = data.uvRect ?? { u0: 0, v0: 0, u1: 1, v1: 1 };
        let color = this.parseColor(data.color ?? "#ffffff", data.backgroundAlpha ?? 1);
        color = this.applyTint(color, data.tint);
        const [r, g, b, a] = color;
        const vertexStart = globalVertexOffset / 48;
        globalVertexOffset += this.addQuad(globalVertexOffset, bounds.x, bounds.y, bounds.width, bounds.height, uvRect.u0, uvRect.v0, uvRect.u1, uvRect.v1, r, g, b, a);
        if (!layerInfo.images.has(data.texture)) {
          layerInfo.images.set(data.texture, []);
        }
        layerInfo.images.get(data.texture).push({ data, vertexStart });
      }
      layerInfo.overlayQuadStart = globalVertexOffset / 48;
      for (const data of overlayQuads) {
        const [br, bg, bb, ba] = this.parseColor(data.borderColor, 1);
        const bw = data.borderWidth;
        const bounds = data.bounds;
        globalVertexOffset += this.addQuad(globalVertexOffset, bounds.x, bounds.y, bounds.width, bw, 0, 0, 1, 1, br, bg, bb, ba);
        layerInfo.overlayQuadCount++;
        globalVertexOffset += this.addQuad(globalVertexOffset, bounds.x, bounds.y + bounds.height - bw, bounds.width, bw, 0, 0, 1, 1, br, bg, bb, ba);
        layerInfo.overlayQuadCount++;
        globalVertexOffset += this.addQuad(globalVertexOffset, bounds.x, bounds.y + bw, bw, bounds.height - bw * 2, 0, 0, 1, 1, br, bg, bb, ba);
        layerInfo.overlayQuadCount++;
        globalVertexOffset += this.addQuad(globalVertexOffset, bounds.x + bounds.width - bw, bounds.y + bw, bw, bounds.height - bw * 2, 0, 0, 1, 1, br, bg, bb, ba);
        layerInfo.overlayQuadCount++;
      }
      const hasCanvasContent = (texts.length > 0 || roundedQuads.length > 0) && this.textTexture;
      if (hasCanvasContent) {
        layerInfo.canvasOverlayVertexStart = globalVertexOffset / 48;
        globalVertexOffset += this.addQuad(globalVertexOffset, 0, 0, this.width, this.height, 0, 0, 1, 1, 1, 1, 1, 1);
      }
      layerRenderInfos.set(layer, layerInfo);
    }
    if (globalVertexOffset > 0) {
      this.device.queue.writeBuffer(this.vertexBuffer, 0, this.vertexData.buffer, 0, globalVertexOffset * 4);
    }
    for (const layer of sortedLayers) {
      const layerInfo = layerRenderInfos.get(layer);
      if (!layerInfo)
        continue;
      const hasGPUContent = layerInfo.backgroundQuadCount > 0 || layerInfo.images.size > 0 || layerInfo.overlayQuadCount > 0;
      if (hasGPUContent) {
        const renderPassDescriptor = {
          colorAttachments: [{
            view: textureView,
            loadOp: "load",
            storeOp: "store"
          }]
        };
        const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
        passEncoder.setVertexBuffer(0, this.vertexBuffer);
        if (layerInfo.backgroundQuadCount > 0) {
          passEncoder.setPipeline(this.quadPipeline);
          passEncoder.setBindGroup(0, this.uniformBindGroup);
          passEncoder.setBindGroup(1, this.defaultBindGroup);
          passEncoder.draw(layerInfo.backgroundQuadCount * 6, 1, layerInfo.backgroundQuadStart * 6, 0);
        }
        for (const [texture, imageList] of layerInfo.images) {
          const firstImage = imageList[0];
          if (!firstImage.data.textureView)
            continue;
          const bindGroup = this.getTextureBindGroup(texture, firstImage.data.textureView);
          passEncoder.setPipeline(this.quadPipeline);
          passEncoder.setBindGroup(0, this.uniformBindGroup);
          passEncoder.setBindGroup(1, bindGroup);
          for (const img of imageList) {
            passEncoder.draw(6, 1, img.vertexStart * 6, 0);
          }
        }
        if (layerInfo.overlayQuadCount > 0) {
          passEncoder.setPipeline(this.quadPipeline);
          passEncoder.setBindGroup(0, this.uniformBindGroup);
          passEncoder.setBindGroup(1, this.defaultBindGroup);
          passEncoder.draw(layerInfo.overlayQuadCount * 6, 1, layerInfo.overlayQuadStart * 6, 0);
        }
        passEncoder.end();
      }
      const hasCanvasContent = (layerInfo.texts.length > 0 || layerInfo.roundedQuads.length > 0) && this.textTexture;
      if (hasCanvasContent) {
        this.renderTextToCanvas(layerInfo.texts, layerInfo.roundedQuads);
        const renderPassDescriptor = {
          colorAttachments: [{
            view: textureView,
            loadOp: "load",
            storeOp: "store"
          }]
        };
        const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
        passEncoder.setVertexBuffer(0, this.vertexBuffer);
        passEncoder.setPipeline(this.quadPipeline);
        passEncoder.setBindGroup(0, this.uniformBindGroup);
        passEncoder.setBindGroup(1, this.textBindGroup);
        passEncoder.draw(6, 1, layerInfo.canvasOverlayVertexStart * 6, 0);
        passEncoder.end();
      }
    }
  }
  renderTextToCanvas(texts, roundedQuads = []) {
    if (!this.textContext || !this.textCanvas || !this.device || !this.textTexture)
      return;
    this.textContext.clearRect(0, 0, this.textCanvas.width, this.textCanvas.height);
    this.textContext.globalAlpha = 1;
    this.textContext.globalCompositeOperation = "source-over";
    const time = performance.now() / 1000;
    const allCanvasContent = [];
    for (const data of roundedQuads) {
      allCanvasContent.push({ data, isText: false });
    }
    for (const data of texts) {
      allCanvasContent.push({ data, isText: true });
    }
    allCanvasContent.sort((a, b) => {
      const layerA = a.data.renderLayer ?? 0;
      const layerB = b.data.renderLayer ?? 0;
      if (layerA !== layerB)
        return layerA - layerB;
      const zIndexA = a.data.zIndex ?? 0;
      const zIndexB = b.data.zIndex ?? 0;
      if (zIndexA !== zIndexB)
        return zIndexA - zIndexB;
      if (a.isText !== b.isText)
        return a.isText ? 1 : -1;
      return 0;
    });
    for (const { data, isText } of allCanvasContent) {
      this.textContext.save();
      if (isText) {
        if (data.richTextSegments && data.richTextSegments.length > 0) {
          this.renderRichText(data, time);
        } else if (data.text) {
          this.renderPlainText(data);
        }
      } else {
        this.renderRoundedQuad(data);
      }
      this.textContext.restore();
    }
    const imageData = this.textContext.getImageData(0, 0, this.textCanvas.width, this.textCanvas.height);
    this.device.queue.writeTexture({ texture: this.textTexture }, imageData.data, { bytesPerRow: this.textCanvas.width * 4, rowsPerImage: this.textCanvas.height }, [this.textCanvas.width, this.textCanvas.height]);
  }
  renderRoundedQuad(data) {
    if (!this.textContext)
      return;
    const bounds = data.bounds;
    const radius = data.borderRadius ?? 0;
    const bgColor = data.backgroundColor;
    const bgAlpha = data.backgroundAlpha ?? 1;
    const borderColor = data.borderColor;
    const borderWidth = data.borderWidth ?? 0;
    if (bgColor) {
      const [r, g, b, a] = this.parseColor(bgColor, bgAlpha);
      this.textContext.fillStyle = `rgba(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)}, ${a})`;
      this.textContext.beginPath();
      this.roundRect(bounds.x, bounds.y, bounds.width, bounds.height, radius);
      this.textContext.fill();
    }
    if (borderColor && borderWidth > 0) {
      const [r, g, b, a] = this.parseColor(borderColor, 1);
      this.textContext.strokeStyle = `rgba(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)}, ${a})`;
      this.textContext.lineWidth = borderWidth;
      this.textContext.beginPath();
      const inset = borderWidth / 2;
      this.roundRect(bounds.x + inset, bounds.y + inset, bounds.width - borderWidth, bounds.height - borderWidth, Math.max(0, radius - inset));
      this.textContext.stroke();
    }
  }
  roundRect(x, y, w, h, r) {
    if (!this.textContext)
      return;
    r = Math.min(r, w / 2, h / 2);
    this.textContext.moveTo(x + r, y);
    this.textContext.lineTo(x + w - r, y);
    this.textContext.quadraticCurveTo(x + w, y, x + w, y + r);
    this.textContext.lineTo(x + w, y + h - r);
    this.textContext.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    this.textContext.lineTo(x + r, y + h);
    this.textContext.quadraticCurveTo(x, y + h, x, y + h - r);
    this.textContext.lineTo(x, y + r);
    this.textContext.quadraticCurveTo(x, y, x + r, y);
    this.textContext.closePath();
  }
  renderPlainText(data) {
    if (!this.textContext || !data.text)
      return;
    const bounds = data.bounds;
    const fontSize = data.fontSize ?? 16;
    const fontFamily = data.fontFamily ?? "sans-serif";
    const textAlign = data.textAlign ?? "left";
    const color = data.color ?? "#ffffff";
    const alpha = data.textAlpha ?? 1;
    this.textContext.font = `${fontSize}px ${fontFamily}`;
    this.textContext.globalAlpha = alpha;
    this.textContext.fillStyle = color;
    this.textContext.textBaseline = "middle";
    let x;
    switch (textAlign) {
      case "center":
        this.textContext.textAlign = "center";
        x = bounds.x + bounds.width / 2;
        break;
      case "right":
        this.textContext.textAlign = "right";
        x = bounds.x + bounds.width;
        break;
      default:
        this.textContext.textAlign = "left";
        x = bounds.x;
    }
    const y = bounds.y + bounds.height / 2;
    const lines = data.text.split(`
`);
    const lineHeight = fontSize * 1.4;
    const totalHeight = lines.length * lineHeight;
    const startY = y - totalHeight / 2 + lineHeight / 2;
    for (let i = 0;i < lines.length; i++) {
      this.textContext.fillText(lines[i], x, startY + i * lineHeight);
    }
  }
  renderRichText(data, time) {
    if (!this.textContext || !data.richTextSegments)
      return;
    const bounds = data.bounds;
    const baseFontSize = data.fontSize ?? 16;
    const fontFamily = data.fontFamily ?? "sans-serif";
    const baseColor = data.color ?? "#ffffff";
    const lineHeight = baseFontSize * 1.4;
    this.textContext.textAlign = "left";
    this.textContext.textBaseline = "middle";
    let x = bounds.x;
    let y = bounds.y + lineHeight / 2;
    let charIndex = 0;
    for (const segment of data.richTextSegments) {
      if (!segment.text)
        continue;
      const fontSize = segment.fontSize ?? baseFontSize;
      const color = segment.color ?? baseColor;
      const bold = segment.bold ?? false;
      const italic = segment.italic ?? false;
      const fontStyle = `${italic ? "italic " : ""}${bold ? "bold " : ""}${fontSize}px ${fontFamily}`;
      this.textContext.font = fontStyle;
      this.textContext.fillStyle = color;
      for (const char of segment.text) {
        if (char === `
`) {
          x = bounds.x;
          y += lineHeight;
          charIndex++;
          continue;
        }
        let offsetX = 0;
        let offsetY = 0;
        if (segment.shake) {
          offsetX = (Math.random() - 0.5) * 3;
          offsetY = (Math.random() - 0.5) * 3;
        }
        if (segment.wave) {
          offsetY += Math.sin(time * 4 + charIndex * 0.3) * 3;
        }
        this.textContext.fillText(char, x + offsetX, y + offsetY);
        const charWidth = this.textContext.measureText(char).width;
        x += charWidth;
        if (x > bounds.x + bounds.width && char === " ") {
          x = bounds.x;
          y += lineHeight;
        }
        charIndex++;
      }
    }
  }
  destroy() {
    this.vertexBuffer?.destroy();
    this.uniformBuffer?.destroy();
    this.whiteTexture?.destroy();
    this.textTexture?.destroy();
  }
}

// ../../src/core/renderer/ShadowUtils.ts
class ShadowUtils {
  static getShadowViewProj(light, camera) {
    const lightDir = light.transform.getForwardVector().normalize();
    let up = Vector3.up;
    if (Math.abs(lightDir.dot(up)) > 0.99) {
      up = new Vector3(0, 0, 1);
    }
    const shadowDistance = 300;
    const lightPos = camera.transform.position.clone().subtract(lightDir.multiply(shadowDistance));
    const lightTarget = camera.transform.position.clone();
    const lightView = new Matrix4().lookAt(lightPos, lightTarget, up);
    const lightProj = new Matrix4().makeOrthographic(-250, 250, 250, -250, 1, 800);
    return lightProj.multiply(lightView);
  }
  static getSpotLightShadowViewProj(light) {
    const lightPos = light.transform.position;
    const lightDir = light.transform.getForwardVector().normalize();
    const target = lightPos.clone().add(lightDir);
    let up = Vector3.up;
    if (Math.abs(lightDir.dot(up)) > 0.99) {
      up = new Vector3(0, 0, 1);
    }
    const lightView = new Matrix4().lookAt(lightPos, target, up);
    const fov = light.outerAngle * 2;
    const aspect = 1;
    const near = 0.1;
    const far = 100;
    const lightProj = new Matrix4().makePerspective(fov, aspect, near, far);
    return lightProj.multiply(lightView);
  }
  static getLightShadowViewProj(light, camera) {
    if (light.type === 2 /* Spot */) {
      return this.getSpotLightShadowViewProj(light);
    }
    return this.getShadowViewProj(light, camera);
  }
}

// ../../src/core/renderer/SceneUniforms.ts
class SceneUniforms {
  device;
  buffer;
  debugMode = 0;
  static hasLoggedLights = false;
  static hasLoggedMatrices = false;
  static MAX_LIGHTS = 8;
  static BUFFER_SIZE = 480 + 8 * 96;
  uniformData = new ArrayBuffer(SceneUniforms.BUFFER_SIZE);
  uniformFloatView = new Float32Array(this.uniformData);
  uniformUintView = new Uint32Array(this.uniformData);
  tempMatrix = new Matrix4;
  tempMatrix2 = new Matrix4;
  constructor(device) {
    this.device = device;
    this.buffer = device.createBuffer({
      label: "Scene Uniform Buffer",
      size: SceneUniforms.BUFFER_SIZE,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
  }
  update(camera, scene) {
    const floatView = this.uniformFloatView;
    const uintView = this.uniformUintView;
    let offset = 0;
    floatView.set(camera.viewMatrix.elements, offset);
    offset += 16;
    floatView.set(camera.projectionMatrix.elements, offset);
    offset += 16;
    const light = scene.lights.find((l) => l.type === 0 /* Directional */);
    if (light && scene.shadows.enabled) {
      const lightViewProj = ShadowUtils.getShadowViewProj(light, camera);
      floatView.set(lightViewProj.elements, offset);
    } else {
      floatView.set(Matrix4.identity.elements, offset);
    }
    offset += 16;
    this.tempMatrix.copy(camera.previousProjectionMatrix).multiply(camera.previousViewMatrix);
    floatView.set(this.tempMatrix.elements, offset);
    offset += 16;
    this.tempMatrix2.copy(camera.projectionMatrix).invert();
    floatView.set(this.tempMatrix2.elements, offset);
    offset += 16;
    const pos = camera.transform.position;
    floatView[offset++] = pos.x;
    floatView[offset++] = pos.y;
    floatView[offset++] = pos.z;
    floatView[offset++] = performance.now() / 1000;
    const position = pos;
    const activeLights = scene.getClosestLights(position, SceneUniforms.MAX_LIGHTS);
    if (!SceneUniforms.hasLoggedLights) {
      console.log("SceneUniforms: Lights", {
        lightCount: activeLights.length,
        lights: activeLights.map((l) => ({ type: l.type, intensity: l.intensity, color: [l.color.x, l.color.y, l.color.z], shadowAtlasIndex: l.shadowAtlasIndex }))
      });
      SceneUniforms.hasLoggedLights = true;
    }
    uintView[offset++] = activeLights.length;
    uintView[offset++] = this.debugMode;
    let flags = 0;
    if (scene.shadows.enabled)
      flags |= 1;
    if (scene.render.frustumCulling)
      flags |= 2;
    if (scene.render.occlusionCulling)
      flags |= 4;
    uintView[offset++] = flags;
    floatView[offset++] = scene.environmentIntensity;
    floatView[offset++] = 0;
    floatView[offset++] = 0;
    floatView[offset++] = 0;
    floatView[offset++] = 0;
    floatView[offset++] = 0;
    floatView[offset++] = 0;
    floatView[offset++] = 0;
    floatView[offset++] = 0;
    uintView[offset++] = 0;
    uintView[offset++] = 0;
    uintView[offset++] = 0;
    uintView[offset++] = 0;
    floatView[offset++] = scene.cloudShadows.enabled ? 1 : 0;
    floatView[offset++] = scene.cloudShadows.intensity;
    floatView[offset++] = scene.cloudShadows.scale;
    floatView[offset++] = scene.cloudShadows.speed;
    const windRad = scene.cloudShadows.windDirection * Math.PI / 180;
    floatView[offset++] = scene.cloudShadows.coverage;
    floatView[offset++] = scene.cloudShadows.softness;
    floatView[offset++] = Math.cos(windRad);
    floatView[offset++] = Math.sin(windRad);
    floatView[offset++] = scene.fog.color.x;
    floatView[offset++] = scene.fog.color.y;
    floatView[offset++] = scene.fog.color.z;
    floatView[offset++] = scene.fog.density;
    floatView[offset++] = scene.fog.near;
    floatView[offset++] = scene.fog.far;
    floatView[offset++] = scene.fog.type === "LINEAR" ? 0 : 1;
    floatView[offset++] = scene.fog.enabled ? 1 : 0;
    floatView[offset++] = scene.fog.skyFalloff;
    floatView[offset++] = 0;
    floatView[offset++] = 0;
    floatView[offset++] = 0;
    for (const light2 of activeLights) {
      const lPos = light2.transform.position;
      floatView[offset++] = lPos.x;
      floatView[offset++] = lPos.y;
      floatView[offset++] = lPos.z;
      floatView[offset++] = 0;
      let lDir;
      if (light2.type === 4 /* Hemisphere */) {
        lDir = light2.direction;
      } else {
        lDir = light2.transform.getForwardVector();
      }
      floatView[offset++] = lDir.x;
      floatView[offset++] = lDir.y;
      floatView[offset++] = lDir.z;
      floatView[offset++] = 0;
      floatView[offset++] = light2.color.x;
      floatView[offset++] = light2.color.y;
      floatView[offset++] = light2.color.z;
      floatView[offset++] = light2.intensity;
      if (light2.type === 1 /* Point */) {
        const pointLight = light2;
        floatView[offset++] = pointLight.distance;
        floatView[offset++] = pointLight.decay;
        floatView[offset++] = 0;
      } else if (light2.type === 2 /* Spot */) {
        const spotLight = light2;
        floatView[offset++] = spotLight.distance;
        floatView[offset++] = spotLight.decay;
        floatView[offset++] = 0;
      } else if (light2.type === 4 /* Hemisphere */) {
        const hemiLight = light2;
        floatView[offset++] = hemiLight.groundColor.x;
        floatView[offset++] = hemiLight.groundColor.y;
        floatView[offset++] = hemiLight.groundColor.z;
      } else {
        floatView[offset++] = 0;
        floatView[offset++] = 0;
        floatView[offset++] = 0;
      }
      uintView[offset++] = light2.type;
      if (light2.type === 2 /* Spot */) {
        const spot = light2;
        floatView[offset++] = spot.innerAngle || 0;
        floatView[offset++] = spot.outerAngle || 0;
      } else {
        floatView[offset++] = 0;
        floatView[offset++] = 0;
      }
      const shadowIdx = light2.shadow.castShadow ? light2.shadowAtlasIndex : -1;
      uintView[offset++] = shadowIdx >>> 0;
      floatView[offset++] = light2.shadow.radius;
      floatView[offset++] = light2.shadow.intensity;
      floatView[offset++] = 0;
      floatView[offset++] = 0;
      floatView[offset++] = 0;
    }
    if (!SceneUniforms.hasLoggedMatrices) {
      SceneUniforms.hasLoggedMatrices = true;
      console.log(`[SceneUniforms] View matrix diagonal: [${floatView[0].toFixed(3)}, ${floatView[5].toFixed(3)}, ${floatView[10].toFixed(3)}, ${floatView[15].toFixed(3)}]`);
      console.log(`[SceneUniforms] View matrix translation column: [${floatView[12].toFixed(3)}, ${floatView[13].toFixed(3)}, ${floatView[14].toFixed(3)}]`);
      console.log(`[SceneUniforms] Projection matrix diagonal: [${floatView[16].toFixed(3)}, ${floatView[21].toFixed(3)}, ${floatView[26].toFixed(3)}, ${floatView[31].toFixed(3)}]`);
      console.log(`[SceneUniforms] Camera position: [${floatView[80].toFixed(3)}, ${floatView[81].toFixed(3)}, ${floatView[82].toFixed(3)}]`);
    }
    this.device.queue.writeBuffer(this.buffer, 0, this.uniformData);
  }
}

// ../../src/core/renderer/ObjectBuffer.ts
class ObjectBuffer {
  device;
  buffer;
  capacity;
  count = 0;
  static hasLogged = false;
  _wasResized = false;
  static ELEMENT_SIZE = 256;
  constructor(device, initialCapacity = 100) {
    this.device = device;
    this.capacity = initialCapacity;
    this.buffer = this.createBuffer(this.capacity);
  }
  createBuffer(count) {
    return this.device.createBuffer({
      label: "Global Object Buffer",
      size: count * ObjectBuffer.ELEMENT_SIZE,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
    });
  }
  get objectCount() {
    return this.count;
  }
  checkAndClearResized() {
    const wasResized = this._wasResized;
    this._wasResized = false;
    return wasResized;
  }
  update(meshes) {
    const prevCount = this.count;
    this.count = meshes.length;
    if (Math.abs(this.count - prevCount) > 10 || this.count === 0) {
      console.log(`[ObjectBuffer] update: ${prevCount} -> ${this.count} meshes`);
    }
    if (this.count > this.capacity) {
      console.log(`[ObjectBuffer] RESIZING: capacity ${this.capacity} -> ${Math.max(this.count, this.capacity * 2)}, destroying old buffer`);
      this.capacity = Math.max(this.count, this.capacity * 2);
      this.buffer.destroy();
      this.buffer = this.createBuffer(this.capacity);
      this._wasResized = true;
      console.log(`[ObjectBuffer] New buffer created`);
    }
    const arrayBuffer = new ArrayBuffer(this.count * ObjectBuffer.ELEMENT_SIZE);
    const floatView = new Float32Array(arrayBuffer);
    const uintView = new Uint32Array(arrayBuffer);
    for (let i = 0;i < this.count; i++) {
      const mesh = meshes[i];
      mesh.renderIndex = i;
      const offset = i * (ObjectBuffer.ELEMENT_SIZE / 4);
      const worldMatrixElements = mesh.transform.worldMatrix.elements;
      if (worldMatrixElements.some((v) => isNaN(v))) {
        console.error("NaN detected in worldMatrix for mesh:", mesh);
      }
      floatView.set(worldMatrixElements, offset);
      const normalMatrix = mesh.transform.worldMatrix.clone().inverse().transpose();
      if (normalMatrix.elements.some((v) => isNaN(v))) {
        console.error("NaN detected in normalMatrix for mesh:", mesh, "worldMatrix:", mesh.transform.worldMatrix.elements);
        floatView.set([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], offset + 16);
      } else {
        floatView.set(normalMatrix.elements, offset + 16);
      }
      floatView[offset + 32] = mesh.worldBounds.min.x;
      floatView[offset + 33] = mesh.worldBounds.min.y;
      floatView[offset + 34] = mesh.worldBounds.min.z;
      uintView[offset + 35] = mesh.geometry.triangleCount;
      floatView[offset + 36] = mesh.worldBounds.max.x;
      floatView[offset + 37] = mesh.worldBounds.max.y;
      floatView[offset + 38] = mesh.worldBounds.max.z;
      floatView[offset + 39] = 0;
      floatView.set(mesh.previousWorldMatrix.elements, offset + 40);
    }
    this.device.queue.writeBuffer(this.buffer, 0, arrayBuffer);
    if (!ObjectBuffer.hasLogged && this.count > 0) {
      ObjectBuffer.hasLogged = true;
      const firstMesh = meshes[0];
      console.log(`[ObjectBuffer] First mesh: ${firstMesh.name || "unnamed"}`);
      console.log(`[ObjectBuffer] Model matrix diagonal: [${floatView[0].toFixed(3)}, ${floatView[5].toFixed(3)}, ${floatView[10].toFixed(3)}, ${floatView[15].toFixed(3)}]`);
      console.log(`[ObjectBuffer] Model matrix translation: [${floatView[12].toFixed(3)}, ${floatView[13].toFixed(3)}, ${floatView[14].toFixed(3)}]`);
    }
  }
}

// ../../src/core/renderer/HiZBuffer.ts
class HiZBuffer {
  texture = null;
  width = 0;
  height = 0;
  mipLevels = 1;
  device;
  constructor(device, width, height) {
    this.device = device;
    this.resize(width, height);
  }
  resize(width, height) {
    if (width <= 0 || height <= 0)
      return;
    if (this.width === width && this.height === height)
      return;
    this.width = width;
    this.height = height;
    this.mipLevels = Math.floor(Math.log2(Math.max(width, height))) + 1;
    if (this.texture)
      this.texture.destroy();
    this.texture = this.device.createTexture({
      label: "Hi-Z Buffer",
      size: { width, height, depthOrArrayLayers: 1 },
      mipLevelCount: this.mipLevels,
      format: "r32float",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST
    });
    let mipWidth = width;
    let mipHeight = height;
    for (let mip = 0;mip < this.mipLevels; mip++) {
      const size = mipWidth * mipHeight;
      const data = new Float32Array(size);
      data.fill(1);
      this.device.queue.writeTexture({ texture: this.texture, mipLevel: mip }, data, { bytesPerRow: mipWidth * 4 }, { width: mipWidth, height: mipHeight });
      mipWidth = Math.max(1, Math.floor(mipWidth / 2));
      mipHeight = Math.max(1, Math.floor(mipHeight / 2));
    }
  }
}

// ../../src/core/renderer/IndirectDrawBuffer.ts
class IndirectDrawBuffer {
  device;
  buffer;
  capacity;
  count = 0;
  static hasLogged = false;
  static STRIDE = 20;
  constructor(device, initialCapacity = 100) {
    this.device = device;
    this.capacity = initialCapacity;
    this.buffer = this.createBuffer(this.capacity);
  }
  createBuffer(count) {
    return this.device.createBuffer({
      label: "Indirect Draw Buffer",
      size: count * IndirectDrawBuffer.STRIDE,
      usage: GPUBufferUsage.INDIRECT | GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE
    });
  }
  update(meshes) {
    this.count = meshes.length;
    if (this.count === 0)
      return;
    if (this.count > this.capacity) {
      this.capacity = Math.max(this.count, this.capacity * 2);
      this.buffer.destroy();
      this.buffer = this.createBuffer(this.capacity);
    }
    const data = new Uint32Array(this.count * 5);
    for (let i = 0;i < this.count; i++) {
      const mesh = meshes[i];
      const offset = i * 5;
      if (mesh.geometry.indices) {
        data[offset + 0] = mesh.geometry.indexCount;
        data[offset + 1] = 1;
        data[offset + 2] = 0;
        data[offset + 3] = 0;
        data[offset + 4] = i;
      } else {
        data[offset + 0] = mesh.geometry.vertexCount;
        data[offset + 1] = 1;
        data[offset + 2] = 0;
        data[offset + 3] = i;
        data[offset + 4] = 0;
      }
    }
    if (!IndirectDrawBuffer.hasLogged) {
      IndirectDrawBuffer.hasLogged = true;
    }
    this.device.queue.writeBuffer(this.buffer, 0, data);
  }
  getBufferForMesh(_renderIndex) {
    return this.buffer;
  }
}

// ../../src/core/CubeTexture.ts
class CubeTexture extends Texture {
  constructor(label = "CubeTexture") {
    super(label);
  }
  async loadCube(device, urls) {
    try {
      const promises = urls.map((url) => fetch(url).then((res) => res.blob()).then((blob) => createImageBitmap(blob)));
      const bitmaps = await Promise.all(promises);
      this.createFromImageBitmaps(device, bitmaps);
    } catch (e) {
      console.error(`Failed to load cube texture`, e);
    }
  }
  createFromImageBitmaps(device, bitmaps) {
    if (bitmaps.length !== 6) {
      throw new Error("CubeTexture requires 6 images");
    }
    const width = bitmaps[0].width;
    const height = bitmaps[0].height;
    this.gpuTexture = device.createTexture({
      label: this.label,
      size: [width, height, 6],
      format: "rgba8unorm",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
      viewFormats: ["rgba8unorm"]
    });
    for (let i = 0;i < 6; i++) {
      device.queue.copyExternalImageToTexture({ source: bitmaps[i] }, { texture: this.gpuTexture, origin: [0, 0, i] }, [width, height]);
    }
    this.view = this.gpuTexture.createView({
      dimension: "cube"
    });
    this.sampler = device.createSampler({
      magFilter: "linear",
      minFilter: "linear",
      mipmapFilter: "linear",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge",
      addressModeW: "clamp-to-edge"
    });
  }
  static _defaultCubeTextures = new WeakMap;
  static getDefault(device) {
    if (!CubeTexture._defaultCubeTextures.has(device)) {
      const texture = new CubeTexture("Default Cube Texture");
      texture.gpuTexture = device.createTexture({
        label: "Default Cube Texture",
        size: [1, 1, 6],
        format: "rgba8unorm",
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
      });
      const data = new Uint8Array([0, 0, 0, 255]);
      for (let i = 0;i < 6; i++) {
        device.queue.writeTexture({ texture: texture.gpuTexture, origin: [0, 0, i] }, data, { bytesPerRow: 4, rowsPerImage: 1 }, [1, 1, 1]);
      }
      texture.view = texture.gpuTexture.createView({
        dimension: "cube"
      });
      texture.sampler = device.createSampler({
        magFilter: "linear",
        minFilter: "linear"
      });
      CubeTexture._defaultCubeTextures.set(device, texture);
    }
    return CubeTexture._defaultCubeTextures.get(device);
  }
  static createFromColors(device, px, nx, py, ny, pz, nz) {
    const texture = new CubeTexture("Procedural Cube Texture");
    texture.gpuTexture = device.createTexture({
      label: "Procedural Cube Texture",
      size: [1, 1, 6],
      format: "rgba8unorm",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
    });
    const faces = [px, nx, py, ny, pz, nz];
    for (let i = 0;i < 6; i++) {
      const color = faces[i];
      const data = new Uint8Array([color[0] * 255, color[1] * 255, color[2] * 255, 255]);
      device.queue.writeTexture({ texture: texture.gpuTexture, origin: [0, 0, i] }, data, { bytesPerRow: 4, rowsPerImage: 1 }, [1, 1, 1]);
    }
    texture.view = texture.gpuTexture.createView({
      dimension: "cube"
    });
    texture.sampler = device.createSampler({
      magFilter: "linear",
      minFilter: "linear"
    });
    return texture;
  }
}

// ../../src/core/renderer/GlobalResources.ts
var MAX_SHADOW_LIGHTS = 4;
var activeShadowLayers = 1;
var SHADOW_UNIFORMS_SIZE = 336;
var CASCADE_COUNT = 4;
var CASCADE_UNIFORMS_SIZE = 288;

class GlobalResources {
  sceneUniforms;
  objectBuffer;
  hiZBuffer;
  indirectDrawBuffer;
  lightStorageBuffer;
  statsBuffer;
  cullingDebugBuffer;
  shadowAtlas = null;
  shadowSampler = null;
  shadowUniformsBuffer = null;
  cascadeUniformsBuffer = null;
  pointShadowAtlas = null;
  pointShadowSampler = null;
  environmentMap = null;
  static MAX_STORAGE_LIGHTS = 1024;
  static LIGHT_BUFFER_SIZE = 16 + GlobalResources.MAX_STORAGE_LIGHTS * 96;
  lightBufferData = new ArrayBuffer(GlobalResources.LIGHT_BUFFER_SIZE);
  lightBufferFloatView = new Float32Array(this.lightBufferData);
  lightBufferUintView = new Uint32Array(this.lightBufferData);
  shadowUniformsData = new ArrayBuffer(SHADOW_UNIFORMS_SIZE);
  shadowUniformsFloatView = new Float32Array(this.shadowUniformsData);
  shadowUniformsUintView = new Uint32Array(this.shadowUniformsData);
  cascadeUniformsData = new Float32Array(CASCADE_UNIFORMS_SIZE / 4);
  nearestSampler = null;
  linearSampler = null;
  transmittanceLUT = null;
  scatteringLUT = null;
  irradianceLUT = null;
  skyViewLUT = null;
  cloudNoiseLUT = null;
  atmosphereUniformsBuffer = null;
  atmosphereBindGroup = null;
  atmosphereBindGroupLayout = null;
  computeBindGroup = null;
  computeBindGroupLayout = null;
  renderBindGroup = null;
  renderBindGroupLayout = null;
  get bindGroup() {
    return this.computeBindGroup;
  }
  get bindGroupLayout() {
    return this.computeBindGroupLayout;
  }
  _bindGroupsDirty = true;
  _lastEnvironmentMap = null;
  markBindGroupsDirty() {
    this._bindGroupsDirty = true;
  }
  updateBindGroupsIfNeeded(device) {
    if (this.objectBuffer.checkAndClearResized()) {
      console.log("[GlobalResources] ObjectBuffer was resized, marking bind groups dirty");
      this._bindGroupsDirty = true;
    }
    if (this.environmentMap !== this._lastEnvironmentMap) {
      console.log("[GlobalResources] Environment map changed, marking bind groups dirty");
      this._bindGroupsDirty = true;
      this._lastEnvironmentMap = this.environmentMap;
    }
    if (this._bindGroupsDirty) {
      console.log("[GlobalResources] Recreating bind groups");
      this.createBindGroup(device);
      this._bindGroupsDirty = false;
    }
  }
  _shadowsInitialized = false;
  constructor(device) {
    this.sceneUniforms = new SceneUniforms(device);
    this.objectBuffer = new ObjectBuffer(device);
    this.hiZBuffer = new HiZBuffer(device, 1, 1);
    this.indirectDrawBuffer = new IndirectDrawBuffer(device);
    this.lightStorageBuffer = device.createBuffer({
      label: "Light Storage Buffer",
      size: 16 + 1024 * 96,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
    });
    this.statsBuffer = device.createBuffer({
      label: "Render Stats Buffer",
      size: 16,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST
    });
    this.cullingDebugBuffer = device.createBuffer({
      label: "Culling Debug Buffer",
      size: 64,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST
    });
    this.shadowAtlas = device.createTexture({
      label: "Shadow Atlas Placeholder",
      size: [1, 1, 1],
      format: "depth32float",
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
    });
    this.pointShadowAtlas = device.createTexture({
      label: "Point Shadow Atlas Placeholder",
      size: [1, 1, 1],
      format: "r32float",
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
    });
    this._shadowsInitialized = false;
    this.shadowSampler = device.createSampler({
      compare: "less",
      magFilter: "linear",
      minFilter: "linear"
    });
    this.shadowUniformsBuffer = device.createBuffer({
      label: "Shadow Uniforms Buffer",
      size: SHADOW_UNIFORMS_SIZE,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.cascadeUniformsBuffer = device.createBuffer({
      label: "Cascade Uniforms Buffer",
      size: CASCADE_UNIFORMS_SIZE,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.pointShadowSampler = device.createSampler({
      label: "Point Shadow Sampler",
      magFilter: "nearest",
      minFilter: "nearest"
    });
  }
  get shadowsInitialized() {
    return this._shadowsInitialized;
  }
  resize(width, height) {
    this.hiZBuffer.resize(width, height);
    this._bindGroupsDirty = true;
  }
  resizeShadows(resolution, maxLights, device, pointShadowResolution, shadowsEnabled = true) {
    if (!shadowsEnabled) {
      return;
    }
    const pointRes = pointShadowResolution ?? 1024;
    let needsBindGroupRecreate = false;
    const spotLightLayers = Math.max(0, Math.min(MAX_SHADOW_LIGHTS, maxLights));
    const layers = CASCADE_COUNT + spotLightLayers;
    if (this.shadowAtlas && (this.shadowAtlas.width !== resolution || this.shadowAtlas.depthOrArrayLayers !== layers)) {
      this.shadowAtlas.destroy();
      activeShadowLayers = layers;
      const isFirstInit = !this._shadowsInitialized;
      console.log(`GlobalResources: ${isFirstInit ? "Creating" : "Resizing"} shadow atlas to ${resolution}x${resolution}x${layers} (${(resolution * resolution * layers * 4 / 1024 / 1024).toFixed(1)} MB)`);
      this.shadowAtlas = device.createTexture({
        label: "Shadow Atlas (Array)",
        size: [resolution, resolution, layers],
        format: "depth32float",
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
      });
      needsBindGroupRecreate = true;
    }
    const pointLayers = MAX_SHADOW_LIGHTS * 6;
    if (this.pointShadowAtlas && this.pointShadowAtlas.width !== pointRes) {
      this.pointShadowAtlas.destroy();
      const isFirstInit = !this._shadowsInitialized;
      console.log(`GlobalResources: ${isFirstInit ? "Creating" : "Resizing"} point shadow atlas to ${pointRes}x${pointRes}x${pointLayers} (${(pointRes * pointRes * pointLayers * 4 / 1024 / 1024).toFixed(1)} MB)`);
      this.pointShadowAtlas = device.createTexture({
        label: "Point Shadow Atlas (Cube Array)",
        size: [pointRes, pointRes, pointLayers],
        format: "r32float",
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
      });
      needsBindGroupRecreate = true;
    }
    if (needsBindGroupRecreate) {
      this._shadowsInitialized = true;
      this.createBindGroup(device);
    }
  }
  getShadowAtlasLayers() {
    return this.shadowAtlas?.depthOrArrayLayers ?? activeShadowLayers;
  }
  setAtmosphereLUTs(transmittance, scattering, irradiance, skyView, cloudNoise = null) {
    this.transmittanceLUT = transmittance;
    this.scatteringLUT = scattering;
    this.irradianceLUT = irradiance;
    this.skyViewLUT = skyView;
    this.cloudNoiseLUT = cloudNoise;
  }
  hasLoggedShadowUniforms = false;
  updateShadowUniforms(device, shadowLights, atlasResolution) {
    if (!this.shadowUniformsBuffer)
      return;
    if (!this.hasLoggedShadowUniforms && shadowLights.length > 0) {
      console.log("GlobalResources.updateShadowUniforms:", {
        numLights: shadowLights.length,
        lights: shadowLights.map((l, i) => ({
          index: i,
          atlasLayer: l.atlasLayer,
          bias: l.bias,
          viewProjDiag: [l.viewProj[0], l.viewProj[5], l.viewProj[10], l.viewProj[15]]
        }))
      });
      this.hasLoggedShadowUniforms = true;
    }
    const floatView = this.shadowUniformsFloatView;
    const uintView = this.shadowUniformsUintView;
    let offset = 0;
    for (let i = 0;i < MAX_SHADOW_LIGHTS; i++) {
      const light = shadowLights[i];
      if (light) {
        floatView.set(light.viewProj, offset);
        offset += 16;
        uintView[offset++] = light.atlasLayer;
        floatView[offset++] = light.bias;
        floatView[offset++] = light.normalBias;
        uintView[offset++] = 0;
      } else {
        offset += 20;
      }
    }
    uintView[offset++] = Math.min(shadowLights.length, MAX_SHADOW_LIGHTS);
    floatView[offset++] = atlasResolution;
    offset += 2;
    device.queue.writeBuffer(this.shadowUniformsBuffer, 0, this.shadowUniformsData);
  }
  updateCascadeUniforms(device, cascadeViewProjs, splits, biases) {
    if (!this.cascadeUniformsBuffer)
      return;
    const data = this.cascadeUniformsData;
    let offset = 0;
    for (let i = 0;i < CASCADE_COUNT; i++) {
      if (cascadeViewProjs[i]) {
        data.set(cascadeViewProjs[i], offset);
      }
      offset += 16;
    }
    data.set(splits, offset);
    offset += 4;
    data.set(biases, offset);
    device.queue.writeBuffer(this.cascadeUniformsBuffer, 0, data);
  }
  updateLightBuffer(device, scene, camera) {
    const activeLights = scene.getClosestLights(camera.transform.position, GlobalResources.MAX_STORAGE_LIGHTS);
    let spotShadowIndex = 0;
    let pointShadowLayerIndex = 0;
    for (const light of activeLights) {
      if (light.shadow.castShadow) {
        if (light.type === 0) {
          light.shadowAtlasIndex = 0;
        } else if (light.type === 2) {
          light.shadowAtlasIndex = spotShadowIndex++;
        } else if (light.type === 1) {
          light.shadowAtlasIndex = pointShadowLayerIndex++;
        } else {
          light.shadowAtlasIndex = -1;
        }
      } else {
        light.shadowAtlasIndex = -1;
      }
    }
    const floatView = this.lightBufferFloatView;
    const uintView = this.lightBufferUintView;
    uintView[0] = activeLights.length;
    let offset = 4;
    for (let i = 0;i < activeLights.length; i++) {
      const light = activeLights[i];
      const lPos = light.transform.position;
      floatView[offset++] = lPos.x;
      floatView[offset++] = lPos.y;
      floatView[offset++] = lPos.z;
      floatView[offset++] = 0;
      let lDir;
      if (light.type === 4 /* Hemisphere */) {
        lDir = light.direction;
      } else {
        lDir = light.transform.getForwardVector();
      }
      floatView[offset++] = lDir.x;
      floatView[offset++] = lDir.y;
      floatView[offset++] = lDir.z;
      floatView[offset++] = 0;
      floatView[offset++] = light.color.x;
      floatView[offset++] = light.color.y;
      floatView[offset++] = light.color.z;
      floatView[offset++] = light.intensity;
      if (light.type === 1 /* Point */) {
        const pointLight = light;
        floatView[offset++] = pointLight.distance;
        floatView[offset++] = pointLight.decay;
        floatView[offset++] = 0;
      } else if (light.type === 2 /* Spot */) {
        const spotLight = light;
        floatView[offset++] = spotLight.distance;
        floatView[offset++] = spotLight.decay;
        floatView[offset++] = 0;
      } else if (light.type === 4 /* Hemisphere */) {
        const hemiLight = light;
        floatView[offset++] = hemiLight.groundColor.x;
        floatView[offset++] = hemiLight.groundColor.y;
        floatView[offset++] = hemiLight.groundColor.z;
      } else {
        floatView[offset++] = 0;
        floatView[offset++] = 0;
        floatView[offset++] = 0;
      }
      uintView[offset++] = light.type;
      if (light.type === 2 /* Spot */) {
        const spot = light;
        floatView[offset++] = spot.innerAngle || 0;
        floatView[offset++] = spot.outerAngle || 0;
      } else {
        floatView[offset++] = 0;
        floatView[offset++] = 0;
      }
      const shadowIdx = light.shadow.castShadow ? light.shadowAtlasIndex : -1;
      uintView[offset++] = shadowIdx >>> 0;
      floatView[offset++] = light.shadow.radius;
      floatView[offset++] = light.shadow.intensity;
      floatView[offset++] = 0;
      floatView[offset++] = 0;
      floatView[offset++] = 0;
    }
    device.queue.writeBuffer(this.lightStorageBuffer, 0, this.lightBufferData);
  }
  createBindGroup(device) {
    const defaultEnv = CubeTexture.getDefault(device);
    const envMap = this.environmentMap || defaultEnv;
    if (!this.computeBindGroupLayout) {
      this.computeBindGroupLayout = device.createBindGroupLayout({
        label: "Global Compute Bind Group Layout",
        entries: [
          { binding: 0, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE, buffer: { type: "uniform" } },
          { binding: 1, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE, buffer: { type: "read-only-storage" } },
          { binding: 2, visibility: GPUShaderStage.COMPUTE, texture: { sampleType: "unfilterable-float", viewDimension: "2d" } },
          { binding: 3, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE, buffer: { type: "read-only-storage" } },
          { binding: 4, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "depth", viewDimension: "2d-array" } },
          { binding: 5, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "comparison" } },
          { binding: 6, visibility: GPUShaderStage.FRAGMENT, texture: { viewDimension: "cube" } },
          { binding: 7, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "filtering" } },
          { binding: 8, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
          { binding: 9, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "unfilterable-float", viewDimension: "2d-array" } },
          { binding: 10, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "non-filtering" } },
          { binding: 11, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } }
        ]
      });
    }
    this.computeBindGroup = device.createBindGroup({
      label: "Global Compute Bind Group",
      layout: this.computeBindGroupLayout,
      entries: [
        { binding: 0, resource: { buffer: this.sceneUniforms.buffer } },
        { binding: 1, resource: { buffer: this.objectBuffer.buffer } },
        { binding: 2, resource: this.hiZBuffer.texture ? this.hiZBuffer.texture.createView() : undefined },
        { binding: 3, resource: { buffer: this.lightStorageBuffer } },
        { binding: 4, resource: this.shadowAtlas.createView({ dimension: "2d-array" }) },
        { binding: 5, resource: this.shadowSampler },
        { binding: 6, resource: envMap.view },
        { binding: 7, resource: envMap.sampler },
        { binding: 8, resource: { buffer: this.shadowUniformsBuffer } },
        { binding: 9, resource: this.pointShadowAtlas.createView({ dimension: "2d-array" }) },
        { binding: 10, resource: this.pointShadowSampler },
        { binding: 11, resource: { buffer: this.cascadeUniformsBuffer } }
      ]
    });
    if (!this.renderBindGroupLayout) {
      this.renderBindGroupLayout = device.createBindGroupLayout({
        label: "Global Render Bind Group Layout",
        entries: [
          { binding: 0, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
          { binding: 1, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: "read-only-storage" } },
          { binding: 3, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: "read-only-storage" } },
          { binding: 4, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "depth", viewDimension: "2d-array" } },
          { binding: 5, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "comparison" } },
          { binding: 6, visibility: GPUShaderStage.FRAGMENT, texture: { viewDimension: "cube" } },
          { binding: 7, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "filtering" } },
          { binding: 8, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
          { binding: 9, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "unfilterable-float", viewDimension: "2d-array" } },
          { binding: 10, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "non-filtering" } },
          { binding: 11, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } }
        ]
      });
    }
    this.renderBindGroup = device.createBindGroup({
      label: "Global Render Bind Group",
      layout: this.renderBindGroupLayout,
      entries: [
        { binding: 0, resource: { buffer: this.sceneUniforms.buffer } },
        { binding: 1, resource: { buffer: this.objectBuffer.buffer } },
        { binding: 3, resource: { buffer: this.lightStorageBuffer } },
        { binding: 4, resource: this.shadowAtlas.createView({ dimension: "2d-array" }) },
        { binding: 5, resource: this.shadowSampler },
        { binding: 6, resource: envMap.view },
        { binding: 7, resource: envMap.sampler },
        { binding: 8, resource: { buffer: this.shadowUniformsBuffer } },
        { binding: 9, resource: this.pointShadowAtlas.createView({ dimension: "2d-array" }) },
        { binding: 10, resource: this.pointShadowSampler },
        { binding: 11, resource: { buffer: this.cascadeUniformsBuffer } }
      ]
    });
    if (this.transmittanceLUT && this.skyViewLUT) {
      if (!this.nearestSampler) {
        this.nearestSampler = device.createSampler({
          minFilter: "nearest",
          magFilter: "nearest"
        });
      }
      if (!this.linearSampler) {
        this.linearSampler = device.createSampler({
          minFilter: "linear",
          magFilter: "linear",
          mipmapFilter: "linear",
          addressModeU: "repeat",
          addressModeV: "repeat",
          addressModeW: "repeat"
        });
      }
      if (!this.atmosphereUniformsBuffer) {
        this.atmosphereUniformsBuffer = device.createBuffer({
          label: "Atmosphere Uniforms Buffer",
          size: 512,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        });
      }
      if (!this.atmosphereBindGroupLayout) {
        this.atmosphereBindGroupLayout = device.createBindGroupLayout({
          label: "Atmosphere Bind Group Layout (SkyboxPass)",
          entries: [
            { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "unfilterable-float", viewDimension: "2d" } },
            { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "unfilterable-float", viewDimension: "2d" } },
            { binding: 2, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
            { binding: 3, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "non-filtering" } },
            { binding: 4, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "float", viewDimension: "3d" } },
            { binding: 5, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "filtering" } }
          ]
        });
      }
      const noiseView = this.cloudNoiseLUT ? this.cloudNoiseLUT.createView() : this.transmittanceLUT.createView();
      this.atmosphereBindGroup = device.createBindGroup({
        label: "Atmosphere Bind Group (SkyboxPass)",
        layout: this.atmosphereBindGroupLayout,
        entries: [
          { binding: 0, resource: this.transmittanceLUT.createView() },
          { binding: 1, resource: this.skyViewLUT.createView() },
          { binding: 2, resource: { buffer: this.atmosphereUniformsBuffer } },
          { binding: 3, resource: this.nearestSampler },
          { binding: 4, resource: noiseView },
          { binding: 5, resource: this.linearSampler }
        ]
      });
    }
  }
}

// ../../src/core/procedural/water/WaterMaterial.ts
var DEFAULT_WATER_MATERIAL_CONFIG = {
  shallowColor: new Vector3(0, 0.5, 0.8),
  deepColor: new Vector3(0, 0.1, 0.25),
  opacity: 0.95,
  roughness: 0.05,
  fresnelPower: 5,
  fresnelBias: 0.02,
  skyReflectionBlend: 0.3,
  refractionStrength: 0.05,
  chromaticAberration: true,
  chromaticAberrationStrength: 0.01,
  depthFadeDistance: 10,
  foamEnabled: false,
  foamIntensity: 0.5,
  foamColor: new Vector3(1, 1, 1),
  foamSpeed: 1,
  causticsEnabled: true,
  causticsIntensity: 0.15,
  causticsScale: 8,
  causticsOctaves: 4,
  scatterColor: new Vector3(0, 0.7, 0.6),
  scatterIntensity: 0.4,
  waveHeightMultiplier: 1,
  ssrEnabled: false,
  ssrStrength: 0.5,
  refractionEnabled: false
};
var MAX_LIGHTS = 8;

class WaterMaterial extends Material {
  config;
  alphaMode = "BLEND";
  opacity = 0.8;
  displacementTexture = null;
  waveNormalTexture = null;
  depthTexture = null;
  ssrTexture = null;
  sceneColorTexture = null;
  normalMap = null;
  foamTexture = null;
  time = 0;
  worldSize = { width: 100, depth: 100 };
  screenWidth = 1920;
  screenHeight = 1080;
  constructor(config = {}) {
    super();
    this.config = { ...DEFAULT_WATER_MATERIAL_CONFIG, ...config };
    this.opacity = this.config.opacity;
    this.initShaders();
  }
  initShaders() {
    const commonDefines = `
      struct Light {
        position: vec3f,
        _pad1: f32,
        direction: vec3f,
        _pad2: f32,
        color: vec3f,
        intensity: f32,
        attenuation: vec3f,
        lightType: u32,
        coneAngles: vec2f,
        shadowIndex: i32,
        shadowRadius: f32,
        shadowIntensity: f32,
        _pad3: f32,
        _pad4: f32,
        _pad5: f32,
      }

      struct SceneUniforms {
        viewMatrix : mat4x4<f32>,
        projectionMatrix : mat4x4<f32>,
        lightViewProj : mat4x4<f32>,
        prevViewProj : mat4x4<f32>,
        inverseProjectionMatrix : mat4x4<f32>,
        cameraPosition : vec3f,
        time : f32,
        lightCount : u32,
        debugMode : u32,
        flags : u32,
        environmentIntensity : f32,
        fogColor: vec3f,
        fogDensity: f32,
        fogParams: vec4f,
        fogSettings: vec4u,
        lights : array<Light, ${MAX_LIGHTS}>,
      }

      struct ObjectData {
        modelMatrix : mat4x4<f32>,
        normalMatrix : mat4x4<f32>,
        aabbMin : vec3f,
        _pad1 : f32,
        aabbMax : vec3f,
        _pad2 : f32,
        prevModelMatrix : mat4x4<f32>,
        _pad3 : vec4<f32>,
        _pad4 : vec4<f32>,
      }

      struct WaterUniforms {
        shallowColor: vec3f,
        opacity: f32,
        deepColor: vec3f,
        roughness: f32,
        fresnelPower: f32,
        fresnelBias: f32,
        skyReflectionBlend: f32,
        refractionStrength: f32,
        depthFadeDistance: f32,
        foamEnabled: u32,
        foamIntensity: f32,
        causticsEnabled: u32,
        foamColor: vec3f,
        causticsIntensity: f32,
        scatterColor: vec3f,
        scatterIntensity: f32,
        causticsScale: f32,
        waveHeightMultiplier: f32,
        time: f32,
        worldWidth: f32,
        worldDepth: f32,
        screenWidth: f32,
        screenHeight: f32,
        nearPlane: f32,
        farPlane: f32,
        // New uniforms for improved water
        ssrEnabled: u32,
        ssrStrength: f32,
        refractionEnabled: u32,
        chromaticAberration: u32,
        chromaticAberrationStrength: f32,
        foamSpeed: f32,
        causticsOctaves: u32,
        _pad: f32,
      }

      @group(0) @binding(0) var<uniform> scene : SceneUniforms;
      @group(0) @binding(1) var<storage, read> objects : array<ObjectData>;

      @group(1) @binding(0) var<uniform> water : WaterUniforms;
      @group(1) @binding(1) var linearSampler : sampler;
      @group(1) @binding(2) var displacementTex : texture_2d<f32>;
      @group(1) @binding(3) var waveNormalTex : texture_2d<f32>;
      @group(1) @binding(4) var sceneDepthTex : texture_depth_2d;
      @group(1) @binding(5) var depthSampler : sampler;
      @group(1) @binding(6) var ssrTex : texture_2d<f32>;
      @group(1) @binding(7) var sceneColorTex : texture_2d<f32>;
      @group(1) @binding(8) var foamTex : texture_2d<f32>;

      struct VertexInput {
        @location(0) position : vec3<f32>,
        @location(1) normal : vec3<f32>,
        @location(2) uv : vec2<f32>,
      }

      struct VertexOutput {
        @builtin(position) position : vec4<f32>,
        @location(0) worldNormal : vec3<f32>,
        @location(1) uv : vec2<f32>,
        @location(2) worldPosition : vec3<f32>,
        @location(3) foam : f32,
        @location(4) clipPosition : vec4<f32>,
      }
    `;
    this.vertexShaderCode = `
      ${commonDefines}

      @vertex
      fn vs_main(input : VertexInput, @builtin(instance_index) instanceIndex : u32) -> VertexOutput {
        var output : VertexOutput;

        let modelMatrix = objects[instanceIndex].modelMatrix;
        let normalMatrix = objects[instanceIndex].normalMatrix;

        // Calculate UV for wave sampling (based on world position)
        let localWorldPos = (modelMatrix * vec4<f32>(input.position, 1.0)).xyz;
        let waveUV = vec2f(
          (localWorldPos.x / water.worldWidth) + 0.5,
          (localWorldPos.z / water.worldDepth) + 0.5
        );

        // Sample displacement texture
        let displacement = textureSampleLevel(displacementTex, linearSampler, waveUV, 0.0);

        // Apply wave displacement
        var displacedPosition = input.position;
        displacedPosition.x += displacement.x * water.waveHeightMultiplier;
        displacedPosition.y += displacement.y * water.waveHeightMultiplier;
        displacedPosition.z += displacement.z * water.waveHeightMultiplier;

        let worldPos = modelMatrix * vec4<f32>(displacedPosition, 1.0);
        output.worldPosition = worldPos.xyz;

        let clipPos = scene.projectionMatrix * scene.viewMatrix * worldPos;
        output.position = clipPos;

        // Pass clip position to fragment shader for depth sampling
        output.clipPosition = clipPos;

        // Sample wave normal
        let waveNormal = textureSampleLevel(waveNormalTex, linearSampler, waveUV, 0.0).xyz * 2.0 - 1.0;

        // Transform normal to world space
        let baseNormal = normalize((normalMatrix * vec4<f32>(input.normal, 0.0)).xyz);

        // Blend base normal with wave normal
        let tangent = normalize(cross(baseNormal, vec3f(0.0, 0.0, 1.0)));
        let bitangent = normalize(cross(baseNormal, tangent));
        let TBN = mat3x3f(tangent, bitangent, baseNormal);
        output.worldNormal = normalize(TBN * waveNormal);

        output.uv = input.uv;
        output.foam = displacement.w;

        return output;
      }
    `;
    this.fragmentShaderCode = `
      ${commonDefines}

      const PI = 3.14159265359;

      // Hash functions for procedural noise
      fn hash21(p: vec2f) -> f32 {
        var p3 = fract(vec3f(p.xyx) * 0.1031);
        p3 += dot(p3, p3.yzx + 33.33);
        return fract((p3.x + p3.y) * p3.z);
      }

      fn hash22(p: vec2f) -> vec2f {
        let n = sin(dot(p, vec2f(41.0, 289.0)));
        return fract(vec2f(262144.0, 32768.0) * n) * 2.0 - 1.0;
      }

      // Smooth noise for caustics and foam
      fn noise2D(p: vec2f) -> f32 {
        let i = floor(p);
        let f = fract(p);
        let u = f * f * (3.0 - 2.0 * f);

        return mix(
          mix(hash21(i + vec2f(0.0, 0.0)), hash21(i + vec2f(1.0, 0.0)), u.x),
          mix(hash21(i + vec2f(0.0, 1.0)), hash21(i + vec2f(1.0, 1.0)), u.x),
          u.y
        );
      }

      // FBM noise for more detailed foam
      fn fbm(p: vec2f, octaves: i32) -> f32 {
        var value = 0.0;
        var amplitude = 0.5;
        var frequency = 1.0;
        var pp = p;

        for (var i = 0; i < octaves; i++) {
          value += amplitude * noise2D(pp * frequency);
          amplitude *= 0.5;
          frequency *= 2.0;
        }
        return value;
      }

      // Enhanced Voronoi-based caustics pattern with configurable octaves
      fn caustics(uv: vec2f, time: f32, octaves: u32) -> f32 {
        var c = 0.0;
        let numLayers = min(i32(octaves), 5);

        // Multiple layers for complex pattern
        for (var i = 0; i < numLayers; i++) {
          let scale = 1.0 + f32(i) * 0.4;
          let speed = 0.5 + f32(i) * 0.15;
          let weight = 1.0 / (f32(i) + 1.0);

          // Offset each layer slightly for more variation
          let offset = vec2f(f32(i) * 17.3, f32(i) * 31.7);
          let p = uv * scale + offset + vec2f(time * speed * 0.1, time * speed * 0.07);

          // Voronoi-like pattern
          let ip = floor(p);
          let fp = fract(p);

          var minDist = 1.0;
          var secondMinDist = 1.0;

          for (var y = -1; y <= 1; y++) {
            for (var x = -1; x <= 1; x++) {
              let neighbor = vec2f(f32(x), f32(y));
              let point = hash22(ip + neighbor) * 0.5 + 0.5;
              // More complex animation with multiple frequencies
              let animPoint = point + 0.25 * sin(time * 0.5 + 6.28 * point)
                                     + 0.1 * sin(time * 1.3 + 3.14 * point.yx);
              let diff = neighbor + animPoint - fp;
              let dist = length(diff);

              if (dist < minDist) {
                secondMinDist = minDist;
                minDist = dist;
              } else if (dist < secondMinDist) {
                secondMinDist = dist;
              }
            }
          }

          // Use edge distance for more caustic-like pattern
          let edge = secondMinDist - minDist;
          c += pow(1.0 - edge * 2.0, 2.0) * weight;
        }

        // Apply power curve for sharper, more realistic caustics
        return pow(clamp(c * 0.4, 0.0, 1.0), 1.5);
      }

      // Fresnel calculation
      fn fresnel(viewDir: vec3f, normal: vec3f, power: f32, bias: f32) -> f32 {
        let NdotV = max(dot(normal, viewDir), 0.0);
        return bias + (1.0 - bias) * pow(1.0 - NdotV, power);
      }

      // GGX distribution
      fn distributionGGX(N: vec3f, H: vec3f, roughness: f32) -> f32 {
        let a = roughness * roughness;
        let a2 = a * a;
        let NdotH = max(dot(N, H), 0.0);
        let NdotH2 = NdotH * NdotH;
        let num = a2;
        let denom = (NdotH2 * (a2 - 1.0) + 1.0);
        return num / (PI * denom * denom);
      }

      // Detail normal from procedural noise
      fn getDetailNormal(worldPos: vec3f, time: f32) -> vec3f {
        let scale1 = 0.5;
        let scale2 = 1.5;

        let uv1 = worldPos.xz * scale1 + vec2f(time * 0.02, time * 0.015);
        let uv2 = worldPos.xz * scale2 + vec2f(-time * 0.03, time * 0.02);

        let h1 = noise2D(uv1);
        let h2 = noise2D(uv2) * 0.5;

        // Calculate normal from height
        let eps = 0.1;
        let h1x = noise2D(uv1 + vec2f(eps, 0.0)) + noise2D(uv2 + vec2f(eps, 0.0)) * 0.5;
        let h1z = noise2D(uv1 + vec2f(0.0, eps)) + noise2D(uv2 + vec2f(0.0, eps)) * 0.5;

        let dx = (h1x - h1 - h2) / eps;
        let dz = (h1z - h1 - h2) / eps;

        return normalize(vec3f(-dx * 0.3, 1.0, -dz * 0.3));
      }

      // Linearize depth from [0,1] non-linear to linear view-space depth
      fn linearizeDepth(depth: f32, near: f32, far: f32) -> f32 {
        return near * far / (far - depth * (far - near));
      }

      // Sample scene color with chromatic aberration for refraction
      fn sampleRefractionColor(baseUV: vec2f, offset: vec2f, chromaticStrength: f32, chromaticEnabled: bool) -> vec3f {
        if (chromaticEnabled && chromaticStrength > 0.0) {
          // Sample R, G, B at slightly different offsets for chromatic aberration
          let rOffset = offset * (1.0 + chromaticStrength);
          let gOffset = offset;
          let bOffset = offset * (1.0 - chromaticStrength);

          let rUV = clamp(baseUV + rOffset, vec2f(0.001), vec2f(0.999));
          let gUV = clamp(baseUV + gOffset, vec2f(0.001), vec2f(0.999));
          let bUV = clamp(baseUV + bOffset, vec2f(0.001), vec2f(0.999));

          let r = textureSample(sceneColorTex, linearSampler, rUV).r;
          let g = textureSample(sceneColorTex, linearSampler, gUV).g;
          let b = textureSample(sceneColorTex, linearSampler, bUV).b;

          return vec3f(r, g, b);
        } else {
          let refractUV = clamp(baseUV + offset, vec2f(0.001), vec2f(0.999));
          return textureSample(sceneColorTex, linearSampler, refractUV).rgb;
        }
      }

      @fragment
      fn fs_main(
        @builtin(position) fragCoord : vec4f,
        @location(0) worldNormal : vec3f,
        @location(1) uv : vec2f,
        @location(2) worldPosition : vec3f,
        @location(3) foam : f32,
        @location(4) clipPosition : vec4f
      ) -> @location(0) vec4f {
        // Calculate screen UV from fragment position
        let screenUV = vec2f(fragCoord.x / water.screenWidth, fragCoord.y / water.screenHeight);

        // Sample scene depth to calculate water depth
        let sceneDepthRaw = textureSample(sceneDepthTex, depthSampler, screenUV);
        let sceneDepthLinear = linearizeDepth(sceneDepthRaw, water.nearPlane, water.farPlane);

        // Water surface depth (from clip position)
        let waterDepthLinear = linearizeDepth(fragCoord.z, water.nearPlane, water.farPlane);

        // Calculate actual water depth (distance from surface to scene geometry behind)
        let waterDepth = max(0.0, sceneDepthLinear - waterDepthLinear);

        // Depth factor for color and opacity (0 = surface, 1 = deep)
        let depthFactor = clamp(waterDepth / water.depthFadeDistance, 0.0, 1.0);

        // Add detail normal for micro-ripples
        let detailNormal = getDetailNormal(worldPosition, water.time);
        let N = normalize(mix(worldNormal, detailNormal, 0.3));

        let V = normalize(scene.cameraPosition - worldPosition);
        let NdotV = max(dot(N, V), 0.0);

        // Fresnel term - high at glancing angles (more reflection), low when looking down (more see-through)
        let fresnelTerm = fresnel(V, N, water.fresnelPower, water.fresnelBias);

        // Water color based on actual depth - shallow to deep gradient
        let waterColor = mix(water.shallowColor, water.deepColor, depthFactor);

        // === REFRACTION - Sample scene color behind water ===
        var refractionColor = vec3f(0.0);
        if (water.refractionEnabled == 1u) {
          // Calculate refraction offset based on wave normal
          let refractionOffset = N.xz * water.refractionStrength * (1.0 - depthFactor * 0.5);
          let chromaticEnabled = water.chromaticAberration == 1u;
          refractionColor = sampleRefractionColor(screenUV, refractionOffset, water.chromaticAberrationStrength, chromaticEnabled);

          // Tint refracted color with water color based on depth
          refractionColor = mix(refractionColor, refractionColor * waterColor * 2.0, depthFactor * 0.7);
        }

        // === SKY REFLECTION ===
        let reflectDir = reflect(-V, N);
        let skyT = clamp(reflectDir.y * 0.5 + 0.5, 0.0, 1.0);
        let horizonColor = vec3f(0.7, 0.8, 0.9);
        let zenithColor = vec3f(0.3, 0.5, 0.85);
        var reflectionColor = mix(horizonColor, zenithColor, skyT);

        // === SSR INTEGRATION - Sample screen-space reflections ===
        if (water.ssrEnabled == 1u) {
          let ssrSample = textureSample(ssrTex, linearSampler, screenUV);
          let ssrColor = ssrSample.rgb;
          let ssrAlpha = ssrSample.a;

          // Blend SSR with sky reflection - SSR takes priority when available
          if (ssrAlpha > 0.01) {
            reflectionColor = mix(reflectionColor, ssrColor, ssrAlpha * water.ssrStrength);
          }
        }

        // Subsurface scattering - stronger in shallow water where light penetrates
        var sss = vec3f(0.0);
        let sssDepthFactor = 1.0 - depthFactor; // More SSS in shallow water
        for (var i = 0u; i < scene.lightCount; i++) {
          let light = scene.lights[i];
          var L = vec3f(0.0);

          if (light.lightType == 0u) {
            L = normalize(-light.direction);
          } else {
            L = normalize(light.position - worldPosition);
          }

          let LdotV = max(dot(L, -V), 0.0);
          let scatter = pow(LdotV, 3.0) * NdotV * sssDepthFactor;
          sss += water.scatterColor * scatter * light.color * light.intensity * water.scatterIntensity;
        }

        // === ENHANCED CAUSTICS - more visible in shallow water ===
        var causticsColor = vec3f(0.0);
        if (water.causticsEnabled == 1u) {
          let causticsUV = worldPosition.xz * water.causticsScale * 0.01;
          let causticsValue = caustics(causticsUV, water.time, water.causticsOctaves);
          let causticsStrength = (1.0 - fresnelTerm) * (1.0 - depthFactor * 0.7);

          // Use slightly warm tint for caustics (sunlight through water)
          let causticsTint = vec3f(1.0, 0.98, 0.9);
          causticsColor = causticsTint * causticsValue * water.causticsIntensity * causticsStrength;
        }

        // === COMPOSE FINAL COLOR ===
        // Start with base color: blend between refraction and water color
        var finalColor = waterColor;
        if (water.refractionEnabled == 1u) {
          // Blend refraction with water color based on fresnel and depth
          // When depthFactor is very high (>0.95), there's likely no geometry behind the water
          // (we're seeing the sky/background), so reduce refraction to avoid washed-out look
          let hasGeometryBehind = smoothstep(0.95, 0.8, depthFactor); // 1.0 when geometry present, 0.0 when sky
          let refractionBlend = (1.0 - fresnelTerm) * (1.0 - depthFactor * 0.3) * hasGeometryBehind;
          finalColor = mix(waterColor, refractionColor, refractionBlend * 0.8);
        }

        // Add subsurface scattering and caustics
        finalColor += sss + causticsColor;

        // Add reflection based on fresnel
        finalColor = mix(finalColor, reflectionColor, fresnelTerm * water.skyReflectionBlend);

        // Specular highlights from lights
        for (var i = 0u; i < scene.lightCount; i++) {
          let light = scene.lights[i];
          var L = vec3f(0.0);
          var attenuation = 1.0;

          if (light.lightType == 0u) {
            L = normalize(-light.direction);
          } else {
            let lightVec = light.position - worldPosition;
            let dist = length(lightVec);
            L = normalize(lightVec);
            attenuation = 1.0 / (1.0 + 0.09 * dist + 0.032 * dist * dist);
          }

          let H = normalize(V + L);
          let NdotL = max(dot(N, L), 0.0);

          // Specular (sun glitter)
          let D = distributionGGX(N, H, water.roughness);
          let specular = D * fresnelTerm;

          finalColor += specular * light.color * light.intensity * attenuation * NdotL * 0.3;
        }

        // === ENHANCED FOAM ===
        if (water.foamEnabled == 1u && water.foamIntensity > 0.0) {
          let timeOffset = water.time * water.foamSpeed;

          // Sample foam texture if available, otherwise use procedural
          let foamUV = worldPosition.xz * 0.1;
          var foamSample = textureSample(foamTex, linearSampler, foamUV).r;

          // Fallback to procedural foam if texture is placeholder (all 1s)
          if (foamSample > 0.99) {
            // Animated procedural foam pattern
            let foamPattern1 = fbm(worldPosition.xz * 2.0 + vec2f(timeOffset * 0.1, 0.0), 3);
            let foamPattern2 = fbm(worldPosition.xz * 4.0 + vec2f(0.0, timeOffset * 0.15) + vec2f(100.0, 50.0), 2);
            let foamPattern3 = noise2D(worldPosition.xz * 8.0 - vec2f(timeOffset * 0.2, timeOffset * 0.1));
            foamSample = foamPattern1 * 0.5 + foamPattern2 * 0.35 + foamPattern3 * 0.15;
          }

          // Edge foam where water is very shallow (main foam source)
          let edgeThreshold = 0.4;
          let shallowFactor = 1.0 - smoothstep(0.0, edgeThreshold, depthFactor);
          let edgeFoam = shallowFactor * foamSample;

          // Dynamic foam at wave crests - use foam input from vertex shader
          let crestFoam = foam * 0.5 * foamSample;

          // Wave intersection foam (where waves meet)
          let waveIntersection = pow(max(0.0, 1.0 - abs(N.y)), 3.0) * 0.3 * foamSample;

          // Combine all foam sources
          let totalFoam = clamp((edgeFoam + crestFoam + waveIntersection) * water.foamIntensity, 0.0, 0.9);

          if (totalFoam > 0.03) {
            // Add subtle animation to foam color
            let foamBrightness = 1.0 + 0.1 * sin(water.time * 2.0 + worldPosition.x * 0.5);
            let animatedFoamColor = water.foamColor * foamBrightness;
            finalColor = mix(finalColor, animatedFoamColor, totalFoam);
          }
        }

        // Opacity: shallow water = more transparent, deep water = more opaque
        // Also factor in fresnel: glancing angles = more opaque (reflection)
        // The opacity setting now properly scales the entire opacity range
        var finalOpacity = water.opacity;
        if (water.refractionEnabled == 1u) {
          // With refraction, use mostly high opacity so refraction shows through alpha blend
          let depthOpacity = water.opacity * mix(0.5, 1.0, depthFactor);
          finalOpacity = depthOpacity + fresnelTerm * (1.0 - depthOpacity) * 0.4;
        } else {
          // Scale opacity by depth: shallow = 30% of opacity, deep = 100% of opacity
          let depthOpacity = water.opacity * mix(0.3, 1.0, depthFactor);
          finalOpacity = depthOpacity + fresnelTerm * (1.0 - depthOpacity) * 0.5;
        }

        return vec4f(finalColor, clamp(finalOpacity, 0.0, 1.0));
      }
    `;
  }
  getRenderingPath() {
    return "forward";
  }
  getVertexShader(_pass) {
    return this.vertexShaderCode;
  }
  getFragmentShader(_pass) {
    return this.fragmentShaderCode;
  }
  getUniformBufferSize() {
    return 176;
  }
  updateUniforms(device, buffer, _offset, _context) {
    const arrayBuffer = new ArrayBuffer(this.getUniformBufferSize());
    const floatView = new Float32Array(arrayBuffer);
    const uintView = new Uint32Array(arrayBuffer);
    let i = 0;
    floatView[i++] = this.config.shallowColor.x;
    floatView[i++] = this.config.shallowColor.y;
    floatView[i++] = this.config.shallowColor.z;
    floatView[i++] = this.config.opacity;
    floatView[i++] = this.config.deepColor.x;
    floatView[i++] = this.config.deepColor.y;
    floatView[i++] = this.config.deepColor.z;
    floatView[i++] = this.config.roughness;
    floatView[i++] = this.config.fresnelPower;
    floatView[i++] = this.config.fresnelBias;
    floatView[i++] = this.config.skyReflectionBlend;
    floatView[i++] = this.config.refractionStrength;
    floatView[i++] = this.config.depthFadeDistance;
    uintView[i++] = this.config.foamEnabled ? 1 : 0;
    floatView[i++] = this.config.foamIntensity;
    uintView[i++] = this.config.causticsEnabled ? 1 : 0;
    floatView[i++] = this.config.foamColor.x;
    floatView[i++] = this.config.foamColor.y;
    floatView[i++] = this.config.foamColor.z;
    floatView[i++] = this.config.causticsIntensity;
    floatView[i++] = this.config.scatterColor.x;
    floatView[i++] = this.config.scatterColor.y;
    floatView[i++] = this.config.scatterColor.z;
    floatView[i++] = this.config.scatterIntensity;
    floatView[i++] = this.config.causticsScale;
    floatView[i++] = this.config.waveHeightMultiplier;
    floatView[i++] = this.time;
    floatView[i++] = this.worldSize.width;
    floatView[i++] = this.worldSize.depth;
    floatView[i++] = this.screenWidth;
    floatView[i++] = this.screenHeight;
    floatView[i++] = _context?.camera?.near ?? 0.1;
    floatView[i++] = _context?.camera?.far ?? 1000;
    uintView[i++] = this.config.ssrEnabled ? 1 : 0;
    floatView[i++] = this.config.ssrStrength;
    uintView[i++] = this.config.refractionEnabled ? 1 : 0;
    uintView[i++] = this.config.chromaticAberration ? 1 : 0;
    floatView[i++] = this.config.chromaticAberrationStrength;
    floatView[i++] = this.config.foamSpeed;
    uintView[i++] = this.config.causticsOctaves;
    floatView[i++] = 0;
    floatView[i++] = 0;
    floatView[i++] = 0;
    floatView[i++] = 0;
    device.queue.writeBuffer(buffer, 0, arrayBuffer);
  }
  getBindGroupEntries(device, uniformBuffer) {
    const defaultTex = Texture.getDefault(device);
    const linearSampler = device.createSampler({
      magFilter: "linear",
      minFilter: "linear",
      mipmapFilter: "linear",
      addressModeU: "repeat",
      addressModeV: "repeat"
    });
    const depthSampler = device.createSampler({
      magFilter: "nearest",
      minFilter: "nearest"
    });
    const displacementView = this.displacementTexture?.createView() ?? defaultTex.view;
    const normalView = this.waveNormalTexture?.createView() ?? defaultTex.view;
    let depthView;
    if (this.depthTexture) {
      depthView = this.depthTexture.createView();
    } else {
      const dummyDepth = device.createTexture({
        size: [1, 1],
        format: "depth32float",
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT
      });
      depthView = dummyDepth.createView();
    }
    const ssrView = this.ssrTexture ? this.ssrTexture.createView() : defaultTex.view;
    const sceneColorView = this.sceneColorTexture ? this.sceneColorTexture.createView() : defaultTex.view;
    const foamView = this.foamTexture ? this.foamTexture.view : defaultTex.view;
    return [
      { binding: 0, resource: { buffer: uniformBuffer } },
      { binding: 1, resource: linearSampler },
      { binding: 2, resource: displacementView },
      { binding: 3, resource: normalView },
      { binding: 4, resource: depthView },
      { binding: 5, resource: depthSampler },
      { binding: 6, resource: ssrView },
      { binding: 7, resource: sceneColorView },
      { binding: 8, resource: foamView }
    ];
  }
  createBindGroupLayout(device) {
    return device.createBindGroupLayout({
      label: "WaterMaterial Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
        { binding: 1, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, sampler: { type: "filtering" } },
        { binding: 2, visibility: GPUShaderStage.VERTEX, texture: { sampleType: "float" } },
        { binding: 3, visibility: GPUShaderStage.VERTEX, texture: {} },
        { binding: 4, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "depth" } },
        { binding: 5, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "non-filtering" } },
        { binding: 6, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "float" } },
        { binding: 7, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "float" } },
        { binding: 8, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "float" } }
      ]
    });
  }
  setShallowColor(color) {
    this.config.shallowColor = color;
  }
  setDeepColor(color) {
    this.config.deepColor = color;
  }
  setOpacity(opacity) {
    this.config.opacity = Math.max(0, Math.min(1, opacity));
    this.opacity = this.config.opacity;
  }
  getConfig() {
    return { ...this.config };
  }
  setConfig(config) {
    if (config.shallowColor)
      this.config.shallowColor = config.shallowColor;
    if (config.deepColor)
      this.config.deepColor = config.deepColor;
    if (config.opacity !== undefined)
      this.config.opacity = config.opacity;
    if (config.roughness !== undefined)
      this.config.roughness = config.roughness;
    if (config.fresnelPower !== undefined)
      this.config.fresnelPower = config.fresnelPower;
    if (config.fresnelBias !== undefined)
      this.config.fresnelBias = config.fresnelBias;
    if (config.skyReflectionBlend !== undefined)
      this.config.skyReflectionBlend = config.skyReflectionBlend;
    if (config.refractionStrength !== undefined)
      this.config.refractionStrength = config.refractionStrength;
    if (config.chromaticAberration !== undefined)
      this.config.chromaticAberration = config.chromaticAberration;
    if (config.chromaticAberrationStrength !== undefined)
      this.config.chromaticAberrationStrength = config.chromaticAberrationStrength;
    if (config.depthFadeDistance !== undefined)
      this.config.depthFadeDistance = config.depthFadeDistance;
    if (config.foamEnabled !== undefined)
      this.config.foamEnabled = config.foamEnabled;
    if (config.foamIntensity !== undefined)
      this.config.foamIntensity = config.foamIntensity;
    if (config.foamColor)
      this.config.foamColor = config.foamColor;
    if (config.foamSpeed !== undefined)
      this.config.foamSpeed = config.foamSpeed;
    if (config.causticsEnabled !== undefined)
      this.config.causticsEnabled = config.causticsEnabled;
    if (config.causticsIntensity !== undefined)
      this.config.causticsIntensity = config.causticsIntensity;
    if (config.causticsScale !== undefined)
      this.config.causticsScale = config.causticsScale;
    if (config.causticsOctaves !== undefined)
      this.config.causticsOctaves = config.causticsOctaves;
    if (config.scatterColor)
      this.config.scatterColor = config.scatterColor;
    if (config.scatterIntensity !== undefined)
      this.config.scatterIntensity = config.scatterIntensity;
    if (config.waveHeightMultiplier !== undefined)
      this.config.waveHeightMultiplier = config.waveHeightMultiplier;
    if (config.ssrEnabled !== undefined)
      this.config.ssrEnabled = config.ssrEnabled;
    if (config.ssrStrength !== undefined)
      this.config.ssrStrength = config.ssrStrength;
    if (config.refractionEnabled !== undefined)
      this.config.refractionEnabled = config.refractionEnabled;
  }
}

// ../../src/core/procedural/water/WaveGenerator.ts
var DEFAULT_WAVE_CONFIG = {
  waveType: "gerstner",
  resolution: 256,
  worldSize: { width: 100, depth: 100 },
  waves: [
    { direction: new Vector2(1, 0), steepness: 0.5, wavelength: 10, speed: 1 },
    { direction: new Vector2(0.7, 0.7), steepness: 0.3, wavelength: 5, speed: 1.2 },
    { direction: new Vector2(-0.3, 0.9), steepness: 0.2, wavelength: 3, speed: 0.8 },
    { direction: new Vector2(0.5, -0.8), steepness: 0.15, wavelength: 2, speed: 1.5 }
  ]
};
var MAX_WAVES = 8;

class WaveGenerator {
  config;
  _device = null;
  initialized = false;
  displacementTexture = null;
  normalTexture = null;
  computePipeline = null;
  bindGroup = null;
  uniformBuffer = null;
  waveBuffer = null;
  constructor(config = {}) {
    this.config = { ...DEFAULT_WAVE_CONFIG, ...config };
  }
  init(device) {
    this._device = device;
    const resolution = this.config.resolution;
    this.displacementTexture = device.createTexture({
      label: "Wave Displacement Texture",
      size: [resolution, resolution],
      format: "rgba16float",
      usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING
    });
    this.normalTexture = device.createTexture({
      label: "Wave Normal Texture",
      size: [resolution, resolution],
      format: "rgba8unorm",
      usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING
    });
    this.uniformBuffer = device.createBuffer({
      label: "Wave Uniforms",
      size: 48,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.waveBuffer = device.createBuffer({
      label: "Wave Parameters",
      size: MAX_WAVES * 32,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
    });
    const shaderModule = device.createShaderModule({
      label: "Wave Compute Shader",
      code: this.getComputeShaderCode()
    });
    const bindGroupLayout = device.createBindGroupLayout({
      label: "Wave Bind Group Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: "uniform" } },
        { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: "read-only-storage" } },
        { binding: 2, visibility: GPUShaderStage.COMPUTE, storageTexture: { access: "write-only", format: "rgba16float" } },
        { binding: 3, visibility: GPUShaderStage.COMPUTE, storageTexture: { access: "write-only", format: "rgba8unorm" } }
      ]
    });
    const pipelineLayout = device.createPipelineLayout({
      label: "Wave Pipeline Layout",
      bindGroupLayouts: [bindGroupLayout]
    });
    this.computePipeline = device.createComputePipeline({
      label: "Wave Compute Pipeline",
      layout: pipelineLayout,
      compute: {
        module: shaderModule,
        entryPoint: "main"
      }
    });
    this.bindGroup = device.createBindGroup({
      label: "Wave Bind Group",
      layout: bindGroupLayout,
      entries: [
        { binding: 0, resource: { buffer: this.uniformBuffer } },
        { binding: 1, resource: { buffer: this.waveBuffer } },
        { binding: 2, resource: this.displacementTexture.createView() },
        { binding: 3, resource: this.normalTexture.createView() }
      ]
    });
    this.uploadWaveParameters();
    this.initialized = true;
    console.log("WaveGenerator: Initialized with resolution", resolution);
  }
  uploadWaveParameters() {
    if (!this._device || !this.waveBuffer)
      return;
    const waves = this.config.waves || [];
    const waveData = new Float32Array(MAX_WAVES * 8);
    for (let i = 0;i < Math.min(waves.length, MAX_WAVES); i++) {
      const wave = waves[i];
      const offset = i * 8;
      const dirLen = Math.sqrt(wave.direction.x * wave.direction.x + wave.direction.y * wave.direction.y);
      const dirX = dirLen > 0 ? wave.direction.x / dirLen : 1;
      const dirY = dirLen > 0 ? wave.direction.y / dirLen : 0;
      waveData[offset + 0] = dirX;
      waveData[offset + 1] = dirY;
      waveData[offset + 2] = wave.steepness;
      waveData[offset + 3] = wave.wavelength;
      waveData[offset + 4] = wave.speed;
      waveData[offset + 5] = 0;
      waveData[offset + 6] = 0;
      waveData[offset + 7] = 0;
    }
    this._device.queue.writeBuffer(this.waveBuffer, 0, waveData);
  }
  generate(time, commandEncoder) {
    if (!this.initialized || !this._device || !this.computePipeline || !this.bindGroup || !this.uniformBuffer) {
      return;
    }
    const waveCount = Math.min(this.config.waves?.length || 0, MAX_WAVES);
    const uniformData = new Float32Array([
      time,
      this.config.resolution,
      this.config.worldSize.width,
      this.config.worldSize.depth,
      waveCount,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    this._device.queue.writeBuffer(this.uniformBuffer, 0, uniformData);
    const computePass = commandEncoder.beginComputePass({
      label: "Wave Compute Pass"
    });
    computePass.setPipeline(this.computePipeline);
    computePass.setBindGroup(0, this.bindGroup);
    const workgroupSize = 8;
    const workgroupCountX = Math.ceil(this.config.resolution / workgroupSize);
    const workgroupCountY = Math.ceil(this.config.resolution / workgroupSize);
    computePass.dispatchWorkgroups(workgroupCountX, workgroupCountY);
    computePass.end();
  }
  getComputeShaderCode() {
    return `
      struct Uniforms {
        time: f32,
        resolution: f32,
        worldWidth: f32,
        worldDepth: f32,
        waveCount: f32,
        _pad: vec3f,
      }

      struct Wave {
        direction: vec2f,
        steepness: f32,
        wavelength: f32,
        speed: f32,
        _pad: vec3f,
      }

      @group(0) @binding(0) var<uniform> uniforms: Uniforms;
      @group(0) @binding(1) var<storage, read> waves: array<Wave>;
      @group(0) @binding(2) var outputDisplacement: texture_storage_2d<rgba16float, write>;
      @group(0) @binding(3) var outputNormal: texture_storage_2d<rgba8unorm, write>;

      const PI: f32 = 3.14159265359;
      const GRAVITY: f32 = 9.81;

      // Gerstner wave displacement calculation
      fn gerstnerWave(worldPos: vec2f, time: f32, wave: Wave) -> vec4f {
        let k = 2.0 * PI / wave.wavelength;
        let c = sqrt(GRAVITY / k); // Wave speed from dispersion relation
        let d = wave.direction;
        let f = k * dot(d, worldPos) - c * time * wave.speed;
        let a = wave.steepness / k;

        // Displacement (horizontal X, vertical Y, horizontal Z)
        let dx = d.x * a * cos(f);
        let dy = a * sin(f);
        let dz = d.y * a * cos(f);

        // Foam based on wave peaks (when sin(f) > threshold)
        let foam = max(0.0, sin(f) - 0.7) * 3.0;

        return vec4f(dx, dy, dz, foam);
      }

      // Calculate partial derivatives for normal computation
      fn gerstnerDerivatives(worldPos: vec2f, time: f32, wave: Wave) -> vec4f {
        let k = 2.0 * PI / wave.wavelength;
        let c = sqrt(GRAVITY / k);
        let d = wave.direction;
        let f = k * dot(d, worldPos) - c * time * wave.speed;
        let a = wave.steepness / k;

        // Partial derivatives of height with respect to x and z
        let dhdx = k * d.x * a * cos(f);
        let dhdz = k * d.y * a * cos(f);

        // Also compute horizontal displacement derivatives for Gerstner normal
        let ddxdx = -k * d.x * d.x * a * sin(f);
        let ddzdz = -k * d.y * d.y * a * sin(f);

        return vec4f(dhdx, dhdz, ddxdx, ddzdz);
      }

      @compute @workgroup_size(8, 8)
      fn main(@builtin(global_invocation_id) globalId: vec3u) {
        let resolution = u32(uniforms.resolution);

        if (globalId.x >= resolution || globalId.y >= resolution) {
          return;
        }

        let uv = vec2f(f32(globalId.x), f32(globalId.y)) / uniforms.resolution;

        // Convert UV to world position
        let worldPos = vec2f(
          (uv.x - 0.5) * uniforms.worldWidth,
          (uv.y - 0.5) * uniforms.worldDepth
        );

        var totalDisplacement = vec3f(0.0);
        var totalFoam = 0.0;
        var totalDhdx = 0.0;
        var totalDhdz = 0.0;

        let waveCount = u32(uniforms.waveCount);

        for (var i = 0u; i < waveCount; i++) {
          let wave = waves[i];
          let result = gerstnerWave(worldPos, uniforms.time, wave);
          totalDisplacement += result.xyz;
          totalFoam += result.w;

          let derivatives = gerstnerDerivatives(worldPos, uniforms.time, wave);
          totalDhdx += derivatives.x;
          totalDhdz += derivatives.y;
        }

        // Clamp foam
        totalFoam = clamp(totalFoam, 0.0, 1.0);

        // Write displacement
        textureStore(outputDisplacement, vec2i(globalId.xy), vec4f(totalDisplacement, totalFoam));

        // Calculate normal from derivatives
        // For Gerstner waves: N = normalize(vec3(-dhdx, 1, -dhdz))
        let normal = normalize(vec3f(-totalDhdx, 1.0, -totalDhdz));

        // Encode normal to 0-1 range for storage
        let encodedNormal = normal * 0.5 + 0.5;

        textureStore(outputNormal, vec2i(globalId.xy), vec4f(encodedNormal, 1.0));
      }
    `;
  }
  getDisplacementTexture() {
    return this.displacementTexture;
  }
  getNormalTexture() {
    return this.normalTexture;
  }
  getHeightAt(x, z, time) {
    if (this.config.waveType !== "gerstner" || !this.config.waves) {
      return 0;
    }
    let height = 0;
    for (const wave of this.config.waves) {
      const k = 2 * Math.PI / wave.wavelength;
      const c = Math.sqrt(9.81 / k);
      const d = wave.direction;
      const dirLen = Math.sqrt(d.x * d.x + d.y * d.y);
      const dirX = dirLen > 0 ? d.x / dirLen : 1;
      const dirY = dirLen > 0 ? d.y / dirLen : 0;
      const f = k * (dirX * x + dirY * z) - c * time * wave.speed;
      const a = wave.steepness / k;
      height += a * Math.sin(f);
    }
    return height;
  }
  setConfig(config) {
    const oldResolution = this.config.resolution;
    this.config = { ...this.config, ...config };
    if (config.resolution && config.resolution !== oldResolution && this._device) {
      this.destroy();
      this.init(this._device);
    } else if (config.waves) {
      this.uploadWaveParameters();
    }
  }
  getConfig() {
    return { ...this.config };
  }
  addWave(wave) {
    if (!this.config.waves) {
      this.config.waves = [];
    }
    if (this.config.waves.length < MAX_WAVES) {
      this.config.waves.push(wave);
      this.uploadWaveParameters();
    } else {
      console.warn("WaveGenerator: Maximum wave count reached");
    }
  }
  clearWaves() {
    this.config.waves = [];
    this.uploadWaveParameters();
  }
  static getGerstnerWGSL() {
    return `
      // Gerstner wave function
      // Returns: vec4f(displacement.xyz, foam)
      fn gerstnerWave(
        worldPos: vec2f,
        time: f32,
        direction: vec2f,
        steepness: f32,
        wavelength: f32,
        speed: f32
      ) -> vec4f {
        let k = 2.0 * 3.14159 / wavelength;
        let c = sqrt(9.81 / k);
        let d = normalize(direction);
        let f = k * dot(d, worldPos) - c * time * speed;
        let a = steepness / k;

        // Displacement
        let dx = d.x * a * cos(f);
        let dy = a * sin(f);
        let dz = d.y * a * cos(f);

        // Foam based on wave peaks
        let foam = max(0.0, sin(f) - 0.8) * 5.0;

        return vec4f(dx, dy, dz, foam);
      }

      // Sum multiple Gerstner waves
      fn sumGerstnerWaves(
        worldPos: vec2f,
        time: f32,
        waves: array<vec4f, 8>,  // direction.xy, steepness, wavelength
        speeds: array<f32, 8>,
        waveCount: u32
      ) -> vec4f {
        var result = vec4f(0.0);

        for (var i = 0u; i < waveCount; i++) {
          let wave = waves[i];
          result += gerstnerWave(
            worldPos,
            time,
            wave.xy,
            wave.z,
            wave.w,
            speeds[i]
          );
        }

        return result;
      }
    `;
  }
  destroy() {
    this.displacementTexture?.destroy();
    this.normalTexture?.destroy();
    this.uniformBuffer?.destroy();
    this.waveBuffer?.destroy();
    this.displacementTexture = null;
    this.normalTexture = null;
    this.computePipeline = null;
    this.bindGroup = null;
    this.uniformBuffer = null;
    this.waveBuffer = null;
    this._device = null;
    this.initialized = false;
  }
}

// ../../src/core/procedural/water/Water.ts
var DEFAULT_WATER_CONFIG = {
  segments: { x: 64, z: 64 },
  deepColor: new Vector3(0, 0.1, 0.25),
  roughness: 0.05,
  wavesEnabled: true,
  waveCount: 4,
  fresnelPower: 5,
  fresnelBias: 0.02,
  skyReflectionBlend: 0.3,
  refractionStrength: 0.05,
  chromaticAberration: true,
  chromaticAberrationStrength: 0.01,
  foamEnabled: false,
  foamIntensity: 0.5,
  foamColor: new Vector3(1, 1, 1),
  foamSpeed: 1,
  causticsEnabled: true,
  causticsIntensity: 0.15,
  causticsScale: 8,
  causticsOctaves: 4,
  scatterColor: new Vector3(0, 0.7, 0.6),
  scatterIntensity: 0.4,
  ssrEnabled: false,
  ssrStrength: 0.5,
  refractionEnabled: false,
  depthFadeDistance: 10,
  waveResolution: 256
};

class Water extends Node {
  config;
  _device = null;
  initialized = false;
  mesh = null;
  material = null;
  waveGenerator = null;
  geometry = null;
  _totalTime = 0;
  constructor(config) {
    super("Water");
    this.config = { ...DEFAULT_WATER_CONFIG, ...config };
    this._initState = "pending";
    this._needsUpdate = true;
  }
  async onInit(device) {
    await this.init(device);
  }
  onUpdate(deltaTime) {
    this._totalTime += deltaTime;
    if (this.material) {
      this.material.time = this._totalTime;
      if (this.mesh) {
        this.mesh.bindGroup = null;
      }
    }
  }
  async init(device) {
    this._device = device;
    this.geometry = this.createWaterGeometry();
    if (this.config.wavesEnabled !== false) {
      const waves = this.config.customWaves || this.generateDefaultWaves();
      this.waveGenerator = new WaveGenerator({
        waveType: "gerstner",
        resolution: this.config.waveResolution || 256,
        worldSize: { width: this.config.size.width, depth: this.config.size.depth },
        waves
      });
      this.waveGenerator.init(device);
    }
    this.material = new WaterMaterial({
      shallowColor: this.config.shallowColor,
      deepColor: this.config.deepColor || new Vector3(0, 0.15, 0.3),
      opacity: this.config.opacity,
      roughness: this.config.roughness ?? 0.05,
      fresnelPower: this.config.fresnelPower ?? 5,
      fresnelBias: this.config.fresnelBias ?? 0.02,
      skyReflectionBlend: this.config.skyReflectionBlend ?? 0.3,
      refractionStrength: this.config.refractionStrength ?? 0.05,
      chromaticAberration: this.config.chromaticAberration ?? true,
      chromaticAberrationStrength: this.config.chromaticAberrationStrength ?? 0.01,
      depthFadeDistance: this.config.depthFadeDistance ?? 10,
      foamEnabled: this.config.foamEnabled ?? true,
      foamIntensity: this.config.foamIntensity ?? 0.5,
      foamColor: this.config.foamColor || new Vector3(1, 1, 1),
      foamSpeed: this.config.foamSpeed ?? 1,
      causticsEnabled: this.config.causticsEnabled ?? true,
      causticsIntensity: this.config.causticsIntensity ?? 0.3,
      causticsScale: this.config.causticsScale ?? 8,
      causticsOctaves: this.config.causticsOctaves ?? 4,
      scatterColor: this.config.scatterColor || new Vector3(0, 0.7, 0.6),
      scatterIntensity: this.config.scatterIntensity ?? 0.4,
      waveHeightMultiplier: this.config.waveHeight,
      ssrEnabled: this.config.ssrEnabled ?? true,
      ssrStrength: this.config.ssrStrength ?? 0.5,
      refractionEnabled: this.config.refractionEnabled ?? true
    });
    if (this.waveGenerator) {
      this.material.displacementTexture = this.waveGenerator.getDisplacementTexture();
      this.material.waveNormalTexture = this.waveGenerator.getNormalTexture();
    }
    this.material.worldSize = { width: this.config.size.width, depth: this.config.size.depth };
    this.mesh = new Mesh(this.geometry, this.material);
    this.addChild(this.mesh);
    this.setWaterLevel(this.config.waterLevel);
    this.initialized = true;
    this._initState = "ready";
    console.log(`Water: Initialized ${this.config.size.width}x${this.config.size.depth} with ${this.config.segments?.x}x${this.config.segments?.z} segments`);
  }
  generateDefaultWaves() {
    const waveCount = this.config.waveCount ?? 4;
    const baseSpeed = this.config.waveSpeed;
    const baseHeight = this.config.waveHeight;
    const waves = [];
    for (let i = 0;i < waveCount; i++) {
      const angle = i / waveCount * Math.PI * 2 + Math.random() * 0.5;
      const wavelength = 10 / (i + 1) + Math.random() * 2;
      const steepness = 0.5 / (i + 1) * baseHeight;
      waves.push({
        direction: new Vector2(Math.cos(angle), Math.sin(angle)),
        steepness: Math.max(0.05, steepness),
        wavelength: Math.max(1, wavelength),
        speed: baseSpeed * (0.8 + Math.random() * 0.4)
      });
    }
    return waves;
  }
  createWaterGeometry() {
    const geometry = new Geometry;
    const segmentsX = this.config.segments?.x ?? 64;
    const segmentsZ = this.config.segments?.z ?? 64;
    const width = this.config.size.width;
    const depth = this.config.size.depth;
    const vertexCount = (segmentsX + 1) * (segmentsZ + 1);
    const positions = new Float32Array(vertexCount * 3);
    const normals = new Float32Array(vertexCount * 3);
    const uvs = new Float32Array(vertexCount * 2);
    let vi = 0;
    let ni = 0;
    let ui = 0;
    for (let z = 0;z <= segmentsZ; z++) {
      for (let x = 0;x <= segmentsX; x++) {
        const u = x / segmentsX;
        const v = z / segmentsZ;
        positions[vi++] = (u - 0.5) * width;
        positions[vi++] = 0;
        positions[vi++] = (v - 0.5) * depth;
        normals[ni++] = 0;
        normals[ni++] = 1;
        normals[ni++] = 0;
        uvs[ui++] = u;
        uvs[ui++] = v;
      }
    }
    const indexCount = segmentsX * segmentsZ * 6;
    const useUint32 = vertexCount > 65535;
    const indices = useUint32 ? new Uint32Array(indexCount) : new Uint16Array(indexCount);
    let ii = 0;
    for (let z = 0;z < segmentsZ; z++) {
      for (let x = 0;x < segmentsX; x++) {
        const a = z * (segmentsX + 1) + x;
        const b = a + 1;
        const c = a + (segmentsX + 1);
        const d = c + 1;
        indices[ii++] = a;
        indices[ii++] = c;
        indices[ii++] = b;
        indices[ii++] = b;
        indices[ii++] = c;
        indices[ii++] = d;
      }
    }
    geometry.setAttribute("position", positions);
    geometry.setAttribute("normal", normals);
    geometry.setAttribute("uv", uvs);
    geometry.setIndices(indices);
    return geometry;
  }
  update(time, commandEncoder) {
    if (!this.initialized)
      return;
    if (this.waveGenerator && commandEncoder) {
      this.waveGenerator.generate(time * this.config.waveSpeed, commandEncoder);
    }
    if (this.material) {
      this.material.time = time;
      if (this.waveGenerator) {
        this.material.displacementTexture = this.waveGenerator.getDisplacementTexture();
        this.material.waveNormalTexture = this.waveGenerator.getNormalTexture();
      }
      if (this.mesh) {
        this.mesh.bindGroup = null;
      }
    }
  }
  setWaterLevel(level) {
    this.config.waterLevel = level;
    const pos = this.transform.position;
    this.transform.position = new Vector3(pos.x, level, pos.z);
  }
  setConfig(config) {
    if (config.size) {
      const needsGeometryUpdate = config.size.width !== this.config.size.width || config.size.depth !== this.config.size.depth;
      this.config.size = config.size;
      if (needsGeometryUpdate && this._device) {
        this.geometry = this.createWaterGeometry();
        if (this.mesh && this.material) {
          this.removeChild(this.mesh);
          this.mesh = new Mesh(this.geometry, this.material);
          this.addChild(this.mesh);
        }
        if (this.waveGenerator) {
          this.waveGenerator.setConfig({
            worldSize: { width: config.size.width, depth: config.size.depth }
          });
        }
        if (this.material) {
          this.material.worldSize = { width: config.size.width, depth: config.size.depth };
        }
      }
    }
    if (config.segments && this._device) {
      this.config.segments = config.segments;
      this.geometry = this.createWaterGeometry();
      if (this.mesh && this.material) {
        this.removeChild(this.mesh);
        this.mesh = new Mesh(this.geometry, this.material);
        this.addChild(this.mesh);
      }
    }
    if (config.waterLevel !== undefined) {
      this.setWaterLevel(config.waterLevel);
    }
    if (config.shallowColor && this.material) {
      this.config.shallowColor = config.shallowColor;
      this.material.setConfig({ shallowColor: config.shallowColor });
    }
    if (config.deepColor && this.material) {
      this.config.deepColor = config.deepColor;
      this.material.setConfig({ deepColor: config.deepColor });
    }
    if (config.opacity !== undefined && this.material) {
      this.config.opacity = config.opacity;
      this.material.setOpacity(config.opacity);
    }
    if (config.roughness !== undefined && this.material) {
      this.config.roughness = config.roughness;
      this.material.setConfig({ roughness: config.roughness });
    }
    if (config.waveHeight !== undefined) {
      this.config.waveHeight = config.waveHeight;
      if (this.material) {
        this.material.setConfig({ waveHeightMultiplier: config.waveHeight });
      }
    }
    if (config.waveSpeed !== undefined) {
      this.config.waveSpeed = config.waveSpeed;
    }
    if (config.waveCount !== undefined && this.waveGenerator && this._device) {
      this.config.waveCount = config.waveCount;
      const waves = this.generateDefaultWaves();
      this.waveGenerator.setConfig({ waves });
    }
    if (config.customWaves && this.waveGenerator) {
      this.waveGenerator.setConfig({ waves: config.customWaves });
    }
    if (config.fresnelPower !== undefined && this.material) {
      this.config.fresnelPower = config.fresnelPower;
      this.material.setConfig({ fresnelPower: config.fresnelPower });
    }
    if (config.fresnelBias !== undefined && this.material) {
      this.config.fresnelBias = config.fresnelBias;
      this.material.setConfig({ fresnelBias: config.fresnelBias });
    }
    if (config.skyReflectionBlend !== undefined && this.material) {
      this.config.skyReflectionBlend = config.skyReflectionBlend;
      this.material.setConfig({ skyReflectionBlend: config.skyReflectionBlend });
    }
    if (config.refractionStrength !== undefined && this.material) {
      this.config.refractionStrength = config.refractionStrength;
      this.material.setConfig({ refractionStrength: config.refractionStrength });
    }
    if (config.foamEnabled !== undefined && this.material) {
      this.config.foamEnabled = config.foamEnabled;
      this.material.setConfig({ foamEnabled: config.foamEnabled });
    }
    if (config.foamIntensity !== undefined && this.material) {
      this.config.foamIntensity = config.foamIntensity;
      this.material.setConfig({ foamIntensity: config.foamIntensity });
    }
    if (config.foamColor && this.material) {
      this.config.foamColor = config.foamColor;
      this.material.setConfig({ foamColor: config.foamColor });
    }
    if (config.causticsEnabled !== undefined && this.material) {
      this.config.causticsEnabled = config.causticsEnabled;
      this.material.setConfig({ causticsEnabled: config.causticsEnabled });
    }
    if (config.causticsIntensity !== undefined && this.material) {
      this.config.causticsIntensity = config.causticsIntensity;
      this.material.setConfig({ causticsIntensity: config.causticsIntensity });
    }
    if (config.causticsScale !== undefined && this.material) {
      this.config.causticsScale = config.causticsScale;
      this.material.setConfig({ causticsScale: config.causticsScale });
    }
    if (config.scatterColor && this.material) {
      this.config.scatterColor = config.scatterColor;
      this.material.setConfig({ scatterColor: config.scatterColor });
    }
    if (config.scatterIntensity !== undefined && this.material) {
      this.config.scatterIntensity = config.scatterIntensity;
      this.material.setConfig({ scatterIntensity: config.scatterIntensity });
    }
    if (config.depthFadeDistance !== undefined && this.material) {
      this.config.depthFadeDistance = config.depthFadeDistance;
      this.material.setConfig({ depthFadeDistance: config.depthFadeDistance });
    }
    if (config.chromaticAberration !== undefined && this.material) {
      this.config.chromaticAberration = config.chromaticAberration;
      this.material.setConfig({ chromaticAberration: config.chromaticAberration });
    }
    if (config.chromaticAberrationStrength !== undefined && this.material) {
      this.config.chromaticAberrationStrength = config.chromaticAberrationStrength;
      this.material.setConfig({ chromaticAberrationStrength: config.chromaticAberrationStrength });
    }
    if (config.foamSpeed !== undefined && this.material) {
      this.config.foamSpeed = config.foamSpeed;
      this.material.setConfig({ foamSpeed: config.foamSpeed });
    }
    if (config.causticsOctaves !== undefined && this.material) {
      this.config.causticsOctaves = config.causticsOctaves;
      this.material.setConfig({ causticsOctaves: config.causticsOctaves });
    }
    if (config.ssrEnabled !== undefined && this.material) {
      this.config.ssrEnabled = config.ssrEnabled;
      this.material.setConfig({ ssrEnabled: config.ssrEnabled });
    }
    if (config.ssrStrength !== undefined && this.material) {
      this.config.ssrStrength = config.ssrStrength;
      this.material.setConfig({ ssrStrength: config.ssrStrength });
    }
    if (config.refractionEnabled !== undefined && this.material) {
      this.config.refractionEnabled = config.refractionEnabled;
      this.material.setConfig({ refractionEnabled: config.refractionEnabled });
    }
  }
  getConfig() {
    return { ...this.config };
  }
  isUnderwater(position) {
    const waveHeight = this.getWaveHeightAt(position.x, position.z, this.material?.time ?? 0);
    return position.y < this.config.waterLevel + waveHeight;
  }
  getWaveHeightAt(x, z, time) {
    if (!this.waveGenerator)
      return 0;
    return this.waveGenerator.getHeightAt(x, z, time * this.config.waveSpeed) * this.config.waveHeight;
  }
  getWaveGenerator() {
    return this.waveGenerator;
  }
  getMaterial() {
    return this.material;
  }
  getMesh() {
    return this.mesh;
  }
  exportGeometry() {
    if (!this.geometry)
      return null;
    const positions = this.geometry.attributes["position"];
    const normals = this.geometry.attributes["normal"];
    const uvs = this.geometry.attributes["uv"];
    const indices = this.geometry.indices;
    if (!positions || !normals || !uvs || !indices)
      return null;
    return {
      vertices: new Float32Array(positions),
      normals: new Float32Array(normals),
      uvs: new Float32Array(uvs),
      indices: new Uint32Array(indices)
    };
  }
  destroy() {
    if (this.waveGenerator) {
      this.waveGenerator.destroy();
      this.waveGenerator = null;
    }
    if (this.mesh) {
      this.removeChild(this.mesh);
      this.mesh = null;
    }
    this.geometry = null;
    this.material = null;
    this._device = null;
    this.initialized = false;
    console.log("Water: Destroyed");
  }
}

// ../../src/core/renderer/RenderGraph.ts
class RenderGraph {
  passes = [];
  globalResources = null;
  getPasses() {
    return this.passes;
  }
  addPass(pass) {
    this.passes.push(pass);
  }
  removePass(pass) {
    const index = this.passes.indexOf(pass);
    if (index !== -1) {
      this.passes.splice(index, 1);
      return true;
    }
    return false;
  }
  init(device, context, presentationFormat) {
    this.globalResources = new GlobalResources(device);
    this.globalResources.createBindGroup(device);
    for (const pass of this.passes) {
      pass.init(device, context, presentationFormat);
    }
  }
  resize(width, height) {
    if (width <= 0 || height <= 0) {
      console.warn(`RenderGraph: Skipping resize with invalid dimensions: ${width}x${height}`);
      return;
    }
    if (this.globalResources) {
      this.globalResources.resize(width, height);
    }
    for (const pass of this.passes) {
      pass.resize(width, height);
    }
  }
  setDebugMode(mode) {
    if (this.globalResources) {
      this.globalResources.sceneUniforms.debugMode = mode;
    }
  }
  getGlobalResources() {
    return this.globalResources;
  }
  execute(device, context) {
    if (!this.globalResources)
      return;
    const shadowsEnabled = context.scene.shadows.enabled;
    const shadowRes = context.scene.shadows.resolution;
    const shadowLayers = context.scene.shadows.maxLights ?? 1;
    const pointShadowRes = context.scene.shadows.pointShadowResolution;
    this.globalResources.resizeShadows(shadowRes, shadowLayers, device, pointShadowRes, shadowsEnabled);
    this.globalResources.environmentMap = context.scene.environmentMap;
    this.globalResources.sceneUniforms.update(context.camera, context.scene);
    const meshes = [];
    context.scene.traverse((node) => {
      if (!node.visible)
        return false;
      if (node instanceof Mesh) {
        node.updateWorldBounds();
        meshes.push(node);
      }
    });
    if (meshes.length === 0 && this.globalResources.objectBuffer.objectCount > 0) {
      console.warn("[RenderGraph] Mesh count dropped to 0 from", this.globalResources.objectBuffer.objectCount);
    }
    this.globalResources.objectBuffer.update(meshes);
    this.globalResources.indirectDrawBuffer.update(meshes);
    this.globalResources.updateBindGroupsIfNeeded(device);
    const commandEncoder = device.createCommandEncoder();
    const time = context.time ?? 0;
    context.scene.traverse((node) => {
      if (!node.visible)
        return false;
      if (node instanceof Water) {
        node.update(time, commandEncoder);
      }
    });
    for (const pass of this.passes) {
      pass.execute(commandEncoder, context, this.globalResources);
    }
    device.queue.submit([commandEncoder.finish()]);
  }
}

// ../../src/core/materials/StandardMaterial.ts
class StandardMaterial extends Material {
  albedo;
  roughness;
  metallic;
  emissive;
  opacity = 1;
  alphaMode = "OPAQUE";
  alphaCutoff = 0.5;
  albedoMap = null;
  normalMap = null;
  roughnessMap = null;
  metallicMap = null;
  emissiveMap = null;
  occlusionMap = null;
  displacementMap = null;
  displacementScale = 0.1;
  textureScale = { x: 1, y: 1 };
  receiveShadows = true;
  doubleSided = false;
  ambientIntensity = 1;
  windEnabled = false;
  windStrength = 0.3;
  windSpeed = 1;
  windFrequency = 1.5;
  blendMap2 = null;
  blendNormalMap2 = null;
  blendMode = "none";
  blendNoiseScale = 100;
  blendPatchiness = 0.5;
  useWorldSpaceUV = false;
  worldSpaceUVScale = 30;
  static MAX_LIGHTS = 8;
  forwardFragmentShaderCode;
  constructor(albedo = new Vector3(1, 1, 1), roughness = 0.5, metallic = 0, emissive = new Vector3(0, 0, 0)) {
    super();
    this.albedo = albedo;
    this.roughness = roughness;
    this.metallic = metallic;
    this.emissive = emissive;
    const commonDefines = `
      struct Light {
        position: vec3f,
        _pad1: f32,
        direction: vec3f,
        _pad2: f32,
        color: vec3f,
        intensity: f32,
        attenuation: vec3f,
        lightType: u32,
        coneAngles: vec2f,
        shadowIndex: i32,  // -1 = no shadow, 0-3 = shadow atlas layer
        shadowRadius: f32, // Shadow softness/blur radius (higher = softer)
        shadowIntensity: f32, // How dark shadows get (0=no shadow, 1=fully dark)
        _pad3: f32,
        _pad4: f32,
        _pad5: f32,
      }

      struct SceneUniforms {
        viewMatrix : mat4x4<f32>,
        projectionMatrix : mat4x4<f32>,
        lightViewProj : mat4x4<f32>,
        prevViewProj : mat4x4<f32>,
        inverseProjectionMatrix : mat4x4<f32>,
        cameraPosition : vec3f,
        time : f32,
        lightCount : u32,
        debugMode : u32,
        flags : u32,
        environmentIntensity : f32,
        fogColorLegacy: vec3f,      // Legacy fog (unused)
        fogDensityLegacy: f32,
        fogParamsLegacy: vec4f,
        fogSettingsLegacy: vec4u,
        cloudShadowParams: vec4f,   // x=enabled, y=intensity, z=scale, w=speed
        cloudShadowParams2: vec4f,  // x=coverage, y=softness, z=windDirX, w=windDirZ
        fogColor: vec3f,            // Actual fog color
        fogDensity: f32,            // FogExp2 density
        fogParams: vec4f,           // x=near, y=far, z=type (0=linear,1=exp2), w=enabled
        fogSkyFalloff: f32,
        _fogPad1: f32,
        _fogPad2: f32,
        _fogPad3: f32,
        lights : array<Light, ${StandardMaterial.MAX_LIGHTS}>,
      }

      struct ShadowLight {
        viewProj: mat4x4<f32>,
        atlasLayer: u32,
        bias: f32,
        normalBias: f32,
        _pad: u32,
      }

      struct ShadowUniforms {
        lights: array<ShadowLight, 4>,
        shadowLightCount: u32,
        atlasResolution: f32,
        _pad: vec2<f32>,
      }

      struct ObjectData {
        modelMatrix : mat4x4<f32>,
        normalMatrix : mat4x4<f32>,
        aabbMin : vec3f,
        _pad1 : f32,
        aabbMax : vec3f,
        _pad2 : f32,
        prevModelMatrix : mat4x4<f32>,
        _pad3 : vec4<f32>, // Padding to 256 bytes
        _pad4 : vec4<f32>,
      }

      struct MaterialUniforms {
        albedo : vec3<f32>,
        roughness : f32,
        emissive : vec3<f32>,
        metallic : f32,
        opacity : f32,
        alphaCutoff : f32,
        displacementScale : f32,
        textureFlags : u32,
        alphaMode : u32,
        receiveShadows : f32,
        textureScale : vec2<f32>,  // UV tiling/repeat
        doubleSided : f32,         // Two-sided lighting flag
        ambientIntensity : f32,    // Per-material ambient multiplier (0-1)
        windEnabled : f32,         // Wind animation enabled
        windStrength : f32,        // Wind displacement strength
        windSpeed : f32,           // Wind animation speed
        windFrequency : f32,       // Wind wave frequency
        // Texture blending (for ground/terrain)
        blendMode : u32,           // 0=none, 1=noise
        useWorldSpaceUV : f32,     // Use world XZ for UVs
        worldSpaceUVScale : f32,   // World UV tiling scale
        blendNoiseScale : f32,     // Noise scale for blending
        blendPatchiness : f32,     // Blend threshold
        _blendPad1 : f32,          // Padding for alignment
        _blendPad2 : f32,
        _blendPad3 : f32,
      }

      @group(0) @binding(0) var<uniform> scene : SceneUniforms;
      @group(0) @binding(1) var<storage, read> objects : array<ObjectData>;
      @group(0) @binding(4) var shadowMap: texture_depth_2d_array;
      @group(0) @binding(5) var shadowSampler: sampler_comparison;
      @group(0) @binding(8) var<uniform> shadowUniforms: ShadowUniforms;
      @group(0) @binding(9) var pointShadowTex: texture_2d_array<f32>;
      @group(0) @binding(10) var pointShadowSamp: sampler;

      // Cascade Shadow Map uniforms for directional lights
      struct CascadeUniforms {
        viewProj: array<mat4x4<f32>, 4>,
        splits: vec4<f32>,
        biases: vec4<f32>,
      }
      @group(0) @binding(11) var<uniform> cascadeUniforms: CascadeUniforms;

      @group(1) @binding(0) var<uniform> material : MaterialUniforms;
      @group(1) @binding(1) var samp : sampler;
      @group(1) @binding(2) var albedoTex : texture_2d<f32>;
      @group(1) @binding(3) var normalTex : texture_2d<f32>;
      @group(1) @binding(4) var roughnessTex : texture_2d<f32>;
      @group(1) @binding(5) var metallicTex : texture_2d<f32>;
      @group(1) @binding(6) var emissiveTex : texture_2d<f32>;
      @group(1) @binding(7) var occlusionTex : texture_2d<f32>;
      @group(1) @binding(8) var displacementTex : texture_2d<f32>;
      @group(1) @binding(9) var blendAlbedoTex2 : texture_2d<f32>;   // Secondary albedo for blending
      @group(1) @binding(10) var blendNormalTex2 : texture_2d<f32>; // Secondary normal for blending

      struct VertexInput {
        @location(0) position : vec3<f32>,
        @location(1) normal : vec3<f32>,
        @location(2) uv : vec2<f32>,
      }

      struct VertexOutput {
        @builtin(position) position : vec4<f32>,
        @location(0) worldNormal : vec3<f32>,
        @location(1) uv : vec2<f32>,
        @location(2) worldPosition : vec3<f32>,
        @location(3) currentClip : vec4<f32>,
        @location(4) prevClip : vec4<f32>,
      }

      fn applyFog(color: vec3f, worldPos: vec3f) -> vec3f {
        // fogParams: x=near, y=far, z=type (0=linear, 1=exp2), w=enabled
        let fogEnabled = scene.fogParams.w;
        if (fogEnabled < 0.5) {
            return color;
        }

        // Calculate view-space Z depth (exactly like Three.js)
        // Three.js: vFogDepth = -mvPosition.z where mvPosition = modelViewMatrix * position
        let viewPos = scene.viewMatrix * vec4f(worldPos, 1.0);
        let fogDepth = -viewPos.z;  // Negate because camera looks down -Z in view space

        var fogFactor = 0.0;
        let fogType = scene.fogParams.z;

        if (fogType < 0.5) { // LINEAR (type 0)
            let near = scene.fogParams.x;
            let far = scene.fogParams.y;
            fogFactor = clamp((fogDepth - near) / (far - near), 0.0, 1.0);
        } else { // EXP2 (type 1)
            let density = scene.fogDensity;
            // FogExp2 formula exactly like Three.js
            fogFactor = 1.0 - exp(-density * density * fogDepth * fogDepth);
        }

        return mix(color, scene.fogColor, fogFactor);
      }

      // Get hemisphere light irradiance based on surface normal
      // Interpolates between ground and sky color based on how much the surface faces up
      fn getHemisphereLightIrradiance(skyColor: vec3f, groundColor: vec3f, normal: vec3f, direction: vec3f) -> vec3f {
          let dotNL = dot(normal, direction);
          let hemiDiffuseWeight = dotNL * 0.5 + 0.5;  // Remap [-1,1] to [0,1]
          return mix(groundColor, skyColor, hemiDiffuseWeight);
      }
    `;
    this.vertexShaderCode = `
      ${commonDefines}

      // Wind displacement function for foliage animation
      fn calculateWindDisplacement(worldPos: vec3f, time: f32, strength: f32, speed: f32, frequency: f32) -> vec3f {
        // Use world position for spatial variation
        let phase = worldPos.x * 0.1 + worldPos.z * 0.1;

        // Multi-frequency wind for more natural motion
        let wind1 = sin(time * speed + phase) * strength;
        let wind2 = sin(time * speed * 1.7 + phase * 1.3) * strength * 0.5;
        let wind3 = cos(time * speed * 0.5 + phase * 0.7) * strength * 0.3;

        // Combine into displacement vector (mostly horizontal movement)
        return vec3f(
          (wind1 + wind2) * frequency,
          wind3 * 0.2,  // Less vertical movement
          (wind1 - wind2 * 0.5) * frequency * 0.7
        );
      }

      @vertex
      fn vs_main(input : VertexInput, @builtin(instance_index) instanceIndex : u32) -> VertexOutput {
        var output : VertexOutput;

        let modelMatrix = objects[instanceIndex].modelMatrix;
        let normalMatrix = objects[instanceIndex].normalMatrix;
        let prevModelMatrix = objects[instanceIndex].prevModelMatrix;

        var localPos = input.position;

        // Apply wind displacement for foliage
        if (material.windEnabled > 0.5) {
          // Transform to world space first to get consistent wind across instances
          let tempWorldPos = modelMatrix * vec4<f32>(localPos, 1.0);

          // Height-based wind influence (base anchored, top moves most)
          // Uses localPos.y directly - assumes base at y=0, top at y>0
          let heightFactor = saturate(localPos.y);

          // Calculate wind displacement
          let windDisp = calculateWindDisplacement(
            tempWorldPos.xyz,
            scene.time,
            material.windStrength * heightFactor,
            material.windSpeed,
            material.windFrequency
          );

          // Apply displacement in world space, then transform back
          localPos = localPos + windDisp;
        }

        let worldPos = modelMatrix * vec4<f32>(localPos, 1.0);
        output.worldPosition = worldPos.xyz;

        let clipPos = scene.projectionMatrix * scene.viewMatrix * worldPos;
        output.position = clipPos;
        output.currentClip = clipPos;

        // Previous Frame Position (without wind for stable motion vectors)
        let prevWorldPos = prevModelMatrix * vec4<f32>(input.position, 1.0);
        output.prevClip = scene.prevViewProj * prevWorldPos;

        output.worldNormal = (normalMatrix * vec4<f32>(input.normal, 0.0)).xyz;
        output.uv = input.uv;
        return output;
      }
    `;
    this.fragmentShaderCode = `
      ${commonDefines}

      struct FragmentOutput {
        @location(0) albedo : vec4<f32>,   // RGB = Color, A = Roughness
        @location(1) normal : vec4<f32>,   // RGB = Normal, A = Metalness
        @location(2) position : vec4<f32>, // RGB = World Position, A = Occlusion
        @location(3) emissive : vec4<f32>, // RGB = Emissive, A = Unused
        @location(4) velocity : vec2<f32>, // RG = Velocity
      }

      const HAS_ALBEDO_MAP = 1u;
      const HAS_NORMAL_MAP = 2u;
      const HAS_ROUGHNESS_MAP = 4u;
      const HAS_METALLIC_MAP = 8u;
      const HAS_EMISSIVE_MAP = 16u;
      const HAS_OCCLUSION_MAP = 32u;
      const HAS_DISPLACEMENT_MAP = 64u;
      const HAS_BLEND_MAP_2 = 128u;
      const HAS_BLEND_NORMAL_2 = 256u;

      const BLEND_MODE_NONE = 0u;
      const BLEND_MODE_NOISE = 1u;

      // Simplex noise helper functions
      fn mod289_3(x: vec3f) -> vec3f {
        return x - floor(x * (1.0 / 289.0)) * 289.0;
      }

      fn mod289_2(x: vec2f) -> vec2f {
        return x - floor(x * (1.0 / 289.0)) * 289.0;
      }

      fn permute(x: vec3f) -> vec3f {
        return mod289_3(((x * 34.0) + 1.0) * x);
      }

      fn simplex2d(v: vec2f) -> f32 {
        let C = vec4f(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
        var i = floor(v + dot(v, C.yy));
        let x0 = v - i + dot(i, C.xx);
        var i1: vec2f;
        if (x0.x > x0.y) {
          i1 = vec2f(1.0, 0.0);
        } else {
          i1 = vec2f(0.0, 1.0);
        }
        var x12 = x0.xyxy + C.xxzz;
        x12 = vec4f(x12.xy - i1, x12.zw);

        i = mod289_2(i);
        let p = permute(permute(i.y + vec3f(0.0, i1.y, 1.0)) + i.x + vec3f(0.0, i1.x, 1.0));

        var m = max(vec3f(0.5) - vec3f(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), vec3f(0.0));
        m = m * m;
        m = m * m;

        let x = 2.0 * fract(p * C.www) - 1.0;
        let h = abs(x) - 0.5;
        let ox = floor(x + 0.5);
        let a0 = x - ox;

        m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);

        var g: vec3f;
        g.x = a0.x * x0.x + h.x * x0.y;
        g.y = a0.y * x12.x + h.y * x12.y;
        g.z = a0.z * x12.z + h.z * x12.w;
        return 130.0 * dot(m, g);
      }

      fn parallaxMapping(texCoords: vec2f, viewDir: vec3f) -> vec2f {
         // Parallax Occlusion Mapping (Simplified / Steep Parallax)
         
         // Safety check for grazing angles
         if (abs(viewDir.z) < 0.05) {
             return texCoords;
         }

         // Steep Parallax Mapping
         let numLayers = mix(32.0, 8.0, abs(dot(vec3f(0.0, 0.0, 1.0), viewDir)));
         let layerDepth = 1.0 / numLayers;
         var currentLayerDepth = 0.0;
         let P = viewDir.xy / viewDir.z * material.displacementScale;
         let deltaTexCoords = P / numLayers;
         
         var currentTexCoords = texCoords;
         var currentDepthMapValue = 1.0 - textureSampleLevel(displacementTex, samp, currentTexCoords, 0.0).r;
         
         // Loop limit safety
         var i = 0u;
         while(currentLayerDepth < currentDepthMapValue && i < 64u) {
            currentTexCoords -= deltaTexCoords;
            currentDepthMapValue = 1.0 - textureSampleLevel(displacementTex, samp, currentTexCoords, 0.0).r;
            currentLayerDepth += layerDepth;
            i++;
         }
         
         // Parallax Occlusion (Interpolation)
         let prevTexCoords = currentTexCoords + deltaTexCoords;
         let afterDepth = currentDepthMapValue - currentLayerDepth;
         let beforeDepth = (1.0 - textureSampleLevel(displacementTex, samp, prevTexCoords, 0.0).r) - currentLayerDepth + layerDepth;
         let weight = afterDepth / (afterDepth - beforeDepth);
         let finalTexCoords = prevTexCoords * weight + currentTexCoords * (1.0 - weight);
         
         return finalTexCoords;
      }

      @fragment
      fn fs_main(@location(0) worldNormal : vec3<f32>, @location(1) inUV : vec2<f32>, @location(2) worldPosition : vec3<f32>, @location(3) currentClip : vec4<f32>, @location(4) prevClip : vec4<f32>) -> FragmentOutput {
        var output : FragmentOutput;

        // Safe normalize to prevent NaN from zero-length or degenerate normals
        let normalLen = length(worldNormal);
        var N = select(vec3f(0.0, 1.0, 0.0), worldNormal / normalLen, normalLen > 0.0001);

        // Apply texture scale/tiling (matches THREE.js texture.repeat)
        // Or use world-space UVs for ground/terrain
        var uv: vec2f;
        if (material.useWorldSpaceUV > 0.5) {
          uv = worldPosition.xz / material.worldSpaceUVScale;
        } else {
          uv = inUV * material.textureScale;
        }

        // Velocity Calculation
        // TODO: Handle jitter removal for more accurate TAA
        let currentNDC = currentClip.xy / currentClip.w;
        let prevNDC = prevClip.xy / prevClip.w;
        let velocity = (currentNDC - prevNDC) * 0.5;
        // Invert Y to match Texture UV space (Y down)
        output.velocity = vec2<f32>(velocity.x, -velocity.y);

        // Calculate Tangent Space View Vector for Parallax Mapping
        // We need TBN matrix early if displacement is enabled
        let V_world = normalize(scene.cameraPosition - worldPosition);
        
        if ((material.textureFlags & HAS_DISPLACEMENT_MAP) != 0u) {
            let Q1 = dpdx(worldPosition);
            let Q2 = dpdy(worldPosition);
            let st1 = dpdx(uv);
            let st2 = dpdy(uv);
            let T = normalize(Q1 * st2.y - Q2 * st1.y);
            let B = -normalize(cross(N, T));
            let TBN = mat3x3f(T, B, N);
            
            let V_tangent = normalize(transpose(TBN) * V_world);
            
            // Check if V_tangent.z is positive (looking at surface)
            // If surface is backfacing relative to tangent plane, skip or clamp?
            // Usually not an issue with backface culling.
            
            uv = parallaxMapping(uv, V_tangent);
            
            // Discard if UV is out of bounds?
            if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
                // discard; // Optional: depends on wrapping mode
            }
        }

        var baseColor = material.albedo;
        var roughness = material.roughness;
        var metallic = material.metallic;
        var alpha = material.opacity;
        var emissive = vec3f(0.0);
        var occlusion = 1.0;

        // Calculate blend factor for noise-based texture blending (used for albedo and normal)
        var blendFactor = 0.0;
        if (material.blendMode == BLEND_MODE_NOISE) {
            let noiseVal = simplex2d(worldPosition.xz / material.blendNoiseScale);
            let normalizedNoise = noiseVal * 0.5 + 0.5; // Map from [-1,1] to [0,1]
            blendFactor = smoothstep(
                material.blendPatchiness - 0.1,
                material.blendPatchiness + 0.1,
                normalizedNoise
            );
        }

        // Albedo Map with optional blending
        if ((material.textureFlags & HAS_ALBEDO_MAP) != 0u) {
            let texColor1 = textureSample(albedoTex, samp, uv);
            var finalAlbedo = texColor1.rgb;
            var finalAlpha = texColor1.a;

            // Noise-based texture blending for ground/terrain
            if (material.blendMode == BLEND_MODE_NOISE && (material.textureFlags & HAS_BLEND_MAP_2) != 0u) {
                let texColor2 = textureSample(blendAlbedoTex2, samp, uv);
                finalAlbedo = mix(texColor1.rgb, texColor2.rgb, blendFactor);
                finalAlpha = mix(texColor1.a, texColor2.a, blendFactor);
            }

            baseColor = baseColor * finalAlbedo;
            alpha = alpha * finalAlpha;
        }

        // Alpha Masking
        if (material.alphaCutoff > 0.0 && alpha < material.alphaCutoff) {
            if (material.alphaMode == 1u) { // MASK
                discard;
            }
        }

        // Normal Map with optional blending
        if ((material.textureFlags & HAS_NORMAL_MAP) != 0u) {
          var rawNormal = textureSample(normalTex, samp, uv).xyz * 2.0 - 1.0;

          // Blend with secondary normal map if enabled
          if (material.blendMode == BLEND_MODE_NOISE && (material.textureFlags & HAS_BLEND_NORMAL_2) != 0u) {
              let rawNormal2 = textureSample(blendNormalTex2, samp, uv).xyz * 2.0 - 1.0;
              rawNormal = mix(rawNormal, rawNormal2, blendFactor);
          }

          let mapNormalLength = length(rawNormal);

          // Roughness Bias (Geometric AA)
          // If normal length is short, it means high variance (averaged out).
          // Increase roughness to prevent aliasing.
          let variance = clamp(1.0 - mapNormalLength, 0.0, 1.0);
          roughness = max(roughness, variance * 2.0);

          // Re-normalize for shading
          let mapNormal = rawNormal / max(mapNormalLength, 0.001);

          // Re-calculate TBN for the new UVs (gradients might have changed? strictly speaking yes)
          // But usually we can reuse or just re-compute.
          // Re-computing is safer for correctness with new UVs.
          let Q1 = dpdx(worldPosition);
          let Q2 = dpdy(worldPosition);
          let st1 = dpdx(uv);
          let st2 = dpdy(uv);
          let T = normalize(Q1 * st2.y - Q2 * st1.y);
          let B = -normalize(cross(N, T));
          let TBN = mat3x3f(T, B, N);
          N = normalize(TBN * mapNormal);
        }

        // Roughness Map
        if ((material.textureFlags & HAS_ROUGHNESS_MAP) != 0u) {
            roughness = textureSample(roughnessTex, samp, uv).g;
        }

        // Metallic Map
        if ((material.textureFlags & HAS_METALLIC_MAP) != 0u) {
            metallic = textureSample(metallicTex, samp, uv).b;
        }
        
        // Emissive Map
        if ((material.textureFlags & HAS_EMISSIVE_MAP) != 0u) {
             // Emissive texture is sRGB usually? Assuming linear here if loaded as such.
             // Multiply by emissive factor
             emissive = textureSample(emissiveTex, samp, uv).rgb * material.emissive;
        } else {
             emissive = material.emissive;
        }

        // Occlusion Map
        if ((material.textureFlags & HAS_OCCLUSION_MAP) != 0u) {
            occlusion = textureSample(occlusionTex, samp, uv).r;
        }

        output.albedo = vec4<f32>(baseColor, roughness);
        output.normal = vec4<f32>(N * 0.5 + 0.5, metallic);
        output.position = vec4<f32>(worldPosition, occlusion);
        output.emissive = vec4<f32>(emissive, material.ambientIntensity);  // alpha = ambient intensity multiplier
        output.velocity = vec2<f32>(0.0, 0.0); // Dummy velocity

        return output;
      }
    `;
    this.forwardFragmentShaderCode = `
      ${commonDefines}

      const PI = 3.14159265359;

      const HAS_ALBEDO_MAP = 1u;
      const HAS_NORMAL_MAP = 2u;
      const HAS_ROUGHNESS_MAP = 4u;
      const HAS_METALLIC_MAP = 8u;
      const HAS_EMISSIVE_MAP = 16u;
      const HAS_OCCLUSION_MAP = 32u;
      const HAS_BLEND_MAP_2 = 128u;
      const HAS_BLEND_NORMAL_2 = 256u;

      const BLEND_MODE_NONE = 0u;
      const BLEND_MODE_NOISE = 1u;

      // Simplex noise helper functions for texture blending
      fn mod289_3(x: vec3f) -> vec3f {
        return x - floor(x * (1.0 / 289.0)) * 289.0;
      }

      fn mod289_2(x: vec2f) -> vec2f {
        return x - floor(x * (1.0 / 289.0)) * 289.0;
      }

      fn permute(x: vec3f) -> vec3f {
        return mod289_3(((x * 34.0) + 1.0) * x);
      }

      fn simplex2d(v: vec2f) -> f32 {
        let C = vec4f(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
        var i = floor(v + dot(v, C.yy));
        let x0 = v - i + dot(i, C.xx);
        var i1: vec2f;
        if (x0.x > x0.y) {
          i1 = vec2f(1.0, 0.0);
        } else {
          i1 = vec2f(0.0, 1.0);
        }
        var x12 = x0.xyxy + C.xxzz;
        x12 = vec4f(x12.xy - i1, x12.zw);

        i = mod289_2(i);
        let p = permute(permute(i.y + vec3f(0.0, i1.y, 1.0)) + i.x + vec3f(0.0, i1.x, 1.0));

        var m = max(vec3f(0.5) - vec3f(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), vec3f(0.0));
        m = m * m;
        m = m * m;

        let x = 2.0 * fract(p * C.www) - 1.0;
        let h = abs(x) - 0.5;
        let ox = floor(x + 0.5);
        let a0 = x - ox;

        m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);

        var g: vec3f;
        g.x = a0.x * x0.x + h.x * x0.y;
        g.y = a0.y * x12.x + h.y * x12.y;
        g.z = a0.z * x12.z + h.z * x12.w;
        return 130.0 * dot(m, g);
      }

      // Simple hash-based noise for foliage normal variation
      fn hash31(p: vec3f) -> f32 {
          var p3 = fract(p * 0.1031);
          p3 += dot(p3, p3.yzx + 33.33);
          return fract((p3.x + p3.y) * p3.z);
      }

      fn hash33(p: vec3f) -> vec3f {
          var p3 = fract(p * vec3f(0.1031, 0.1030, 0.0973));
          p3 += dot(p3, p3.yxz + 33.33);
          return fract((p3.xxy + p3.yxx) * p3.zyx);
      }

      // Simple hash function for cloud shadow noise
      fn hash2(p: vec2f) -> f32 {
          let h = dot(p, vec2f(127.1, 311.7));
          return fract(sin(h) * 43758.5453);
      }

      // Value noise for cloud shadows
      fn noise2(p: vec2f) -> f32 {
          let i = floor(p);
          let f = fract(p);
          let u = f * f * (3.0 - 2.0 * f); // Smoothstep

          let a = hash2(i);
          let b = hash2(i + vec2f(1.0, 0.0));
          let c = hash2(i + vec2f(0.0, 1.0));
          let d = hash2(i + vec2f(1.0, 1.0));

          return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
      }

      // FBM (Fractal Brownian Motion) for cloud shadows
      fn fbmCloudShadow(pos: vec2f) -> f32 {
          var p = pos;
          var value = 0.0;
          var amplitude = 0.5;
          var frequency = 1.0;

          for (var i = 0; i < 5; i++) {
              value += amplitude * noise2(p * frequency);
              amplitude *= 0.5;
              frequency *= 2.0;
          }

          return value;
      }

      // Calculate cloud shadow factor based on world position
      fn getCloudShadow(worldPos: vec3f) -> f32 {
          let enabled = scene.cloudShadowParams.x;
          if (enabled < 0.5) {
              return 1.0; // No shadow when disabled
          }

          let intensity = scene.cloudShadowParams.y;
          let scale = scene.cloudShadowParams.z;
          let speed = scene.cloudShadowParams.w;
          let coverage = scene.cloudShadowParams2.x;
          let softness = scene.cloudShadowParams2.y;
          let windDirX = scene.cloudShadowParams2.z;
          let windDirZ = scene.cloudShadowParams2.w;

          // Calculate UV from world XZ position with wind animation
          let windOffset = vec2f(windDirX, windDirZ) * scene.time * speed;
          let uv = worldPos.xz * scale + windOffset;

          // Sample FBM noise
          let noise = fbmCloudShadow(uv);

          // Apply coverage threshold - higher coverage = more shadow
          let threshold = 1.0 - coverage;
          let cloudAmount = smoothstep(threshold - softness * 0.5, threshold + softness * 0.5, noise);

          // Return shadow factor: 1 = no shadow, (1-intensity) = max shadow
          return 1.0 - cloudAmount * intensity;
      }

      // Procedural normal variation for foliage (grass, leaves)
      // Creates subtle normal perturbations based on world position
      fn getFoliageNormalVariation(worldPos: vec3f, baseNormal: vec3f, strength: f32) -> vec3f {
          // Use world position to generate per-blade/leaf variation
          let noise = hash33(worldPos * 2.0) * 2.0 - 1.0;

          // Create tangent vectors for normal perturbation
          var tangent = vec3f(1.0, 0.0, 0.0);
          if (abs(baseNormal.x) > 0.9) {
              tangent = vec3f(0.0, 1.0, 0.0);
          }
          let bitangent = normalize(cross(baseNormal, tangent));
          tangent = normalize(cross(bitangent, baseNormal));

          // Apply noise-based perturbation (stronger horizontal, weaker vertical)
          let perturbedNormal = baseNormal
              + tangent * noise.x * strength * 0.6
              + bitangent * noise.z * strength * 0.6
              + baseNormal * noise.y * strength * 0.2;

          return normalize(perturbedNormal);
      }

      fn distributionGGX(N: vec3f, H: vec3f, roughness: f32) -> f32 {
        let a = roughness * roughness;
        let a2 = a * a;
        let NdotH = max(dot(N, H), 0.0);
        let NdotH2 = NdotH * NdotH;
        let num = a2;
        let denom = (NdotH2 * (a2 - 1.0) + 1.0);
        return num / (PI * denom * denom);
      }

      fn geometrySchlickGGX(NdotV: f32, roughness: f32) -> f32 {
        let r = (roughness + 1.0);
        let k = (r * r) / 8.0;
        let num = NdotV;
        let denom = NdotV * (1.0 - k) + k;
        return num / denom;
      }

      fn geometrySmith(N: vec3f, V: vec3f, L: vec3f, roughness: f32) -> f32 {
        let NdotV = max(dot(N, V), 0.0);
        let NdotL = max(dot(N, L), 0.0);
        let ggx2 = geometrySchlickGGX(NdotV, roughness);
        let ggx1 = geometrySchlickGGX(NdotL, roughness);
        return ggx1 * ggx2;
      }

      fn fresnelSchlick(cosTheta: f32, F0: vec3f) -> vec3f {
        return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
      }
      
      // Convert direction to cube face index and UV coordinates
      // Face order: 0=+X, 1=-X, 2=+Y, 3=-Y, 4=+Z, 5=-Z
      // Derived from lookAt view matrices: ze=eye-target, xe=up×ze, ye=ze×xe
      fn dirToCubeFaceUV(dir: vec3f) -> vec3f {
          let absDir = abs(dir);
          var faceIndex: f32;
          var uv: vec2f;

          if (absDir.x >= absDir.y && absDir.x >= absDir.z) {
              if (dir.x > 0.0) {
                  faceIndex = 0.0; // +X: xe=(0,0,-1), ye=(0,-1,0)
                  uv = vec2f(-dir.z, dir.y) / absDir.x;
              } else {
                  faceIndex = 1.0; // -X: xe=(0,0,1), ye=(0,-1,0)
                  uv = vec2f(dir.z, dir.y) / absDir.x;
              }
          } else if (absDir.y >= absDir.x && absDir.y >= absDir.z) {
              if (dir.y > 0.0) {
                  faceIndex = 2.0; // +Y: xe=(1,0,0), ye=(0,0,1)
                  uv = vec2f(dir.x, -dir.z) / absDir.y;
              } else {
                  faceIndex = 3.0; // -Y: xe=(1,0,0), ye=(0,0,-1)
                  uv = vec2f(dir.x, dir.z) / absDir.y;
              }
          } else {
              if (dir.z > 0.0) {
                  faceIndex = 4.0; // +Z: xe=(1,0,0), ye=(0,-1,0)
                  uv = vec2f(dir.x, dir.y) / absDir.z;
              } else {
                  faceIndex = 5.0; // -Z: xe=(-1,0,0), ye=(0,-1,0)
                  uv = vec2f(-dir.x, dir.y) / absDir.z;
              }
          }
          uv = uv * 0.5 + 0.5;
          return vec3f(uv, faceIndex);
      }

      fn samplePointShadow(shadowIndex: i32, worldPos: vec3f, lightPos: vec3f) -> f32 {
          let shadowsEnabled = (scene.flags & 1u) != 0u;

          let L = worldPos - lightPos;
          let dir = normalize(L);

          let far = 100.0;
          let currentDepth = length(L) / far;

          let faceUV = dirToCubeFaceUV(dir);
          let layerIndex = shadowIndex * 6 + i32(faceUV.z);

          let shadowDepth = textureSampleLevel(pointShadowTex, pointShadowSamp, faceUV.xy, layerIndex, 0.0).r;

          let bias = 0.005;
          let inShadow = select(0.0, 1.0, currentDepth - bias <= shadowDepth);

          return select(1.0, inShadow, shadowsEnabled);
      }

      // Interleaved Gradient Noise for randomizing sampling patterns per pixel
      fn interleavedGradientNoise(position: vec2f) -> f32 {
          return fract(52.9829189 * fract(dot(position, vec2f(0.06711056, 0.00583715))));
      }

      // Vogel disk sampling for uniform circular distribution
      fn vogelDiskSample(sampleIndex: i32, samplesCount: i32, phi: f32) -> vec2f {
          let goldenAngle = 2.399963229728653;
          let r = sqrt((f32(sampleIndex) + 0.5) / f32(samplesCount));
          let theta = f32(sampleIndex) * goldenAngle + phi;
          return vec2f(cos(theta), sin(theta)) * r;
      }

      // Sample shadow for a specific light using its shadow atlas layer
      fn sampleShadowForLight(shadowLightIdx: u32, worldPos: vec3f, N: vec3f, L: vec3f) -> f32 {
          if ((scene.flags & 1u) == 0u) {
              return 1.0;
          }
          if (shadowLightIdx >= shadowUniforms.shadowLightCount) {
              return 1.0;
          }

          let shadowLight = shadowUniforms.lights[shadowLightIdx];

          // Apply normal bias to prevent shadow acne
          let biasedWorldPos = worldPos + N * shadowLight.normalBias;

          // Project to light space
          let lightSpacePos = shadowLight.viewProj * vec4f(biasedWorldPos, 1.0);
          let projCoords = lightSpacePos.xyz / lightSpacePos.w;
          let uv = vec2f(projCoords.x, -projCoords.y) * 0.5 + 0.5;

          // Check bounds
          if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0 || projCoords.z < 0.0 || projCoords.z > 1.0) {
              return 1.0;
          }

          // Dynamic bias based on surface angle
          let angleBias = max(shadowLight.bias * (1.0 - dot(N, L)), shadowLight.bias * 0.1);
          let currentDepth = projCoords.z - angleBias;

          // PCF (Percentage Closer Filtering) with 3x3 kernel
          var visibility = 0.0;
          let oneOverSize = 1.0 / shadowUniforms.atlasResolution;
          let layer = i32(shadowLight.atlasLayer);

          for (var y = -1; y <= 1; y++) {
              for (var x = -1; x <= 1; x++) {
                  let offset = vec2f(f32(x), f32(y)) * oneOverSize;
                  visibility += textureSampleCompareLevel(
                      shadowMap, shadowSampler,
                      uv + offset, layer, currentDepth
                  );
              }
          }
          return visibility / 9.0;
      }

      // Sample a single cascade with noise-based PCF to eliminate moire patterns
      fn sampleCascadeWithNoise(cascade: u32, worldPos: vec3f, N: vec3f, fragCoord: vec2f) -> f32 {
        let viewProj = cascadeUniforms.viewProj[cascade];
        let bias = cascadeUniforms.biases[cascade];

        // Minimal normal bias
        let normalBias = 0.01;
        let biasedWorldPos = worldPos + N * normalBias;
        let lightSpacePos = viewProj * vec4f(biasedWorldPos, 1.0);
        let projCoords = lightSpacePos.xyz / lightSpacePos.w;
        let uv = vec2f(projCoords.x, -projCoords.y) * 0.5 + 0.5;

        if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0 || projCoords.z < 0.0 || projCoords.z > 1.0) {
            return 1.0;
        }

        let currentDepth = projCoords.z - bias;
        var visibility = 0.0;
        let oneOverSize = 1.0 / 2048.0;
        let layer = i32(cascade);

        // Scale filter size by cascade - larger cascades get larger filter
        let filterScale = 1.0 + f32(cascade) * 0.5;
        let filterRadius = oneOverSize * filterScale * 1.5;

        // Use IGN to rotate sampling pattern per pixel - eliminates moire
        let phi = interleavedGradientNoise(fragCoord) * 6.283185307;

        // 12 Vogel disk samples for smooth shadows
        let NUM_SAMPLES = 12;
        for (var i = 0; i < NUM_SAMPLES; i++) {
            let offset2D = vogelDiskSample(i, NUM_SAMPLES, phi) * filterRadius;
            visibility += textureSampleCompareLevel(
                shadowMap, shadowSampler,
                uv + offset2D, layer, currentDepth
            );
        }
        return visibility / f32(NUM_SAMPLES);
      }

      // Cascaded Shadow Map sampling with noise-based PCF and blending
      fn sampleCascadedShadowWithNoise(worldPos: vec3f, N: vec3f, viewMatrix: mat4x4<f32>, fragCoord: vec2f) -> f32 {
        if ((scene.flags & 1u) == 0u) {
            return 1.0;
        }

        let viewPos = viewMatrix * vec4f(worldPos, 1.0);
        let depth = -viewPos.z;

        var cascade = 3u;
        if (depth < cascadeUniforms.splits.x) {
            cascade = 0u;
        } else if (depth < cascadeUniforms.splits.y) {
            cascade = 1u;
        } else if (depth < cascadeUniforms.splits.z) {
            cascade = 2u;
        }

        let shadow1 = sampleCascadeWithNoise(cascade, worldPos, N, fragCoord);

        // Cascade blending at boundaries (last 25% of each cascade)
        if (cascade < 3u) {
            let splits = array<f32, 4>(
                cascadeUniforms.splits.x,
                cascadeUniforms.splits.y,
                cascadeUniforms.splits.z,
                cascadeUniforms.splits.w
            );
            let cascadeEnd = splits[cascade];
            let blendStart = cascadeEnd * 0.75; // Blend in last 25%

            if (depth > blendStart) {
                // Use smoothstep for a more gradual transition
                let t = (depth - blendStart) / (cascadeEnd - blendStart);
                let blendFactor = t * t * (3.0 - 2.0 * t); // smoothstep
                let shadow2 = sampleCascadeWithNoise(cascade + 1u, worldPos, N, fragCoord);
                return mix(shadow1, shadow2, blendFactor);
            }
        }

        return shadow1;
      }

      @fragment
      fn fs_main(@location(0) worldNormal : vec3f, @location(1) inUV : vec2f, @location(2) worldPosition : vec3f, @builtin(front_facing) frontFacing : bool, @builtin(position) fragCoord : vec4f) -> @location(0) vec4f {
        // Safe normalize to prevent NaN from zero-length or degenerate normals
        let normalLen = length(worldNormal);
        var N = select(vec3f(0.0, 1.0, 0.0), worldNormal / normalLen, normalLen > 0.0001);

        // For doubleSided materials: flip normal to face camera (like THREE.js DoubleSide)
        if (material.doubleSided > 0.5 && !frontFacing) {
          N = -N;
        }

        let V = normalize(scene.cameraPosition - worldPosition);

        // Apply texture scale/tiling (matches THREE.js texture.repeat)
        // Or use world-space UVs for ground/terrain
        var uv: vec2f;
        if (material.useWorldSpaceUV > 0.5) {
          uv = worldPosition.xz / material.worldSpaceUVScale;
        } else {
          uv = inUV * material.textureScale;
        }

        var baseColor = material.albedo;
        var alpha = material.opacity;
        var roughness = material.roughness;
        var metallic = material.metallic;
        var emissive = material.emissive;
        var occlusion = 1.0;

        // Calculate blend factor for noise-based texture blending (used for albedo and normal)
        var blendFactor = 0.0;
        if (material.blendMode == BLEND_MODE_NOISE) {
            let noiseVal = simplex2d(worldPosition.xz / material.blendNoiseScale);
            let normalizedNoise = noiseVal * 0.5 + 0.5; // Map from [-1,1] to [0,1]
            blendFactor = smoothstep(
                material.blendPatchiness - 0.1,
                material.blendPatchiness + 0.1,
                normalizedNoise
            );
        }

        // Albedo Map with optional blending
        if ((material.textureFlags & HAS_ALBEDO_MAP) != 0u) {
            let texColor1 = textureSample(albedoTex, samp, uv);
            var finalAlbedo = texColor1.rgb;
            var finalAlpha = texColor1.a;

            // Noise-based texture blending for ground/terrain
            if (material.blendMode == BLEND_MODE_NOISE && (material.textureFlags & HAS_BLEND_MAP_2) != 0u) {
                let texColor2 = textureSample(blendAlbedoTex2, samp, uv);
                finalAlbedo = mix(texColor1.rgb, texColor2.rgb, blendFactor);
                finalAlpha = mix(texColor1.a, texColor2.a, blendFactor);
            }

            baseColor = baseColor * finalAlbedo;
            alpha = alpha * finalAlpha;
        }

        // Normal Map with optional blending
        if ((material.textureFlags & HAS_NORMAL_MAP) != 0u) {
          var mapNormal = textureSample(normalTex, samp, uv).xyz * 2.0 - 1.0;

          // Blend with secondary normal map if enabled
          if (material.blendMode == BLEND_MODE_NOISE && (material.textureFlags & HAS_BLEND_NORMAL_2) != 0u) {
              let mapNormal2 = textureSample(blendNormalTex2, samp, uv).xyz * 2.0 - 1.0;
              mapNormal = mix(mapNormal, mapNormal2, blendFactor);
          }

          let Q1 = dpdx(worldPosition);
          let Q2 = dpdy(worldPosition);
          let st1 = dpdx(uv);
          let st2 = dpdy(uv);
          let T = normalize(Q1 * st2.y - Q2 * st1.y);
          let B = -normalize(cross(N, T));
          let TBN = mat3x3f(T, B, N);
          N = normalize(TBN * mapNormal);
        }

        // Foliage normal variation: Add procedural normal perturbation for wind-enabled materials
        // This creates lighting variation for grass/leaves that lack normal maps
        if (material.windEnabled > 0.5 && (material.textureFlags & HAS_NORMAL_MAP) == 0u) {
          // Strength based on wind strength - more wind = more normal variation
          let variationStrength = 0.3 + material.windStrength * 0.4;
          N = getFoliageNormalVariation(worldPosition, N, variationStrength);
        }

        // Roughness Map
        if ((material.textureFlags & HAS_ROUGHNESS_MAP) != 0u) {
            roughness = textureSample(roughnessTex, samp, uv).g;
        }

        // Metallic Map
        if ((material.textureFlags & HAS_METALLIC_MAP) != 0u) {
            metallic = textureSample(metallicTex, samp, uv).b;
        }

        // Emissive Map
        if ((material.textureFlags & HAS_EMISSIVE_MAP) != 0u) {
            emissive = textureSample(emissiveTex, samp, uv).rgb * material.emissive; // Multiply by factor
        }

        // Occlusion Map
        if ((material.textureFlags & HAS_OCCLUSION_MAP) != 0u) {
            occlusion = textureSample(occlusionTex, samp, uv).r;
        }
        
        // Alpha Test
        if (material.alphaCutoff > 0.0 && alpha < material.alphaCutoff) {
             if (material.alphaMode == 1u) { // MASK
                discard; 
             }
        }
        
        var F0 = vec3f(0.04);
        F0 = mix(F0, baseColor, metallic);

        // ===========================================
        // PHASE 1: Collect Ambient/Hemisphere Light
        // These lights add uniform illumination not based on direction
        // ===========================================
        var ambientIrradiance = vec3f(0.0);
        for (var i = 0u; i < scene.lightCount; i++) {
            let light = scene.lights[i];

            if (light.lightType == 3u) { // Ambient Light
                // Flat ambient - same everywhere regardless of normal
                ambientIrradiance += light.color * light.intensity;
            } else if (light.lightType == 4u) { // Hemisphere Light
                // Sky/ground interpolation based on surface normal
                // light.color = skyColor, light.attenuation = groundColor
                let hemiIrradiance = getHemisphereLightIrradiance(
                    light.color,
                    light.attenuation,  // groundColor stored in attenuation field
                    N,
                    light.direction     // up direction (usually 0,1,0)
                );
                ambientIrradiance += hemiIrradiance * light.intensity;
            }
        }

        // Add a small base ambient if no ambient lights exist
        if (length(ambientIrradiance) < 0.001) {
            ambientIrradiance = vec3f(0.03);  // Minimal fallback ambient
        }

        // ===========================================
        // PHASE 2: Direct Lighting with Shadows
        // Only Directional, Point, and Spot lights
        // ===========================================
        var Lo = vec3f(0.0);

        for (var i = 0u; i < scene.lightCount; i++) {
            let light = scene.lights[i];

            // Skip ambient and hemisphere lights (already processed above)
            if (light.lightType == 3u || light.lightType == 4u) {
                continue;
            }

            var L = vec3f(0.0);
            var attenuation = 1.0;
            var shadow = 1.0;

            if (light.lightType == 0u) { // Directional
                L = normalize(-light.direction);
            } else {
                let lightVec = light.position - worldPosition;
                let dist = length(lightVec);
                L = normalize(lightVec);
                attenuation = 1.0 / (1.0 + 0.09 * dist + 0.032 * dist * dist);
                if (light.lightType == 2u) { // Spot
                   let spotDir = normalize(-light.direction);
                   let angle = acos(dot(L, spotDir));
                   let inner = light.coneAngles.x;
                   let outer = light.coneAngles.y;
                   let spotEffect = 1.0 - smoothstep(inner, outer, angle);
                   attenuation *= spotEffect;
                }
            }

            // Sample shadow if this light has a valid shadow index
            if (light.shadowIndex >= 0) {
                if (light.lightType == 0u) { // Directional - use Cascaded Shadow Maps with noise-based PCF
                    shadow = sampleCascadedShadowWithNoise(worldPosition, N, scene.viewMatrix, fragCoord.xy);
                    // Apply shadow intensity - allows ambient to leak through
                    shadow = mix(1.0, shadow, light.shadowIntensity);
                    // Apply cloud shadows for directional lights
                    shadow *= getCloudShadow(worldPosition);
                } else if (light.lightType == 1u) { // Point
                    shadow = samplePointShadow(light.shadowIndex, worldPosition, light.position);
                    shadow = mix(1.0, shadow, light.shadowIntensity);
                } else { // Spot
                    shadow = sampleShadowForLight(u32(light.shadowIndex), worldPosition, N, L);
                    shadow = mix(1.0, shadow, light.shadowIntensity);
                }
            }

            let H = normalize(V + L);
            let radiance = light.color * light.intensity * attenuation * shadow;

            let NDF = distributionGGX(N, H, roughness);
            let G = geometrySmith(N, V, L, roughness);
            let F = fresnelSchlick(max(dot(H, V), 0.0), F0);

            let numerator = NDF * G * F;

            // Standard NdotV/NdotL - normal was already flipped for back faces if doubleSided
            let NdotV = max(dot(N, V), 0.0);
            let NdotL = max(dot(N, L), 0.0);

            let denominator = 4.0 * NdotV * NdotL + 0.0001;
            let specular = numerator / denominator;

            let kS = F;
            var kD = vec3f(1.0) - kS;
            kD *= 1.0 - metallic;

            Lo += (kD * baseColor / PI + specular) * radiance * NdotL;
        }

        // Combine ambient irradiance with base color, occlusion, and per-material intensity
        let ambient = ambientIrradiance * baseColor * occlusion * material.ambientIntensity;
        var color = ambient + Lo + emissive;

        // Apply Fog
        color = applyFog(color, worldPosition);

        // Output linear color - ToneMappingPass handles gamma correction
        return vec4f(color, alpha);
      }
    `;
  }
  getRenderingPath() {
    if (this.alphaMode === "BLEND" || this.alphaMode === "MASK" || this.doubleSided) {
      return "forward";
    }
    return "deferred";
  }
  getTextureFlags() {
    let flags = 0;
    if (this.albedoMap)
      flags |= 1;
    if (this.normalMap)
      flags |= 2;
    if (this.roughnessMap)
      flags |= 4;
    if (this.metallicMap)
      flags |= 8;
    if (this.emissiveMap)
      flags |= 16;
    if (this.occlusionMap)
      flags |= 32;
    if (this.displacementMap)
      flags |= 64;
    if (this.blendMap2)
      flags |= 128;
    if (this.blendNormalMap2)
      flags |= 256;
    return flags;
  }
  getInstancedVertexShader(pass) {
    return `
      struct Light {
        position: vec3f,
        _pad1: f32,
        direction: vec3f,
        _pad2: f32,
        color: vec3f,
        intensity: f32,
        attenuation: vec3f,
        lightType: u32,
        coneAngles: vec2f,
        shadowIndex: i32,
        shadowRadius: f32,
        shadowIntensity: f32,
        _pad3: f32,
        _pad4: f32,
        _pad5: f32,
      }

      struct SceneUniforms {
        viewMatrix : mat4x4<f32>,
        projectionMatrix : mat4x4<f32>,
        lightViewProj : mat4x4<f32>,
        prevViewProj : mat4x4<f32>,
        inverseProjectionMatrix : mat4x4<f32>,
        cameraPosition : vec3f,
        time : f32,
        lightCount : u32,
        debugMode : u32,
        flags : u32,
        environmentIntensity : f32,
        fogColorLegacy: vec3f,
        fogDensityLegacy: f32,
        fogParamsLegacy: vec4f,
        fogSettingsLegacy: vec4u,
        cloudShadowParams: vec4f,
        cloudShadowParams2: vec4f,
        fogColor: vec3f,
        fogDensity: f32,
        fogParams: vec4f,
        fogSkyFalloff: f32,
        _fogPad1: f32,
        _fogPad2: f32,
        _fogPad3: f32,
        lights : array<Light, ${StandardMaterial.MAX_LIGHTS}>,
      }

      struct MaterialUniforms {
        albedo : vec3<f32>,
        roughness : f32,
        emissive : vec3<f32>,
        metallic : f32,
        opacity : f32,
        alphaCutoff : f32,
        displacementScale : f32,
        textureFlags : u32,
        alphaMode : u32,
        receiveShadows : f32,
        textureScale : vec2<f32>,
        doubleSided : f32,
        ambientIntensity : f32,
        windEnabled : f32,
        windStrength : f32,
        windSpeed : f32,
        windFrequency : f32,
        blendMode : u32,
        useWorldSpaceUV : f32,
        worldSpaceUVScale : f32,
        blendNoiseScale : f32,
        blendPatchiness : f32,
        _blendPad1 : f32,
        _blendPad2 : f32,
        _blendPad3 : f32,
      }

      @group(0) @binding(0) var<uniform> scene : SceneUniforms;
      @group(1) @binding(0) var<uniform> material : MaterialUniforms;

      // Per-vertex attributes
      struct VertexInput {
        @location(0) position : vec3<f32>,
        @location(1) normal : vec3<f32>,
        @location(2) uv : vec2<f32>,
        // Per-instance attributes
        @location(3) instancePosRot : vec4<f32>,  // position.xyz, rotation
        @location(4) instanceScale : vec4<f32>,   // scale.xyz, unused
        @location(5) instanceColor : vec4<f32>,   // color.rgb, unused
      }

      struct VertexOutput {
        @builtin(position) position : vec4<f32>,
        @location(0) worldNormal : vec3<f32>,
        @location(1) uv : vec2<f32>,
        @location(2) worldPosition : vec3<f32>,
        @location(3) instanceColor : vec3<f32>,  // Pass color to fragment shader
      }

      // Wind displacement function for foliage animation
      fn calculateWindDisplacement(worldPos: vec3f, time: f32, strength: f32, speed: f32, frequency: f32) -> vec3f {
        let phase = worldPos.x * 0.1 + worldPos.z * 0.1;
        let wind1 = sin(time * speed + phase) * strength;
        let wind2 = sin(time * speed * 1.7 + phase * 1.3) * strength * 0.5;
        let wind3 = cos(time * speed * 0.5 + phase * 0.7) * strength * 0.3;
        return vec3f(
          (wind1 + wind2) * frequency,
          wind3 * 0.2,
          (wind1 - wind2 * 0.5) * frequency * 0.7
        );
      }

      @vertex
      fn vs_main(input : VertexInput) -> VertexOutput {
        var output : VertexOutput;

        // Extract instance data
        let instancePos = input.instancePosRot.xyz;
        let rotationY = input.instancePosRot.w;
        let scale = input.instanceScale.xyz;
        let color = input.instanceColor.rgb;

        // Build Y-axis rotation matrix
        let cosR = cos(rotationY);
        let sinR = sin(rotationY);
        let rotMat = mat3x3f(
          vec3f(cosR, 0.0, sinR),
          vec3f(0.0, 1.0, 0.0),
          vec3f(-sinR, 0.0, cosR)
        );

        // Apply scale
        var localPos = input.position * scale;

        // Apply wind displacement for foliage (based on local Y position)
        if (material.windEnabled > 0.5) {
          // Use instance position for wind phase variation
          let tempWorldPos = rotMat * localPos + instancePos;
          let heightFactor = saturate(input.position.y * scale.y / max(scale.y, 0.001));

          let windDisp = calculateWindDisplacement(
            tempWorldPos,
            scene.time,
            material.windStrength * heightFactor,
            material.windSpeed,
            material.windFrequency
          );

          localPos = localPos + windDisp;
        }

        // Apply rotation and translation
        let worldPos = rotMat * localPos + instancePos;
        output.worldPosition = worldPos;

        let clipPos = scene.projectionMatrix * scene.viewMatrix * vec4f(worldPos, 1.0);
        output.position = clipPos;

        // Transform normal with rotation
        output.worldNormal = rotMat * input.normal;
        output.uv = input.uv;
        output.instanceColor = color;

        return output;
      }
    `;
  }
  getInstancedFragmentShader(pass) {
    if (pass === "forward") {
      return this.getInstancedForwardFragmentShader();
    }
    return this.getInstancedDeferredFragmentShader();
  }
  getInstancedDeferredFragmentShader() {
    return `
      struct Light {
        position: vec3f,
        _pad1: f32,
        direction: vec3f,
        _pad2: f32,
        color: vec3f,
        intensity: f32,
        attenuation: vec3f,
        lightType: u32,
        coneAngles: vec2f,
        shadowIndex: i32,
        shadowRadius: f32,
        shadowIntensity: f32,
        _pad3: f32,
        _pad4: f32,
        _pad5: f32,
      }

      struct SceneUniforms {
        viewMatrix : mat4x4<f32>,
        projectionMatrix : mat4x4<f32>,
        lightViewProj : mat4x4<f32>,
        prevViewProj : mat4x4<f32>,
        inverseProjectionMatrix : mat4x4<f32>,
        cameraPosition : vec3f,
        time : f32,
        lightCount : u32,
        debugMode : u32,
        flags : u32,
        environmentIntensity : f32,
        fogColorLegacy: vec3f,
        fogDensityLegacy: f32,
        fogParamsLegacy: vec4f,
        fogSettingsLegacy: vec4u,
        cloudShadowParams: vec4f,
        cloudShadowParams2: vec4f,
        fogColor: vec3f,
        fogDensity: f32,
        fogParams: vec4f,
        fogSkyFalloff: f32,
        _fogPad1: f32,
        _fogPad2: f32,
        _fogPad3: f32,
        lights : array<Light, ${StandardMaterial.MAX_LIGHTS}>,
      }

      struct MaterialUniforms {
        albedo : vec3<f32>,
        roughness : f32,
        emissive : vec3<f32>,
        metallic : f32,
        opacity : f32,
        alphaCutoff : f32,
        displacementScale : f32,
        textureFlags : u32,
        alphaMode : u32,
        receiveShadows : f32,
        textureScale : vec2<f32>,
        doubleSided : f32,
        ambientIntensity : f32,
        windEnabled : f32,
        windStrength : f32,
        windSpeed : f32,
        windFrequency : f32,
        blendMode : u32,
        useWorldSpaceUV : f32,
        worldSpaceUVScale : f32,
        blendNoiseScale : f32,
        blendPatchiness : f32,
        _blendPad1 : f32,
        _blendPad2 : f32,
        _blendPad3 : f32,
      }

      @group(0) @binding(0) var<uniform> scene : SceneUniforms;
      @group(1) @binding(0) var<uniform> material : MaterialUniforms;
      @group(1) @binding(1) var samp : sampler;
      @group(1) @binding(2) var albedoTex : texture_2d<f32>;

      struct FragmentOutput {
        @location(0) albedo : vec4<f32>,   // RGB = Color, A = Roughness
        @location(1) normal : vec4<f32>,   // RGB = Normal, A = Metalness
        @location(2) position : vec4<f32>, // RGB = World Position, A = Occlusion
        @location(3) emissive : vec4<f32>, // RGB = Emissive, A = Ambient Intensity
        @location(4) velocity : vec2<f32>, // RG = Velocity (unused for instanced)
      }

      const HAS_ALBEDO_MAP = 1u;

      @fragment
      fn fs_main(
        @builtin(front_facing) frontFacing : bool,
        @location(0) worldNormal : vec3<f32>,
        @location(1) inUV : vec2<f32>,
        @location(2) worldPosition : vec3<f32>,
        @location(3) instanceColor : vec3<f32>
      ) -> FragmentOutput {
        var output : FragmentOutput;

        // Safe normalize
        let normalLen = length(worldNormal);
        var N = select(vec3f(0.0, 1.0, 0.0), worldNormal / normalLen, normalLen > 0.0001);

        // Two-sided lighting: flip normal for back faces
        if (material.doubleSided > 0.5 && !frontFacing) {
          N = -N;
        }

        // Apply texture scale
        var uv: vec2f;
        if (material.useWorldSpaceUV > 0.5) {
          uv = worldPosition.xz / material.worldSpaceUVScale;
        } else {
          uv = inUV * material.textureScale;
        }

        var baseColor = material.albedo;
        var alpha = material.opacity;

        // Sample albedo texture if available
        if ((material.textureFlags & HAS_ALBEDO_MAP) != 0u) {
          let texColor = textureSample(albedoTex, samp, uv);
          baseColor = baseColor * texColor.rgb;
          alpha = alpha * texColor.a;
        }

        // Apply instance color tint
        baseColor = baseColor * instanceColor;

        // Alpha test
        if (material.alphaCutoff > 0.0 && alpha < material.alphaCutoff) {
          if (material.alphaMode == 1u) { // MASK
            discard;
          }
        }

        let roughness = material.roughness;
        let metallic = material.metallic;
        let occlusion = 1.0;
        let emissive = material.emissive;

        output.albedo = vec4f(baseColor, roughness);
        output.normal = vec4f(N * 0.5 + 0.5, metallic);
        output.position = vec4f(worldPosition, occlusion);
        output.emissive = vec4f(emissive, material.ambientIntensity);
        output.velocity = vec2f(0.0, 0.0);

        return output;
      }
    `;
  }
  getInstancedForwardFragmentShader() {
    return `
      struct Light {
        position: vec3f,
        _pad1: f32,
        direction: vec3f,
        _pad2: f32,
        color: vec3f,
        intensity: f32,
        attenuation: vec3f,
        lightType: u32,
        coneAngles: vec2f,
        shadowIndex: i32,
        shadowRadius: f32,
        shadowIntensity: f32,
        _pad3: f32,
        _pad4: f32,
        _pad5: f32,
      }

      struct SceneUniforms {
        viewMatrix : mat4x4<f32>,
        projectionMatrix : mat4x4<f32>,
        lightViewProj : mat4x4<f32>,
        prevViewProj : mat4x4<f32>,
        inverseProjectionMatrix : mat4x4<f32>,
        cameraPosition : vec3f,
        time : f32,
        lightCount : u32,
        debugMode : u32,
        flags : u32,
        environmentIntensity : f32,
        fogColorLegacy: vec3f,
        fogDensityLegacy: f32,
        fogParamsLegacy: vec4f,
        fogSettingsLegacy: vec4u,
        cloudShadowParams: vec4f,
        cloudShadowParams2: vec4f,
        fogColor: vec3f,
        fogDensity: f32,
        fogParams: vec4f,
        fogSkyFalloff: f32,
        _fogPad1: f32,
        _fogPad2: f32,
        _fogPad3: f32,
        lights : array<Light, ${StandardMaterial.MAX_LIGHTS}>,
      }

      struct MaterialUniforms {
        albedo : vec3<f32>,
        roughness : f32,
        emissive : vec3<f32>,
        metallic : f32,
        opacity : f32,
        alphaCutoff : f32,
        displacementScale : f32,
        textureFlags : u32,
        alphaMode : u32,
        receiveShadows : f32,
        textureScale : vec2<f32>,
        doubleSided : f32,
        ambientIntensity : f32,
        windEnabled : f32,
        windStrength : f32,
        windSpeed : f32,
        windFrequency : f32,
        blendMode : u32,
        useWorldSpaceUV : f32,
        worldSpaceUVScale : f32,
        blendNoiseScale : f32,
        blendPatchiness : f32,
        _blendPad1 : f32,
        _blendPad2 : f32,
        _blendPad3 : f32,
      }

      @group(0) @binding(0) var<uniform> scene : SceneUniforms;
      @group(1) @binding(0) var<uniform> material : MaterialUniforms;
      @group(1) @binding(1) var samp : sampler;
      @group(1) @binding(2) var albedoTex : texture_2d<f32>;

      const PI = 3.14159265359;
      const HAS_ALBEDO_MAP = 1u;

      fn applyFog(color: vec3f, worldPos: vec3f) -> vec3f {
        let fogEnabled = scene.fogParams.w;
        if (fogEnabled < 0.5) {
          return color;
        }
        let viewPos = scene.viewMatrix * vec4f(worldPos, 1.0);
        let fogDepth = -viewPos.z;
        var fogFactor = 0.0;
        let fogType = scene.fogParams.z;
        if (fogType < 0.5) {
          let near = scene.fogParams.x;
          let far = scene.fogParams.y;
          fogFactor = clamp((fogDepth - near) / (far - near), 0.0, 1.0);
        } else {
          let density = scene.fogDensity;
          fogFactor = 1.0 - exp(-density * density * fogDepth * fogDepth);
        }
        return mix(color, scene.fogColor, fogFactor);
      }

      fn getHemisphereLightIrradiance(skyColor: vec3f, groundColor: vec3f, normal: vec3f, direction: vec3f) -> vec3f {
        let dotNL = dot(normal, direction);
        let hemiDiffuseWeight = dotNL * 0.5 + 0.5;
        return mix(groundColor, skyColor, hemiDiffuseWeight);
      }

      @fragment
      fn fs_main(
        @builtin(front_facing) frontFacing : bool,
        @location(0) worldNormal : vec3<f32>,
        @location(1) inUV : vec2<f32>,
        @location(2) worldPosition : vec3<f32>,
        @location(3) instanceColor : vec3<f32>
      ) -> @location(0) vec4f {
        // Safe normalize
        let normalLen = length(worldNormal);
        var N = select(vec3f(0.0, 1.0, 0.0), worldNormal / normalLen, normalLen > 0.0001);

        // Two-sided lighting
        if (material.doubleSided > 0.5 && !frontFacing) {
          N = -N;
        }

        let V = normalize(scene.cameraPosition - worldPosition);

        // Apply texture scale
        var uv: vec2f;
        if (material.useWorldSpaceUV > 0.5) {
          uv = worldPosition.xz / material.worldSpaceUVScale;
        } else {
          uv = inUV * material.textureScale;
        }

        var baseColor = material.albedo;
        var alpha = material.opacity;

        // Sample albedo texture
        if ((material.textureFlags & HAS_ALBEDO_MAP) != 0u) {
          let texColor = textureSample(albedoTex, samp, uv);
          baseColor = baseColor * texColor.rgb;
          alpha = alpha * texColor.a;
        }

        // Apply instance color tint
        baseColor = baseColor * instanceColor;

        // Alpha test
        if (material.alphaCutoff > 0.0 && alpha < material.alphaCutoff) {
          if (material.alphaMode == 1u) {
            discard;
          }
        }

        let roughness = material.roughness;
        let metallic = material.metallic;
        let emissive = material.emissive;
        let occlusion = 1.0;

        var F0 = vec3f(0.04);
        F0 = mix(F0, baseColor, metallic);

        // Ambient lighting
        var ambientIrradiance = vec3f(0.0);
        for (var i = 0u; i < scene.lightCount; i++) {
          let light = scene.lights[i];
          if (light.lightType == 3u) { // Ambient
            ambientIrradiance += light.color * light.intensity;
          } else if (light.lightType == 4u) { // Hemisphere
            let hemiIrradiance = getHemisphereLightIrradiance(
              light.color, light.attenuation, N, light.direction
            );
            ambientIrradiance += hemiIrradiance * light.intensity;
          }
        }
        if (length(ambientIrradiance) < 0.001) {
          ambientIrradiance = vec3f(0.03);
        }

        // Direct lighting (simplified - full version has shadow sampling)
        var Lo = vec3f(0.0);
        for (var i = 0u; i < scene.lightCount; i++) {
          let light = scene.lights[i];
          if (light.lightType == 3u || light.lightType == 4u) {
            continue;
          }

          var L = vec3f(0.0);
          var attenuation = 1.0;

          if (light.lightType == 0u) { // Directional
            L = normalize(-light.direction);
          } else {
            let lightVec = light.position - worldPosition;
            let dist = length(lightVec);
            L = normalize(lightVec);
            attenuation = 1.0 / (1.0 + 0.09 * dist + 0.032 * dist * dist);
          }

          let NdotL = max(dot(N, L), 0.0);
          let radiance = light.color * light.intensity * attenuation;

          // Simple Lambertian diffuse
          Lo += baseColor / PI * radiance * NdotL;
        }

        let ambient = ambientIrradiance * baseColor * occlusion * material.ambientIntensity;
        var color = ambient + Lo + emissive;

        color = applyFog(color, worldPosition);

        return vec4f(color, alpha);
      }
    `;
  }
  getVertexShader(pass, options) {
    const includeVelocity = options?.includeVelocity ?? true;
    if (includeVelocity) {
      return this.vertexShaderCode;
    }
    return this.vertexShaderCode.replace("@location(4) prevClip : vec4<f32>,", "").replace(/let prevWorldPos = prevModelMatrix \* vec4<f32>\(input\.position, 1\.0\);\s*output\.prevClip = scene\.prevViewProj \* prevWorldPos;/g, "");
  }
  getFragmentShader(pass, options) {
    if (pass === "forward") {
      return this.forwardFragmentShaderCode;
    }
    const includeVelocity = options?.includeVelocity ?? true;
    if (includeVelocity) {
      return this.fragmentShaderCode;
    }
    return this.fragmentShaderCode.replace("@location(4) velocity : vec2<f32>, // RG = Velocity", "").replace(/, @location\(4\) prevClip : vec4<f32>\)/g, ")").replace(/\/\/ Velocity Calculation[\s\S]*?output\.velocity = vec2<f32>\(velocity\.x, -velocity\.y\);/g, "").replace(/output\.velocity = vec2<f32>\(0\.0, 0\.0\); \/\/ Dummy velocity/g, "");
  }
  getUniformBufferSize() {
    return 128;
  }
  updateUniforms(device, buffer, offset, context) {
    const arrayBuffer = new ArrayBuffer(this.getUniformBufferSize());
    const floatView = new Float32Array(arrayBuffer);
    const uintView = new Uint32Array(arrayBuffer);
    let i = 0;
    floatView[i++] = this.albedo.x;
    floatView[i++] = this.albedo.y;
    floatView[i++] = this.albedo.z;
    floatView[i++] = this.roughness;
    floatView[i++] = this.emissive.x;
    floatView[i++] = this.emissive.y;
    floatView[i++] = this.emissive.z;
    floatView[i++] = this.metallic;
    floatView[i++] = this.opacity;
    floatView[i++] = this.alphaCutoff;
    floatView[i++] = this.displacementScale;
    uintView[i++] = this.getTextureFlags();
    uintView[i++] = this.alphaMode === "OPAQUE" ? 0 : this.alphaMode === "MASK" ? 1 : 2;
    floatView[i++] = this.receiveShadows ? 1 : 0;
    floatView[i++] = this.textureScale.x;
    floatView[i++] = this.textureScale.y;
    floatView[i++] = this.doubleSided ? 1 : 0;
    floatView[i++] = this.ambientIntensity;
    floatView[i++] = this.windEnabled ? 1 : 0;
    floatView[i++] = this.windStrength;
    floatView[i++] = this.windSpeed;
    floatView[i++] = this.windFrequency;
    uintView[i++] = this.blendMode === "none" ? 0 : 1;
    floatView[i++] = this.useWorldSpaceUV ? 1 : 0;
    floatView[i++] = this.worldSpaceUVScale;
    floatView[i++] = this.blendNoiseScale;
    floatView[i++] = this.blendPatchiness;
    floatView[i++] = 0;
    floatView[i++] = 0;
    floatView[i++] = 0;
    device.queue.writeBuffer(buffer, offset, arrayBuffer);
  }
  getBindGroupEntries(device, uniformBuffer) {
    const defaultTex = Texture.getDefault(device);
    return [
      { binding: 0, resource: { buffer: uniformBuffer } },
      { binding: 1, resource: this.albedoMap?.sampler || defaultTex.sampler },
      { binding: 2, resource: this.albedoMap?.view || defaultTex.view },
      { binding: 3, resource: this.normalMap?.view || defaultTex.view },
      { binding: 4, resource: this.roughnessMap?.view || defaultTex.view },
      { binding: 5, resource: this.metallicMap?.view || defaultTex.view },
      { binding: 6, resource: this.emissiveMap?.view || defaultTex.view },
      { binding: 7, resource: this.occlusionMap?.view || defaultTex.view },
      { binding: 8, resource: this.displacementMap?.view || defaultTex.view },
      { binding: 9, resource: this.blendMap2?.view || defaultTex.view },
      { binding: 10, resource: this.blendNormalMap2?.view || defaultTex.view }
    ];
  }
  createBindGroupLayout(device) {
    return device.createBindGroupLayout({
      label: "StandardMaterial Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX, buffer: { type: "uniform" } },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "filtering" } },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 3, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 4, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 5, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 6, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 7, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 8, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 9, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 10, visibility: GPUShaderStage.FRAGMENT, texture: {} }
      ]
    });
  }
}

// ../../src/core/materials/TerrainMaterial.ts
var DEFAULT_TERRAIN_LAYER = {
  albedo: new Vector3(0.5, 0.5, 0.5),
  roughness: 0.8,
  metallic: 0,
  tilingScale: 10,
  displacementScale: 0
};

class TerrainMaterial extends Material {
  splatmap = null;
  layers = [];
  triplanarEnabled = true;
  triplanarSharpness = 4;
  triplanarBlendThreshold = 0.7;
  heightBlendSharpness = 0.5;
  macroVariationScale = 0.02;
  macroVariationStrength = 0.15;
  tilingReductionEnabled = false;
  detailFadeStart = 50;
  detailFadeEnd = 200;
  uvOffsetNoiseScale = 0.05;
  uvOffsetNoiseStrength = 0.1;
  debugMode = 0;
  morphingEnabled = false;
  morphFactor = 0;
  static MAX_LIGHTS = 8;
  forwardFragmentShaderCode;
  constructor() {
    super();
    for (let i = 0;i < 4; i++) {
      this.layers.push({ ...DEFAULT_TERRAIN_LAYER, albedo: DEFAULT_TERRAIN_LAYER.albedo.clone() });
    }
    this.layers[0].albedo = new Vector3(0.15, 0.35, 0.08);
    this.layers[0].roughness = 0.9;
    this.layers[0].tilingScale = 15;
    this.layers[1].albedo = new Vector3(0.45, 0.35, 0.2);
    this.layers[1].roughness = 0.85;
    this.layers[1].tilingScale = 12;
    this.layers[2].albedo = new Vector3(0.35, 0.32, 0.3);
    this.layers[2].roughness = 0.75;
    this.layers[2].tilingScale = 8;
    this.layers[2].displacementScale = 0.05;
    this.layers[3].albedo = new Vector3(0.9, 0.92, 0.95);
    this.layers[3].roughness = 0.6;
    this.layers[3].tilingScale = 20;
    const commonDefines = this.getCommonShaderDefines();
    this.vertexShaderCode = this.buildVertexShader(commonDefines);
    this.fragmentShaderCode = this.buildDeferredFragmentShader(commonDefines);
    this.forwardFragmentShaderCode = this.buildForwardFragmentShader(commonDefines);
  }
  setSplatmap(splatmap, device) {
    if (splatmap instanceof Texture) {
      this.splatmap = splatmap;
    } else if (splatmap && device) {
      this.splatmap = Texture.fromGPUTexture(device, splatmap, "Terrain Splatmap");
    } else if (splatmap) {
      console.warn("TerrainMaterial.setSplatmap: GPUTexture passed without device parameter. Splatmap will not work correctly.");
      this.splatmap = null;
    } else {
      this.splatmap = null;
    }
  }
  setLayer(index, config) {
    if (index < 0 || index >= 4)
      return;
    const layer = this.layers[index];
    if (config.albedoMap !== undefined)
      layer.albedoMap = config.albedoMap;
    if (config.normalMap !== undefined)
      layer.normalMap = config.normalMap;
    if (config.roughnessMap !== undefined)
      layer.roughnessMap = config.roughnessMap;
    if (config.albedo !== undefined)
      layer.albedo = config.albedo;
    if (config.roughness !== undefined)
      layer.roughness = config.roughness;
    if (config.metallic !== undefined)
      layer.metallic = config.metallic;
    if (config.tilingScale !== undefined)
      layer.tilingScale = config.tilingScale;
    if (config.displacementScale !== undefined)
      layer.displacementScale = config.displacementScale;
  }
  getLayer(index) {
    if (index < 0 || index >= 4)
      return null;
    return this.layers[index];
  }
  getRenderingPath() {
    return "deferred";
  }
  getCommonShaderDefines() {
    return `
      struct Light {
        position: vec3f,
        _pad1: f32,
        direction: vec3f,
        _pad2: f32,
        color: vec3f,
        intensity: f32,
        attenuation: vec3f,
        lightType: u32,
        coneAngles: vec2f,
        shadowIndex: i32,
        shadowRadius: f32,
        shadowIntensity: f32,
        _pad3: f32,
        _pad4: f32,
        _pad5: f32,
      }

      struct SceneUniforms {
        viewMatrix : mat4x4<f32>,
        projectionMatrix : mat4x4<f32>,
        lightViewProj : mat4x4<f32>,
        prevViewProj : mat4x4<f32>,
        inverseProjectionMatrix : mat4x4<f32>,
        cameraPosition : vec3f,
        time : f32,
        lightCount : u32,
        debugMode : u32,
        flags : u32,
        environmentIntensity : f32,
        fogColor: vec3f,
        fogDensity: f32,
        fogParams: vec4f,
        fogSettings: vec4u,
        lights : array<Light, ${TerrainMaterial.MAX_LIGHTS}>,
      }

      struct ObjectData {
        modelMatrix : mat4x4<f32>,
        normalMatrix : mat4x4<f32>,
        aabbMin : vec3f,
        _pad1 : f32,
        aabbMax : vec3f,
        _pad2 : f32,
        prevModelMatrix : mat4x4<f32>,
        _pad3 : vec4<f32>,
        _pad4 : vec4<f32>,
      }

      // Terrain material uniforms
      // Layer data: vec4 per layer (tilingScale, displacementScale, roughness, metallic)
      // Plus layer albedo colors, and global settings
      struct TerrainUniforms {
        layer0Props: vec4<f32>,  // tilingScale, displacementScale, roughness, metallic
        layer1Props: vec4<f32>,
        layer2Props: vec4<f32>,
        layer3Props: vec4<f32>,
        layer0Albedo: vec4<f32>, // RGB = albedo, A = unused
        layer1Albedo: vec4<f32>,
        layer2Albedo: vec4<f32>,
        layer3Albedo: vec4<f32>,
        globalSettings: vec4<f32>, // triplanarSharpness, triplanarThreshold, heightBlendSharpness, triplanarEnabled
        macroSettings: vec4<f32>,  // macroScale, macroStrength, textureFlags, debugMode
        distanceSettings: vec4<f32>, // detailFadeStart, detailFadeEnd, uvOffsetScale, uvOffsetStrength
      }

      @group(0) @binding(0) var<uniform> scene : SceneUniforms;
      @group(0) @binding(1) var<storage, read> objects : array<ObjectData>;

      @group(1) @binding(0) var<uniform> terrain : TerrainUniforms;
      @group(1) @binding(1) var splatmapSampler : sampler;  // clamp-to-edge for splatmap
      @group(1) @binding(2) var layerSampler : sampler;     // repeat for layer textures
      @group(1) @binding(3) var splatmapTex : texture_2d<f32>;
      // Layer 0 textures
      @group(1) @binding(4) var layer0AlbedoTex : texture_2d<f32>;
      @group(1) @binding(5) var layer0NormalTex : texture_2d<f32>;
      @group(1) @binding(6) var layer0RoughnessTex : texture_2d<f32>;
      // Layer 1 textures
      @group(1) @binding(7) var layer1AlbedoTex : texture_2d<f32>;
      @group(1) @binding(8) var layer1NormalTex : texture_2d<f32>;
      @group(1) @binding(9) var layer1RoughnessTex : texture_2d<f32>;
      // Layer 2 textures
      @group(1) @binding(10) var layer2AlbedoTex : texture_2d<f32>;
      @group(1) @binding(11) var layer2NormalTex : texture_2d<f32>;
      @group(1) @binding(12) var layer2RoughnessTex : texture_2d<f32>;
      // Layer 3 textures
      @group(1) @binding(13) var layer3AlbedoTex : texture_2d<f32>;
      @group(1) @binding(14) var layer3NormalTex : texture_2d<f32>;
      @group(1) @binding(15) var layer3RoughnessTex : texture_2d<f32>;

      struct VertexInput {
        @location(0) position : vec3<f32>,
        @location(1) normal : vec3<f32>,
        @location(2) uv : vec2<f32>,
      }

      struct VertexOutput {
        @builtin(position) position : vec4<f32>,
        @location(0) worldNormal : vec3<f32>,
        @location(1) uv : vec2<f32>,
        @location(2) worldPosition : vec3<f32>,
        @location(3) currentClip : vec4<f32>,
        @location(4) prevClip : vec4<f32>,
      }

      // Texture flag helpers
      const LAYER0_HAS_ALBEDO = 1u;
      const LAYER0_HAS_NORMAL = 2u;
      const LAYER0_HAS_ROUGHNESS = 4u;
      const LAYER1_HAS_ALBEDO = 8u;
      const LAYER1_HAS_NORMAL = 16u;
      const LAYER1_HAS_ROUGHNESS = 32u;
      const LAYER2_HAS_ALBEDO = 64u;
      const LAYER2_HAS_NORMAL = 128u;
      const LAYER2_HAS_ROUGHNESS = 256u;
      const LAYER3_HAS_ALBEDO = 512u;
      const LAYER3_HAS_NORMAL = 1024u;
      const LAYER3_HAS_ROUGHNESS = 2048u;
      const HAS_SPLATMAP = 4096u;

      // Hash functions for noise generation
      fn hash21(p: vec2f) -> f32 {
        var p3 = fract(p.xyx * vec3f(0.1031, 0.1030, 0.0973));
        p3 += dot(p3, p3.yzx + 33.33);
        return fract((p3.x + p3.y) * p3.z);
      }

      fn hash22(p: vec2f) -> vec2f {
        var p3 = fract(p.xyx * vec3f(0.1031, 0.1030, 0.0973));
        p3 += dot(p3, p3.yzx + 33.33);
        return fract((p3.xx + p3.yz) * p3.zy);
      }

      // Value noise for macro variation
      fn valueNoise(p: vec2f) -> f32 {
        let i = floor(p);
        let f = fract(p);
        // Quintic interpolation for smoother results
        let u = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);
        return mix(
          mix(hash21(i + vec2f(0.0, 0.0)), hash21(i + vec2f(1.0, 0.0)), u.x),
          mix(hash21(i + vec2f(0.0, 1.0)), hash21(i + vec2f(1.0, 1.0)), u.x),
          u.y
        );
      }

      // Fractal Brownian Motion for higher quality noise
      fn fbm(p: vec2f, octaves: u32) -> f32 {
        var value = 0.0;
        var amplitude = 0.5;
        var frequency = 1.0;
        var maxValue = 0.0;
        for (var i = 0u; i < octaves; i++) {
          value += amplitude * valueNoise(p * frequency);
          maxValue += amplitude;
          amplitude *= 0.5;
          frequency *= 2.0;
        }
        return value / maxValue; // Normalize to [0, 1]
      }

      // 2D vector noise for UV offset (returns offset in both directions)
      fn vectorNoise(p: vec2f) -> vec2f {
        let i = floor(p);
        let f = fract(p);
        let u = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);
        return mix(
          mix(hash22(i + vec2f(0.0, 0.0)), hash22(i + vec2f(1.0, 0.0)), u.x),
          mix(hash22(i + vec2f(0.0, 1.0)), hash22(i + vec2f(1.0, 1.0)), u.x),
          u.y
        ) * 2.0 - 1.0; // Map to [-1, 1]
      }

      // FBM-based vector noise for smoother UV distortion
      fn fbmVector(p: vec2f, octaves: u32) -> vec2f {
        var value = vec2f(0.0);
        var amplitude = 0.5;
        var frequency = 1.0;
        var maxValue = 0.0;
        for (var i = 0u; i < octaves; i++) {
          value += amplitude * vectorNoise(p * frequency);
          maxValue += amplitude;
          amplitude *= 0.5;
          frequency *= 2.0;
        }
        return value / maxValue;
      }

      // Triplanar blend weights based on normal
      fn getTriplanarWeights(N: vec3f, sharpness: f32) -> vec3f {
        var weights = abs(N);
        weights = pow(weights, vec3f(sharpness));
        weights = weights / (weights.x + weights.y + weights.z);
        return weights;
      }
    `;
  }
  buildVertexShader(commonDefines) {
    return `
      ${commonDefines}

      @vertex
      fn vs_main(input : VertexInput, @builtin(instance_index) instanceIndex : u32) -> VertexOutput {
        var output : VertexOutput;

        let modelMatrix = objects[instanceIndex].modelMatrix;
        let normalMatrix = objects[instanceIndex].normalMatrix;
        let prevModelMatrix = objects[instanceIndex].prevModelMatrix;

        let worldPos = modelMatrix * vec4<f32>(input.position, 1.0);
        output.worldPosition = worldPos.xyz;

        let clipPos = scene.projectionMatrix * scene.viewMatrix * worldPos;
        output.position = clipPos;
        output.currentClip = clipPos;

        let prevWorldPos = prevModelMatrix * vec4<f32>(input.position, 1.0);
        output.prevClip = scene.prevViewProj * prevWorldPos;

        output.worldNormal = (normalMatrix * vec4<f32>(input.normal, 0.0)).xyz;
        output.uv = input.uv;
        return output;
      }
    `;
  }
  buildDeferredFragmentShader(commonDefines) {
    return `
      ${commonDefines}

      struct FragmentOutput {
        @location(0) albedo : vec4<f32>,
        @location(1) normal : vec4<f32>,
        @location(2) position : vec4<f32>,
        @location(3) emissive : vec4<f32>,
        @location(4) velocity : vec2<f32>,
      }

      // Sample a layer's textures with triplanar blending
      // Note: Using textureSampleLevel with LOD 0 to avoid non-uniform control flow issues
      // triplanarFactor: 0 = pure UV mapping, 1 = pure triplanar mapping
      fn sampleLayerAlbedo(
        layerTex: texture_2d<f32>,
        hasTexture: bool,
        fallbackColor: vec3f,
        uv: vec2f,
        worldPos: vec3f,
        N: vec3f,
        tiling: f32,
        triplanarFactor: f32,
        triWeights: vec3f
      ) -> vec3f {
        if (!hasTexture) {
          return fallbackColor;
        }

        // Sample both paths and blend to avoid non-uniform control flow
        // Triplanar sampling
        let uvX = worldPos.zy * tiling;
        let uvY = worldPos.xz * tiling;
        let uvZ = worldPos.xy * tiling;

        let sampleX = textureSampleLevel(layerTex, layerSampler, uvX, 0.0).rgb;
        let sampleY = textureSampleLevel(layerTex, layerSampler, uvY, 0.0).rgb;
        let sampleZ = textureSampleLevel(layerTex, layerSampler, uvZ, 0.0).rgb;
        let triplanarResult = sampleX * triWeights.x + sampleY * triWeights.y + sampleZ * triWeights.z;

        // Standard UV sampling
        let standardResult = textureSampleLevel(layerTex, layerSampler, uv * tiling, 0.0).rgb;

        // Smooth blend between UV and triplanar based on factor
        return mix(standardResult, triplanarResult, triplanarFactor);
      }

      // Sample layer normal map and return world-space normal
      // For triplanar projection, each plane needs its own TBN matrix
      fn sampleLayerNormalWorldSpace(
        layerTex: texture_2d<f32>,
        hasTexture: bool,
        uv: vec2f,
        worldPos: vec3f,
        geometryNormal: vec3f,
        tiling: f32,
        triplanarFactor: f32,
        triWeights: vec3f,
        uvTBN: mat3x3f
      ) -> vec3f {
        if (!hasTexture) {
          return geometryNormal;
        }

        // Triplanar UVs
        let uvX = worldPos.zy * tiling;
        let uvY = worldPos.xz * tiling;
        let uvZ = worldPos.xy * tiling;

        // Sample normal maps for each projection plane
        let sampleX = textureSampleLevel(layerTex, layerSampler, uvX, 0.0).rgb * 2.0 - 1.0;
        let sampleY = textureSampleLevel(layerTex, layerSampler, uvY, 0.0).rgb * 2.0 - 1.0;
        let sampleZ = textureSampleLevel(layerTex, layerSampler, uvZ, 0.0).rgb * 2.0 - 1.0;

        // Per-plane TBN matrices for triplanar projection
        // XY plane (looking down Z axis): T=(1,0,0), B=(0,1,0), N=(0,0,1)
        let tbnXY = mat3x3f(
          vec3f(1.0, 0.0, 0.0),
          vec3f(0.0, 1.0, 0.0),
          vec3f(0.0, 0.0, sign(geometryNormal.z + 0.0001))
        );
        // XZ plane (looking down Y axis): T=(1,0,0), B=(0,0,1), N=(0,1,0)
        let tbnXZ = mat3x3f(
          vec3f(1.0, 0.0, 0.0),
          vec3f(0.0, 0.0, 1.0),
          vec3f(0.0, sign(geometryNormal.y + 0.0001), 0.0)
        );
        // YZ plane (looking down X axis): T=(0,1,0), B=(0,0,1), N=(1,0,0)
        let tbnYZ = mat3x3f(
          vec3f(0.0, 1.0, 0.0),
          vec3f(0.0, 0.0, 1.0),
          vec3f(sign(geometryNormal.x + 0.0001), 0.0, 0.0)
        );

        // Transform each sample to world space using its plane's TBN
        let worldNormalX = normalize(tbnYZ * sampleX);
        let worldNormalY = normalize(tbnXZ * sampleY);
        let worldNormalZ = normalize(tbnXY * sampleZ);

        // Blend world-space normals using triplanar weights
        let triplanarNormal = normalize(
          worldNormalX * triWeights.x +
          worldNormalY * triWeights.y +
          worldNormalZ * triWeights.z
        );

        // Standard UV sampling with traditional TBN
        let standardSample = textureSampleLevel(layerTex, layerSampler, uv * tiling, 0.0).rgb * 2.0 - 1.0;
        let standardNormal = normalize(uvTBN * standardSample);

        // Smooth blend between UV and triplanar normals
        return normalize(mix(standardNormal, triplanarNormal, triplanarFactor));
      }

      fn sampleLayerRoughness(
        layerTex: texture_2d<f32>,
        hasTexture: bool,
        fallbackRoughness: f32,
        uv: vec2f,
        worldPos: vec3f,
        tiling: f32,
        triplanarFactor: f32,
        triWeights: vec3f
      ) -> f32 {
        if (!hasTexture) {
          return fallbackRoughness;
        }

        // Sample both paths and blend
        let uvX = worldPos.zy * tiling;
        let uvY = worldPos.xz * tiling;
        let uvZ = worldPos.xy * tiling;

        let sampleX = textureSampleLevel(layerTex, layerSampler, uvX, 0.0).g;
        let sampleY = textureSampleLevel(layerTex, layerSampler, uvY, 0.0).g;
        let sampleZ = textureSampleLevel(layerTex, layerSampler, uvZ, 0.0).g;
        let triplanarResult = sampleX * triWeights.x + sampleY * triWeights.y + sampleZ * triWeights.z;

        let standardResult = textureSampleLevel(layerTex, layerSampler, uv * tiling, 0.0).g;

        // Smooth blend between UV and triplanar
        return mix(standardResult, triplanarResult, triplanarFactor);
      }

      @fragment
      fn fs_main(
        @location(0) worldNormal : vec3<f32>,
        @location(1) inUV : vec2<f32>,
        @location(2) worldPosition : vec3<f32>,
        @location(3) currentClip : vec4<f32>,
        @location(4) prevClip : vec4<f32>
      ) -> FragmentOutput {
        var output : FragmentOutput;

        // Normalize surface normal
        let normalLen = length(worldNormal);
        var N = select(vec3f(0.0, 1.0, 0.0), worldNormal / normalLen, normalLen > 0.0001);
        let uv = inUV;

        // Velocity calculation
        let currentNDC = currentClip.xy / currentClip.w;
        let prevNDC = prevClip.xy / prevClip.w;
        let velocity = (currentNDC - prevNDC) * 0.5;
        output.velocity = vec2<f32>(velocity.x, -velocity.y);

        // Get texture flags
        let textureFlags = u32(terrain.macroSettings.z);
        let hasSplatmap = (textureFlags & HAS_SPLATMAP) != 0u;

        // Sample splatmap for blend weights
        var splatWeights = vec4f(1.0, 0.0, 0.0, 0.0); // Default to layer 0
        if (hasSplatmap) {
          splatWeights = textureSampleLevel(splatmapTex, splatmapSampler, uv, 0.0);
        }

        // Triplanar settings
        let triplanarEnabled = terrain.globalSettings.w > 0.5;
        let triplanarSharpness = terrain.globalSettings.x;
        let triplanarThreshold = terrain.globalSettings.y;

        // Calculate slope (1 = vertical, 0 = flat)
        let slope = 1.0 - abs(N.y);

        // Smooth blend factor for triplanar: 0 = pure UV, 1 = pure triplanar
        // Uses smoothstep for gradual transition instead of hard binary switch
        let triplanarFactor = select(
          0.0,
          smoothstep(triplanarThreshold - 0.1, triplanarThreshold + 0.1, slope),
          triplanarEnabled
        );
        let triWeights = getTriplanarWeights(N, triplanarSharpness);

        // Build UV-based TBN matrix for standard normal mapping
        let Q1 = dpdx(worldPosition);
        let Q2 = dpdy(worldPosition);
        let st1 = dpdx(uv);
        let st2 = dpdy(uv);
        let T = normalize(Q1 * st2.y - Q2 * st1.y);
        let B = -normalize(cross(N, T));
        let uvTBN = mat3x3f(T, B, N);

        // Distance-based settings for detail reduction
        let detailFadeStart = terrain.distanceSettings.x;
        let detailFadeEnd = terrain.distanceSettings.y;
        let uvOffsetScale = terrain.distanceSettings.z;
        let uvOffsetStrength = terrain.distanceSettings.w;

        // Calculate distance from camera for LOD-style fading
        let distToCamera = length(worldPosition - scene.cameraPosition);
        let detailFade = smoothstep(detailFadeStart, detailFadeEnd, distToCamera);

        // UV offset noise to break tiling (applied before texture sampling)
        // Use FBM-based vector noise for smoother UV distortion
        let uvOffset = fbmVector(worldPosition.xz * uvOffsetScale, 3u) * uvOffsetStrength;
        // Reduce UV offset at distance (it's less noticeable anyway)
        let adjustedUvOffset = uvOffset * (1.0 - detailFade * 0.7);

        // Macro variation to break tiling - use multi-octave FBM for better quality
        let macroScale = terrain.macroSettings.x;
        let macroStrength = terrain.macroSettings.y;
        // Use FBM with 4 octaves for richer, more natural variation
        let macroNoise = fbm(worldPosition.xz * macroScale, 4u);
        // Add a secondary lower-frequency noise layer for large-scale variation
        let macroNoise2 = fbm(worldPosition.xz * macroScale * 0.3, 3u);
        let combinedMacro = macroNoise * 0.7 + macroNoise2 * 0.3;
        let macroVariation = 1.0 + (combinedMacro - 0.5) * macroStrength * 2.0;

        // Layer properties
        let layer0Tiling = terrain.layer0Props.x;
        let layer1Tiling = terrain.layer1Props.x;
        let layer2Tiling = terrain.layer2Props.x;
        let layer3Tiling = terrain.layer3Props.x;

        // Apply UV offset to break tiling patterns
        let distortedUV = uv + adjustedUvOffset;

        // Sample each layer with UV offset applied
        // Layer 0
        let l0HasAlbedo = (textureFlags & LAYER0_HAS_ALBEDO) != 0u;
        let l0HasNormal = (textureFlags & LAYER0_HAS_NORMAL) != 0u;
        let l0HasRoughness = (textureFlags & LAYER0_HAS_ROUGHNESS) != 0u;

        let l0Albedo = sampleLayerAlbedo(layer0AlbedoTex, l0HasAlbedo, terrain.layer0Albedo.rgb, distortedUV, worldPosition, N, layer0Tiling, triplanarFactor, triWeights);
        let l0Normal = sampleLayerNormalWorldSpace(layer0NormalTex, l0HasNormal, distortedUV, worldPosition, N, layer0Tiling, triplanarFactor, triWeights, uvTBN);
        let l0Roughness = sampleLayerRoughness(layer0RoughnessTex, l0HasRoughness, terrain.layer0Props.z, distortedUV, worldPosition, layer0Tiling, triplanarFactor, triWeights);

        // Layer 1
        let l1HasAlbedo = (textureFlags & LAYER1_HAS_ALBEDO) != 0u;
        let l1HasNormal = (textureFlags & LAYER1_HAS_NORMAL) != 0u;
        let l1HasRoughness = (textureFlags & LAYER1_HAS_ROUGHNESS) != 0u;

        let l1Albedo = sampleLayerAlbedo(layer1AlbedoTex, l1HasAlbedo, terrain.layer1Albedo.rgb, distortedUV, worldPosition, N, layer1Tiling, triplanarFactor, triWeights);
        let l1Normal = sampleLayerNormalWorldSpace(layer1NormalTex, l1HasNormal, distortedUV, worldPosition, N, layer1Tiling, triplanarFactor, triWeights, uvTBN);
        let l1Roughness = sampleLayerRoughness(layer1RoughnessTex, l1HasRoughness, terrain.layer1Props.z, distortedUV, worldPosition, layer1Tiling, triplanarFactor, triWeights);

        // Layer 2
        let l2HasAlbedo = (textureFlags & LAYER2_HAS_ALBEDO) != 0u;
        let l2HasNormal = (textureFlags & LAYER2_HAS_NORMAL) != 0u;
        let l2HasRoughness = (textureFlags & LAYER2_HAS_ROUGHNESS) != 0u;

        let l2Albedo = sampleLayerAlbedo(layer2AlbedoTex, l2HasAlbedo, terrain.layer2Albedo.rgb, distortedUV, worldPosition, N, layer2Tiling, triplanarFactor, triWeights);
        let l2Normal = sampleLayerNormalWorldSpace(layer2NormalTex, l2HasNormal, distortedUV, worldPosition, N, layer2Tiling, triplanarFactor, triWeights, uvTBN);
        let l2Roughness = sampleLayerRoughness(layer2RoughnessTex, l2HasRoughness, terrain.layer2Props.z, distortedUV, worldPosition, layer2Tiling, triplanarFactor, triWeights);

        // Layer 3
        let l3HasAlbedo = (textureFlags & LAYER3_HAS_ALBEDO) != 0u;
        let l3HasNormal = (textureFlags & LAYER3_HAS_NORMAL) != 0u;
        let l3HasRoughness = (textureFlags & LAYER3_HAS_ROUGHNESS) != 0u;

        let l3Albedo = sampleLayerAlbedo(layer3AlbedoTex, l3HasAlbedo, terrain.layer3Albedo.rgb, distortedUV, worldPosition, N, layer3Tiling, triplanarFactor, triWeights);
        let l3Normal = sampleLayerNormalWorldSpace(layer3NormalTex, l3HasNormal, distortedUV, worldPosition, N, layer3Tiling, triplanarFactor, triWeights, uvTBN);
        let l3Roughness = sampleLayerRoughness(layer3RoughnessTex, l3HasRoughness, terrain.layer3Props.z, distortedUV, worldPosition, layer3Tiling, triplanarFactor, triWeights);

        // Debug mode check
        let debugMode = u32(terrain.macroSettings.w);

        // Blend layers based on splatmap weights
        // Note: l0Normal etc. are now world-space normals from sampleLayerNormalWorldSpace
        var blendedAlbedo = l0Albedo * splatWeights.r + l1Albedo * splatWeights.g + l2Albedo * splatWeights.b + l3Albedo * splatWeights.a;
        let blendedNormal = normalize(l0Normal * splatWeights.r + l1Normal * splatWeights.g + l2Normal * splatWeights.b + l3Normal * splatWeights.a);
        let blendedRoughness = l0Roughness * splatWeights.r + l1Roughness * splatWeights.g + l2Roughness * splatWeights.b + l3Roughness * splatWeights.a;

        // Debug mode 1: Show raw splatmap weights directly
        // Debug mode 2: Show UV coordinates as RG
        // Debug mode 3: Calculate weights from world height (bypass splatmap)
        // Debug mode 4: Show raw layer 0 texture sample (verify texture loading)
        if (debugMode == 1u) {
          // Direct splatmap visualization: R=grass, G=dirt, B=rock, brightness=snow
          blendedAlbedo = vec3f(splatWeights.r, splatWeights.g, splatWeights.b);
        } else if (debugMode == 2u) {
          // UV coordinate visualization
          blendedAlbedo = vec3f(uv.x, uv.y, 0.0);
        } else if (debugMode == 4u) {
          // Raw texture sample from layer 0 - verifies texture is loaded and can be sampled
          let rawSample = textureSampleLevel(layer0AlbedoTex, layerSampler, uv * layer0Tiling, 0.0).rgb;
          blendedAlbedo = rawSample;
        } else if (debugMode == 3u) {
          // Calculate height-based weights directly from world position
          // Assuming terrain height roughly maps to worldPosition.y
          // Normalize assuming terrain height scale ~25 units, centered at 0
          let normalizedHeight = clamp((worldPosition.y + 12.5) / 25.0, 0.0, 1.0);

          // Simple 4-band gradient based on height
          var hw0 = 1.0 - clamp(normalizedHeight / 0.35, 0.0, 1.0); // Grass: high at low heights
          var hw1 = 1.0 - abs(normalizedHeight - 0.4) / 0.2; // Dirt: peak at 0.4
          var hw2 = 1.0 - abs(normalizedHeight - 0.65) / 0.2; // Rock: peak at 0.65
          var hw3 = clamp((normalizedHeight - 0.7) / 0.3, 0.0, 1.0); // Snow: high at high heights

          hw0 = max(hw0, 0.0);
          hw1 = max(hw1, 0.0);
          hw2 = max(hw2, 0.0);
          hw3 = max(hw3, 0.0);

          // Normalize
          let totalHW = hw0 + hw1 + hw2 + hw3 + 0.001;
          hw0 /= totalHW; hw1 /= totalHW; hw2 /= totalHW; hw3 /= totalHW;

          // Show as colors
          blendedAlbedo = vec3f(hw0, hw1, hw2) + vec3f(hw3 * 0.3);
        }

        // Calculate average color for distance-based simplification
        // At far distances, blend towards a simplified average to reduce tiling visibility
        let avgLayerColor = terrain.layer0Albedo.rgb * splatWeights.r +
                           terrain.layer1Albedo.rgb * splatWeights.g +
                           terrain.layer2Albedo.rgb * splatWeights.b +
                           terrain.layer3Albedo.rgb * splatWeights.a;

        // Apply macro variation (reduce effect at distance where tiling is less visible)
        let distanceAdjustedMacro = mix(macroVariation, 1.0, detailFade * 0.5);
        blendedAlbedo *= distanceAdjustedMacro;

        // Blend between detailed texture and simplified average color based on distance
        // This reduces the perception of tiling at far distances
        blendedAlbedo = mix(blendedAlbedo, avgLayerColor * distanceAdjustedMacro, detailFade * 0.3);

        // Blend metallic (usually 0 for terrain)
        let blendedMetallic = terrain.layer0Props.w * splatWeights.r + terrain.layer1Props.w * splatWeights.g +
                             terrain.layer2Props.w * splatWeights.b + terrain.layer3Props.w * splatWeights.a;

        // blendedNormal is already in world space from sampleLayerNormalWorldSpace
        // which handles per-plane TBN for triplanar and UV-based TBN for standard sampling

        // Output to GBuffer
        output.albedo = vec4<f32>(blendedAlbedo, blendedRoughness);
        output.normal = vec4<f32>(blendedNormal * 0.5 + 0.5, blendedMetallic);
        output.position = vec4<f32>(worldPosition, 1.0); // Occlusion = 1.0
        output.emissive = vec4<f32>(0.0, 0.0, 0.0, 1.0); // No emissive for terrain

        return output;
      }
    `;
  }
  buildForwardFragmentShader(commonDefines) {
    return `
      ${commonDefines}

      @fragment
      fn fs_main(
        @location(0) worldNormal : vec3<f32>,
        @location(1) inUV : vec2<f32>,
        @location(2) worldPosition : vec3<f32>
      ) -> @location(0) vec4f {
        let normalLen = length(worldNormal);
        let N = select(vec3f(0.0, 1.0, 0.0), worldNormal / normalLen, normalLen > 0.0001);

        // Simple shading
        let lightDir = normalize(vec3f(0.5, 1.0, 0.3));
        let NdotL = max(dot(N, lightDir), 0.0);

        let textureFlags = u32(terrain.macroSettings.z);
        let hasSplatmap = (textureFlags & HAS_SPLATMAP) != 0u;

        var splatWeights = vec4f(1.0, 0.0, 0.0, 0.0);
        if (hasSplatmap) {
          splatWeights = textureSampleLevel(splatmapTex, splatmapSampler, inUV, 0.0);
        }

        let blendedColor = terrain.layer0Albedo.rgb * splatWeights.r +
                          terrain.layer1Albedo.rgb * splatWeights.g +
                          terrain.layer2Albedo.rgb * splatWeights.b +
                          terrain.layer3Albedo.rgb * splatWeights.a;

        let ambient = 0.1;
        let diffuse = NdotL * 0.9;
        let color = blendedColor * (ambient + diffuse);

        return vec4f(color, 1.0);
      }
    `;
  }
  getTextureFlags() {
    let flags = 0;
    if (this.layers[0].albedoMap)
      flags |= 1;
    if (this.layers[0].normalMap)
      flags |= 2;
    if (this.layers[0].roughnessMap)
      flags |= 4;
    if (this.layers[1].albedoMap)
      flags |= 8;
    if (this.layers[1].normalMap)
      flags |= 16;
    if (this.layers[1].roughnessMap)
      flags |= 32;
    if (this.layers[2].albedoMap)
      flags |= 64;
    if (this.layers[2].normalMap)
      flags |= 128;
    if (this.layers[2].roughnessMap)
      flags |= 256;
    if (this.layers[3].albedoMap)
      flags |= 512;
    if (this.layers[3].normalMap)
      flags |= 1024;
    if (this.layers[3].roughnessMap)
      flags |= 2048;
    if (this.splatmap)
      flags |= 4096;
    return flags;
  }
  getVertexShader(pass) {
    return this.vertexShaderCode;
  }
  getFragmentShader(pass) {
    if (pass === "forward") {
      return this.forwardFragmentShaderCode;
    }
    return this.fragmentShaderCode;
  }
  getUniformBufferSize() {
    return 176;
  }
  updateUniforms(device, buffer, offset, context) {
    const arrayBuffer = new ArrayBuffer(this.getUniformBufferSize());
    const floatView = new Float32Array(arrayBuffer);
    let i = 0;
    floatView[i++] = this.layers[0].tilingScale;
    floatView[i++] = this.layers[0].displacementScale;
    floatView[i++] = this.layers[0].roughness;
    floatView[i++] = this.layers[0].metallic;
    floatView[i++] = this.layers[1].tilingScale;
    floatView[i++] = this.layers[1].displacementScale;
    floatView[i++] = this.layers[1].roughness;
    floatView[i++] = this.layers[1].metallic;
    floatView[i++] = this.layers[2].tilingScale;
    floatView[i++] = this.layers[2].displacementScale;
    floatView[i++] = this.layers[2].roughness;
    floatView[i++] = this.layers[2].metallic;
    floatView[i++] = this.layers[3].tilingScale;
    floatView[i++] = this.layers[3].displacementScale;
    floatView[i++] = this.layers[3].roughness;
    floatView[i++] = this.layers[3].metallic;
    floatView[i++] = this.layers[0].albedo.x;
    floatView[i++] = this.layers[0].albedo.y;
    floatView[i++] = this.layers[0].albedo.z;
    floatView[i++] = 0;
    floatView[i++] = this.layers[1].albedo.x;
    floatView[i++] = this.layers[1].albedo.y;
    floatView[i++] = this.layers[1].albedo.z;
    floatView[i++] = 0;
    floatView[i++] = this.layers[2].albedo.x;
    floatView[i++] = this.layers[2].albedo.y;
    floatView[i++] = this.layers[2].albedo.z;
    floatView[i++] = 0;
    floatView[i++] = this.layers[3].albedo.x;
    floatView[i++] = this.layers[3].albedo.y;
    floatView[i++] = this.layers[3].albedo.z;
    floatView[i++] = 0;
    floatView[i++] = this.triplanarSharpness;
    floatView[i++] = this.triplanarBlendThreshold;
    floatView[i++] = this.heightBlendSharpness;
    floatView[i++] = this.triplanarEnabled ? 1 : 0;
    floatView[i++] = this.macroVariationScale;
    floatView[i++] = this.tilingReductionEnabled ? this.macroVariationStrength : 0;
    floatView[i++] = this.getTextureFlags();
    floatView[i++] = this.debugMode;
    floatView[i++] = this.tilingReductionEnabled ? this.detailFadeStart : 1e5;
    floatView[i++] = this.tilingReductionEnabled ? this.detailFadeEnd : 100001;
    floatView[i++] = this.uvOffsetNoiseScale;
    floatView[i++] = this.tilingReductionEnabled ? this.uvOffsetNoiseStrength : 0;
    device.queue.writeBuffer(buffer, offset, arrayBuffer);
  }
  layerSampler = null;
  getLayerSampler(device) {
    if (!this.layerSampler) {
      this.layerSampler = device.createSampler({
        label: "Terrain Layer Sampler (repeat)",
        magFilter: "linear",
        minFilter: "linear",
        mipmapFilter: "linear",
        addressModeU: "repeat",
        addressModeV: "repeat",
        maxAnisotropy: 4
      });
    }
    return this.layerSampler;
  }
  getBindGroupEntries(device, uniformBuffer) {
    const defaultTex = Texture.getDefault(device);
    return [
      { binding: 0, resource: { buffer: uniformBuffer } },
      { binding: 1, resource: this.splatmap?.sampler || defaultTex.sampler },
      { binding: 2, resource: this.getLayerSampler(device) },
      { binding: 3, resource: this.splatmap?.view || defaultTex.view },
      { binding: 4, resource: this.layers[0].albedoMap?.view || defaultTex.view },
      { binding: 5, resource: this.layers[0].normalMap?.view || defaultTex.view },
      { binding: 6, resource: this.layers[0].roughnessMap?.view || defaultTex.view },
      { binding: 7, resource: this.layers[1].albedoMap?.view || defaultTex.view },
      { binding: 8, resource: this.layers[1].normalMap?.view || defaultTex.view },
      { binding: 9, resource: this.layers[1].roughnessMap?.view || defaultTex.view },
      { binding: 10, resource: this.layers[2].albedoMap?.view || defaultTex.view },
      { binding: 11, resource: this.layers[2].normalMap?.view || defaultTex.view },
      { binding: 12, resource: this.layers[2].roughnessMap?.view || defaultTex.view },
      { binding: 13, resource: this.layers[3].albedoMap?.view || defaultTex.view },
      { binding: 14, resource: this.layers[3].normalMap?.view || defaultTex.view },
      { binding: 15, resource: this.layers[3].roughnessMap?.view || defaultTex.view }
    ];
  }
  createBindGroupLayout(device) {
    return device.createBindGroupLayout({
      label: "TerrainMaterial Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX, buffer: { type: "uniform" } },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "filtering" } },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "filtering" } },
        { binding: 3, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 4, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 5, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 6, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 7, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 8, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 9, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 10, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 11, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 12, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 13, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 14, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 15, visibility: GPUShaderStage.FRAGMENT, texture: {} }
      ]
    });
  }
}

// ../../src/core/sprites/SpriteGeometry.ts
class SpriteGeometry extends Geometry {
  _width;
  _height;
  _anchorX;
  _anchorY;
  constructor(width = 1, height = 1, anchor = { x: 0.5, y: 0.5 }) {
    super();
    this._width = width;
    this._height = height;
    this._anchorX = anchor.x;
    this._anchorY = anchor.y;
    this.buildGeometry();
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this._width = value;
    this.buildGeometry();
  }
  get height() {
    return this._height;
  }
  set height(value) {
    this._height = value;
    this.buildGeometry();
  }
  get anchorX() {
    return this._anchorX;
  }
  get anchorY() {
    return this._anchorY;
  }
  setAnchor(x, y) {
    this._anchorX = x;
    this._anchorY = y;
    this.buildGeometry();
  }
  setSize(width, height) {
    this._width = width;
    this._height = height;
    this.buildGeometry();
  }
  buildGeometry() {
    const w = this._width;
    const h = this._height;
    const ax = this._anchorX;
    const ay = this._anchorY;
    const left = -w * ax;
    const right = w * (1 - ax);
    const bottom = -h * ay;
    const top = h * (1 - ay);
    const positions = new Float32Array([
      left,
      bottom,
      0,
      right,
      bottom,
      0,
      right,
      top,
      0,
      left,
      top,
      0
    ]);
    const normals = new Float32Array([
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1
    ]);
    const uvs = new Float32Array([
      0,
      1,
      1,
      1,
      1,
      0,
      0,
      0
    ]);
    const indices = new Uint16Array([
      0,
      1,
      2,
      0,
      2,
      3
    ]);
    this.setAttribute("position", positions);
    this.setAttribute("normal", normals);
    this.setAttribute("uv", uvs);
    this.setIndices(indices);
  }
  static createShared(width = 1, height = 1, anchor = { x: 0.5, y: 0.5 }) {
    return new SpriteGeometry(width, height, anchor);
  }
}

// ../../src/core/sprites/SpriteMaterial.ts
class SpriteMaterial extends Material {
  texture = null;
  tint = new Vector3(1, 1, 1);
  opacity = 1;
  uvOffset = { x: 0, y: 0 };
  uvScale = { x: 1, y: 1 };
  alphaMode = "BLEND";
  alphaCutoff = 0.5;
  pixelPerfect = false;
  billboard = "none";
  depthWrite = false;
  depthTest = true;
  _pixelPerfectSampler = null;
  _linearSampler = null;
  static MAX_LIGHTS = 8;
  constructor() {
    super();
    const commonDefines = `
      struct Light {
        position: vec3f,
        _pad1: f32,
        direction: vec3f,
        _pad2: f32,
        color: vec3f,
        intensity: f32,
        attenuation: vec3f,
        lightType: u32,
        coneAngles: vec2f,
        shadowIndex: i32,
        shadowRadius: f32,
        shadowIntensity: f32,
        _pad3: f32,
        _pad4: f32,
        _pad5: f32,
      }

      struct SceneUniforms {
        viewMatrix : mat4x4<f32>,
        projectionMatrix : mat4x4<f32>,
        lightViewProj : mat4x4<f32>,
        prevViewProj : mat4x4<f32>,
        inverseProjectionMatrix : mat4x4<f32>,
        cameraPosition : vec3f,
        time : f32,
        lightCount : u32,
        debugMode : u32,
        flags : u32,
        environmentIntensity : f32,
        fogColor: vec3f,
        fogDensity: f32,
        fogParams: vec4f,
        fogSettings: vec4u,
        lights : array<Light, ${SpriteMaterial.MAX_LIGHTS}>,
      }

      struct ObjectData {
        modelMatrix : mat4x4<f32>,
        normalMatrix : mat4x4<f32>,
        aabbMin : vec3f,
        _pad1 : f32,
        aabbMax : vec3f,
        _pad2 : f32,
        prevModelMatrix : mat4x4<f32>,
        _pad3 : vec4<f32>,
        _pad4 : vec4<f32>,
      }

      struct SpriteUniforms {
        modelMatrix : mat4x4<f32>,
        tint : vec3<f32>,
        opacity : f32,
        uvOffset : vec2<f32>,
        uvScale : vec2<f32>,
        alphaCutoff : f32,
        textureFlags : u32,
        alphaMode : u32,
        billboard : u32,
        jitter : vec2<f32>,          // TAA jitter to counter (for pixel-perfect rendering)
        _pad : vec2<f32>,
      }

      @group(0) @binding(0) var<uniform> scene : SceneUniforms;
      @group(0) @binding(1) var<storage, read> objects : array<ObjectData>;

      @group(1) @binding(0) var<uniform> material : SpriteUniforms;
      @group(1) @binding(1) var samp : sampler;
      @group(1) @binding(2) var spriteTex : texture_2d<f32>;

      struct VertexInput {
        @location(0) position : vec3<f32>,
        @location(1) normal : vec3<f32>,
        @location(2) uv : vec2<f32>,
      }

      struct VertexOutput {
        @builtin(position) position : vec4<f32>,
        @location(0) uv : vec2<f32>,
        @location(1) worldPosition : vec3<f32>,
      }
    `;
    this.vertexShaderCode = `
      ${commonDefines}

      @vertex
      fn vs_main(input : VertexInput) -> VertexOutput {
        var output : VertexOutput;

        // Use model matrix from material uniforms (each sprite has its own)
        let modelMatrix = material.modelMatrix;
        var worldPos : vec4<f32>;

        if (material.billboard == 1u) {
          // Spherical billboard - always face camera
          let camRight = vec3f(scene.viewMatrix[0][0], scene.viewMatrix[1][0], scene.viewMatrix[2][0]);
          let camUp = vec3f(scene.viewMatrix[0][1], scene.viewMatrix[1][1], scene.viewMatrix[2][1]);
          let center = vec3f(modelMatrix[3][0], modelMatrix[3][1], modelMatrix[3][2]);
          let scaleX = length(vec3f(modelMatrix[0][0], modelMatrix[0][1], modelMatrix[0][2]));
          let scaleY = length(vec3f(modelMatrix[1][0], modelMatrix[1][1], modelMatrix[1][2]));

          worldPos = vec4f(
            center +
            camRight * input.position.x * scaleX +
            camUp * input.position.y * scaleY,
            1.0
          );
        } else if (material.billboard == 2u) {
          // Cylindrical billboard - rotate around Y axis only to face camera
          let center = vec3f(modelMatrix[3][0], modelMatrix[3][1], modelMatrix[3][2]);
          let scaleX = length(vec3f(modelMatrix[0][0], modelMatrix[0][1], modelMatrix[0][2]));
          let scaleY = length(vec3f(modelMatrix[1][0], modelMatrix[1][1], modelMatrix[1][2]));

          // Calculate direction from sprite to camera in XZ plane
          let toCamera = scene.cameraPosition - center;
          let toCameraXZ = normalize(vec2f(toCamera.x, toCamera.z));

          // Sprite's right vector = cross(worldUp, forward) = (forward.z, 0, -forward.x)
          let spriteRight = vec3f(toCameraXZ.y, 0.0, -toCameraXZ.x);
          let worldUp = vec3f(0.0, 1.0, 0.0);

          worldPos = vec4f(
            center +
            spriteRight * input.position.x * scaleX +
            worldUp * input.position.y * scaleY,
            1.0
          );
        } else {
          // No billboard - standard transform
          worldPos = modelMatrix * vec4f(input.position, 1.0);
        }

        output.worldPosition = worldPos.xyz;
        output.position = scene.projectionMatrix * scene.viewMatrix * worldPos;

        // Counter TAA jitter for pixel-perfect rendering
        // The jitter was added to projection matrix, so we subtract it from clip position
        output.position.x -= material.jitter.x * output.position.w;
        output.position.y -= material.jitter.y * output.position.w;

        // Apply small depth bias to prevent z-fighting with nearby geometry
        // This pushes the sprite slightly towards the camera in clip space
        output.position.z = output.position.z - 0.0001 * output.position.w;

        // Apply UV transform for spritesheet frames
        output.uv = input.uv * material.uvScale + material.uvOffset;

        return output;
      }
    `;
    this.fragmentShaderCode = `
      ${commonDefines}

      @fragment
      fn fs_main(@location(0) uv : vec2<f32>, @location(1) worldPosition : vec3<f32>) -> @location(0) vec4<f32> {
        var color = material.tint;
        var alpha = material.opacity;

        // Sample texture if available
        if ((material.textureFlags & 1u) != 0u) {
          let texColor = textureSample(spriteTex, samp, uv);
          color = color * texColor.rgb;
          alpha = alpha * texColor.a;
        }

        // Alpha cutoff for MASK mode
        if (material.alphaMode == 1u && alpha < material.alphaCutoff) {
          discard;
        }

        // For OPAQUE mode, force alpha to 1
        if (material.alphaMode == 0u) {
          alpha = 1.0;
        }

        return vec4f(color, alpha);
      }
    `;
  }
  getRenderingPath() {
    return "forward";
  }
  getTextureFlags() {
    let flags = 0;
    if (this.texture)
      flags |= 1;
    return flags;
  }
  getBillboardFlag() {
    switch (this.billboard) {
      case "none":
        return 0;
      case "spherical":
        return 1;
      case "cylindrical":
        return 2;
      default:
        return 0;
    }
  }
  getAlphaModeFlag() {
    switch (this.alphaMode) {
      case "OPAQUE":
        return 0;
      case "MASK":
        return 1;
      case "BLEND":
        return 2;
      default:
        return 2;
    }
  }
  getUniformBufferSize() {
    return 128;
  }
  updateUniforms(device, buffer, offset, context) {
    const arrayBuffer = new ArrayBuffer(this.getUniformBufferSize());
    const floatView = new Float32Array(arrayBuffer);
    const uintView = new Uint32Array(arrayBuffer);
    let i = 0;
    if (context.modelMatrix) {
      const m = context.modelMatrix.elements;
      for (let j = 0;j < 16; j++) {
        floatView[i++] = m[j];
      }
    } else {
      floatView[i++] = 1;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 1;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 1;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 1;
    }
    floatView[i++] = this.tint.x;
    floatView[i++] = this.tint.y;
    floatView[i++] = this.tint.z;
    floatView[i++] = this.opacity;
    floatView[i++] = this.uvOffset.x;
    floatView[i++] = this.uvOffset.y;
    floatView[i++] = this.uvScale.x;
    floatView[i++] = this.uvScale.y;
    floatView[i++] = this.alphaCutoff;
    uintView[i++] = this.getTextureFlags();
    uintView[i++] = this.getAlphaModeFlag();
    uintView[i++] = this.getBillboardFlag();
    const jitter = context.camera?.projectionJitter;
    floatView[i++] = jitter?.x ?? 0;
    floatView[i++] = jitter?.y ?? 0;
    floatView[i++] = 0;
    floatView[i++] = 0;
    device.queue.writeBuffer(buffer, offset, arrayBuffer);
  }
  getSampler(device) {
    if (this.pixelPerfect) {
      if (!this._pixelPerfectSampler) {
        this._pixelPerfectSampler = device.createSampler({
          magFilter: "nearest",
          minFilter: "nearest",
          mipmapFilter: "nearest",
          addressModeU: "clamp-to-edge",
          addressModeV: "clamp-to-edge"
        });
      }
      return this._pixelPerfectSampler;
    } else {
      if (!this._linearSampler) {
        this._linearSampler = device.createSampler({
          magFilter: "linear",
          minFilter: "linear",
          mipmapFilter: "linear",
          addressModeU: "clamp-to-edge",
          addressModeV: "clamp-to-edge"
        });
      }
      return this._linearSampler;
    }
  }
  getBindGroupEntries(device, uniformBuffer) {
    const defaultTex = Texture.getDefault(device);
    const sampler = this.getSampler(device);
    return [
      { binding: 0, resource: { buffer: uniformBuffer } },
      { binding: 1, resource: sampler },
      { binding: 2, resource: this.texture?.view || defaultTex.view }
    ];
  }
  createBindGroupLayout(device) {
    return device.createBindGroupLayout({
      label: "SpriteMaterial Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX, buffer: { type: "uniform" } },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "filtering" } },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, texture: {} }
      ]
    });
  }
  setUVRegion(x, y, width, height, textureWidth, textureHeight) {
    this.uvOffset.x = x / textureWidth;
    this.uvOffset.y = y / textureHeight;
    this.uvScale.x = width / textureWidth;
    this.uvScale.y = height / textureHeight;
  }
  resetUV() {
    this.uvOffset.x = 0;
    this.uvOffset.y = 0;
    this.uvScale.x = 1;
    this.uvScale.y = 1;
  }
}

// ../../src/core/sprites/SpriteAnimator.ts
class SpriteAnimator {
  spritesheet = null;
  currentAnimation = null;
  currentFrameIndex = 0;
  elapsed = 0;
  playing = false;
  playMode = "forward";
  speed = 1;
  pingpongDirection = 1;
  onFrameChange = null;
  onAnimationEnd = null;
  onLoop = null;
  constructor(spritesheet) {
    if (spritesheet) {
      this.spritesheet = spritesheet;
    }
  }
  play(animationName, options) {
    if (!this.spritesheet)
      return false;
    const animation = this.spritesheet.getAnimation(animationName);
    if (!animation) {
      console.warn(`Animation '${animationName}' not found`);
      return false;
    }
    const restart = options?.restart ?? this.currentAnimation !== animationName;
    if (restart) {
      this.currentFrameIndex = 0;
      this.elapsed = 0;
      this.pingpongDirection = 1;
    }
    this.currentAnimation = animationName;
    this.playing = true;
    this.playMode = options?.playMode ?? this.playMode;
    this.speed = options?.speed ?? this.speed;
    const frame = this.getCurrentFrame();
    if (frame !== null && this.onFrameChange) {
      this.onFrameChange(frame);
    }
    return true;
  }
  pause() {
    this.playing = false;
  }
  resume() {
    this.playing = true;
  }
  stop() {
    this.playing = false;
    this.currentFrameIndex = 0;
    this.elapsed = 0;
    this.pingpongDirection = 1;
  }
  setFrame(index) {
    const animation = this.getCurrentAnimationData();
    if (!animation)
      return;
    this.currentFrameIndex = Math.max(0, Math.min(index, animation.frames.length - 1));
    this.elapsed = 0;
    const frame = this.getCurrentFrame();
    if (frame !== null && this.onFrameChange) {
      this.onFrameChange(frame);
    }
  }
  nextFrame() {
    const animation = this.getCurrentAnimationData();
    if (!animation)
      return;
    this.currentFrameIndex = (this.currentFrameIndex + 1) % animation.frames.length;
    this.elapsed = 0;
    const frame = this.getCurrentFrame();
    if (frame !== null && this.onFrameChange) {
      this.onFrameChange(frame);
    }
  }
  prevFrame() {
    const animation = this.getCurrentAnimationData();
    if (!animation)
      return;
    this.currentFrameIndex = this.currentFrameIndex - 1;
    if (this.currentFrameIndex < 0) {
      this.currentFrameIndex = animation.frames.length - 1;
    }
    this.elapsed = 0;
    const frame = this.getCurrentFrame();
    if (frame !== null && this.onFrameChange) {
      this.onFrameChange(frame);
    }
  }
  update(dt) {
    if (!this.playing || !this.currentAnimation || !this.spritesheet) {
      return this.getCurrentFrame();
    }
    const animation = this.spritesheet.getAnimation(this.currentAnimation);
    if (!animation || animation.frames.length === 0) {
      return null;
    }
    const frameDuration = 1 / (animation.frameRate * this.speed);
    this.elapsed += dt;
    let frameChanged = false;
    while (this.elapsed >= frameDuration) {
      this.elapsed -= frameDuration;
      frameChanged = true;
      if (this.playMode === "forward") {
        this.currentFrameIndex++;
        if (this.currentFrameIndex >= animation.frames.length) {
          if (animation.loop) {
            this.currentFrameIndex = 0;
            if (this.onLoop) {
              this.onLoop(this.currentAnimation);
            }
          } else {
            this.currentFrameIndex = animation.frames.length - 1;
            this.playing = false;
            if (this.onAnimationEnd) {
              this.onAnimationEnd(this.currentAnimation);
            }
          }
        }
      } else if (this.playMode === "reverse") {
        this.currentFrameIndex--;
        if (this.currentFrameIndex < 0) {
          if (animation.loop) {
            this.currentFrameIndex = animation.frames.length - 1;
            if (this.onLoop) {
              this.onLoop(this.currentAnimation);
            }
          } else {
            this.currentFrameIndex = 0;
            this.playing = false;
            if (this.onAnimationEnd) {
              this.onAnimationEnd(this.currentAnimation);
            }
          }
        }
      } else if (this.playMode === "pingpong") {
        this.currentFrameIndex += this.pingpongDirection;
        if (this.currentFrameIndex >= animation.frames.length) {
          this.pingpongDirection = -1;
          this.currentFrameIndex = animation.frames.length - 2;
          if (this.currentFrameIndex < 0)
            this.currentFrameIndex = 0;
        } else if (this.currentFrameIndex < 0) {
          if (animation.loop) {
            this.pingpongDirection = 1;
            this.currentFrameIndex = 1;
            if (this.currentFrameIndex >= animation.frames.length)
              this.currentFrameIndex = 0;
            if (this.onLoop) {
              this.onLoop(this.currentAnimation);
            }
          } else {
            this.currentFrameIndex = 0;
            this.playing = false;
            if (this.onAnimationEnd) {
              this.onAnimationEnd(this.currentAnimation);
            }
          }
        }
      }
    }
    const frame = this.getCurrentFrame();
    if (frameChanged && this.onFrameChange && frame !== null) {
      this.onFrameChange(frame);
    }
    return frame;
  }
  isPlaying() {
    return this.playing;
  }
  getCurrentFrame() {
    const animation = this.getCurrentAnimationData();
    if (!animation || animation.frames.length === 0) {
      return null;
    }
    const frameIndex = Math.max(0, Math.min(this.currentFrameIndex, animation.frames.length - 1));
    return animation.frames[frameIndex];
  }
  getProgress() {
    const animation = this.getCurrentAnimationData();
    if (!animation || animation.frames.length <= 1) {
      return 0;
    }
    return this.currentFrameIndex / (animation.frames.length - 1);
  }
  getCurrentAnimationData() {
    if (!this.spritesheet || !this.currentAnimation) {
      return null;
    }
    return this.spritesheet.getAnimation(this.currentAnimation);
  }
  hasAnimation(name) {
    return this.spritesheet?.getAnimation(name) !== null;
  }
  getAnimationDuration(name) {
    if (!this.spritesheet)
      return 0;
    const animation = this.spritesheet.getAnimation(name);
    if (!animation)
      return 0;
    return animation.frames.length / animation.frameRate;
  }
}

// ../../src/core/sprites/Sprite.ts
class Sprite extends Node {
  geometry;
  material;
  uniformBuffer = null;
  bindGroup = null;
  worldBounds = new AABB;
  worldBoundingSphere = { center: new Vector3, radius: 0 };
  renderIndex = -1;
  previousWorldMatrix = new Matrix4;
  _spritesheet = null;
  _currentFrame = null;
  _animator = null;
  constructor(width = 1, height = 1, anchor) {
    super("Sprite");
    this.geometry = new SpriteGeometry(width, height, anchor);
    this.material = new SpriteMaterial;
    this.renderOrder = 10;
    this._animator = new SpriteAnimator;
    this._animator.onFrameChange = (frame) => {
      this.setFrame(frame);
    };
  }
  get texture() {
    return this.material.texture;
  }
  set texture(tex) {
    this.material.texture = tex;
    if (!this._spritesheet) {
      this.material.resetUV();
    }
    this.bindGroup = null;
  }
  get tint() {
    return this.material.tint;
  }
  set tint(color) {
    this.material.tint.copy(color);
  }
  get opacity() {
    return this.material.opacity;
  }
  set opacity(value) {
    this.material.opacity = Math.max(0, Math.min(1, value));
  }
  get pixelPerfect() {
    return this.material.pixelPerfect;
  }
  set pixelPerfect(value) {
    if (this.material.pixelPerfect !== value) {
      this.material.pixelPerfect = value;
      this.bindGroup = null;
    }
  }
  setSize(width, height) {
    this.geometry.setSize(width, height);
  }
  getSize() {
    return { width: this.geometry.width, height: this.geometry.height };
  }
  setAnchor(x, y) {
    this.geometry.setAnchor(x, y);
  }
  setBillboard(mode) {
    this.material.billboard = mode;
  }
  get billboard() {
    return this.material.billboard;
  }
  get spritesheet() {
    return this._spritesheet;
  }
  set spritesheet(sheet) {
    this._spritesheet = sheet;
    if (sheet) {
      this.material.texture = sheet.texture;
      this._animator.spritesheet = sheet;
      if (sheet.frameCount > 0) {
        this.setFrame(0);
      }
    }
    this.bindGroup = null;
  }
  get currentFrame() {
    return this._currentFrame;
  }
  setFrame(frame) {
    if (!this._spritesheet)
      return;
    const uv = this._spritesheet.getFrameUV(frame);
    if (uv) {
      this.material.uvOffset.x = uv.offset.x;
      this.material.uvOffset.y = uv.offset.y;
      this.material.uvScale.x = uv.scale.x;
      this.material.uvScale.y = uv.scale.y;
      this._currentFrame = frame;
    }
  }
  get animator() {
    return this._animator;
  }
  play(animationName, options) {
    if (!this._animator || !this._spritesheet)
      return false;
    return this._animator.play(animationName, options);
  }
  pause() {
    this._animator?.pause();
  }
  resume() {
    this._animator?.resume();
  }
  stop() {
    this._animator?.stop();
  }
  isPlaying() {
    return this._animator?.isPlaying() ?? false;
  }
  update(dt) {
    if (this._animator) {
      this._animator.update(dt);
    }
  }
  updateWorldBounds() {
    const min = this.geometry.aabb.min;
    const max = this.geometry.aabb.max;
    const corners = [
      new Vector3(min.x, min.y, min.z),
      new Vector3(min.x, min.y, max.z),
      new Vector3(min.x, max.y, min.z),
      new Vector3(min.x, max.y, max.z),
      new Vector3(max.x, min.y, min.z),
      new Vector3(max.x, min.y, max.z),
      new Vector3(max.x, max.y, min.z),
      new Vector3(max.x, max.y, max.z)
    ];
    this.worldBounds.min.set(Infinity, Infinity, Infinity);
    this.worldBounds.max.set(-Infinity, -Infinity, -Infinity);
    for (const corner of corners) {
      corner.applyMatrix4(this.transform.worldMatrix);
      this.worldBounds.min.min(corner);
      this.worldBounds.max.max(corner);
    }
    this.worldBoundingSphere.center = this.geometry.boundingSphere.center.clone().applyMatrix4(this.transform.worldMatrix);
    const scale = this.transform.scale;
    const maxScale = Math.max(Math.abs(scale.x), Math.max(Math.abs(scale.y), Math.abs(scale.z)));
    this.worldBoundingSphere.radius = this.geometry.boundingSphere.radius * maxScale;
  }
  setTint(r, g, b) {
    this.material.tint.set(r, g, b);
  }
  setTintHex(hex) {
    const r = (hex >> 16 & 255) / 255;
    const g = (hex >> 8 & 255) / 255;
    const b = (hex & 255) / 255;
    this.material.tint.set(r, g, b);
  }
  flipX() {
    this.transform.scale.x *= -1;
  }
  flipY() {
    this.transform.scale.y *= -1;
  }
  setFlipped(flipX, flipY) {
    this.transform.scale.x = Math.abs(this.transform.scale.x) * (flipX ? -1 : 1);
    this.transform.scale.y = Math.abs(this.transform.scale.y) * (flipY ? -1 : 1);
  }
  static async fromTexture(device, url, options) {
    const texture = new Texture("Sprite Texture");
    await texture.load(device, url);
    const sprite = new Sprite(options?.width ?? 1, options?.height ?? 1);
    sprite.texture = texture;
    if (options?.pixelPerfect !== undefined) {
      sprite.pixelPerfect = options.pixelPerfect;
    }
    if (options?.billboard) {
      sprite.setBillboard(options.billboard);
    }
    return sprite;
  }
}

// ../../src/core/tilemaps/TilemapGeometry.ts
class TilemapGeometry extends Geometry {
  _width;
  _height;
  _anchorX;
  _anchorY;
  constructor(width = 1, height = 1, anchor = { x: 0, y: 0 }) {
    super();
    this._width = width;
    this._height = height;
    this._anchorX = anchor.x;
    this._anchorY = anchor.y;
    this.buildGeometry();
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  setSize(width, height) {
    if (this._width !== width || this._height !== height) {
      this._width = width;
      this._height = height;
      this.buildGeometry();
    }
  }
  setAnchor(x, y) {
    if (this._anchorX !== x || this._anchorY !== y) {
      this._anchorX = x;
      this._anchorY = y;
      this.buildGeometry();
    }
  }
  buildGeometry() {
    const w = this._width;
    const h = this._height;
    const ax = this._anchorX;
    const ay = this._anchorY;
    const left = -w * ax;
    const right = w * (1 - ax);
    const bottom = -h * ay;
    const top = h * (1 - ay);
    const positions = new Float32Array([
      left,
      bottom,
      0,
      right,
      bottom,
      0,
      right,
      top,
      0,
      left,
      top,
      0
    ]);
    const normals = new Float32Array([
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1
    ]);
    const uvs = new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1
    ]);
    const indices = new Uint16Array([
      0,
      1,
      2,
      0,
      2,
      3
    ]);
    this.setAttribute("position", positions);
    this.setAttribute("normal", normals);
    this.setAttribute("uv", uvs);
    this.setIndices(indices);
  }
}

// ../../src/core/tilemaps/TilemapMaterial.ts
class TilemapMaterial extends Material {
  tileset;
  mapWidth = 1;
  mapHeight = 1;
  tileScaleX = 1;
  tileScaleY = 1;
  tint = new Vector3(1, 1, 1);
  opacity = 1;
  alphaMode = "BLEND";
  alphaCutoff = 0.1;
  depthWrite = false;
  depthTest = true;
  pixelPerfect = true;
  _dataTexture = null;
  _linearSampler = null;
  _pixelSampler = null;
  static MAX_LIGHTS = 8;
  constructor(tileset) {
    super();
    this.tileset = tileset;
    const commonDefines = `
      struct Light {
        position: vec3f,
        _pad1: f32,
        direction: vec3f,
        _pad2: f32,
        color: vec3f,
        intensity: f32,
        attenuation: vec3f,
        lightType: u32,
        coneAngles: vec2f,
        shadowIndex: i32,
        shadowRadius: f32,
        shadowIntensity: f32,
        _pad3: f32,
        _pad4: f32,
        _pad5: f32,
      }

      struct SceneUniforms {
        viewMatrix : mat4x4<f32>,
        projectionMatrix : mat4x4<f32>,
        lightViewProj : mat4x4<f32>,
        prevViewProj : mat4x4<f32>,
        inverseProjectionMatrix : mat4x4<f32>,
        cameraPosition : vec3f,
        time : f32,
        lightCount : u32,
        debugMode : u32,
        flags : u32,
        environmentIntensity : f32,
        fogColor: vec3f,
        fogDensity: f32,
        fogParams: vec4f,
        fogSettings: vec4u,
        lights : array<Light, ${TilemapMaterial.MAX_LIGHTS}>,
      }

      struct ObjectData {
        modelMatrix : mat4x4<f32>,
        normalMatrix : mat4x4<f32>,
        aabbMin : vec3f,
        _pad1 : f32,
        aabbMax : vec3f,
        _pad2 : f32,
        prevModelMatrix : mat4x4<f32>,
        _pad3 : vec4<f32>,
        _pad4 : vec4<f32>,
      }

      struct TilemapUniforms {
        modelMatrix : mat4x4<f32>,
        mapSize : vec2<u32>,         // Width/height in tiles
        tileSize : vec2<f32>,        // Tileset tile size in UV (0-1)
        tilesetSize : vec2<f32>,     // Tileset dimensions in tiles
        firstGid : u32,
        _pad1 : u32,
        tint : vec3<f32>,
        opacity : f32,
        alphaCutoff : f32,
        alphaMode : u32,
        textureFlags : u32,
        _pad2 : u32,
        jitter : vec2<f32>,          // TAA jitter to counter (for pixel-perfect rendering)
        _pad3 : vec2<f32>,
      }

      @group(0) @binding(0) var<uniform> scene : SceneUniforms;
      @group(0) @binding(1) var<storage, read> objects : array<ObjectData>;

      @group(1) @binding(0) var<uniform> material : TilemapUniforms;
      @group(1) @binding(1) var tileSampler : sampler;
      @group(1) @binding(2) var tilesetTex : texture_2d<f32>;
      @group(1) @binding(3) var tileDataTex : texture_2d<u32>;

      struct VertexInput {
        @location(0) position : vec3<f32>,
        @location(1) normal : vec3<f32>,
        @location(2) uv : vec2<f32>,
      }

      struct VertexOutput {
        @builtin(position) position : vec4<f32>,
        @location(0) uv : vec2<f32>,
        @location(1) worldPosition : vec3<f32>,
      }
    `;
    this.vertexShaderCode = `
      ${commonDefines}

      @vertex
      fn vs_main(input : VertexInput) -> VertexOutput {
        var output : VertexOutput;

        let worldPos = material.modelMatrix * vec4f(input.position, 1.0);
        output.worldPosition = worldPos.xyz;
        output.position = scene.projectionMatrix * scene.viewMatrix * worldPos;

        // Counter TAA jitter for pixel-perfect rendering
        // The jitter was added to projection matrix, so we subtract it from clip position
        output.position.x -= material.jitter.x * output.position.w;
        output.position.y -= material.jitter.y * output.position.w;

        // UV spans 0-1 across entire tilemap
        output.uv = input.uv;

        return output;
      }
    `;
    this.fragmentShaderCode = `
      ${commonDefines}

      @fragment
      fn fs_main(@location(0) uv : vec2<f32>, @location(1) worldPosition : vec3<f32>) -> @location(0) vec4<f32> {
        // Calculate which tile we're in
        let mapSizeF = vec2f(f32(material.mapSize.x), f32(material.mapSize.y));
        let tileCoordF = uv * mapSizeF;
        let tileCoord = vec2u(u32(tileCoordF.x), u32(tileCoordF.y));

        // Clamp to valid range
        let clampedCoord = vec2u(
          min(tileCoord.x, material.mapSize.x - 1u),
          min(tileCoord.y, material.mapSize.y - 1u)
        );

        // Sample tile ID from data texture
        let tileId = textureLoad(tileDataTex, clampedCoord, 0).r;

        // Skip empty tiles (ID 0)
        if (tileId == 0u) {
          discard;
        }

        // Convert to local tile index (subtract firstGid)
        let localIndex = tileId - material.firstGid;

        // Calculate UV within current tile (fractional part)
        let tileUV = fract(tileCoordF);

        // Calculate which tile in tileset (column, row)
        let tilesetCols = u32(material.tilesetSize.x);
        let tileCol = localIndex % tilesetCols;
        let tileRow = localIndex / tilesetCols;

        // Calculate tileset UV
        // tileSize is the UV size of one tile in the tileset
        let tilesetUV = (vec2f(f32(tileCol), f32(tileRow)) + tileUV) * material.tileSize;

        // Sample tileset texture
        let texColor = textureSample(tilesetTex, tileSampler, tilesetUV);

        // Apply tint and opacity
        var finalColor = texColor.rgb * material.tint;
        var finalAlpha = texColor.a * material.opacity;

        // Alpha cutoff for MASK mode
        if (material.alphaMode == 1u && finalAlpha < material.alphaCutoff) {
          discard;
        }

        // For OPAQUE mode, force alpha to 1
        if (material.alphaMode == 0u) {
          finalAlpha = 1.0;
        }

        // Discard nearly transparent pixels
        if (finalAlpha < 0.01) {
          discard;
        }

        return vec4f(finalColor, finalAlpha);
      }
    `;
  }
  getRenderingPath() {
    return "forward";
  }
  getTextureFlags() {
    let flags = 0;
    if (this.tileset.texture)
      flags |= 1;
    if (this._dataTexture)
      flags |= 2;
    return flags;
  }
  getAlphaModeFlag() {
    switch (this.alphaMode) {
      case "OPAQUE":
        return 0;
      case "MASK":
        return 1;
      case "BLEND":
        return 2;
      default:
        return 2;
    }
  }
  getUniformBufferSize() {
    return 144;
  }
  updateUniforms(device, buffer, offset, context) {
    const arrayBuffer = new ArrayBuffer(this.getUniformBufferSize());
    const floatView = new Float32Array(arrayBuffer);
    const uintView = new Uint32Array(arrayBuffer);
    let i = 0;
    if (context.modelMatrix) {
      const m = context.modelMatrix.elements;
      for (let j = 0;j < 16; j++) {
        floatView[i++] = m[j];
      }
    } else {
      floatView[i++] = 1;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 1;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 1;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 1;
    }
    uintView[i++] = this.mapWidth;
    uintView[i++] = this.mapHeight;
    floatView[i++] = this.tileset.tileWidth / this.tileset.getTextureSize().width;
    floatView[i++] = this.tileset.tileHeight / this.tileset.getTextureSize().height;
    floatView[i++] = this.tileset.columns;
    floatView[i++] = this.tileset.rows;
    uintView[i++] = this.tileset.firstGid;
    uintView[i++] = 0;
    floatView[i++] = this.tint.x;
    floatView[i++] = this.tint.y;
    floatView[i++] = this.tint.z;
    floatView[i++] = this.opacity;
    floatView[i++] = this.alphaCutoff;
    uintView[i++] = this.getAlphaModeFlag();
    uintView[i++] = this.getTextureFlags();
    uintView[i++] = 0;
    const jitter = context.camera?.projectionJitter;
    floatView[i++] = jitter?.x ?? 0;
    floatView[i++] = jitter?.y ?? 0;
    floatView[i++] = 0;
    floatView[i++] = 0;
    device.queue.writeBuffer(buffer, offset, arrayBuffer);
  }
  updateDataTexture(device, data, width, height) {
    this.mapWidth = width;
    this.mapHeight = height;
    if (!this._dataTexture || this._dataTexture.width !== width || this._dataTexture.height !== height) {
      if (this._dataTexture) {
        this._dataTexture.destroy();
      }
      this._dataTexture = device.createTexture({
        label: "Tilemap Data Texture",
        size: [width, height],
        format: "r32uint",
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
      });
    }
    const dataBuffer = new Uint32Array(data).buffer;
    device.queue.writeTexture({ texture: this._dataTexture }, dataBuffer, { bytesPerRow: width * 4, rowsPerImage: height }, [width, height]);
  }
  getSampler(device) {
    if (this.pixelPerfect) {
      if (!this._pixelSampler) {
        this._pixelSampler = device.createSampler({
          magFilter: "nearest",
          minFilter: "nearest",
          mipmapFilter: "nearest",
          addressModeU: "clamp-to-edge",
          addressModeV: "clamp-to-edge"
        });
      }
      return this._pixelSampler;
    } else {
      if (!this._linearSampler) {
        this._linearSampler = device.createSampler({
          magFilter: "linear",
          minFilter: "linear",
          mipmapFilter: "linear",
          addressModeU: "clamp-to-edge",
          addressModeV: "clamp-to-edge"
        });
      }
      return this._linearSampler;
    }
  }
  getBindGroupEntries(device, uniformBuffer) {
    const defaultTex = Texture.getDefault(device);
    const sampler = this.getSampler(device);
    if (!this._dataTexture) {
      this._dataTexture = device.createTexture({
        label: "Tilemap Data Texture (default)",
        size: [1, 1],
        format: "r32uint",
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
      });
      device.queue.writeTexture({ texture: this._dataTexture }, new Uint32Array([0]), { bytesPerRow: 4 }, [1, 1]);
    }
    return [
      { binding: 0, resource: { buffer: uniformBuffer } },
      { binding: 1, resource: sampler },
      { binding: 2, resource: this.tileset.texture?.view || defaultTex.view },
      { binding: 3, resource: this._dataTexture.createView() }
    ];
  }
  createBindGroupLayout(device) {
    return device.createBindGroupLayout({
      label: "TilemapMaterial Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX, buffer: { type: "uniform" } },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "filtering" } },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "float" } },
        { binding: 3, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "uint" } }
      ]
    });
  }
  destroy() {
    if (this._dataTexture) {
      this._dataTexture.destroy();
      this._dataTexture = null;
    }
  }
}

// ../../src/core/tilemaps/TilemapLayer.ts
class TilemapLayer extends Node {
  geometry;
  material;
  uniformBuffer = null;
  bindGroup = null;
  worldBounds = new AABB;
  worldBoundingSphere = { center: new Vector3, radius: 0 };
  renderIndex = -1;
  previousWorldMatrix = new Matrix4;
  _tileset;
  _data;
  _tileScaleX = 1;
  _tileScaleY = 1;
  _device = null;
  constructor(tileset, data, options) {
    super("TilemapLayer");
    this._tileset = tileset;
    this._data = data;
    this._tileScaleX = options?.tileScaleX ?? 1;
    this._tileScaleY = options?.tileScaleY ?? 1;
    const worldWidth = data.width * this._tileScaleX;
    const worldHeight = data.height * this._tileScaleY;
    const anchor = options?.anchor ?? { x: 0, y: 0 };
    this.geometry = new TilemapGeometry(worldWidth, worldHeight, anchor);
    this.material = new TilemapMaterial(tileset);
    this.material.mapWidth = data.width;
    this.material.mapHeight = data.height;
    this.material.tileScaleX = this._tileScaleX;
    this.material.tileScaleY = this._tileScaleY;
  }
  get tileset() {
    return this._tileset;
  }
  set tileset(tileset) {
    this._tileset = tileset;
    this.material.tileset = tileset;
    this.bindGroup = null;
  }
  get data() {
    return this._data;
  }
  set data(data) {
    this._data = data;
    this.material.mapWidth = data.width;
    this.material.mapHeight = data.height;
    this.updateGeometrySize();
    this._data.markDirty();
  }
  get tileScaleX() {
    return this._tileScaleX;
  }
  set tileScaleX(value) {
    if (this._tileScaleX !== value) {
      this._tileScaleX = value;
      this.material.tileScaleX = value;
      this.updateGeometrySize();
    }
  }
  get tileScaleY() {
    return this._tileScaleY;
  }
  set tileScaleY(value) {
    if (this._tileScaleY !== value) {
      this._tileScaleY = value;
      this.material.tileScaleY = value;
      this.updateGeometrySize();
    }
  }
  setTileScale(x, y) {
    if (this._tileScaleX !== x || this._tileScaleY !== y) {
      this._tileScaleX = x;
      this._tileScaleY = y;
      this.material.tileScaleX = x;
      this.material.tileScaleY = y;
      this.updateGeometrySize();
    }
  }
  get tint() {
    return this.material.tint;
  }
  set tint(color) {
    this.material.tint.copy(color);
  }
  get opacity() {
    return this.material.opacity;
  }
  set opacity(value) {
    this.material.opacity = Math.max(0, Math.min(1, value));
  }
  get alphaMode() {
    return this.material.alphaMode;
  }
  set alphaMode(mode) {
    this.material.alphaMode = mode;
  }
  get pixelPerfect() {
    return this.material.pixelPerfect;
  }
  set pixelPerfect(value) {
    if (this.material.pixelPerfect !== value) {
      this.material.pixelPerfect = value;
      this.bindGroup = null;
    }
  }
  getTile(x, y) {
    return this._data.getTile(x, y);
  }
  setTile(x, y, tileId) {
    this._data.setTile(x, y, tileId);
  }
  fillRect(x, y, width, height, tileId) {
    this._data.fillRect(x, y, width, height, tileId);
  }
  clear() {
    this._data.clear();
  }
  worldToTile(worldX, worldY) {
    const localX = worldX - this.transform.position.x;
    const localY = worldY - this.transform.position.y;
    return {
      x: Math.floor(localX / this._tileScaleX),
      y: Math.floor(localY / this._tileScaleY)
    };
  }
  tileToWorld(tileX, tileY) {
    return {
      x: this.transform.position.x + (tileX + 0.5) * this._tileScaleX,
      y: this.transform.position.y + (tileY + 0.5) * this._tileScaleY
    };
  }
  getTileBounds(tileX, tileY) {
    const bounds = new AABB;
    const worldX = this.transform.position.x + tileX * this._tileScaleX;
    const worldY = this.transform.position.y + tileY * this._tileScaleY;
    bounds.min.set(worldX, worldY, this.transform.position.z - 0.01);
    bounds.max.set(worldX + this._tileScaleX, worldY + this._tileScaleY, this.transform.position.z + 0.01);
    return bounds;
  }
  getMapSize() {
    return { width: this._data.width, height: this._data.height };
  }
  getWorldSize() {
    return {
      width: this._data.width * this._tileScaleX,
      height: this._data.height * this._tileScaleY
    };
  }
  initGPU(device) {
    this._device = device;
    this.syncDataTexture();
  }
  syncDataTexture() {
    if (!this._device || !this._data.dirty)
      return;
    this.material.updateDataTexture(this._device, this._data.data, this._data.width, this._data.height);
    this._data.markClean();
    this.bindGroup = null;
  }
  forceSync() {
    this._data.markDirty();
    this.syncDataTexture();
  }
  updateWorldBounds() {
    const min = this.geometry.aabb.min;
    const max = this.geometry.aabb.max;
    const corners = [
      new Vector3(min.x, min.y, min.z),
      new Vector3(min.x, min.y, max.z),
      new Vector3(min.x, max.y, min.z),
      new Vector3(min.x, max.y, max.z),
      new Vector3(max.x, min.y, min.z),
      new Vector3(max.x, min.y, max.z),
      new Vector3(max.x, max.y, min.z),
      new Vector3(max.x, max.y, max.z)
    ];
    this.worldBounds.min.set(Infinity, Infinity, Infinity);
    this.worldBounds.max.set(-Infinity, -Infinity, -Infinity);
    for (const corner of corners) {
      corner.applyMatrix4(this.transform.worldMatrix);
      this.worldBounds.min.min(corner);
      this.worldBounds.max.max(corner);
    }
    this.worldBoundingSphere.center = this.geometry.boundingSphere.center.clone().applyMatrix4(this.transform.worldMatrix);
    const scale = this.transform.scale;
    const maxScale = Math.max(Math.abs(scale.x), Math.max(Math.abs(scale.y), Math.abs(scale.z)));
    this.worldBoundingSphere.radius = this.geometry.boundingSphere.radius * maxScale;
  }
  setTint(r, g, b) {
    this.material.tint.set(r, g, b);
  }
  setTintHex(hex) {
    const r = (hex >> 16 & 255) / 255;
    const g = (hex >> 8 & 255) / 255;
    const b = (hex & 255) / 255;
    this.material.tint.set(r, g, b);
  }
  updateGeometrySize() {
    const worldWidth = this._data.width * this._tileScaleX;
    const worldHeight = this._data.height * this._tileScaleY;
    this.geometry.setSize(worldWidth, worldHeight);
  }
  destroy() {
    this.material.destroy();
    if (this.uniformBuffer) {
      this.uniformBuffer.destroy();
      this.uniformBuffer = null;
    }
    this.bindGroup = null;
    this._device = null;
  }
}

// ../../src/core/renderer/ForwardRenderPass.ts
function usesGlobalResources(material) {
  return typeof material.createBindGroupLayout === "function";
}

class ForwardRenderPass {
  device = null;
  context = null;
  presentationFormat = null;
  depthTexture = null;
  depthCopyTexture = null;
  sceneColorCopyTexture = null;
  gBuffer = null;
  width = 0;
  height = 0;
  ssrTexture = null;
  constructor(gBuffer = null) {
    this.gBuffer = gBuffer;
  }
  init(device, context, presentationFormat) {
    this.device = device;
    this.context = context;
    this.presentationFormat = presentationFormat;
    const canvas = context.canvas;
    this.width = canvas.width;
    this.height = canvas.height;
    this.createDepthTexture();
  }
  resize(width, height) {
    this.width = width;
    this.height = height;
    this.createDepthTexture();
  }
  createDepthTexture() {
    if (!this.device || this.width === 0 || this.height === 0)
      return;
    if (this.depthCopyTexture) {
      this.depthCopyTexture.destroy();
    }
    if (this.sceneColorCopyTexture) {
      this.sceneColorCopyTexture.destroy();
    }
    if (!this.gBuffer) {
      if (this.depthTexture) {
        this.depthTexture.destroy();
      }
      this.depthTexture = this.device.createTexture({
        size: [this.width, this.height],
        format: "depth32float",
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
      });
    }
    const depthCopyFormat = this.gBuffer?.depthTexture?.format || "depth32float";
    this.depthCopyTexture = this.device.createTexture({
      size: [this.width, this.height],
      format: depthCopyFormat,
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
      label: "Depth Copy for Water"
    });
    this.sceneColorCopyTexture = this.device.createTexture({
      size: [this.width, this.height],
      format: "rgba16float",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
      label: "Scene Color Copy for Water Refraction"
    });
  }
  execute(commandEncoder, context, globalResources) {
    const depthTexture = this.gBuffer ? this.gBuffer.depthTexture : this.depthTexture;
    if (!this.device || !this.context || !this.presentationFormat || !depthTexture)
      return;
    const { scene, camera } = context;
    let textureView;
    let currentTexture = null;
    if (this.gBuffer && this.gBuffer.accumulationTexture) {
      currentTexture = this.gBuffer.accumulationTexture;
      textureView = currentTexture.createView();
    } else {
      currentTexture = this.context.getCurrentTexture();
      textureView = currentTexture.createView();
    }
    const loadOp = this.gBuffer ? "load" : "clear";
    const depthLoadOp = this.gBuffer ? "load" : "clear";
    const opaqueMeshes = [];
    const transparentMeshes = [];
    const flames = [];
    const billboardClouds = [];
    let hasWater = false;
    scene.traverse((node) => {
      if (!node.visible)
        return false;
      if (node.isFlame === true) {
        flames.push(node);
        return;
      }
      if (node.isBillboardClouds === true) {
        billboardClouds.push(node);
        return;
      }
      if (node instanceof Sprite) {
        if (node.material.opacity < 1 || node.material.alphaMode === "BLEND") {
          transparentMeshes.push(node);
        } else {
          opaqueMeshes.push(node);
        }
        return;
      }
      if (node instanceof TilemapLayer) {
        if (this.device) {
          node.initGPU(this.device);
          node.syncDataTexture();
        }
        if (node.material.opacity < 1 || node.material.alphaMode === "BLEND") {
          transparentMeshes.push(node);
        } else {
          opaqueMeshes.push(node);
        }
        return;
      }
      if (node instanceof Mesh) {
        if (node.material instanceof WaterMaterial) {
          hasWater = true;
        }
        if (this.gBuffer) {
          if (node.material instanceof StandardMaterial || node.material instanceof TerrainMaterial) {
            if (node.material.getRenderingPath() === "deferred") {
              return;
            }
            transparentMeshes.push(node);
          } else {
            if (node.material.opacity < 1 || node.material.alphaMode === "BLEND") {
              transparentMeshes.push(node);
            } else {
              opaqueMeshes.push(node);
            }
          }
        } else {
          if (node.material.opacity < 1 || node.material.alphaMode === "BLEND") {
            transparentMeshes.push(node);
          } else {
            opaqueMeshes.push(node);
          }
        }
      }
    });
    for (const flame of flames) {
      flame.setDeltaTime(context.deltaTime || 0.016);
      flame.runCompute(commandEncoder);
    }
    transparentMeshes.sort((a, b) => {
      const orderA = a.renderOrder ?? 0;
      const orderB = b.renderOrder ?? 0;
      if (orderA !== orderB) {
        return orderA - orderB;
      }
      const distA = a.transform.position.distanceTo(camera.transform.position);
      const distB = b.transform.position.distanceTo(camera.transform.position);
      return distB - distA;
    });
    if (hasWater && transparentMeshes.length > 0) {
      const opaquePassDescriptor = {
        colorAttachments: [{
          view: textureView,
          clearValue: scene.backgroundColor,
          loadOp,
          storeOp: "store"
        }],
        depthStencilAttachment: {
          view: depthTexture.createView(),
          depthClearValue: 1,
          depthLoadOp,
          depthStoreOp: "store"
        }
      };
      const opaquePass = commandEncoder.beginRenderPass(opaquePassDescriptor);
      for (const mesh of opaqueMeshes) {
        this.renderMesh(mesh, context, opaquePass, globalResources);
      }
      opaquePass.end();
      const depthSource = this.gBuffer?.depthTexture || this.depthTexture;
      if (depthSource && this.depthCopyTexture) {
        commandEncoder.copyTextureToTexture({ texture: depthSource }, { texture: this.depthCopyTexture }, [this.width, this.height]);
      }
      const colorSource = this.gBuffer?.accumulationTexture || currentTexture;
      if (colorSource && this.sceneColorCopyTexture) {
        commandEncoder.copyTextureToTexture({ texture: colorSource }, { texture: this.sceneColorCopyTexture }, [this.width, this.height]);
      }
      for (const mesh of transparentMeshes) {
        if (mesh instanceof Mesh && mesh.material instanceof WaterMaterial) {
          mesh.material.depthTexture = this.depthCopyTexture;
          mesh.material.ssrTexture = this.ssrTexture;
          mesh.material.sceneColorTexture = this.sceneColorCopyTexture;
          mesh.material.screenWidth = this.width;
          mesh.material.screenHeight = this.height;
          mesh.bindGroup = null;
        }
      }
      const transparentTextureView = currentTexture ? currentTexture.createView() : textureView;
      const transparentPassDescriptor = {
        colorAttachments: [{
          view: transparentTextureView,
          loadOp: "load",
          storeOp: "store"
        }],
        depthStencilAttachment: {
          view: depthTexture.createView(),
          depthLoadOp: "load",
          depthStoreOp: "store"
        }
      };
      const transparentPass = commandEncoder.beginRenderPass(transparentPassDescriptor);
      for (const mesh of transparentMeshes) {
        this.renderMesh(mesh, context, transparentPass, globalResources);
      }
      transparentPass.end();
      if (billboardClouds.length > 0) {
        for (const clouds of billboardClouds) {
          clouds.setDeltaTime(context.deltaTime || 0.016);
          clouds.render(commandEncoder, camera, currentTexture, depthTexture, scene);
        }
      }
      if (flames.length > 0) {
        for (const flame of flames) {
          flame.render(commandEncoder, camera, currentTexture, depthTexture);
        }
      }
    } else {
      const renderPassDescriptor = {
        colorAttachments: [{
          view: textureView,
          clearValue: scene.backgroundColor,
          loadOp,
          storeOp: "store"
        }],
        depthStencilAttachment: {
          view: depthTexture.createView(),
          depthClearValue: 1,
          depthLoadOp,
          depthStoreOp: "store"
        }
      };
      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
      for (const mesh of opaqueMeshes) {
        this.renderMesh(mesh, context, passEncoder, globalResources);
      }
      for (const mesh of transparentMeshes) {
        if (mesh instanceof Mesh && mesh.material instanceof WaterMaterial) {
          mesh.material.depthTexture = null;
          mesh.material.ssrTexture = this.ssrTexture;
          mesh.material.sceneColorTexture = null;
          mesh.material.screenWidth = this.width;
          mesh.material.screenHeight = this.height;
        }
      }
      for (const mesh of transparentMeshes) {
        this.renderMesh(mesh, context, passEncoder, globalResources);
      }
      passEncoder.end();
      const accumulationTexture = this.gBuffer?.accumulationTexture || currentTexture;
      if (accumulationTexture && billboardClouds.length > 0) {
        for (const clouds of billboardClouds) {
          clouds.setDeltaTime(context.deltaTime || 0.016);
          clouds.render(commandEncoder, camera, accumulationTexture, depthTexture, scene);
        }
      }
      if (accumulationTexture && flames.length > 0) {
        for (const flame of flames) {
          flame.render(commandEncoder, camera, accumulationTexture, depthTexture);
        }
      }
    }
  }
  renderMesh(mesh, context, passEncoder, globalResources) {
    if (!this.device || !this.presentationFormat)
      return;
    const needsInit = mesh.geometry.buffersDirty || Object.keys(mesh.geometry.attributes).some((name) => !mesh.geometry.vertexBuffers[name]);
    if (needsInit) {
      this.initGeometryBuffers(mesh.geometry);
      return;
    }
    if (!mesh.material.pipeline) {
      this.initMaterialPipeline(mesh.material, mesh.geometry, globalResources);
    }
    if (!mesh.uniformBuffer || !mesh.bindGroup) {
      this.initMeshUniforms(mesh, globalResources);
    }
    this.updateMeshUniforms(mesh, context);
    if (mesh.material.pipeline && mesh.bindGroup) {
      passEncoder.setPipeline(mesh.material.pipeline);
      if (usesGlobalResources(mesh.material)) {
        if (globalResources.renderBindGroup) {
          passEncoder.setBindGroup(0, globalResources.renderBindGroup);
        }
        passEncoder.setBindGroup(1, mesh.bindGroup);
        const instanceIndex = mesh.renderIndex >= 0 ? mesh.renderIndex : 0;
        this.bindVertexBuffers(passEncoder, mesh);
        if (mesh.geometry.indexBuffer) {
          const indexFormat = mesh.geometry.indices instanceof Uint32Array ? "uint32" : "uint16";
          passEncoder.setIndexBuffer(mesh.geometry.indexBuffer, indexFormat);
          passEncoder.drawIndexed(mesh.geometry.indexCount, 1, 0, 0, instanceIndex);
        } else {
          passEncoder.draw(mesh.geometry.vertexCount, 1, 0, instanceIndex);
        }
      } else {
        passEncoder.setBindGroup(0, mesh.bindGroup);
        this.bindVertexBuffers(passEncoder, mesh);
        if (mesh.geometry.indexBuffer) {
          const indexFormat = mesh.geometry.indices instanceof Uint32Array ? "uint32" : "uint16";
          passEncoder.setIndexBuffer(mesh.geometry.indexBuffer, indexFormat);
          passEncoder.drawIndexed(mesh.geometry.indexCount);
        } else {
          passEncoder.draw(mesh.geometry.vertexCount);
        }
      }
      if (context.frameStats) {
        context.frameStats.drawCalls++;
        context.frameStats.triangles += mesh.geometry.triangleCount;
      }
    }
  }
  bindVertexBuffers(passEncoder, mesh) {
    if (mesh.geometry.vertexBuffers["position"]) {
      passEncoder.setVertexBuffer(0, mesh.geometry.vertexBuffers["position"]);
    }
    if (mesh.geometry.vertexBuffers["normal"]) {
      passEncoder.setVertexBuffer(1, mesh.geometry.vertexBuffers["normal"]);
    }
    if (mesh.geometry.vertexBuffers["uv"]) {
      passEncoder.setVertexBuffer(2, mesh.geometry.vertexBuffers["uv"]);
    }
  }
  initGeometryBuffers(geometry) {
    if (!this.device)
      return;
    if (geometry.buffersDirty) {
      for (const key in geometry.vertexBuffers) {
        geometry.vertexBuffers[key]?.destroy();
        delete geometry.vertexBuffers[key];
      }
      if (geometry.indexBuffer) {
        geometry.indexBuffer.destroy();
        geometry.indexBuffer = null;
      }
    }
    for (const [name, data] of Object.entries(geometry.attributes)) {
      if (!geometry.vertexBuffers[name]) {
        const buffer = this.device.createBuffer({
          label: `${name} Buffer`,
          size: data.byteLength,
          usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
          mappedAtCreation: true
        });
        new Float32Array(buffer.getMappedRange()).set(data);
        buffer.unmap();
        geometry.vertexBuffers[name] = buffer;
      }
    }
    if (geometry.indices && !geometry.indexBuffer) {
      const size = geometry.indices.byteLength;
      const alignedSize = size + 3 & ~3;
      geometry.indexBuffer = this.device.createBuffer({
        label: "Index Buffer",
        size: alignedSize,
        usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,
        mappedAtCreation: true
      });
      if (geometry.indices instanceof Uint16Array) {
        new Uint16Array(geometry.indexBuffer.getMappedRange()).set(geometry.indices);
      } else {
        new Uint32Array(geometry.indexBuffer.getMappedRange()).set(geometry.indices);
      }
      geometry.indexBuffer.unmap();
    }
    geometry.markBuffersClean();
  }
  initMaterialPipeline(material, geometry, globalResources) {
    if (!this.device || !this.presentationFormat)
      return;
    const vertexModule = createShaderModuleSafe(this.device, {
      label: "Material Vertex Shader",
      code: material.getVertexShader("forward")
    });
    const fragmentModule = createShaderModuleSafe(this.device, {
      label: "Material Fragment Shader",
      code: material.getFragmentShader("forward")
    });
    const buffers = [];
    if (geometry.attributes["position"]) {
      buffers.push({
        arrayStride: 3 * 4,
        attributes: [{ shaderLocation: 0, offset: 0, format: "float32x3" }]
      });
    }
    if (geometry.attributes["normal"]) {
      buffers.push({
        arrayStride: 3 * 4,
        attributes: [{ shaderLocation: 1, offset: 0, format: "float32x3" }]
      });
    }
    if (geometry.attributes["uv"]) {
      buffers.push({
        arrayStride: 2 * 4,
        attributes: [{ shaderLocation: 2, offset: 0, format: "float32x2" }]
      });
    }
    let pipelineLayout = "auto";
    if (usesGlobalResources(material)) {
      const materialLayout = material.createBindGroupLayout(this.device);
      pipelineLayout = this.device.createPipelineLayout({
        bindGroupLayouts: [globalResources.renderBindGroupLayout, materialLayout]
      });
    }
    const isTransparent = material.alphaMode === "BLEND" || material.opacity < 1;
    const isSprite = material instanceof SpriteMaterial;
    const blendState = isTransparent ? {
      color: {
        srcFactor: "src-alpha",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      alpha: {
        srcFactor: "src-alpha",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      }
    } : undefined;
    const depthFormat = this.gBuffer && this.gBuffer.depthTexture ? this.gBuffer.depthTexture.format : "depth32float";
    const targetFormat = this.gBuffer ? "rgba16float" : this.presentationFormat;
    let depthWriteEnabled = !isTransparent;
    let depthCompare = "less";
    if (isSprite) {
      depthWriteEnabled = material.depthWrite;
      depthCompare = material.depthTest ? "less-equal" : "always";
    }
    material.pipeline = this.device.createRenderPipeline({
      label: isSprite ? "Sprite Pipeline" : "Material Pipeline",
      layout: pipelineLayout,
      vertex: {
        module: vertexModule,
        entryPoint: "vs_main",
        buffers
      },
      fragment: {
        module: fragmentModule,
        entryPoint: "fs_main",
        targets: [{
          format: targetFormat,
          blend: blendState
        }]
      },
      primitive: {
        topology: "triangle-list",
        cullMode: "none"
      },
      depthStencil: {
        depthWriteEnabled,
        depthCompare,
        format: depthFormat
      }
    });
  }
  initMeshUniforms(mesh, globalResources) {
    if (!this.device || !mesh.material.pipeline)
      return;
    const uniformBufferSize = mesh.material.getUniformBufferSize();
    mesh.uniformBuffer = this.device.createBuffer({
      label: "Uniform Buffer",
      size: uniformBufferSize,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    let layout;
    if (usesGlobalResources(mesh.material)) {
      layout = mesh.material.createBindGroupLayout(this.device);
    } else {
      layout = mesh.material.pipeline.getBindGroupLayout(0);
    }
    mesh.bindGroup = this.device.createBindGroup({
      label: "Uniform Bind Group",
      layout,
      entries: mesh.material.getBindGroupEntries(this.device, mesh.uniformBuffer)
    });
  }
  updateMeshUniforms(mesh, parentContext) {
    if (!this.device || !mesh.uniformBuffer)
      return;
    const context = {
      ...parentContext,
      modelMatrix: mesh.transform.worldMatrix
    };
    mesh.material.updateUniforms(this.device, mesh.uniformBuffer, 0, context);
  }
}

// ../../src/math/Frustum.ts
class Plane {
  normal;
  constant;
  constructor() {
    this.normal = new Vector3(1, 0, 0);
    this.constant = 0;
  }
  setComponents(x, y, z, w) {
    this.normal.set(x, y, z);
    this.constant = w;
    this.normalize();
    return this;
  }
  normalize() {
    const length = this.normal.magnitude();
    if (length > 0) {
      const inverseLength = 1 / length;
      this.normal = this.normal.multiply(inverseLength);
      this.constant *= inverseLength;
    }
    return this;
  }
  distanceToPoint(point) {
    return this.normal.dot(point) + this.constant;
  }
}

class Frustum {
  planes;
  constructor() {
    this.planes = [
      new Plane,
      new Plane,
      new Plane,
      new Plane,
      new Plane,
      new Plane
    ];
  }
  setFromProjectionMatrix(m) {
    const me = m.elements;
    const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
    const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
    const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
    const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
    this.planes[0].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12);
    this.planes[1].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12);
    this.planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13);
    this.planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13);
    this.planes[4].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14);
    this.planes[5].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14);
    return this;
  }
  intersectsBox(minX, minY, minZ, maxX, maxY, maxZ) {
    for (let i = 0;i < 6; i++) {
      const plane = this.planes[i];
      const normal = plane.normal;
      const px = normal.x > 0 ? maxX : minX;
      const py = normal.y > 0 ? maxY : minY;
      const pz = normal.z > 0 ? maxZ : minZ;
      if (normal.x * px + normal.y * py + normal.z * pz + plane.constant < 0) {
        return false;
      }
    }
    return true;
  }
}

// ../../src/core/procedural/noise/NoiseShaders.ts
var NoiseShaderLib = `
// ============================================
// HASH FUNCTIONS (high quality, pattern-free)
// ============================================

// Sine-based hash with carefully chosen constants (IQ's method, improved)
fn hash11(p: f32) -> f32 {
    let p2 = fract(p * 0.1031);
    let p3 = p2 * (p2 + 33.33);
    return fract(p3 * (p3 + p3));
}

fn hash21(p: vec2f) -> f32 {
    // Use sine for better distribution (Inigo Quilez style)
    var p3 = fract(p.xyx * vec3f(0.1031, 0.1030, 0.0973));
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

fn hash31(p: vec3f) -> f32 {
    var p3 = fract(p * vec3f(0.1031, 0.1030, 0.0973));
    p3 += dot(p3, p3.yxz + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

fn hash22(p: vec2f) -> vec2f {
    var p3 = fract(p.xyx * vec3f(0.1031, 0.1030, 0.0973));
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.xx + p3.yz) * p3.zy);
}

fn hash33(p: vec3f) -> vec3f {
    var p3 = fract(p * vec3f(0.1031, 0.1030, 0.0973));
    p3 += dot(p3, p3.yxz + 33.33);
    return fract((p3.xxy + p3.yxx) * p3.zyx);
}

// Seeded hash function
fn hashWithSeed(p: vec2f, seed: f32) -> f32 {
    return hash21(p + vec2f(seed * 127.1, seed * 311.7));
}

// ============================================
// VALUE NOISE
// ============================================

fn valueNoise2D(p: vec2f) -> f32 {
    let i = floor(p);
    let f = fract(p);

    // Quintic interpolation for smoother results (C2 continuity)
    let u = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);

    return mix(
        mix(hash21(i + vec2f(0.0, 0.0)), hash21(i + vec2f(1.0, 0.0)), u.x),
        mix(hash21(i + vec2f(0.0, 1.0)), hash21(i + vec2f(1.0, 1.0)), u.x),
        u.y
    );
}

fn valueNoise3D(p: vec3f) -> f32 {
    let i = floor(p);
    let f = fract(p);
    let u = f * f * (3.0 - 2.0 * f);

    return mix(
        mix(
            mix(hash31(i + vec3f(0,0,0)), hash31(i + vec3f(1,0,0)), u.x),
            mix(hash31(i + vec3f(0,1,0)), hash31(i + vec3f(1,1,0)), u.x),
            u.y
        ),
        mix(
            mix(hash31(i + vec3f(0,0,1)), hash31(i + vec3f(1,0,1)), u.x),
            mix(hash31(i + vec3f(0,1,1)), hash31(i + vec3f(1,1,1)), u.x),
            u.y
        ),
        u.z
    );
}

// ============================================
// GRADIENT NOISE (Perlin-style)
// ============================================

// Generate a random 2D gradient vector from a hash
fn gradient2D(p: vec2f) -> vec2f {
    // Use hash to generate angle, then convert to unit vector
    let angle = hash21(p) * 6.283185307; // 2*PI
    return vec2f(cos(angle), sin(angle));
}

fn perlinNoise2D(p: vec2f) -> f32 {
    let i = floor(p);
    let f = fract(p);

    // Quintic interpolation for C2 continuity (smoother)
    let u = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);

    // Get gradients at four corners
    let g00 = gradient2D(i + vec2f(0.0, 0.0));
    let g10 = gradient2D(i + vec2f(1.0, 0.0));
    let g01 = gradient2D(i + vec2f(0.0, 1.0));
    let g11 = gradient2D(i + vec2f(1.0, 1.0));

    // Calculate dot products with distance vectors
    let d00 = dot(g00, f - vec2f(0.0, 0.0));
    let d10 = dot(g10, f - vec2f(1.0, 0.0));
    let d01 = dot(g01, f - vec2f(0.0, 1.0));
    let d11 = dot(g11, f - vec2f(1.0, 1.0));

    // Bilinear interpolation
    let x0 = mix(d00, d10, u.x);
    let x1 = mix(d01, d11, u.x);
    let n = mix(x0, x1, u.y);

    // Scale to [0, 1] range (Perlin noise range is approximately [-0.7, 0.7])
    return n * 0.7071 + 0.5;
}

// ============================================
// SIMPLEX NOISE (2D)
// ============================================

fn mod289_2(x: vec2f) -> vec2f { return x - floor(x * (1.0 / 289.0)) * 289.0; }
fn mod289_3(x: vec3f) -> vec3f { return x - floor(x * (1.0 / 289.0)) * 289.0; }
fn permute(x: vec3f) -> vec3f { return mod289_3((x * 34.0 + 1.0) * x); }

fn simplexNoise2D(v: vec2f) -> f32 {
    let C = vec4f(
        0.211324865405187,  // (3.0-sqrt(3.0))/6.0
        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
        -0.577350269189626, // -1.0 + 2.0 * C.x
        0.024390243902439   // 1.0 / 41.0
    );

    // First corner
    var i = floor(v + dot(v, vec2f(C.y)));
    let x0 = v - i + dot(i, vec2f(C.x));

    // Other corners
    let i1 = select(vec2f(0.0, 1.0), vec2f(1.0, 0.0), x0.x > x0.y);
    var x12 = x0.xyxy + C.xxzz;
    x12 = vec4f(x12.xy - i1, x12.zw);

    // Permutations
    i = mod289_2(i);
    let p = permute(permute(i.y + vec3f(0.0, i1.y, 1.0)) + i.x + vec3f(0.0, i1.x, 1.0));

    var m = max(0.5 - vec3f(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), vec3f(0.0));
    m = m * m;
    m = m * m;

    // Gradients
    let x = 2.0 * fract(p * C.www) - 1.0;
    let h = abs(x) - 0.5;
    let ox = floor(x + 0.5);
    let a0 = x - ox;

    m = m * (1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h));

    let g = vec3f(
        a0.x * x0.x + h.x * x0.y,
        a0.y * x12.x + h.y * x12.y,
        a0.z * x12.z + h.z * x12.w
    );

    return (130.0 * dot(m, g)) * 0.5 + 0.5;
}

// ============================================
// WORLEY (CELLULAR) NOISE
// ============================================

fn worleyNoise2D(p: vec2f) -> f32 {
    let n = floor(p);
    let f = fract(p);

    var minDist = 1.0;

    for (var j = -1; j <= 1; j++) {
        for (var i = -1; i <= 1; i++) {
            let neighbor = vec2f(f32(i), f32(j));
            let point = hash22(n + neighbor);
            let diff = neighbor + point - f;
            let dist = length(diff);
            minDist = min(minDist, dist);
        }
    }

    return minDist;
}

fn worleyNoise2D_F1F2(p: vec2f) -> vec2f {
    let n = floor(p);
    let f = fract(p);

    var minDist1 = 1.0;
    var minDist2 = 1.0;

    for (var j = -1; j <= 1; j++) {
        for (var i = -1; i <= 1; i++) {
            let neighbor = vec2f(f32(i), f32(j));
            let point = hash22(n + neighbor);
            let diff = neighbor + point - f;
            let dist = length(diff);

            if (dist < minDist1) {
                minDist2 = minDist1;
                minDist1 = dist;
            } else if (dist < minDist2) {
                minDist2 = dist;
            }
        }
    }

    return vec2f(minDist1, minDist2);
}

// ============================================
// FBM (FRACTAL BROWNIAN MOTION)
// ============================================

fn fbm2D(p: vec2f, octaves: u32, lacunarity: f32, gain: f32) -> f32 {
    var value = 0.0;
    var amplitude = 0.5;
    var frequency = 1.0;
    var totalAmplitude = 0.0;
    var pos = p;

    for (var i = 0u; i < octaves; i++) {
        value += amplitude * valueNoise2D(pos * frequency);
        totalAmplitude += amplitude;
        amplitude *= gain;
        frequency *= lacunarity;
    }

    return value / totalAmplitude;
}

fn fbmPerlin2D(p: vec2f, octaves: u32, lacunarity: f32, gain: f32) -> f32 {
    var value = 0.0;
    var amplitude = 0.5;
    var frequency = 1.0;
    var totalAmplitude = 0.0;
    var pos = p;

    for (var i = 0u; i < octaves; i++) {
        value += amplitude * perlinNoise2D(pos * frequency);
        totalAmplitude += amplitude;
        amplitude *= gain;
        frequency *= lacunarity;
    }

    return value / totalAmplitude;
}

fn fbmSimplex2D(p: vec2f, octaves: u32, lacunarity: f32, gain: f32) -> f32 {
    var value = 0.0;
    var amplitude = 0.5;
    var frequency = 1.0;
    var totalAmplitude = 0.0;
    var pos = p;

    for (var i = 0u; i < octaves; i++) {
        value += amplitude * simplexNoise2D(pos * frequency);
        totalAmplitude += amplitude;
        amplitude *= gain;
        frequency *= lacunarity;
    }

    return value / totalAmplitude;
}

// ============================================
// RIDGED NOISE (for mountains)
// ============================================

fn ridgedNoise2D(p: vec2f) -> f32 {
    // Use Simplex noise for grid-free ridges (no directional artifacts)
    let n = simplexNoise2D(p);
    // Create ridge by folding: values near 0.5 become peaks
    return 1.0 - abs(n * 2.0 - 1.0);
}

fn ridgedFBM2D(p: vec2f, octaves: u32, lacunarity: f32, gain: f32) -> f32 {
    var value = 0.0;
    var amplitude = 0.5;
    var frequency = 1.0;
    var totalAmplitude = 0.0;
    var weight = 1.0;
    var pos = p;

    for (var i = 0u; i < octaves; i++) {
        let n = ridgedNoise2D(pos * frequency);
        // Softer signal shaping - use sqrt instead of square for less harsh peaks
        let signal = pow(n, 1.5) * weight;
        value += amplitude * signal;
        totalAmplitude += amplitude;

        // Gentler weight feedback
        weight = clamp(signal * 1.5, 0.0, 1.0);
        amplitude *= gain;
        frequency *= lacunarity;
    }

    return value / totalAmplitude;
}

// ============================================
// BILLOWY NOISE (for soft hills, clouds)
// ============================================

fn billowyNoise2D(p: vec2f) -> f32 {
    // Use Simplex noise for grid-free billows
    let n = simplexNoise2D(p);
    return abs(n * 2.0 - 1.0);
}

fn billowyFBM2D(p: vec2f, octaves: u32, lacunarity: f32, gain: f32) -> f32 {
    var value = 0.0;
    var amplitude = 0.5;
    var frequency = 1.0;
    var totalAmplitude = 0.0;
    var pos = p;

    for (var i = 0u; i < octaves; i++) {
        value += amplitude * billowyNoise2D(pos * frequency);
        totalAmplitude += amplitude;
        amplitude *= gain;
        frequency *= lacunarity;
    }

    return value / totalAmplitude;
}

// ============================================
// DOMAIN WARPING
// ============================================

fn warpedNoise2D(p: vec2f, warpStrength: f32, warpFrequency: f32) -> f32 {
    // Use Perlin noise for smoother warping
    let warp = vec2f(
        fbmPerlin2D(p * warpFrequency, 4u, 2.0, 0.5),
        fbmPerlin2D(p * warpFrequency + vec2f(5.2, 1.3), 4u, 2.0, 0.5)
    );
    return fbmPerlin2D(p + warp * warpStrength, 4u, 2.0, 0.5);
}

fn warpedRidged2D(p: vec2f, warpStrength: f32, warpFrequency: f32) -> f32 {
    // Use Perlin noise for smoother warping
    let warp = vec2f(
        fbmPerlin2D(p * warpFrequency, 4u, 2.0, 0.5),
        fbmPerlin2D(p * warpFrequency + vec2f(5.2, 1.3), 4u, 2.0, 0.5)
    );
    return ridgedFBM2D(p + warp * warpStrength, 6u, 2.0, 0.5);
}

// ============================================
// EROSION PATTERNS
// ============================================

// Simulate basic hydraulic erosion patterns
fn erosionPattern2D(p: vec2f, height: f32) -> f32 {
    // Use worley noise to create erosion channels
    let w = worleyNoise2D_F1F2(p * 4.0);
    let channels = smoothstep(0.0, 0.3, w.y - w.x);

    // Erosion is stronger at lower heights
    let erosionStrength = 1.0 - height;

    return mix(height, height * channels, erosionStrength * 0.3);
}

// ============================================
// TERRACING
// ============================================

fn terrace(value: f32, steps: f32) -> f32 {
    // Always use smooth terracing for better visuals
    return smoothTerrace(value, steps, 0.3);
}

fn smoothTerrace(value: f32, steps: f32, smoothness: f32) -> f32 {
    let t = value * steps;
    let floor_t = floor(t);
    let fract_t = fract(t);

    // Use a smoother S-curve for transitions between terraces
    // This creates flat plateaus with smooth ramps between them
    let edgeWidth = clamp(smoothness, 0.1, 0.45);

    // Remap fract_t so the flat part is in the middle
    var s: f32;
    if (fract_t < edgeWidth) {
        // Rising edge from previous terrace
        s = smoothstep(0.0, edgeWidth, fract_t) * 0.5;
    } else if (fract_t > 1.0 - edgeWidth) {
        // Rising edge to next terrace
        s = 0.5 + smoothstep(1.0 - edgeWidth, 1.0, fract_t) * 0.5;
    } else {
        // Flat plateau in the middle
        s = 0.5;
    }

    return (floor_t + s) / steps;
}

// Even smoother terrace with continuous slopes
fn smoothTerraceGradual(value: f32, steps: f32, smoothness: f32) -> f32 {
    let t = value * steps;
    let floor_t = floor(t);
    let fract_t = fract(t);

    // Hermite interpolation for C1 continuity
    let s = fract_t * fract_t * (3.0 - 2.0 * fract_t);

    // Blend between sharp terrace and smooth based on smoothness
    let sharpened = select(0.0, 1.0, fract_t > 0.5);
    let result = mix(sharpened, s, smoothness * 2.0);

    return (floor_t + result) / steps;
}

// ============================================
// CONTINENTAL NOISE
// Large-scale landmass shapes with detail
// ============================================

fn continentalBase(p: vec2f) -> f32 {
    // Use Voronoi-like cells for continent shapes
    let scale = 0.5;
    let w = worleyNoise2D_F1F2(p * scale);
    // F2 - F1 creates cell-like patterns good for continents
    return smoothstep(0.0, 0.5, w.y - w.x);
}

fn continentalNoise2D(p: vec2f, octaves: u32, lacunarity: f32, gain: f32) -> f32 {
    // Layer 1: Large-scale continental shapes
    let continentMask = continentalBase(p);

    // Layer 2: Mid-scale mountain ranges using ridged noise
    let ridges = ridgedFBM2D(p * 2.0, 4u, lacunarity, gain);

    // Layer 3: Small-scale detail using simplex
    let detail = fbmSimplex2D(p * 4.0, octaves, lacunarity, gain);

    // Combine: continents define where land is, ridges create mountains, detail adds texture
    var height = continentMask * 0.3; // Base continental height
    height += continentMask * ridges * 0.5; // Mountains only on continents
    height += detail * 0.2 * continentMask; // Detail everywhere there's land

    return clamp(height, 0.0, 1.0);
}

// ============================================
// HYBRID NOISE
// Intelligently combines multiple noise types
// ============================================

fn hybridMultifractal2D(p: vec2f, octaves: u32, lacunarity: f32, gain: f32, offset: f32) -> f32 {
    // Hybrid multifractal: smoother in valleys, rougher on peaks
    var result = (simplexNoise2D(p) + offset) * gain;
    var weight = result;
    var amplitude = gain;
    var frequency = lacunarity;

    for (var i = 1u; i < octaves; i++) {
        weight = clamp(weight, 0.0, 1.0);
        let signal = (simplexNoise2D(p * frequency) + offset) * amplitude;
        result += signal * weight;
        weight *= signal;
        amplitude *= gain;
        frequency *= lacunarity;
    }

    return clamp(result * 0.5, 0.0, 1.0);
}

fn swissNoise2D(p: vec2f, octaves: u32, lacunarity: f32, gain: f32) -> f32 {
    // Swiss turbulence: creates glacier-carved valley shapes
    var sum = 0.0;
    var amplitude = 1.0;
    var frequency = 1.0;
    var dsum = vec2f(0.0);

    for (var i = 0u; i < octaves; i++) {
        let n = simplexNoise2D((p + dsum * 0.5) * frequency);
        let dn = vec2f(
            simplexNoise2D((p + dsum * 0.5 + vec2f(0.01, 0.0)) * frequency) - n,
            simplexNoise2D((p + dsum * 0.5 + vec2f(0.0, 0.01)) * frequency) - n
        ) / 0.01;

        sum += amplitude * (1.0 - abs(n));
        dsum += amplitude * dn * -n;

        amplitude *= gain * clamp(sum, 0.0, 1.0);
        frequency *= lacunarity;
    }

    return clamp(sum * 0.5, 0.0, 1.0);
}

// ============================================
// CRATER NOISE
// Impact crater generation
// ============================================

fn craterProfile(dist: f32, radius: f32) -> f32 {
    let normalizedDist = dist / radius;

    if (normalizedDist > 1.5) {
        return 0.0; // Outside crater influence
    }

    if (normalizedDist < 0.3) {
        // Central peak (smoothstep requires low < high per WGSL spec)
        return (1.0 - smoothstep(0.0, 0.3, normalizedDist)) * 0.3;
    } else if (normalizedDist < 0.8) {
        // Crater floor
        return -0.3 * (1.0 - smoothstep(0.3, 0.8, normalizedDist));
    } else if (normalizedDist < 1.0) {
        // Crater rim (raised edge)
        let rimFactor = smoothstep(0.8, 1.0, normalizedDist);
        return mix(-0.1, 0.4, rimFactor);
    } else {
        // Outside rim - gentle slope back to base
        return 0.4 * (1.0 - smoothstep(1.0, 1.5, normalizedDist));
    }
}

fn singleCrater(p: vec2f, center: vec2f, radius: f32, rimHeight: f32) -> f32 {
    let dist = length(p - center);
    return craterProfile(dist, radius) * rimHeight;
}

fn craterField2D(p: vec2f, density: f32, sizeVariation: f32, seed: f32) -> f32 {
    // Generate multiple craters using cell-based placement
    let cellSize = 1.0 / density;
    let cell = floor(p / cellSize);

    var totalCrater = 0.0;

    // Check surrounding cells for craters
    for (var dy = -1; dy <= 1; dy++) {
        for (var dx = -1; dx <= 1; dx++) {
            let checkCell = cell + vec2f(f32(dx), f32(dy));
            let cellHash = hash21(checkCell + seed * 0.1);

            // Probability of crater in cell
            if (cellHash > 0.6) {
                // Random position within cell
                let craterPos = (checkCell + hash22(checkCell + seed * 0.2)) * cellSize;
                // Random size
                let craterRadius = 0.05 + cellHash * sizeVariation * 0.15;
                let rimHeight = 0.3 + hash21(checkCell * 2.0) * 0.4;

                totalCrater += singleCrater(p, craterPos, craterRadius, rimHeight);
            }
        }
    }

    return totalCrater;
}

// ============================================
// ISLAND NOISE
// Creates natural island shapes with beaches
// ============================================

fn islandMask(p: vec2f, center: vec2f, radius: f32, irregularity: f32) -> f32 {
    // Distance from center with noise-based irregularity
    let baseD = length(p - center) / radius;

    // Add noise to make coastline irregular
    let noise = fbmSimplex2D(p * 5.0, 3u, 2.0, 0.5);
    let d = baseD + (noise - 0.5) * irregularity;

    // Smooth falloff from center
    return 1.0 - smoothstep(0.3, 1.0, d);
}

fn islandNoise2D(p: vec2f, octaves: u32, lacunarity: f32, gain: f32) -> f32 {
    // Create island mask centered in terrain
    let islandFactor = islandMask(p, vec2f(0.5), 0.4, 0.3);

    // Base terrain using ridged noise for mountains
    let terrain = ridgedFBM2D(p * 2.0, octaves, lacunarity, gain);

    // Combine: island mask determines where land appears
    var height = islandFactor * terrain;

    // Add beach shelf at low elevations
    if (height > 0.0 && height < 0.15) {
        height = smoothstep(0.0, 0.15, height) * 0.15;
    }

    return clamp(height, 0.0, 1.0);
}
`;
var HeightmapComputeShader = `
${NoiseShaderLib}

// Configuration constants (set via specialization or uniforms)
const NOISE_VALUE: u32 = 0u;
const NOISE_PERLIN: u32 = 1u;
const NOISE_SIMPLEX: u32 = 2u;
const NOISE_RIDGED: u32 = 3u;
const NOISE_BILLOWY: u32 = 4u;
const NOISE_WORLEY: u32 = 5u;
const NOISE_CONTINENTAL: u32 = 6u;
const NOISE_HYBRID: u32 = 7u;
const NOISE_SWISS: u32 = 8u;
const NOISE_CRATER: u32 = 9u;
const NOISE_ISLAND: u32 = 10u;

struct HeightmapConfig {
    frequency: f32,
    amplitude: f32,
    lacunarity: f32,
    persistence: f32,
    octaves: u32,
    noiseType: u32,
    seed: f32,
    warpEnabled: u32,
    warpStrength: f32,
    warpFrequency: f32,
    terracing: u32,
    terraceCount: f32,
    smoothTerraces: u32,
    terraceSmooth: f32,
    erosion: u32,
    _pad: f32,
}

@group(0) @binding(0) var outputTexture: texture_storage_2d<r32float, write>;
@group(0) @binding(1) var<uniform> config: HeightmapConfig;

fn generateHeight(uv: vec2f) -> f32 {
    // Apply seed offset - use fract to keep values in reasonable range for float precision
    let seedX = fract(config.seed * 0.1031) * 100.0;
    let seedY = fract(config.seed * 0.0973) * 100.0;
    var p = uv * config.frequency + vec2f(seedX, seedY);

    // Apply domain warping if enabled (using Perlin for smoothness)
    if (config.warpEnabled != 0u) {
        let warp = vec2f(
            fbmPerlin2D(p * config.warpFrequency, 4u, 2.0, 0.5),
            fbmPerlin2D(p * config.warpFrequency + vec2f(5.2, 1.3), 4u, 2.0, 0.5)
        );
        p = p + warp * config.warpStrength;
    }

    // Generate base noise based on type
    var height = 0.0;

    switch (config.noiseType) {
        case NOISE_VALUE: {
            height = fbm2D(p, config.octaves, config.lacunarity, config.persistence);
        }
        case NOISE_PERLIN: {
            height = fbmPerlin2D(p, config.octaves, config.lacunarity, config.persistence);
        }
        case NOISE_SIMPLEX: {
            height = fbmSimplex2D(p, config.octaves, config.lacunarity, config.persistence);
        }
        case NOISE_RIDGED: {
            height = ridgedFBM2D(p, config.octaves, config.lacunarity, config.persistence);
        }
        case NOISE_BILLOWY: {
            height = billowyFBM2D(p, config.octaves, config.lacunarity, config.persistence);
        }
        case NOISE_WORLEY: {
            height = 1.0 - worleyNoise2D(p);
        }
        case NOISE_CONTINENTAL: {
            height = continentalNoise2D(p, config.octaves, config.lacunarity, config.persistence);
        }
        case NOISE_HYBRID: {
            height = hybridMultifractal2D(p, config.octaves, config.lacunarity, config.persistence, 0.7);
        }
        case NOISE_SWISS: {
            height = swissNoise2D(p, config.octaves, config.lacunarity, config.persistence);
        }
        case NOISE_CRATER: {
            // Base terrain with craters overlaid
            let baseTerrain = fbmSimplex2D(p, 4u, 2.0, 0.5) * 0.3;
            let craters = craterField2D(uv, 3.0, 0.5, config.seed);
            height = clamp(baseTerrain + craters, 0.0, 1.0);
        }
        case NOISE_ISLAND: {
            height = islandNoise2D(p, config.octaves, config.lacunarity, config.persistence);
        }
        default: {
            height = fbmPerlin2D(p, config.octaves, config.lacunarity, config.persistence);
        }
    }

    // Apply amplitude
    height *= config.amplitude;

    // Apply terracing if enabled
    if (config.terracing != 0u) {
        if (config.smoothTerraces != 0u) {
            height = smoothTerrace(height, config.terraceCount, config.terraceSmooth);
        } else {
            height = terrace(height, config.terraceCount);
        }
    }

    // Apply erosion pattern if enabled
    if (config.erosion != 0u) {
        height = erosionPattern2D(uv * 8.0, height);
    }

    return clamp(height, 0.0, 1.0);
}

@compute @workgroup_size(8, 8, 1)
fn main(@builtin(global_invocation_id) id: vec3u) {
    let dims = textureDimensions(outputTexture);
    if (id.x >= dims.x || id.y >= dims.y) { return; }

    let uv = vec2f(id.xy) / vec2f(dims);
    let height = generateHeight(uv);

    textureStore(outputTexture, id.xy, vec4f(height, 0.0, 0.0, 1.0));
}
`;

// ../../src/core/procedural/grass/GrassRenderer.ts
var INSTANCE_STRIDE = 12;

class GrassRenderer {
  config;
  device = null;
  initialized = false;
  instanceBuffer = null;
  vertexBuffer = null;
  indexBuffer = null;
  uniformBuffer = null;
  pipeline = null;
  bindGroup = null;
  bindGroupLayout = null;
  bladeTexture = null;
  bladeTextureView = null;
  sampler = null;
  instanceData = null;
  instanceCount = 0;
  vertexCount = 0;
  indexCount = 0;
  constructor(config) {
    this.config = config;
  }
  init(device, globalBindGroupLayout, bladeTexture) {
    this.device = device;
    const vertices = this.config.mode === "billboard" ? GrassRenderer.getBillboardVertices() : GrassRenderer.getGeometryVertices(this.config.segments, this.config.curvature);
    this.vertexCount = vertices.length / 5;
    this.vertexBuffer = device.createBuffer({
      label: "Grass Vertex Buffer",
      size: vertices.byteLength,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
      mappedAtCreation: true
    });
    new Float32Array(this.vertexBuffer.getMappedRange()).set(vertices);
    this.vertexBuffer.unmap();
    if (this.config.mode === "geometry") {
      const indices = GrassRenderer.getGeometryIndices(this.config.segments);
      this.indexCount = indices.length;
      this.indexBuffer = device.createBuffer({
        label: "Grass Index Buffer",
        size: indices.byteLength,
        usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,
        mappedAtCreation: true
      });
      new Uint16Array(this.indexBuffer.getMappedRange()).set(indices);
      this.indexBuffer.unmap();
    }
    const instanceBufferSize = this.config.maxInstances * INSTANCE_STRIDE * 4;
    this.instanceBuffer = device.createBuffer({
      label: "Grass Instance Buffer",
      size: instanceBufferSize,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
    });
    this.instanceData = new Float32Array(this.config.maxInstances * INSTANCE_STRIDE);
    this.uniformBuffer = device.createBuffer({
      label: "Grass Uniform Buffer",
      size: 64,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    if (bladeTexture) {
      this.bladeTexture = bladeTexture;
    } else {
      this.bladeTexture = device.createTexture({
        label: "Grass Default Texture",
        size: [1, 1],
        format: "rgba8unorm",
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
      });
      device.queue.writeTexture({ texture: this.bladeTexture }, new Uint8Array([255, 255, 255, 255]), { bytesPerRow: 4 }, { width: 1, height: 1 });
    }
    this.bladeTextureView = this.bladeTexture.createView();
    this.sampler = device.createSampler({
      label: "Grass Texture Sampler",
      magFilter: "linear",
      minFilter: "linear",
      mipmapFilter: "linear",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    });
    this.bindGroupLayout = device.createBindGroupLayout({
      label: "Grass Bind Group Layout",
      entries: [
        {
          binding: 0,
          visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
          buffer: { type: "uniform" }
        },
        {
          binding: 1,
          visibility: GPUShaderStage.FRAGMENT,
          texture: { sampleType: "float", viewDimension: "2d" }
        },
        {
          binding: 2,
          visibility: GPUShaderStage.FRAGMENT,
          sampler: { type: "filtering" }
        }
      ]
    });
    this.bindGroup = device.createBindGroup({
      label: "Grass Bind Group",
      layout: this.bindGroupLayout,
      entries: [
        { binding: 0, resource: { buffer: this.uniformBuffer } },
        { binding: 1, resource: this.bladeTextureView },
        { binding: 2, resource: this.sampler }
      ]
    });
    this.createPipeline(device, globalBindGroupLayout);
    this.initialized = true;
  }
  setBladeTexture(texture) {
    if (!this.device || !this.uniformBuffer || !this.sampler)
      return;
    this.bladeTexture = texture;
    this.bladeTextureView = texture.createView();
    this.bindGroup = this.device.createBindGroup({
      label: "Grass Bind Group",
      layout: this.bindGroupLayout,
      entries: [
        { binding: 0, resource: { buffer: this.uniformBuffer } },
        { binding: 1, resource: this.bladeTextureView },
        { binding: 2, resource: this.sampler }
      ]
    });
  }
  createPipeline(device, globalBindGroupLayout) {
    const vertexModule = device.createShaderModule({
      label: "Grass Vertex Shader",
      code: this.getVertexShaderCode()
    });
    const fragmentModule = device.createShaderModule({
      label: "Grass Fragment Shader",
      code: this.getFragmentShaderCode()
    });
    const pipelineLayout = device.createPipelineLayout({
      bindGroupLayouts: [globalBindGroupLayout, this.bindGroupLayout]
    });
    const vertexBuffers = [
      {
        arrayStride: 5 * 4,
        stepMode: "vertex",
        attributes: [
          { shaderLocation: 0, offset: 0, format: "float32x3" },
          { shaderLocation: 1, offset: 12, format: "float32x2" }
        ]
      },
      {
        arrayStride: INSTANCE_STRIDE * 4,
        stepMode: "instance",
        attributes: [
          { shaderLocation: 2, offset: 0, format: "float32x4" }
        ]
      },
      {
        arrayStride: INSTANCE_STRIDE * 4,
        stepMode: "instance",
        attributes: [
          { shaderLocation: 3, offset: 16, format: "float32x4" }
        ]
      },
      {
        arrayStride: INSTANCE_STRIDE * 4,
        stepMode: "instance",
        attributes: [
          { shaderLocation: 4, offset: 32, format: "float32x4" }
        ]
      }
    ];
    this.pipeline = device.createRenderPipeline({
      label: "Grass Render Pipeline",
      layout: pipelineLayout,
      vertex: {
        module: vertexModule,
        entryPoint: "vs_main",
        buffers: vertexBuffers
      },
      fragment: {
        module: fragmentModule,
        entryPoint: "fs_main",
        targets: [
          { format: "rgba16float" },
          { format: "rgba16float" },
          { format: "rgba16float" },
          { format: "rgba16float" },
          { format: "rg16float" }
        ]
      },
      primitive: {
        topology: "triangle-list",
        cullMode: "none"
      },
      depthStencil: {
        depthWriteEnabled: true,
        depthCompare: "less",
        format: "depth24plus"
      }
    });
  }
  uploadInstances(instances) {
    if (!this.device || !this.instanceBuffer || !this.instanceData)
      return;
    this.instanceCount = Math.min(instances.length, this.config.maxInstances);
    for (let i = 0;i < this.instanceCount; i++) {
      const inst = instances[i];
      const offset = i * INSTANCE_STRIDE;
      this.instanceData[offset + 0] = inst.position.x;
      this.instanceData[offset + 1] = inst.position.y;
      this.instanceData[offset + 2] = inst.position.z;
      this.instanceData[offset + 3] = inst.rotation;
      this.instanceData[offset + 4] = inst.scale;
      this.instanceData[offset + 5] = inst.random;
      this.instanceData[offset + 6] = 0;
      this.instanceData[offset + 7] = 0;
      this.instanceData[offset + 8] = inst.color.x;
      this.instanceData[offset + 9] = inst.color.y;
      this.instanceData[offset + 10] = inst.color.z;
      this.instanceData[offset + 11] = 1;
    }
    this.device.queue.writeBuffer(this.instanceBuffer, 0, this.instanceData.buffer, 0, this.instanceCount * INSTANCE_STRIDE * 4);
  }
  updateUniforms(viewProjMatrix, cameraPos, time, windDir, windStrength, windSpeed, turbulence, curvature = 0.5) {
    if (!this.device || !this.uniformBuffer)
      return;
    const data = new Float32Array(16);
    data[0] = windDir.x;
    data[1] = windDir.z;
    data[2] = windStrength;
    data[3] = windSpeed;
    data[4] = cameraPos.x;
    data[5] = cameraPos.y;
    data[6] = cameraPos.z;
    data[7] = time;
    data[8] = turbulence;
    data[9] = curvature;
    data[10] = 0;
    data[11] = 0;
    data[12] = 0;
    data[13] = 0;
    data[14] = 0;
    data[15] = 0;
    this.device.queue.writeBuffer(this.uniformBuffer, 0, data);
  }
  render(passEncoder, globalBindGroup) {
    if (!this.initialized || !this.pipeline || !this.bindGroup || this.instanceCount === 0)
      return;
    if (!this.vertexBuffer || !this.instanceBuffer)
      return;
    passEncoder.setPipeline(this.pipeline);
    passEncoder.setBindGroup(0, globalBindGroup);
    passEncoder.setBindGroup(1, this.bindGroup);
    passEncoder.setVertexBuffer(0, this.vertexBuffer);
    passEncoder.setVertexBuffer(1, this.instanceBuffer);
    passEncoder.setVertexBuffer(2, this.instanceBuffer);
    passEncoder.setVertexBuffer(3, this.instanceBuffer);
    if (this.config.mode === "geometry" && this.indexBuffer) {
      passEncoder.setIndexBuffer(this.indexBuffer, "uint16");
      passEncoder.drawIndexed(this.indexCount, this.instanceCount);
    } else {
      passEncoder.draw(this.vertexCount, this.instanceCount);
    }
  }
  getInstanceCount() {
    return this.instanceCount;
  }
  getVertexShaderCode() {
    return `
      // Noise functions for wind variation
      ${NoiseShaderLib}

      struct SceneUniforms {
        viewMatrix: mat4x4<f32>,
        projectionMatrix: mat4x4<f32>,
        lightViewProj: mat4x4<f32>,
        prevViewProj: mat4x4<f32>,
        inverseProjectionMatrix: mat4x4<f32>,
        cameraPosition: vec3f,
        time: f32,
        lightCount: u32,
        debugMode: u32,
        flags: u32,
        environmentIntensity: f32,
        fogColor: vec3f,
        fogDensity: f32,
        fogParams: vec4f,
        fogSettings: vec4u,
        // lights array omitted for grass
      }

      struct GrassUniforms {
        windDir: vec2f,
        windStrength: f32,
        windSpeed: f32,
        cameraPos: vec3f,
        time: f32,
        turbulence: f32,
        curvature: f32,
        _pad: vec2f,
      }

      @group(0) @binding(0) var<uniform> scene: SceneUniforms;
      @group(1) @binding(0) var<uniform> grass: GrassUniforms;

      struct VertexInput {
        @location(0) position: vec3f,
        @location(1) uv: vec2f,
        @location(2) instancePosRot: vec4f,   // position.xyz, rotation
        @location(3) instanceData: vec4f,     // scale, random, colorVar, unused
        @location(4) instanceColor: vec4f,    // color.rgb, unused
      }

      struct VertexOutput {
        @builtin(position) position: vec4f,
        @location(0) worldNormal: vec3f,
        @location(1) uv: vec2f,
        @location(2) worldPosition: vec3f,
        @location(3) currentClip: vec4f,
        @location(4) prevClip: vec4f,
        @location(5) color: vec3f,
      }

      @vertex
      fn vs_main(input: VertexInput) -> VertexOutput {
        var output: VertexOutput;

        let instancePos = input.instancePosRot.xyz;
        let rotation = input.instancePosRot.w;
        let scale = input.instanceData.x;
        let random = input.instanceData.y;
        let baseColor = input.instanceColor.rgb;

        // Rotate blade around Y axis
        let cosR = cos(rotation);
        let sinR = sin(rotation);
        var localPos = vec3f(
          input.position.x * cosR - input.position.z * sinR,
          input.position.y,
          input.position.x * sinR + input.position.z * cosR
        );

        // Scale blade
        localPos *= scale;

        // Height from base: UV.y is 1 at bottom, 0 at top
        // So (1 - uv.y) gives us 0 at bottom, 1 at top
        let heightFromBase = 1.0 - input.uv.y;

        // TRUE BEZIER CURVE for grass blade shape
        // t goes from 0 (base) to 1 (tip)
        let t = heightFromBase;
        let oneMinusT = 1.0 - t;
        let oneMinusT2 = oneMinusT * oneMinusT;
        let oneMinusT3 = oneMinusT2 * oneMinusT;
        let t2 = t * t;
        let t3 = t2 * t;

        // Each blade has a random lean direction
        let naturalBendDir = random * 6.28318; // Random direction in radians

        // Use second random value for curvature variation (derived from first)
        let random2 = fract(sin(random * 12345.6789) * 43758.5453);
        let random3 = fract(sin(random2 * 98765.4321) * 12345.6789);

        // Cubic bezier control points for X displacement (as function of height t)
        // P0 = 0 (base - no displacement)
        // P1 = near 0 (keeps base tangent nearly vertical)
        // P2 = bulge amount (how much the blade curves outward)
        // P3 = tip displacement (can be less than P2 for droop effect)
        //
        // Cubic bezier: B(t) = (1-t)³P0 + 3(1-t)²t*P1 + 3(1-t)t²*P2 + t³P3

        // Vary the control points per blade for natural variation
        let p1 = 0.0 + random3 * 0.1;  // 0.0 to 0.1 - keeps base vertical
        let p2 = 1.0 + random2 * 0.8;   // 1.0 to 1.8 - bulge amount
        let p3 = 0.5 + random3 * 0.5;   // 0.5 to 1.0 - tip position (droop)

        // Calculate bezier curve value for horizontal displacement
        let bezierCurve = 3.0 * oneMinusT2 * t * p1
                        + 3.0 * oneMinusT * t2 * p2
                        + t3 * p3;

        // Curvature amount varies per blade
        let bladeCurvature = grass.curvature * (0.3 + random2 * 1.2) * scale;

        // Apply bezier curve displacement
        let naturalBendX = cos(naturalBendDir) * bezierCurve * bladeCurvature;
        let naturalBendZ = sin(naturalBendDir) * bezierCurve * bladeCurvature;

        // Apply natural curve
        localPos.x += naturalBendX;
        localPos.z += naturalBendZ;

        // Height influence for wind (still quadratic, zero at base)
        let heightInfluence = t2;

        // Wind animation (stronger at top of blade, zero at base)
        // Sample noise for wind variation
        let noisePos = instancePos.xz * 0.05 + vec2f(grass.time * grass.windSpeed * 0.3);
        let windNoise = simplexNoise2D(noisePos) * 2.0 - 1.0;

        // Secondary turbulence layer
        let turbNoisePos = instancePos.xz * 0.2 + vec2f(grass.time * grass.windSpeed * 0.7 + random * 10.0);
        let turbNoise = simplexNoise2D(turbNoisePos) * grass.turbulence;

        // Calculate wind offset
        let windPhase = grass.time * grass.windSpeed + random * 6.28318;
        let windWave = sin(windPhase) * 0.5 + 0.5;

        let windOffsetX = grass.windDir.x * grass.windStrength * heightInfluence *
                          (windWave + windNoise * 0.3 + turbNoise);
        let windOffsetZ = grass.windDir.y * grass.windStrength * heightInfluence *
                          (windWave * 0.7 + windNoise * 0.3 + turbNoise);

        localPos.x += windOffsetX;
        localPos.z += windOffsetZ;

        // Slight vertical compression when bent (based on total bend)
        let totalBend = length(vec2f(naturalBendX + windOffsetX, naturalBendZ + windOffsetZ));
        localPos.y *= 1.0 - totalBend * 0.15;

        // World position
        let worldPos = localPos + instancePos;

        // Calculate normal (approximation for grass blade)
        // Normal points outward from center of blade, more upward at base
        var normal = vec3f(
          -sinR * (0.5 + heightFromBase * 0.5),
          1.0 - heightFromBase * 0.5,
          cosR * (0.5 + heightFromBase * 0.5)
        );
        normal = normalize(normal);

        // Perturb normal based on total bend (natural + wind)
        normal.x += (naturalBendX + windOffsetX) * 0.5;
        normal.z += (naturalBendZ + windOffsetZ) * 0.5;
        normal = normalize(normal);

        let viewPos = scene.viewMatrix * vec4f(worldPos, 1.0);
        let clipPos = scene.projectionMatrix * viewPos;

        output.position = clipPos;
        output.currentClip = clipPos;
        output.prevClip = scene.prevViewProj * vec4f(worldPos, 1.0);
        output.worldPosition = worldPos;
        output.worldNormal = normal;
        output.uv = input.uv;

        // Color variation based on height (darker at base, lighter at tip)
        let heightGradient = mix(0.6, 1.0, heightFromBase);
        output.color = baseColor * heightGradient;

        return output;
      }
    `;
  }
  getFragmentShaderCode() {
    return `
      @group(1) @binding(1) var bladeTexture: texture_2d<f32>;
      @group(1) @binding(2) var bladeSampler: sampler;

      struct FragmentInput {
        @location(0) worldNormal: vec3f,
        @location(1) uv: vec2f,
        @location(2) worldPosition: vec3f,
        @location(3) currentClip: vec4f,
        @location(4) prevClip: vec4f,
        @location(5) color: vec3f,
      }

      struct FragmentOutput {
        @location(0) albedo: vec4f,    // RGB = Color, A = Roughness
        @location(1) normal: vec4f,    // RGB = Normal, A = Metalness
        @location(2) position: vec4f,  // RGB = World Position, A = Occlusion
        @location(3) emissive: vec4f,  // RGB = Emissive, A = Unused
        @location(4) velocity: vec2f,  // RG = Velocity
      }

      @fragment
      fn fs_main(input: FragmentInput) -> FragmentOutput {
        var output: FragmentOutput;

        // Sample blade texture
        let texColor = textureSample(bladeTexture, bladeSampler, input.uv);

        // Alpha test - discard fully transparent pixels
        if (texColor.a < 0.1) {
          discard;
        }

        // Blend texture color with instance color
        // Texture provides shape and base coloring, instance provides variation
        let finalColor = texColor.rgb * input.color * 1.5;

        // Grass is not metallic, fairly rough
        let roughness = 0.8;
        let metallic = 0.0;
        let occlusion = mix(0.7, 1.0, input.uv.y); // Darker at base

        // Normalize the normal
        let N = normalize(input.worldNormal);

        // Velocity for TAA
        let currentNDC = input.currentClip.xy / input.currentClip.w;
        let prevNDC = input.prevClip.xy / input.prevClip.w;
        let velocity = (currentNDC - prevNDC) * 0.5;

        output.albedo = vec4f(finalColor, roughness);
        output.normal = vec4f(N * 0.5 + 0.5, metallic);
        output.position = vec4f(input.worldPosition, occlusion);
        output.emissive = vec4f(0.0, 0.0, 0.0, 1.0);
        output.velocity = vec2f(velocity.x, -velocity.y);

        return output;
      }
    `;
  }
  static getBillboardVertices() {
    return new Float32Array([
      -0.5,
      0,
      0,
      0,
      1,
      0.5,
      0,
      0,
      1,
      1,
      0.5,
      1,
      0,
      1,
      0,
      -0.5,
      0,
      0,
      0,
      1,
      0.5,
      1,
      0,
      1,
      0,
      -0.5,
      1,
      0,
      0,
      0
    ]);
  }
  static getGeometryVertices(segments, curvature) {
    const vertices = [];
    for (let i = 0;i <= segments; i++) {
      const t = i / segments;
      const y = t;
      const width = 1 - t * 0.8;
      const curve = curvature * t * t;
      vertices.push(-0.5 * width, y, curve, 0, 1 - t);
      vertices.push(0.5 * width, y, curve, 1, 1 - t);
    }
    return new Float32Array(vertices);
  }
  static getGeometryIndices(segments) {
    const indices = [];
    for (let i = 0;i < segments; i++) {
      const bl = i * 2;
      const br = i * 2 + 1;
      const tl = (i + 1) * 2;
      const tr = (i + 1) * 2 + 1;
      indices.push(bl, br, tr);
      indices.push(bl, tr, tl);
    }
    return new Uint16Array(indices);
  }
  destroy() {
    this.vertexBuffer?.destroy();
    this.indexBuffer?.destroy();
    this.instanceBuffer?.destroy();
    this.uniformBuffer?.destroy();
    this.vertexBuffer = null;
    this.indexBuffer = null;
    this.instanceBuffer = null;
    this.uniformBuffer = null;
    this.pipeline = null;
    this.bindGroup = null;
    this.bindGroupLayout = null;
    this.instanceData = null;
    this.device = null;
    this.initialized = false;
  }
}

// ../../src/core/procedural/grass/GrassTextureGenerator.ts
var DEFAULT_GRASS_TEXTURE_CONFIG = {
  width: 256,
  height: 256,
  bladeCount: 12,
  baseColor: { r: 0.15, g: 0.35, b: 0.08 },
  tipColor: { r: 0.3, g: 0.55, b: 0.15 },
  colorVariation: 0.15,
  bladeWidth: 8,
  curvature: 0.4,
  seed: 12345,
  noisy: true
};
function createRng(seed) {
  return function() {
    let t = seed += 1831565813;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}

class GrassTextureGenerator {
  config;
  constructor(config = {}) {
    this.config = { ...DEFAULT_GRASS_TEXTURE_CONFIG, ...config };
  }
  generate() {
    const { width, height } = this.config;
    const imageData = new ImageData(width, height);
    const data = imageData.data;
    for (let i = 0;i < data.length; i += 4) {
      data[i] = 0;
      data[i + 1] = 0;
      data[i + 2] = 0;
      data[i + 3] = 0;
    }
    const rng = createRng(this.config.seed);
    for (let b = 0;b < this.config.bladeCount; b++) {
      this.drawBlade(data, width, height, rng);
    }
    return imageData;
  }
  generateTexture(device) {
    const imageData = this.generate();
    const texture = device.createTexture({
      label: "Grass Blade Texture",
      size: [this.config.width, this.config.height],
      format: "rgba8unorm",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
    });
    device.queue.writeTexture({ texture }, imageData.data, { bytesPerRow: this.config.width * 4 }, { width: this.config.width, height: this.config.height });
    return texture;
  }
  drawBlade(data, width, height, rng) {
    const { baseColor, tipColor, colorVariation, bladeWidth, curvature, noisy } = this.config;
    const startX = width * 0.1 + rng() * width * 0.8;
    const bladeHeight = 0.6 + rng() * 0.4;
    const curveDir = (rng() - 0.5) * 2;
    const curveAmount = curvature * (0.5 + rng() * 0.5);
    const thisBladeWidth = bladeWidth * (0.5 + rng() * 0.5);
    const colorMult = 1 + (rng() - 0.5) * colorVariation * 2;
    const maxY = Math.floor(height * bladeHeight);
    for (let y = height - 1;y >= height - maxY; y--) {
      const normalizedY = (height - 1 - y) / maxY;
      const curveOffset = curveDir * curveAmount * width * 0.3 * normalizedY * normalizedY;
      const centerX = startX + curveOffset;
      const widthAtY = thisBladeWidth * (1 - normalizedY * 0.85);
      const leftX = Math.floor(centerX - widthAtY / 2);
      const rightX = Math.ceil(centerX + widthAtY / 2);
      for (let x = leftX;x <= rightX; x++) {
        if (x < 0 || x >= width)
          continue;
        const distFromCenter = Math.abs(x - centerX) / (widthAtY / 2 + 0.001);
        let alpha = 1 - Math.pow(distFromCenter, 2);
        alpha = Math.max(0, Math.min(1, alpha));
        if (normalizedY > 0.85) {
          alpha *= 1 - (normalizedY - 0.85) / 0.15;
        }
        if (noisy) {
          alpha *= 0.85 + rng() * 0.15;
        }
        if (alpha <= 0)
          continue;
        const r = baseColor.r + (tipColor.r - baseColor.r) * normalizedY;
        const g = baseColor.g + (tipColor.g - baseColor.g) * normalizedY;
        const b = baseColor.b + (tipColor.b - baseColor.b) * normalizedY;
        const finalR = Math.max(0, Math.min(1, r * colorMult));
        const finalG = Math.max(0, Math.min(1, g * colorMult));
        const finalB = Math.max(0, Math.min(1, b * colorMult));
        const idx = (y * width + x) * 4;
        const existingAlpha = data[idx + 3] / 255;
        const newAlpha = alpha;
        const outAlpha = newAlpha + existingAlpha * (1 - newAlpha);
        if (outAlpha > 0) {
          data[idx] = Math.round((finalR * 255 * newAlpha + data[idx] * existingAlpha * (1 - newAlpha)) / outAlpha);
          data[idx + 1] = Math.round((finalG * 255 * newAlpha + data[idx + 1] * existingAlpha * (1 - newAlpha)) / outAlpha);
          data[idx + 2] = Math.round((finalB * 255 * newAlpha + data[idx + 2] * existingAlpha * (1 - newAlpha)) / outAlpha);
          data[idx + 3] = Math.round(outAlpha * 255);
        }
      }
    }
  }
  getConfig() {
    return { ...this.config };
  }
  setConfig(config) {
    this.config = { ...this.config, ...config };
  }
}

// ../../src/core/procedural/grass/Grass.ts
var DEFAULT_GRASS_CONFIG = {
  densityMode: true,
  blade: {
    height: { min: 0.3, max: 0.8 },
    width: { min: 0.02, max: 0.05 },
    segments: 3,
    curvature: 0.3
  },
  colorVariation: 0.1,
  wind: {
    enabled: true,
    direction: { x: 1, z: 0 },
    strength: 0.5,
    speed: 1,
    turbulence: 0.3
  },
  renderMode: "billboard",
  bladesPerTexture: 8,
  maxDistance: 100,
  lodDistances: [20, 50, 80],
  seed: 12345,
  curvature: 0.8
};
function createRng2(seed) {
  return function() {
    let t = seed += 1831565813;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}

class Grass extends Node {
  config;
  device = null;
  initialized = false;
  renderer = null;
  instances = [];
  globalResources = null;
  heightMapData = null;
  heightMapWidth = 0;
  heightMapHeight = 0;
  constructor(config) {
    super();
    this.config = { ...DEFAULT_GRASS_CONFIG, ...config };
    if (config.blade) {
      this.config.blade = { ...DEFAULT_GRASS_CONFIG.blade, ...config.blade };
    }
    if (config.wind) {
      this.config.wind = { ...DEFAULT_GRASS_CONFIG.wind, ...config.wind };
    }
  }
  async init(device, globalResources) {
    this.device = device;
    this.globalResources = globalResources || null;
    let sceneBindGroupLayout;
    if (globalResources?.renderBindGroupLayout) {
      sceneBindGroupLayout = globalResources.renderBindGroupLayout;
    } else {
      sceneBindGroupLayout = device.createBindGroupLayout({
        label: "Grass Scene Bind Group Layout (Standalone)",
        entries: [
          {
            binding: 0,
            visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
            buffer: { type: "uniform" }
          }
        ]
      });
    }
    const textureGenerator = new GrassTextureGenerator({
      width: 256,
      height: 256,
      bladeCount: this.config.bladesPerTexture || 8,
      baseColor: {
        r: this.config.color.x * 0.7,
        g: this.config.color.y * 0.7,
        b: this.config.color.z * 0.7
      },
      tipColor: {
        r: Math.min(1, this.config.color.x * 1.3),
        g: Math.min(1, this.config.color.y * 1.3),
        b: Math.min(1, this.config.color.z * 1.3)
      },
      colorVariation: this.config.colorVariation || 0.15,
      bladeWidth: 12,
      curvature: 0.5,
      seed: this.config.seed || 12345,
      noisy: true,
      ...this.config.texture
    });
    const bladeTexture = textureGenerator.generateTexture(device);
    const bladeCount = this.getBladeCount();
    const maxInstances = Math.max(bladeCount, 500000);
    this.renderer = new GrassRenderer({
      maxInstances,
      verticesPerBlade: this.config.renderMode === "billboard" ? 6 : (this.config.blade.segments + 1) * 2,
      alphaToCoverage: true,
      mode: this.config.renderMode === "geometry" ? "geometry" : "billboard",
      segments: this.config.blade.segments || 3,
      curvature: this.config.blade.curvature || 0.3
    });
    this.renderer.init(device, sceneBindGroupLayout, bladeTexture);
    this.generateInstances();
    this.renderer.uploadInstances(this.instances);
    this.initialized = true;
    console.log(`Grass: Initialized with ${this.instances.length} blades`);
  }
  generateInstances() {
    const rng = createRng2(this.config.seed || 12345);
    const width = this.config.area.width;
    const depth = this.config.area.depth;
    const offset = this.config.offset || new Vector3(0, 0, 0);
    const area = width * depth;
    const totalBlades = Math.floor(this.config.density * area);
    this.instances = [];
    for (let i = 0;i < totalBlades; i++) {
      const x = (rng() - 0.5) * width + offset.x;
      const z = (rng() - 0.5) * depth + offset.z;
      const y = this.getHeightAtLocal(x - offset.x, z - offset.z) + offset.y;
      const rotation = rng() * Math.PI * 2;
      const heightRange = this.config.blade.height.max - this.config.blade.height.min;
      const height = this.config.blade.height.min + rng() * heightRange;
      const widthRange = this.config.blade.width.max - this.config.blade.width.min;
      const bladeWidth = this.config.blade.width.min + rng() * widthRange;
      const colorVar = this.config.colorVariation || 0;
      const colorMult = 1 + (rng() - 0.5) * colorVar * 2;
      const color = new Vector3(Math.max(0, Math.min(1, this.config.color.x * colorMult)), Math.max(0, Math.min(1, this.config.color.y * colorMult)), Math.max(0, Math.min(1, this.config.color.z * colorMult)));
      const random = rng();
      this.instances.push({
        position: new Vector3(x, y, z),
        rotation,
        scale: height * bladeWidth * 10,
        color,
        random
      });
    }
  }
  getHeightAtLocal(x, z) {
    if (!this.heightMapData || this.heightMapWidth === 0 || this.heightMapHeight === 0) {
      return 0;
    }
    const halfWidth = this.config.area.width / 2;
    const halfDepth = this.config.area.depth / 2;
    const u = (x + halfWidth) / this.config.area.width;
    const v = (z + halfDepth) / this.config.area.depth;
    const clampedU = Math.max(0, Math.min(1, u));
    const clampedV = Math.max(0, Math.min(1, v));
    const px = clampedU * (this.heightMapWidth - 1);
    const py = clampedV * (this.heightMapHeight - 1);
    const x0 = Math.floor(px);
    const y0 = Math.floor(py);
    const x1 = Math.min(x0 + 1, this.heightMapWidth - 1);
    const y1 = Math.min(y0 + 1, this.heightMapHeight - 1);
    const fx = px - x0;
    const fy = py - y0;
    const h00 = this.heightMapData[y0 * this.heightMapWidth + x0];
    const h10 = this.heightMapData[y0 * this.heightMapWidth + x1];
    const h01 = this.heightMapData[y1 * this.heightMapWidth + x0];
    const h11 = this.heightMapData[y1 * this.heightMapWidth + x1];
    const h0 = h00 * (1 - fx) + h10 * fx;
    const h1 = h01 * (1 - fx) + h11 * fx;
    return h0 * (1 - fy) + h1 * fy;
  }
  setHeightMap(data, width, height) {
    this.heightMapData = data;
    this.heightMapWidth = width;
    this.heightMapHeight = height;
    if (this.initialized) {
      this.generateInstances();
      this.renderer?.uploadInstances(this.instances);
    }
  }
  update(time, cameraPosition) {
    if (!this.initialized || !this.device || !this.renderer)
      return;
    const wind = this.config.wind;
    this.renderer.updateUniforms(new Float32Array(16), cameraPosition || new Vector3(0, 0, 0), time, wind.enabled ? wind.direction : { x: 0, z: 0 }, wind.enabled ? wind.strength : 0, wind.speed, wind.turbulence, this.config.curvature || 0.5);
  }
  render(passEncoder, globalBindGroup) {
    if (!this.initialized || !this.renderer)
      return;
    const bindGroup = globalBindGroup || this.globalResources?.renderBindGroup;
    if (!bindGroup) {
      console.warn("Grass.render: No bind group available");
      return;
    }
    this.renderer.render(passEncoder, bindGroup);
  }
  getGlobalResources() {
    return this.globalResources;
  }
  getRenderer() {
    return this.renderer;
  }
  setDensity(density) {
    this.config.density = Math.max(0, density);
    if (this.initialized) {
      this.regenerate();
    }
  }
  async setTextureFromURL(url) {
    if (!this.device || !this.renderer)
      return;
    const img = new Image;
    img.crossOrigin = "anonymous";
    await new Promise((resolve, reject) => {
      img.onload = () => resolve();
      img.onerror = () => reject(new Error("Failed to load image"));
      img.src = url;
    });
    const imageBitmap = await createImageBitmap(img);
    const texture = this.device.createTexture({
      label: `Grass Texture: ${url.slice(0, 50)}`,
      size: [imageBitmap.width, imageBitmap.height],
      format: "rgba8unorm",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
    });
    this.device.queue.copyExternalImageToTexture({ source: imageBitmap }, { texture }, [imageBitmap.width, imageBitmap.height]);
    this.renderer.setBladeTexture(texture);
    console.log(`Grass: Set custom texture (${imageBitmap.width}x${imageBitmap.height})`);
  }
  resetToProceduralTexture() {
    if (!this.device || !this.renderer)
      return;
    const textureGenerator = new GrassTextureGenerator({
      width: 256,
      height: 256,
      bladeCount: this.config.bladesPerTexture || 8,
      baseColor: {
        r: this.config.color.x * 0.7,
        g: this.config.color.y * 0.7,
        b: this.config.color.z * 0.7
      },
      tipColor: {
        r: Math.min(1, this.config.color.x * 1.3),
        g: Math.min(1, this.config.color.y * 1.3),
        b: Math.min(1, this.config.color.z * 1.3)
      },
      colorVariation: this.config.colorVariation || 0.15,
      bladeWidth: 12,
      curvature: 0.5,
      seed: this.config.seed || 12345,
      noisy: true,
      ...this.config.texture
    });
    const bladeTexture = textureGenerator.generateTexture(this.device);
    this.renderer.setBladeTexture(bladeTexture);
    console.log("Grass: Reset to procedural texture");
  }
  setWind(wind) {
    this.config.wind = { ...this.config.wind, ...wind };
  }
  setCurvature(curvature) {
    this.config.curvature = Math.max(0, Math.min(2, curvature));
  }
  setColor(color) {
    this.config.color = color;
    if (this.initialized) {
      for (const inst of this.instances) {
        const colorVar = this.config.colorVariation || 0;
        const rng = createRng2(Math.floor(inst.random * 1e4));
        const colorMult = 1 + (rng() - 0.5) * colorVar * 2;
        inst.color = new Vector3(Math.max(0, Math.min(1, color.x * colorMult)), Math.max(0, Math.min(1, color.y * colorMult)), Math.max(0, Math.min(1, color.z * colorMult)));
      }
      this.renderer?.uploadInstances(this.instances);
    }
  }
  setConfig(config) {
    const needsRegenerate = config.area !== undefined || config.density !== undefined || config.blade !== undefined || config.seed !== undefined;
    this.config = { ...this.config, ...config };
    if (config.blade) {
      this.config.blade = { ...this.config.blade, ...config.blade };
    }
    if (config.wind) {
      this.config.wind = { ...this.config.wind, ...config.wind };
    }
    if (this.initialized && needsRegenerate) {
      console.log(`Grass.setConfig: regenerating with area=${this.config.area.width}x${this.config.area.depth}, density=${this.config.density}`);
      this.regenerate();
    }
  }
  async regenerate() {
    if (!this.device || !this.renderer)
      return;
    this.generateInstances();
    this.renderer.uploadInstances(this.instances);
    console.log(`Grass: Regenerated with ${this.instances.length} blades`);
  }
  getConfig() {
    return { ...this.config };
  }
  getBladeCount() {
    const area = this.config.area.width * this.config.area.depth;
    return Math.floor(this.config.density * area);
  }
  getInstanceCount() {
    return this.renderer?.getInstanceCount() || 0;
  }
  getDensityAt(_x, _z) {
    return 1;
  }
  destroy() {
    this.renderer?.destroy();
    this.renderer = null;
    this.globalResources = null;
    this.instances = [];
    this.device = null;
    this.initialized = false;
  }
}

// ../../src/core/procedural/flowers/FlowerTextureGenerator.ts
var DEFAULT_FLOWER_TEXTURE_CONFIG = {
  width: 64,
  height: 64,
  flowerType: "daisy",
  petalCount: 8,
  petalColor: { r: 1, g: 1, b: 1 },
  centerColor: { r: 1, g: 0.8, b: 0.2 },
  stemColor: { r: 0.2, g: 0.5, b: 0.15 },
  colorVariation: 0.1,
  seed: 12345
};
function createRng3(seed) {
  return function() {
    let t = seed += 1831565813;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}

class FlowerTextureGenerator {
  config;
  constructor(config = {}) {
    this.config = { ...DEFAULT_FLOWER_TEXTURE_CONFIG, ...config };
  }
  generateTexture(device) {
    const { width, height } = this.config;
    const data = new Uint8Array(width * height * 4);
    this.drawFlower(data, width, height);
    const texture = device.createTexture({
      label: `Flower Texture (${this.config.flowerType})`,
      size: [width, height],
      format: "rgba8unorm",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
    });
    device.queue.writeTexture({ texture }, data, { bytesPerRow: width * 4 }, { width, height });
    return texture;
  }
  drawFlower(data, width, height) {
    const rng = createRng3(this.config.seed);
    const centerX = width / 2;
    const centerY = height * 0.35;
    for (let i = 0;i < data.length; i += 4) {
      data[i] = 0;
      data[i + 1] = 0;
      data[i + 2] = 0;
      data[i + 3] = 0;
    }
    this.drawStem(data, width, height, centerX, centerY, rng);
    switch (this.config.flowerType) {
      case "daisy":
        this.drawDaisy(data, width, height, centerX, centerY, rng);
        break;
      case "poppy":
        this.drawPoppy(data, width, height, centerX, centerY, rng);
        break;
      case "dandelion":
        this.drawDandelion(data, width, height, centerX, centerY, rng);
        break;
      case "bluebell":
        this.drawBluebell(data, width, height, centerX, centerY, rng);
        break;
      case "tulip":
        this.drawTulip(data, width, height, centerX, centerY, rng);
        break;
      case "wildflower":
        this.drawWildflower(data, width, height, centerX, centerY, rng);
        break;
    }
  }
  drawStem(data, width, height, topX, topY, rng) {
    const stemWidth = Math.max(1, width * 0.06);
    const stemTop = topY + height * 0.08;
    const stemBottom = height - 2;
    for (let y = Math.floor(stemTop);y < stemBottom; y++) {
      const t = (y - stemTop) / (stemBottom - stemTop);
      const curve = Math.sin(t * Math.PI * 0.5) * width * 0.05;
      const x = topX + curve;
      const stemWidthAtY = stemWidth * (1 - t * 0.3);
      for (let dx = -stemWidthAtY;dx <= stemWidthAtY; dx++) {
        const px = Math.floor(x + dx);
        if (px >= 0 && px < width && y >= 0 && y < height) {
          const idx = (y * width + px) * 4;
          const colorVar = (rng() - 0.5) * this.config.colorVariation;
          data[idx] = Math.floor((this.config.stemColor.r + colorVar) * 255);
          data[idx + 1] = Math.floor((this.config.stemColor.g + colorVar) * 255);
          data[idx + 2] = Math.floor((this.config.stemColor.b + colorVar) * 255);
          data[idx + 3] = 255;
        }
      }
    }
  }
  drawDaisy(data, width, height, centerX, centerY, rng) {
    const petalLength = height * 0.25;
    const petalWidth = width * 0.08;
    const centerRadius = height * 0.08;
    for (let i = 0;i < this.config.petalCount; i++) {
      const angle = i / this.config.petalCount * Math.PI * 2 + rng() * 0.2;
      this.drawPetal(data, width, height, centerX, centerY, angle, petalLength, petalWidth, rng);
    }
    this.drawCircle(data, width, height, centerX, centerY, centerRadius, this.config.centerColor, rng);
  }
  drawPoppy(data, width, height, centerX, centerY, rng) {
    const petalRadius = height * 0.28;
    const centerRadius = height * 0.06;
    for (let i = 0;i < 5; i++) {
      const angle = i / 5 * Math.PI * 2 + rng() * 0.3;
      const px = centerX + Math.cos(angle) * petalRadius * 0.4;
      const py = centerY + Math.sin(angle) * petalRadius * 0.4;
      this.drawCircle(data, width, height, px, py, petalRadius * 0.8, this.config.petalColor, rng);
    }
    this.drawCircle(data, width, height, centerX, centerY, centerRadius, { r: 0.1, g: 0.1, b: 0.1 }, rng);
  }
  drawDandelion(data, width, height, centerX, centerY, rng) {
    const radius = height * 0.3;
    const seedCount = 30;
    for (let i = 0;i < seedCount; i++) {
      const angle = rng() * Math.PI * 2;
      const dist = rng() * radius;
      const px = centerX + Math.cos(angle) * dist;
      const py = centerY + Math.sin(angle) * dist;
      const seedRadius = 1 + rng() * 2;
      const brightness = 0.9 + rng() * 0.1;
      this.drawCircle(data, width, height, px, py, seedRadius, { r: brightness, g: brightness, b: brightness }, rng);
    }
  }
  drawBluebell(data, width, height, centerX, centerY, rng) {
    const bellWidth = width * 0.3;
    const bellHeight = height * 0.25;
    for (let y = Math.floor(centerY - bellHeight * 0.3);y < centerY + bellHeight; y++) {
      const t = (y - (centerY - bellHeight * 0.3)) / (bellHeight * 1.3);
      const widthAtY = bellWidth * (0.3 + t * 0.7) * Math.sqrt(1 - Math.pow(t - 0.7, 2) / 0.5);
      for (let x = Math.floor(centerX - widthAtY);x < centerX + widthAtY; x++) {
        if (x >= 0 && x < width && y >= 0 && y < height) {
          const idx = (y * width + x) * 4;
          const colorVar = (rng() - 0.5) * this.config.colorVariation;
          data[idx] = Math.floor((this.config.petalColor.r * 0.3 + colorVar) * 255);
          data[idx + 1] = Math.floor((this.config.petalColor.g * 0.4 + colorVar) * 255);
          data[idx + 2] = Math.floor((this.config.petalColor.b * 1 + colorVar) * 255);
          data[idx + 3] = 255;
        }
      }
    }
  }
  drawTulip(data, width, height, centerX, centerY, rng) {
    const tulipWidth = width * 0.25;
    const tulipHeight = height * 0.35;
    for (let y = Math.floor(centerY - tulipHeight * 0.5);y < centerY + tulipHeight * 0.5; y++) {
      const t = (y - (centerY - tulipHeight * 0.5)) / tulipHeight;
      const shape = Math.sin(t * Math.PI) * 0.7 + 0.3;
      const widthAtY = tulipWidth * shape;
      for (let x = Math.floor(centerX - widthAtY);x < centerX + widthAtY; x++) {
        if (x >= 0 && x < width && y >= 0 && y < height) {
          const idx = (y * width + x) * 4;
          const colorVar = (rng() - 0.5) * this.config.colorVariation;
          const edgeFactor = Math.abs(x - centerX) / widthAtY;
          const shade = 1 - edgeFactor * 0.3;
          data[idx] = Math.floor((this.config.petalColor.r * shade + colorVar) * 255);
          data[idx + 1] = Math.floor((this.config.petalColor.g * shade + colorVar) * 255);
          data[idx + 2] = Math.floor((this.config.petalColor.b * shade + colorVar) * 255);
          data[idx + 3] = 255;
        }
      }
    }
  }
  drawWildflower(data, width, height, centerX, centerY, rng) {
    const petalLength = height * 0.2;
    const petalWidth = width * 0.1;
    const centerRadius = height * 0.06;
    for (let i = 0;i < 5; i++) {
      const angle = i / 5 * Math.PI * 2 - Math.PI / 2;
      this.drawPetal(data, width, height, centerX, centerY, angle, petalLength, petalWidth, rng);
    }
    this.drawCircle(data, width, height, centerX, centerY, centerRadius, { r: 1, g: 0.9, b: 0.3 }, rng);
  }
  drawPetal(data, width, height, cx, cy, angle, length, petalWidth, rng) {
    const steps = Math.ceil(length);
    for (let i = 0;i < steps; i++) {
      const t = i / steps;
      const x = cx + Math.cos(angle) * length * t;
      const y = cy + Math.sin(angle) * length * t;
      const w = petalWidth * Math.sin(t * Math.PI);
      this.drawCircle(data, width, height, x, y, w, this.config.petalColor, rng);
    }
  }
  drawCircle(data, width, height, cx, cy, radius, color, rng) {
    const r2 = radius * radius;
    for (let y = Math.floor(cy - radius);y <= Math.ceil(cy + radius); y++) {
      for (let x = Math.floor(cx - radius);x <= Math.ceil(cx + radius); x++) {
        if (x >= 0 && x < width && y >= 0 && y < height) {
          const dx = x - cx;
          const dy = y - cy;
          const d2 = dx * dx + dy * dy;
          if (d2 < r2) {
            const idx = (y * width + x) * 4;
            const colorVar = (rng() - 0.5) * this.config.colorVariation;
            const edge = 1 - Math.sqrt(d2) / radius;
            const alpha = Math.min(1, edge * 2);
            data[idx] = Math.floor(Math.min(255, (color.r + colorVar) * 255));
            data[idx + 1] = Math.floor(Math.min(255, (color.g + colorVar) * 255));
            data[idx + 2] = Math.floor(Math.min(255, (color.b + colorVar) * 255));
            data[idx + 3] = Math.max(data[idx + 3], Math.floor(alpha * 255));
          }
        }
      }
    }
  }
  setConfig(config) {
    this.config = { ...this.config, ...config };
  }
  getConfig() {
    return { ...this.config };
  }
  static getFlowerPreset(type) {
    switch (type) {
      case "daisy":
        return {
          petalCount: 12,
          petalColor: { r: 1, g: 1, b: 1 },
          centerColor: { r: 1, g: 0.85, b: 0.2 }
        };
      case "poppy":
        return {
          petalCount: 4,
          petalColor: { r: 0.9, g: 0.15, b: 0.1 },
          centerColor: { r: 0.1, g: 0.1, b: 0.1 }
        };
      case "dandelion":
        return {
          petalCount: 30,
          petalColor: { r: 1, g: 1, b: 0.95 },
          centerColor: { r: 0.95, g: 0.95, b: 0.9 }
        };
      case "bluebell":
        return {
          petalCount: 1,
          petalColor: { r: 0.3, g: 0.4, b: 0.9 },
          centerColor: { r: 0.2, g: 0.3, b: 0.7 }
        };
      case "tulip":
        return {
          petalCount: 6,
          petalColor: { r: 0.9, g: 0.2, b: 0.4 },
          centerColor: { r: 0.8, g: 0.15, b: 0.3 }
        };
      case "wildflower":
        return {
          petalCount: 5,
          petalColor: { r: 0.8, g: 0.3, b: 0.7 },
          centerColor: { r: 1, g: 0.9, b: 0.3 }
        };
    }
  }
}

// ../../src/core/procedural/flowers/Flower.ts
var DEFAULT_FLOWER_CONFIG = {
  area: { width: 50, depth: 50 },
  density: 0.5,
  densityMode: true,
  flowerTypes: ["daisy", "poppy", "wildflower"],
  scale: { min: 0.3, max: 0.8 },
  windEnabled: true,
  windStrength: 0.3,
  seed: 54321
};
function createRng4(seed) {
  return function() {
    let t = seed += 1831565813;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}

class Flower extends Node {
  config;
  device = null;
  initialized = false;
  renderers = new Map;
  instances = new Map;
  textures = new Map;
  globalResources = null;
  constructor(config = {}) {
    super("FlowerField");
    this.config = { ...DEFAULT_FLOWER_CONFIG, ...config };
  }
  async init(device, globalResources) {
    if (this.initialized)
      return;
    this.device = device;
    this.globalResources = globalResources || null;
    let sceneBindGroupLayout;
    if (globalResources?.renderBindGroupLayout) {
      sceneBindGroupLayout = globalResources.renderBindGroupLayout;
    } else {
      sceneBindGroupLayout = device.createBindGroupLayout({
        label: "Flower Scene Bind Group Layout (Standalone)",
        entries: [
          {
            binding: 0,
            visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
            buffer: { type: "uniform" }
          }
        ]
      });
    }
    for (const flowerType of this.config.flowerTypes) {
      const preset = FlowerTextureGenerator.getFlowerPreset(flowerType);
      const textureGenerator = new FlowerTextureGenerator({
        width: 64,
        height: 64,
        flowerType,
        seed: this.config.seed,
        ...preset
      });
      const texture = textureGenerator.generateTexture(device);
      this.textures.set(flowerType, texture);
      const renderer = new GrassRenderer({
        maxInstances: 1e5,
        verticesPerBlade: 6,
        alphaToCoverage: true,
        mode: "billboard",
        segments: 1,
        curvature: 0
      });
      renderer.init(device, sceneBindGroupLayout, texture);
      this.renderers.set(flowerType, renderer);
      this.instances.set(flowerType, []);
    }
    this.generateInstances();
    for (const [flowerType, instances] of this.instances) {
      const renderer = this.renderers.get(flowerType);
      if (renderer) {
        renderer.uploadInstances(instances);
      }
    }
    this.initialized = true;
    const totalFlowers = Array.from(this.instances.values()).reduce((sum, arr) => sum + arr.length, 0);
    console.log(`Flower: Initialized with ${totalFlowers} flowers across ${this.config.flowerTypes.length} types`);
  }
  generateInstances() {
    const rng = createRng4(this.config.seed || 54321);
    const width = this.config.area.width;
    const depth = this.config.area.depth;
    const offset = this.config.offset || new Vector3(0, 0, 0);
    const area = width * depth;
    const totalFlowers = this.config.densityMode ? Math.floor(this.config.density * area) : this.config.density;
    for (const instances of this.instances.values()) {
      instances.length = 0;
    }
    for (let i = 0;i < totalFlowers; i++) {
      const x = (rng() - 0.5) * width + offset.x;
      const z = (rng() - 0.5) * depth + offset.z;
      const y = this.config.heightSampler ? this.config.heightSampler(x, z) + offset.y : offset.y;
      const flowerType = this.config.flowerTypes[Math.floor(rng() * this.config.flowerTypes.length)];
      const rotation = rng() * Math.PI * 2;
      const scaleRange = this.config.scale.max - this.config.scale.min;
      const scale = this.config.scale.min + rng() * scaleRange;
      const colorVar = 0.9 + rng() * 0.2;
      const color = new Vector3(colorVar, colorVar, colorVar);
      const instance = {
        position: new Vector3(x, y, z),
        rotation,
        scale,
        color,
        random: rng()
      };
      const instances = this.instances.get(flowerType);
      if (instances) {
        instances.push(instance);
      }
    }
  }
  update(time, cameraPosition) {
    if (!this.initialized || !this.device)
      return;
    const windDir = { x: 1, z: 0.5 };
    const windStrength = this.config.windEnabled ? this.config.windStrength || 0.3 : 0;
    for (const renderer of this.renderers.values()) {
      renderer.updateUniforms(new Float32Array(16), cameraPosition || new Vector3(0, 0, 0), time, windDir, windStrength, 1, 0.2, 0.1);
    }
  }
  render(passEncoder, globalBindGroup) {
    if (!this.initialized)
      return;
    const bindGroup = globalBindGroup || this.globalResources?.renderBindGroup;
    if (!bindGroup) {
      console.warn("Flower.render: No bind group available");
      return;
    }
    for (const renderer of this.renderers.values()) {
      renderer.render(passEncoder, bindGroup);
    }
  }
  getFlowerCount() {
    let total = 0;
    for (const instances of this.instances.values()) {
      total += instances.length;
    }
    return total;
  }
  setDensity(density) {
    this.config.density = Math.max(0, density);
    if (this.initialized) {
      this.regenerate();
    }
  }
  setConfig(config) {
    const needsRegenerate = config.area !== undefined || config.density !== undefined || config.flowerTypes !== undefined || config.scale !== undefined || config.seed !== undefined;
    this.config = { ...this.config, ...config };
    if (this.initialized && needsRegenerate) {
      this.regenerate();
    }
  }
  regenerate() {
    if (!this.device)
      return;
    this.generateInstances();
    for (const [flowerType, instances] of this.instances) {
      const renderer = this.renderers.get(flowerType);
      if (renderer) {
        renderer.uploadInstances(instances);
      }
    }
    console.log(`Flower: Regenerated with ${this.getFlowerCount()} flowers`);
  }
  getConfig() {
    return { ...this.config };
  }
  destroy() {
    for (const renderer of this.renderers.values()) {
      renderer.destroy();
    }
    for (const texture of this.textures.values()) {
      texture.destroy();
    }
    this.renderers.clear();
    this.instances.clear();
    this.textures.clear();
    this.globalResources = null;
    this.device = null;
    this.initialized = false;
  }
}

// ../../node_modules/.bun/@loaders.gl+loader-utils@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/loader-utils/dist/loader-types.js
async function parseFromContext(data, loaders, options, context) {
  return context._parse(data, loaders, options, context);
}
// ../../node_modules/.bun/@loaders.gl+loader-utils@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/assert.js
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || "loader assertion failed.");
  }
}
// ../../node_modules/.bun/@loaders.gl+loader-utils@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/globals.js
var globals = {
  self: typeof self !== "undefined" && self,
  window: typeof window !== "undefined" && window,
  global: typeof global !== "undefined" && global,
  document: typeof document !== "undefined" && document
};
var self_ = globals.self || globals.window || globals.global || {};
var window_ = globals.window || globals.self || globals.global || {};
var global_ = globals.global || globals.self || globals.window || {};
var document_ = globals.document || {};
var isBrowser = Boolean(typeof process !== "object" || String(process) !== "[object process]" || true);
var matches = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
var nodeVersion = matches && parseFloat(matches[1]) || 0;
// ../../node_modules/.bun/@probe.gl+env@4.1.0/node_modules/@probe.gl/env/dist/lib/globals.js
var window_2 = globalThis;
var document_2 = globalThis.document || {};
var process_ = globalThis.process || {};
var console_ = globalThis.console;
var navigator_ = globalThis.navigator || {};
// ../../node_modules/.bun/@probe.gl+env@4.1.0/node_modules/@probe.gl/env/dist/lib/is-electron.js
function isElectron(mockUserAgent) {
  if (typeof window !== "undefined" && window.process?.type === "renderer") {
    return true;
  }
  if (typeof process !== "undefined" && Boolean(process.versions?.["electron"])) {
    return true;
  }
  const realUserAgent = typeof navigator !== "undefined" && navigator.userAgent;
  const userAgent = mockUserAgent || realUserAgent;
  return Boolean(userAgent && userAgent.indexOf("Electron") >= 0);
}

// ../../node_modules/.bun/@probe.gl+env@4.1.0/node_modules/@probe.gl/env/dist/lib/is-browser.js
function isBrowser2() {
  const isNode = typeof process === "object" && String(process) === "[object process]" && !process?.browser;
  return !isNode || isElectron();
}
// ../../node_modules/.bun/@probe.gl+env@4.1.0/node_modules/@probe.gl/env/dist/index.js
var VERSION = "4.1.0";

// ../../node_modules/.bun/@probe.gl+log@4.1.0/node_modules/@probe.gl/log/dist/utils/local-storage.js
function getStorage(type) {
  try {
    const storage = window[type];
    const x = "__storage_test__";
    storage.setItem(x, x);
    storage.removeItem(x);
    return storage;
  } catch (e) {
    return null;
  }
}

class LocalStorage {
  constructor(id, defaultConfig, type = "sessionStorage") {
    this.storage = getStorage(type);
    this.id = id;
    this.config = defaultConfig;
    this._loadConfiguration();
  }
  getConfiguration() {
    return this.config;
  }
  setConfiguration(configuration) {
    Object.assign(this.config, configuration);
    if (this.storage) {
      const serialized = JSON.stringify(this.config);
      this.storage.setItem(this.id, serialized);
    }
  }
  _loadConfiguration() {
    let configuration = {};
    if (this.storage) {
      const serializedConfiguration = this.storage.getItem(this.id);
      configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
    }
    Object.assign(this.config, configuration);
    return this;
  }
}

// ../../node_modules/.bun/@probe.gl+log@4.1.0/node_modules/@probe.gl/log/dist/utils/formatters.js
function formatTime(ms) {
  let formatted;
  if (ms < 10) {
    formatted = `${ms.toFixed(2)}ms`;
  } else if (ms < 100) {
    formatted = `${ms.toFixed(1)}ms`;
  } else if (ms < 1000) {
    formatted = `${ms.toFixed(0)}ms`;
  } else {
    formatted = `${(ms / 1000).toFixed(2)}s`;
  }
  return formatted;
}
function leftPad(string, length = 8) {
  const padLength = Math.max(length - string.length, 0);
  return `${" ".repeat(padLength)}${string}`;
}

// ../../node_modules/.bun/@probe.gl+log@4.1.0/node_modules/@probe.gl/log/dist/utils/color.js
var COLOR;
(function(COLOR2) {
  COLOR2[COLOR2["BLACK"] = 30] = "BLACK";
  COLOR2[COLOR2["RED"] = 31] = "RED";
  COLOR2[COLOR2["GREEN"] = 32] = "GREEN";
  COLOR2[COLOR2["YELLOW"] = 33] = "YELLOW";
  COLOR2[COLOR2["BLUE"] = 34] = "BLUE";
  COLOR2[COLOR2["MAGENTA"] = 35] = "MAGENTA";
  COLOR2[COLOR2["CYAN"] = 36] = "CYAN";
  COLOR2[COLOR2["WHITE"] = 37] = "WHITE";
  COLOR2[COLOR2["BRIGHT_BLACK"] = 90] = "BRIGHT_BLACK";
  COLOR2[COLOR2["BRIGHT_RED"] = 91] = "BRIGHT_RED";
  COLOR2[COLOR2["BRIGHT_GREEN"] = 92] = "BRIGHT_GREEN";
  COLOR2[COLOR2["BRIGHT_YELLOW"] = 93] = "BRIGHT_YELLOW";
  COLOR2[COLOR2["BRIGHT_BLUE"] = 94] = "BRIGHT_BLUE";
  COLOR2[COLOR2["BRIGHT_MAGENTA"] = 95] = "BRIGHT_MAGENTA";
  COLOR2[COLOR2["BRIGHT_CYAN"] = 96] = "BRIGHT_CYAN";
  COLOR2[COLOR2["BRIGHT_WHITE"] = 97] = "BRIGHT_WHITE";
})(COLOR || (COLOR = {}));
var BACKGROUND_INCREMENT = 10;
function getColor(color) {
  if (typeof color !== "string") {
    return color;
  }
  color = color.toUpperCase();
  return COLOR[color] || COLOR.WHITE;
}
function addColor(string, color, background) {
  if (!isBrowser2 && typeof string === "string") {
    if (color) {
      const colorCode = getColor(color);
      string = `\x1B[${colorCode}m${string}\x1B[39m`;
    }
    if (background) {
      const colorCode = getColor(background);
      string = `\x1B[${colorCode + BACKGROUND_INCREMENT}m${string}\x1B[49m`;
    }
  }
  return string;
}

// ../../node_modules/.bun/@probe.gl+log@4.1.0/node_modules/@probe.gl/log/dist/utils/autobind.js
function autobind(obj, predefined = ["constructor"]) {
  const proto = Object.getPrototypeOf(obj);
  const propNames = Object.getOwnPropertyNames(proto);
  const object = obj;
  for (const key of propNames) {
    const value = object[key];
    if (typeof value === "function") {
      if (!predefined.find((name) => key === name)) {
        object[key] = value.bind(obj);
      }
    }
  }
}

// ../../node_modules/.bun/@probe.gl+log@4.1.0/node_modules/@probe.gl/log/dist/utils/assert.js
function assert2(condition, message) {
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
}

// ../../node_modules/.bun/@probe.gl+log@4.1.0/node_modules/@probe.gl/log/dist/utils/hi-res-timestamp.js
function getHiResTimestamp() {
  let timestamp;
  if (isBrowser2() && window_2.performance) {
    timestamp = window_2?.performance?.now?.();
  } else if ("hrtime" in process_) {
    const timeParts = process_?.hrtime?.();
    timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }
  return timestamp;
}

// ../../node_modules/.bun/@probe.gl+log@4.1.0/node_modules/@probe.gl/log/dist/log.js
var originalConsole = {
  debug: isBrowser2() ? console.debug || console.log : console.log,
  log: console.log,
  info: console.info,
  warn: console.warn,
  error: console.error
};
var DEFAULT_LOG_CONFIGURATION = {
  enabled: true,
  level: 0
};
function noop() {}
var cache = {};
var ONCE = { once: true };

class Log {
  constructor({ id } = { id: "" }) {
    this.VERSION = VERSION;
    this._startTs = getHiResTimestamp();
    this._deltaTs = getHiResTimestamp();
    this.userData = {};
    this.LOG_THROTTLE_TIMEOUT = 0;
    this.id = id;
    this.userData = {};
    this._storage = new LocalStorage(`__probe-${this.id}__`, DEFAULT_LOG_CONFIGURATION);
    this.timeStamp(`${this.id} started`);
    autobind(this);
    Object.seal(this);
  }
  set level(newLevel) {
    this.setLevel(newLevel);
  }
  get level() {
    return this.getLevel();
  }
  isEnabled() {
    return this._storage.config.enabled;
  }
  getLevel() {
    return this._storage.config.level;
  }
  getTotal() {
    return Number((getHiResTimestamp() - this._startTs).toPrecision(10));
  }
  getDelta() {
    return Number((getHiResTimestamp() - this._deltaTs).toPrecision(10));
  }
  set priority(newPriority) {
    this.level = newPriority;
  }
  get priority() {
    return this.level;
  }
  getPriority() {
    return this.level;
  }
  enable(enabled = true) {
    this._storage.setConfiguration({ enabled });
    return this;
  }
  setLevel(level) {
    this._storage.setConfiguration({ level });
    return this;
  }
  get(setting) {
    return this._storage.config[setting];
  }
  set(setting, value) {
    this._storage.setConfiguration({ [setting]: value });
  }
  settings() {
    if (console.table) {
      console.table(this._storage.config);
    } else {
      console.log(this._storage.config);
    }
  }
  assert(condition, message) {
    if (!condition) {
      throw new Error(message || "Assertion failed");
    }
  }
  warn(message) {
    return this._getLogFunction(0, message, originalConsole.warn, arguments, ONCE);
  }
  error(message) {
    return this._getLogFunction(0, message, originalConsole.error, arguments);
  }
  deprecated(oldUsage, newUsage) {
    return this.warn(`\`${oldUsage}\` is deprecated and will be removed in a later version. Use \`${newUsage}\` instead`);
  }
  removed(oldUsage, newUsage) {
    return this.error(`\`${oldUsage}\` has been removed. Use \`${newUsage}\` instead`);
  }
  probe(logLevel, message) {
    return this._getLogFunction(logLevel, message, originalConsole.log, arguments, {
      time: true,
      once: true
    });
  }
  log(logLevel, message) {
    return this._getLogFunction(logLevel, message, originalConsole.debug, arguments);
  }
  info(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.info, arguments);
  }
  once(logLevel, message) {
    return this._getLogFunction(logLevel, message, originalConsole.debug || originalConsole.info, arguments, ONCE);
  }
  table(logLevel, table, columns) {
    if (table) {
      return this._getLogFunction(logLevel, table, console.table || noop, columns && [columns], {
        tag: getTableHeader(table)
      });
    }
    return noop;
  }
  time(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.time ? console.time : console.info);
  }
  timeEnd(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.timeEnd ? console.timeEnd : console.info);
  }
  timeStamp(logLevel, message) {
    return this._getLogFunction(logLevel, message, console.timeStamp || noop);
  }
  group(logLevel, message, opts = { collapsed: false }) {
    const options = normalizeArguments({ logLevel, message, opts });
    const { collapsed } = opts;
    options.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
    return this._getLogFunction(options);
  }
  groupCollapsed(logLevel, message, opts = {}) {
    return this.group(logLevel, message, Object.assign({}, opts, { collapsed: true }));
  }
  groupEnd(logLevel) {
    return this._getLogFunction(logLevel, "", console.groupEnd || noop);
  }
  withGroup(logLevel, message, func) {
    this.group(logLevel, message)();
    try {
      func();
    } finally {
      this.groupEnd(logLevel)();
    }
  }
  trace() {
    if (console.trace) {
      console.trace();
    }
  }
  _shouldLog(logLevel) {
    return this.isEnabled() && this.getLevel() >= normalizeLogLevel(logLevel);
  }
  _getLogFunction(logLevel, message, method, args, opts) {
    if (this._shouldLog(logLevel)) {
      opts = normalizeArguments({ logLevel, message, args, opts });
      method = method || opts.method;
      assert2(method);
      opts.total = this.getTotal();
      opts.delta = this.getDelta();
      this._deltaTs = getHiResTimestamp();
      const tag = opts.tag || opts.message;
      if (opts.once && tag) {
        if (!cache[tag]) {
          cache[tag] = getHiResTimestamp();
        } else {
          return noop;
        }
      }
      message = decorateMessage(this.id, opts.message, opts);
      return method.bind(console, message, ...opts.args);
    }
    return noop;
  }
}
Log.VERSION = VERSION;
function normalizeLogLevel(logLevel) {
  if (!logLevel) {
    return 0;
  }
  let resolvedLevel;
  switch (typeof logLevel) {
    case "number":
      resolvedLevel = logLevel;
      break;
    case "object":
      resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
      break;
    default:
      return 0;
  }
  assert2(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
  return resolvedLevel;
}
function normalizeArguments(opts) {
  const { logLevel, message } = opts;
  opts.logLevel = normalizeLogLevel(logLevel);
  const args = opts.args ? Array.from(opts.args) : [];
  while (args.length && args.shift() !== message) {}
  switch (typeof logLevel) {
    case "string":
    case "function":
      if (message !== undefined) {
        args.unshift(message);
      }
      opts.message = logLevel;
      break;
    case "object":
      Object.assign(opts, logLevel);
      break;
    default:
  }
  if (typeof opts.message === "function") {
    opts.message = opts.message();
  }
  const messageType = typeof opts.message;
  assert2(messageType === "string" || messageType === "object");
  return Object.assign(opts, { args }, opts.opts);
}
function decorateMessage(id, message, opts) {
  if (typeof message === "string") {
    const time = opts.time ? leftPad(formatTime(opts.total)) : "";
    message = opts.time ? `${id}: ${time}  ${message}` : `${id}: ${message}`;
    message = addColor(message, opts.color, opts.background);
  }
  return message;
}
function getTableHeader(table) {
  for (const key in table) {
    for (const title in table[key]) {
      return title || "untitled";
    }
  }
  return "empty";
}
// ../../node_modules/.bun/@probe.gl+log@4.1.0/node_modules/@probe.gl/log/dist/init.js
globalThis.probe = {};

// ../../node_modules/.bun/@probe.gl+log@4.1.0/node_modules/@probe.gl/log/dist/index.js
var dist_default = new Log({ id: "@probe.gl/log" });

// ../../node_modules/.bun/@loaders.gl+loader-utils@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/loader-utils/dist/lib/log-utils/log.js
var VERSION2 = "4.3.3";
var version = VERSION2[0] >= "0" && VERSION2[0] <= "9" ? `v${VERSION2}` : "";
function createLog() {
  const log = new Log({ id: "loaders.gl" });
  globalThis.loaders = globalThis.loaders || {};
  globalThis.loaders.log = log;
  globalThis.loaders.version = version;
  globalThis.probe = globalThis.probe || {};
  globalThis.probe.loaders = log;
  return log;
}
var log = createLog();
// ../../node_modules/.bun/@loaders.gl+loader-utils@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/loader-utils/dist/lib/option-utils/merge-loader-options.js
function mergeLoaderOptions(baseOptions, newOptions) {
  return mergeOptionsRecursively(baseOptions || {}, newOptions);
}
function mergeOptionsRecursively(baseOptions, newOptions, level = 0) {
  if (level > 3) {
    return newOptions;
  }
  const options = { ...baseOptions };
  for (const [key, newValue] of Object.entries(newOptions)) {
    if (newValue && typeof newValue === "object" && !Array.isArray(newValue)) {
      options[key] = mergeOptionsRecursively(options[key] || {}, newOptions[key], level + 1);
    } else {
      options[key] = newOptions[key];
    }
  }
  return options;
}
// ../../node_modules/.bun/@loaders.gl+loader-utils@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/loader-utils/dist/lib/module-utils/js-module-utils.js
function registerJSModules(modules) {
  globalThis.loaders ||= {};
  globalThis.loaders.modules ||= {};
  Object.assign(globalThis.loaders.modules, modules);
}
function getJSModuleOrNull(name) {
  const module = globalThis.loaders?.modules?.[name];
  return module || null;
}
// ../../node_modules/.bun/@loaders.gl+worker-utils@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/version.js
var NPM_TAG = "latest";
function getVersion() {
  if (!globalThis._loadersgl_?.version) {
    globalThis._loadersgl_ = globalThis._loadersgl_ || {};
    if (false) {} else {
      globalThis._loadersgl_.version = "4.3.3";
    }
  }
  return globalThis._loadersgl_.version;
}
var VERSION3 = getVersion();

// ../../node_modules/.bun/@loaders.gl+worker-utils@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/assert.js
function assert3(condition, message) {
  if (!condition) {
    throw new Error(message || "loaders.gl assertion failed.");
  }
}
// ../../node_modules/.bun/@loaders.gl+worker-utils@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/worker-utils/dist/lib/env-utils/globals.js
var globals2 = {
  self: typeof self !== "undefined" && self,
  window: typeof window !== "undefined" && window,
  global: typeof global !== "undefined" && global,
  document: typeof document !== "undefined" && document
};
var self_2 = globals2.self || globals2.window || globals2.global || {};
var window_3 = globals2.window || globals2.self || globals2.global || {};
var global_3 = globals2.global || globals2.self || globals2.window || {};
var document_3 = globals2.document || {};
var isBrowser3 = typeof process !== "object" || String(process) !== "[object process]" || true;
var isWorker = typeof importScripts === "function";
var isMobile = typeof window !== "undefined" && typeof window.orientation !== "undefined";
var matches2 = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
var nodeVersion2 = matches2 && parseFloat(matches2[1]) || 0;
// ../../node_modules/.bun/@loaders.gl+worker-utils@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-job.js
class WorkerJob {
  name;
  workerThread;
  isRunning = true;
  result;
  _resolve = () => {};
  _reject = () => {};
  constructor(jobName, workerThread) {
    this.name = jobName;
    this.workerThread = workerThread;
    this.result = new Promise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
    });
  }
  postMessage(type, payload) {
    this.workerThread.postMessage({
      source: "loaders.gl",
      type,
      payload
    });
  }
  done(value) {
    assert3(this.isRunning);
    this.isRunning = false;
    this._resolve(value);
  }
  error(error) {
    assert3(this.isRunning);
    this.isRunning = false;
    this._reject(error);
  }
}

// ../../node_modules/.bun/@loaders.gl+worker-utils@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/worker-utils/dist/lib/node/worker_threads-browser.js
class NodeWorker {
  terminate() {}
}

// ../../node_modules/.bun/@loaders.gl+worker-utils@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-loadable-worker-url.js
var workerURLCache = new Map;
function getLoadableWorkerURL(props) {
  assert3(props.source && !props.url || !props.source && props.url);
  let workerURL = workerURLCache.get(props.source || props.url);
  if (!workerURL) {
    if (props.url) {
      workerURL = getLoadableWorkerURLFromURL(props.url);
      workerURLCache.set(props.url, workerURL);
    }
    if (props.source) {
      workerURL = getLoadableWorkerURLFromSource(props.source);
      workerURLCache.set(props.source, workerURL);
    }
  }
  assert3(workerURL);
  return workerURL;
}
function getLoadableWorkerURLFromURL(url) {
  if (!url.startsWith("http")) {
    return url;
  }
  const workerSource = buildScriptSource(url);
  return getLoadableWorkerURLFromSource(workerSource);
}
function getLoadableWorkerURLFromSource(workerSource) {
  const blob = new Blob([workerSource], { type: "application/javascript" });
  return URL.createObjectURL(blob);
}
function buildScriptSource(workerUrl) {
  return `try {
  importScripts('${workerUrl}');
} catch (error) {
  console.error(error);
  throw error;
}`;
}

// ../../node_modules/.bun/@loaders.gl+worker-utils@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-transfer-list.js
function getTransferList(object, recursive = true, transfers) {
  const transfersSet = transfers || new Set;
  if (!object) {} else if (isTransferable(object)) {
    transfersSet.add(object);
  } else if (isTransferable(object.buffer)) {
    transfersSet.add(object.buffer);
  } else if (ArrayBuffer.isView(object)) {} else if (recursive && typeof object === "object") {
    for (const key in object) {
      getTransferList(object[key], recursive, transfersSet);
    }
  }
  return transfers === undefined ? Array.from(transfersSet) : [];
}
function isTransferable(object) {
  if (!object) {
    return false;
  }
  if (object instanceof ArrayBuffer) {
    return true;
  }
  if (typeof MessagePort !== "undefined" && object instanceof MessagePort) {
    return true;
  }
  if (typeof ImageBitmap !== "undefined" && object instanceof ImageBitmap) {
    return true;
  }
  if (typeof OffscreenCanvas !== "undefined" && object instanceof OffscreenCanvas) {
    return true;
  }
  return false;
}

// ../../node_modules/.bun/@loaders.gl+worker-utils@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-thread.js
var NOOP = () => {};

class WorkerThread {
  name;
  source;
  url;
  terminated = false;
  worker;
  onMessage;
  onError;
  _loadableURL = "";
  static isSupported() {
    return typeof Worker !== "undefined" && isBrowser3 || typeof NodeWorker !== "undefined" && !isBrowser3;
  }
  constructor(props) {
    const { name, source, url } = props;
    assert3(source || url);
    this.name = name;
    this.source = source;
    this.url = url;
    this.onMessage = NOOP;
    this.onError = (error) => console.log(error);
    this.worker = isBrowser3 ? this._createBrowserWorker() : this._createNodeWorker();
  }
  destroy() {
    this.onMessage = NOOP;
    this.onError = NOOP;
    this.worker.terminate();
    this.terminated = true;
  }
  get isRunning() {
    return Boolean(this.onMessage);
  }
  postMessage(data, transferList) {
    transferList = transferList || getTransferList(data);
    this.worker.postMessage(data, transferList);
  }
  _getErrorFromErrorEvent(event) {
    let message = "Failed to load ";
    message += `worker ${this.name} from ${this.url}. `;
    if (event.message) {
      message += `${event.message} in `;
    }
    if (event.lineno) {
      message += `:${event.lineno}:${event.colno}`;
    }
    return new Error(message);
  }
  _createBrowserWorker() {
    this._loadableURL = getLoadableWorkerURL({ source: this.source, url: this.url });
    const worker = new Worker(this._loadableURL, { name: this.name });
    worker.onmessage = (event) => {
      if (!event.data) {
        this.onError(new Error("No data received"));
      } else {
        this.onMessage(event.data);
      }
    };
    worker.onerror = (error) => {
      this.onError(this._getErrorFromErrorEvent(error));
      this.terminated = true;
    };
    worker.onmessageerror = (event) => console.error(event);
    return worker;
  }
  _createNodeWorker() {
    let worker;
    if (this.url) {
      const absolute = this.url.includes(":/") || this.url.startsWith("/");
      const url = absolute ? this.url : `./${this.url}`;
      worker = new NodeWorker(url, { eval: false });
    } else if (this.source) {
      worker = new NodeWorker(this.source, { eval: true });
    } else {
      throw new Error("no worker");
    }
    worker.on("message", (data) => {
      this.onMessage(data);
    });
    worker.on("error", (error) => {
      this.onError(error);
    });
    worker.on("exit", (code) => {});
    return worker;
  }
}

// ../../node_modules/.bun/@loaders.gl+worker-utils@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-pool.js
class WorkerPool {
  name = "unnamed";
  source;
  url;
  maxConcurrency = 1;
  maxMobileConcurrency = 1;
  onDebug = () => {};
  reuseWorkers = true;
  props = {};
  jobQueue = [];
  idleQueue = [];
  count = 0;
  isDestroyed = false;
  static isSupported() {
    return WorkerThread.isSupported();
  }
  constructor(props) {
    this.source = props.source;
    this.url = props.url;
    this.setProps(props);
  }
  destroy() {
    this.idleQueue.forEach((worker) => worker.destroy());
    this.isDestroyed = true;
  }
  setProps(props) {
    this.props = { ...this.props, ...props };
    if (props.name !== undefined) {
      this.name = props.name;
    }
    if (props.maxConcurrency !== undefined) {
      this.maxConcurrency = props.maxConcurrency;
    }
    if (props.maxMobileConcurrency !== undefined) {
      this.maxMobileConcurrency = props.maxMobileConcurrency;
    }
    if (props.reuseWorkers !== undefined) {
      this.reuseWorkers = props.reuseWorkers;
    }
    if (props.onDebug !== undefined) {
      this.onDebug = props.onDebug;
    }
  }
  async startJob(name, onMessage = (job, type, data) => job.done(data), onError = (job, error) => job.error(error)) {
    const startPromise = new Promise((onStart) => {
      this.jobQueue.push({ name, onMessage, onError, onStart });
      return this;
    });
    this._startQueuedJob();
    return await startPromise;
  }
  async _startQueuedJob() {
    if (!this.jobQueue.length) {
      return;
    }
    const workerThread = this._getAvailableWorker();
    if (!workerThread) {
      return;
    }
    const queuedJob = this.jobQueue.shift();
    if (queuedJob) {
      this.onDebug({
        message: "Starting job",
        name: queuedJob.name,
        workerThread,
        backlog: this.jobQueue.length
      });
      const job = new WorkerJob(queuedJob.name, workerThread);
      workerThread.onMessage = (data) => queuedJob.onMessage(job, data.type, data.payload);
      workerThread.onError = (error) => queuedJob.onError(job, error);
      queuedJob.onStart(job);
      try {
        await job.result;
      } catch (error) {
        console.error(`Worker exception: ${error}`);
      } finally {
        this.returnWorkerToQueue(workerThread);
      }
    }
  }
  returnWorkerToQueue(worker) {
    const shouldDestroyWorker = !isBrowser3 || this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency();
    if (shouldDestroyWorker) {
      worker.destroy();
      this.count--;
    } else {
      this.idleQueue.push(worker);
    }
    if (!this.isDestroyed) {
      this._startQueuedJob();
    }
  }
  _getAvailableWorker() {
    if (this.idleQueue.length > 0) {
      return this.idleQueue.shift() || null;
    }
    if (this.count < this._getMaxConcurrency()) {
      this.count++;
      const name = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;
      return new WorkerThread({ name, source: this.source, url: this.url });
    }
    return null;
  }
  _getMaxConcurrency() {
    return isMobile ? this.maxMobileConcurrency : this.maxConcurrency;
  }
}

// ../../node_modules/.bun/@loaders.gl+worker-utils@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/worker-utils/dist/lib/worker-farm/worker-farm.js
var DEFAULT_PROPS = {
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  reuseWorkers: true,
  onDebug: () => {}
};

class WorkerFarm {
  props;
  workerPools = new Map;
  static _workerFarm;
  static isSupported() {
    return WorkerThread.isSupported();
  }
  static getWorkerFarm(props = {}) {
    WorkerFarm._workerFarm = WorkerFarm._workerFarm || new WorkerFarm({});
    WorkerFarm._workerFarm.setProps(props);
    return WorkerFarm._workerFarm;
  }
  constructor(props) {
    this.props = { ...DEFAULT_PROPS };
    this.setProps(props);
    this.workerPools = new Map;
  }
  destroy() {
    for (const workerPool of this.workerPools.values()) {
      workerPool.destroy();
    }
    this.workerPools = new Map;
  }
  setProps(props) {
    this.props = { ...this.props, ...props };
    for (const workerPool of this.workerPools.values()) {
      workerPool.setProps(this._getWorkerPoolProps());
    }
  }
  getWorkerPool(options) {
    const { name, source, url } = options;
    let workerPool = this.workerPools.get(name);
    if (!workerPool) {
      workerPool = new WorkerPool({
        name,
        source,
        url
      });
      workerPool.setProps(this._getWorkerPoolProps());
      this.workerPools.set(name, workerPool);
    }
    return workerPool;
  }
  _getWorkerPoolProps() {
    return {
      maxConcurrency: this.props.maxConcurrency,
      maxMobileConcurrency: this.props.maxMobileConcurrency,
      reuseWorkers: this.props.reuseWorkers,
      onDebug: this.props.onDebug
    };
  }
}
// ../../node_modules/.bun/@loaders.gl+worker-utils@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/get-worker-url.js
function getWorkerURL(worker, options = {}) {
  const workerOptions = options[worker.id] || {};
  const workerFile = isBrowser3 ? `${worker.id}-worker.js` : `${worker.id}-worker-node.js`;
  let url = workerOptions.workerUrl;
  if (!url && worker.id === "compression") {
    url = options.workerUrl;
  }
  if (options._workerType === "test") {
    if (isBrowser3) {
      url = `modules/${worker.module}/dist/${workerFile}`;
    } else {
      url = `modules/${worker.module}/src/workers/${worker.id}-worker-node.ts`;
    }
  }
  if (!url) {
    let version2 = worker.version;
    if (version2 === "latest") {
      version2 = NPM_TAG;
    }
    const versionTag = version2 ? `@${version2}` : "";
    url = `https://unpkg.com/@loaders.gl/${worker.module}${versionTag}/dist/${workerFile}`;
  }
  assert3(url);
  return url;
}
// ../../node_modules/.bun/@loaders.gl+worker-utils@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/worker-utils/dist/lib/worker-api/validate-worker-version.js
function validateWorkerVersion(worker, coreVersion = VERSION3) {
  assert3(worker, "no worker provided");
  const workerVersion = worker.version;
  if (!coreVersion || !workerVersion) {
    return false;
  }
  return true;
}
// ../../node_modules/.bun/@loaders.gl+worker-utils@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/worker-utils/dist/lib/library-utils/library-utils.js
var loadLibraryPromises = {};
async function loadLibrary(libraryUrl, moduleName = null, options = {}, libraryName = null) {
  if (moduleName) {
    libraryUrl = getLibraryUrl(libraryUrl, moduleName, options, libraryName);
  }
  loadLibraryPromises[libraryUrl] = loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);
  return await loadLibraryPromises[libraryUrl];
}
function getLibraryUrl(library, moduleName, options = {}, libraryName = null) {
  if (!options.useLocalLibraries && library.startsWith("http")) {
    return library;
  }
  libraryName = libraryName || library;
  const modules = options.modules || {};
  if (modules[libraryName]) {
    return modules[libraryName];
  }
  if (!isBrowser3) {
    return `modules/${moduleName}/dist/libs/${libraryName}`;
  }
  if (options.CDN) {
    assert3(options.CDN.startsWith("http"));
    return `${options.CDN}/${moduleName}@${VERSION3}/dist/libs/${libraryName}`;
  }
  if (isWorker) {
    return `../src/libs/${libraryName}`;
  }
  return `modules/${moduleName}/src/libs/${libraryName}`;
}
async function loadLibraryFromFile(libraryUrl) {
  if (libraryUrl.endsWith("wasm")) {
    return await loadAsArrayBuffer(libraryUrl);
  }
  if (!isBrowser3) {
    try {
      const { requireFromFile } = globalThis.loaders || {};
      return await requireFromFile?.(libraryUrl);
    } catch (error) {
      console.error(error);
      return null;
    }
  }
  if (isWorker) {
    return importScripts(libraryUrl);
  }
  const scriptSource = await loadAsText(libraryUrl);
  return loadLibraryFromString(scriptSource, libraryUrl);
}
function loadLibraryFromString(scriptSource, id) {
  if (!isBrowser3) {
    const { requireFromString } = globalThis.loaders || {};
    return requireFromString?.(scriptSource, id);
  }
  if (isWorker) {
    eval.call(globalThis, scriptSource);
    return null;
  }
  const script = document.createElement("script");
  script.id = id;
  try {
    script.appendChild(document.createTextNode(scriptSource));
  } catch (e) {
    script.text = scriptSource;
  }
  document.body.appendChild(script);
  return null;
}
async function loadAsArrayBuffer(url) {
  const { readFileAsArrayBuffer } = globalThis.loaders || {};
  if (isBrowser3 || !readFileAsArrayBuffer || url.startsWith("http")) {
    const response = await fetch(url);
    return await response.arrayBuffer();
  }
  return await readFileAsArrayBuffer(url);
}
async function loadAsText(url) {
  const { readFileAsText } = globalThis.loaders || {};
  if (isBrowser3 || !readFileAsText || url.startsWith("http")) {
    const response = await fetch(url);
    return await response.text();
  }
  return await readFileAsText(url);
}
// ../../node_modules/.bun/@loaders.gl+loader-utils@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/loader-utils/dist/lib/worker-loader-utils/parse-with-worker.js
function canParseWithWorker(loader, options) {
  if (!WorkerFarm.isSupported()) {
    return false;
  }
  if (!isBrowser3 && !options?._nodeWorkers) {
    return false;
  }
  return loader.worker && options?.worker;
}
async function parseWithWorker(loader, data, options, context, parseOnMainThread) {
  const name = loader.id;
  const url = getWorkerURL(loader, options);
  const workerFarm = WorkerFarm.getWorkerFarm(options);
  const workerPool = workerFarm.getWorkerPool({ name, url });
  options = JSON.parse(JSON.stringify(options));
  context = JSON.parse(JSON.stringify(context || {}));
  const job = await workerPool.startJob("process-on-worker", onMessage.bind(null, parseOnMainThread));
  job.postMessage("process", {
    input: data,
    options,
    context
  });
  const result = await job.result;
  return await result.result;
}
async function onMessage(parseOnMainThread, job, type, payload) {
  switch (type) {
    case "done":
      job.done(payload);
      break;
    case "error":
      job.error(new Error(payload.error));
      break;
    case "process":
      const { id, input, options } = payload;
      try {
        const result = await parseOnMainThread(input, options);
        job.postMessage("done", { id, result });
      } catch (error) {
        const message = error instanceof Error ? error.message : "unknown error";
        job.postMessage("error", { id, error: message });
      }
      break;
    default:
      console.warn(`parse-with-worker unknown message ${type}`);
  }
}
// ../../node_modules/.bun/@loaders.gl+loader-utils@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/get-first-characters.js
function getFirstCharacters(data, length = 5) {
  if (typeof data === "string") {
    return data.slice(0, length);
  } else if (ArrayBuffer.isView(data)) {
    return getMagicString(data.buffer, data.byteOffset, length);
  } else if (data instanceof ArrayBuffer) {
    const byteOffset = 0;
    return getMagicString(data, byteOffset, length);
  }
  return "";
}
function getMagicString(arrayBuffer, byteOffset, length) {
  if (arrayBuffer.byteLength <= byteOffset + length) {
    return "";
  }
  const dataView = new DataView(arrayBuffer);
  let magic = "";
  for (let i = 0;i < length; i++) {
    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));
  }
  return magic;
}

// ../../node_modules/.bun/@loaders.gl+loader-utils@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/loader-utils/dist/lib/parser-utils/parse-json.js
function parseJSON(string) {
  try {
    return JSON.parse(string);
  } catch (_) {
    throw new Error(`Failed to parse JSON from data starting with "${getFirstCharacters(string)}"`);
  }
}
// ../../node_modules/.bun/@loaders.gl+loader-utils@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/array-buffer-utils.js
function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {
  byteLength = byteLength || arrayBuffer1.byteLength;
  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {
    return false;
  }
  const array1 = new Uint8Array(arrayBuffer1);
  const array2 = new Uint8Array(arrayBuffer2);
  for (let i = 0;i < array1.length; ++i) {
    if (array1[i] !== array2[i]) {
      return false;
    }
  }
  return true;
}
function concatenateArrayBuffers(...sources) {
  return concatenateArrayBuffersFromArray(sources);
}
function concatenateArrayBuffersFromArray(sources) {
  const sourceArrays = sources.map((source2) => source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2);
  const byteLength = sourceArrays.reduce((length, typedArray) => length + typedArray.byteLength, 0);
  const result = new Uint8Array(byteLength);
  let offset = 0;
  for (const sourceArray of sourceArrays) {
    result.set(sourceArray, offset);
    offset += sourceArray.byteLength;
  }
  return result.buffer;
}
function sliceArrayBuffer(arrayBuffer, byteOffset, byteLength) {
  const subArray = byteLength !== undefined ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength) : new Uint8Array(arrayBuffer).subarray(byteOffset);
  const arrayCopy = new Uint8Array(subArray);
  return arrayCopy.buffer;
}
// ../../node_modules/.bun/@loaders.gl+loader-utils@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/memory-copy-utils.js
function padToNBytes(byteLength, padding) {
  assert(byteLength >= 0);
  assert(padding > 0);
  return byteLength + (padding - 1) & ~(padding - 1);
}
function copyToArray(source, target, targetOffset) {
  let sourceArray;
  if (source instanceof ArrayBuffer) {
    sourceArray = new Uint8Array(source);
  } else {
    const srcByteOffset = source.byteOffset;
    const srcByteLength = source.byteLength;
    sourceArray = new Uint8Array(source.buffer || source.arrayBuffer, srcByteOffset, srcByteLength);
  }
  target.set(sourceArray, targetOffset);
  return targetOffset + padToNBytes(sourceArray.byteLength, 4);
}
// ../../node_modules/.bun/@loaders.gl+loader-utils@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/loader-utils/dist/lib/iterators/async-iteration.js
async function concatenateArrayBuffersAsync(asyncIterator) {
  const arrayBuffers = [];
  for await (const chunk of asyncIterator) {
    arrayBuffers.push(chunk);
  }
  return concatenateArrayBuffers(...arrayBuffers);
}
// ../../node_modules/.bun/@loaders.gl+loader-utils@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/file-aliases.js
var pathPrefix = "";
var fileAliases = {};
function resolvePath(filename) {
  for (const alias in fileAliases) {
    if (filename.startsWith(alias)) {
      const replacement = fileAliases[alias];
      filename = filename.replace(alias, replacement);
    }
  }
  if (!filename.startsWith("http://") && !filename.startsWith("https://")) {
    filename = `${pathPrefix}${filename}`;
  }
  return filename;
}
// ../../node_modules/.bun/@loaders.gl+loader-utils@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/loader-utils/dist/lib/node/buffer.browser.js
function toArrayBuffer(buffer) {
  return buffer;
}

// ../../node_modules/.bun/@loaders.gl+loader-utils@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/memory-conversion-utils.js
function isBuffer(value) {
  return value && typeof value === "object" && value.isBuffer;
}
function toArrayBuffer2(data) {
  if (isBuffer(data)) {
    return toArrayBuffer(data);
  }
  if (data instanceof ArrayBuffer) {
    return data;
  }
  if (ArrayBuffer.isView(data)) {
    if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {
      return data.buffer;
    }
    return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
  }
  if (typeof data === "string") {
    const text = data;
    const uint8Array = new TextEncoder().encode(text);
    return uint8Array.buffer;
  }
  if (data && typeof data === "object" && data._toArrayBuffer) {
    return data._toArrayBuffer();
  }
  throw new Error("toArrayBuffer");
}
// ../../node_modules/.bun/@loaders.gl+loader-utils@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/path.js
var exports_path = {};
__export(exports_path, {
  resolve: () => resolve,
  join: () => join,
  filename: () => filename,
  dirname: () => dirname
});

// ../../node_modules/.bun/@loaders.gl+loader-utils@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/get-cwd.js
function getCWD() {
  if (typeof process !== "undefined" && typeof process.cwd !== "undefined") {
    return process.cwd();
  }
  const pathname = window.location?.pathname;
  return pathname?.slice(0, pathname.lastIndexOf("/") + 1) || "";
}

// ../../node_modules/.bun/@loaders.gl+loader-utils@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/loader-utils/dist/lib/path-utils/path.js
function filename(url) {
  const slashIndex = url ? url.lastIndexOf("/") : -1;
  return slashIndex >= 0 ? url.substr(slashIndex + 1) : "";
}
function dirname(url) {
  const slashIndex = url ? url.lastIndexOf("/") : -1;
  return slashIndex >= 0 ? url.substr(0, slashIndex) : "";
}
function join(...parts) {
  const separator = "/";
  parts = parts.map((part, index) => {
    if (index) {
      part = part.replace(new RegExp(`^${separator}`), "");
    }
    if (index !== parts.length - 1) {
      part = part.replace(new RegExp(`${separator}$`), "");
    }
    return part;
  });
  return parts.join(separator);
}
function resolve(...components) {
  const paths = [];
  for (let _i = 0;_i < components.length; _i++) {
    paths[_i] = components[_i];
  }
  let resolvedPath = "";
  let resolvedAbsolute = false;
  let cwd;
  for (let i = paths.length - 1;i >= -1 && !resolvedAbsolute; i--) {
    let path;
    if (i >= 0) {
      path = paths[i];
    } else {
      if (cwd === undefined) {
        cwd = getCWD();
      }
      path = cwd;
    }
    if (path.length === 0) {
      continue;
    }
    resolvedPath = `${path}/${resolvedPath}`;
    resolvedAbsolute = path.charCodeAt(0) === SLASH;
  }
  resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
  if (resolvedAbsolute) {
    return `/${resolvedPath}`;
  } else if (resolvedPath.length > 0) {
    return resolvedPath;
  }
  return ".";
}
var SLASH = 47;
var DOT = 46;
function normalizeStringPosix(path, allowAboveRoot) {
  let res = "";
  let lastSlash = -1;
  let dots = 0;
  let code;
  let isAboveRoot = false;
  for (let i = 0;i <= path.length; ++i) {
    if (i < path.length) {
      code = path.charCodeAt(i);
    } else if (code === SLASH) {
      break;
    } else {
      code = SLASH;
    }
    if (code === SLASH) {
      if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || !isAboveRoot || res.charCodeAt(res.length - 1) !== DOT || res.charCodeAt(res.length - 2) !== DOT) {
          if (res.length > 2) {
            const start = res.length - 1;
            let j = start;
            for (;j >= 0; --j) {
              if (res.charCodeAt(j) === SLASH) {
                break;
              }
            }
            if (j !== start) {
              res = j === -1 ? "" : res.slice(0, j);
              lastSlash = i;
              dots = 0;
              isAboveRoot = false;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSlash = i;
            dots = 0;
            isAboveRoot = false;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0) {
            res += "/..";
          } else {
            res = "..";
          }
          isAboveRoot = true;
        }
      } else {
        const slice = path.slice(lastSlash + 1, i);
        if (res.length > 0) {
          res += `/${slice}`;
        } else {
          res = slice;
        }
        isAboveRoot = false;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === DOT && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}

// ../../node_modules/.bun/@loaders.gl+core@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/core/dist/javascript-utils/is-type.js
var isBoolean = (x) => typeof x === "boolean";
var isFunction = (x) => typeof x === "function";
var isObject = (x) => x !== null && typeof x === "object";
var isPureObject = (x) => isObject(x) && x.constructor === {}.constructor;
var isIterable = (x) => Boolean(x) && typeof x[Symbol.iterator] === "function";
var isAsyncIterable = (x) => x && typeof x[Symbol.asyncIterator] === "function";
var isResponse = (x) => typeof Response !== "undefined" && x instanceof Response || x && x.arrayBuffer && x.text && x.json;
var isBlob = (x) => typeof Blob !== "undefined" && x instanceof Blob;
var isBuffer2 = (x) => x && typeof x === "object" && x.isBuffer;
var isReadableDOMStream = (x) => typeof ReadableStream !== "undefined" && x instanceof ReadableStream || isObject(x) && isFunction(x.tee) && isFunction(x.cancel) && isFunction(x.getReader);
var isReadableNodeStream = (x) => isObject(x) && isFunction(x.read) && isFunction(x.pipe) && isBoolean(x.readable);
var isReadableStream = (x) => isReadableDOMStream(x) || isReadableNodeStream(x);

// ../../node_modules/.bun/@loaders.gl+core@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/core/dist/lib/fetch/fetch-error.js
class FetchError extends Error {
  constructor(message, info) {
    super(message);
    this.reason = info.reason;
    this.url = info.url;
    this.response = info.response;
  }
  reason;
  url;
  response;
}

// ../../node_modules/.bun/@loaders.gl+core@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/core/dist/lib/utils/mime-type-utils.js
var DATA_URL_PATTERN = /^data:([-\w.]+\/[-\w.+]+)(;|,)/;
var MIME_TYPE_PATTERN = /^([-\w.]+\/[-\w.+]+)/;
function compareMIMETypes(mimeType1, mimeType2) {
  if (mimeType1.toLowerCase() === mimeType2.toLowerCase()) {
    return true;
  }
  return false;
}
function parseMIMEType(mimeString) {
  const matches3 = MIME_TYPE_PATTERN.exec(mimeString);
  if (matches3) {
    return matches3[1];
  }
  return mimeString;
}
function parseMIMETypeFromURL(url) {
  const matches3 = DATA_URL_PATTERN.exec(url);
  if (matches3) {
    return matches3[1];
  }
  return "";
}

// ../../node_modules/.bun/@loaders.gl+core@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/core/dist/lib/utils/url-utils.js
var QUERY_STRING_PATTERN = /\?.*/;
function extractQueryString(url) {
  const matches3 = url.match(QUERY_STRING_PATTERN);
  return matches3 && matches3[0];
}
function stripQueryString(url) {
  return url.replace(QUERY_STRING_PATTERN, "");
}
function shortenUrlForDisplay(url) {
  if (url.length < 50) {
    return url;
  }
  const urlEnd = url.slice(url.length - 15);
  const urlStart = url.substr(0, 32);
  return `${urlStart}...${urlEnd}`;
}

// ../../node_modules/.bun/@loaders.gl+core@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/core/dist/lib/utils/resource-utils.js
function getResourceUrl(resource) {
  if (isResponse(resource)) {
    const response = resource;
    return response.url;
  }
  if (isBlob(resource)) {
    const blob = resource;
    return blob.name || "";
  }
  if (typeof resource === "string") {
    return resource;
  }
  return "";
}
function getResourceMIMEType(resource) {
  if (isResponse(resource)) {
    const response = resource;
    const contentTypeHeader = response.headers.get("content-type") || "";
    const noQueryUrl = stripQueryString(response.url);
    return parseMIMEType(contentTypeHeader) || parseMIMETypeFromURL(noQueryUrl);
  }
  if (isBlob(resource)) {
    const blob = resource;
    return blob.type || "";
  }
  if (typeof resource === "string") {
    return parseMIMETypeFromURL(resource);
  }
  return "";
}
function getResourceContentLength(resource) {
  if (isResponse(resource)) {
    const response = resource;
    return response.headers["content-length"] || -1;
  }
  if (isBlob(resource)) {
    const blob = resource;
    return blob.size;
  }
  if (typeof resource === "string") {
    return resource.length;
  }
  if (resource instanceof ArrayBuffer) {
    return resource.byteLength;
  }
  if (ArrayBuffer.isView(resource)) {
    return resource.byteLength;
  }
  return -1;
}

// ../../node_modules/.bun/@loaders.gl+core@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/core/dist/lib/utils/response-utils.js
async function makeResponse(resource) {
  if (isResponse(resource)) {
    return resource;
  }
  const headers = {};
  const contentLength = getResourceContentLength(resource);
  if (contentLength >= 0) {
    headers["content-length"] = String(contentLength);
  }
  const url = getResourceUrl(resource);
  const type = getResourceMIMEType(resource);
  if (type) {
    headers["content-type"] = type;
  }
  const initialDataUrl = await getInitialDataUrl(resource);
  if (initialDataUrl) {
    headers["x-first-bytes"] = initialDataUrl;
  }
  if (typeof resource === "string") {
    resource = new TextEncoder().encode(resource);
  }
  const response = new Response(resource, { headers });
  Object.defineProperty(response, "url", { value: url });
  return response;
}
async function checkResponse(response) {
  if (!response.ok) {
    const error = await getResponseError(response);
    throw error;
  }
}
async function getResponseError(response) {
  const shortUrl = shortenUrlForDisplay(response.url);
  let message = `Failed to fetch resource (${response.status}) ${response.statusText}: ${shortUrl}`;
  message = message.length > 100 ? `${message.slice(0, 100)}...` : message;
  const info = {
    reason: response.statusText,
    url: response.url,
    response
  };
  try {
    const contentType = response.headers.get("Content-Type");
    info.reason = !response.bodyUsed && contentType?.includes("application/json") ? await response.json() : await response.text();
  } catch (error) {}
  return new FetchError(message, info);
}
async function getInitialDataUrl(resource) {
  const INITIAL_DATA_LENGTH = 5;
  if (typeof resource === "string") {
    return `data:,${resource.slice(0, INITIAL_DATA_LENGTH)}`;
  }
  if (resource instanceof Blob) {
    const blobSlice = resource.slice(0, 5);
    return await new Promise((resolve2) => {
      const reader = new FileReader;
      reader.onload = (event) => resolve2(event?.target?.result);
      reader.readAsDataURL(blobSlice);
    });
  }
  if (resource instanceof ArrayBuffer) {
    const slice = resource.slice(0, INITIAL_DATA_LENGTH);
    const base64 = arrayBufferToBase64(slice);
    return `data:base64,${base64}`;
  }
  return null;
}
function arrayBufferToBase64(buffer) {
  let binary = "";
  const bytes = new Uint8Array(buffer);
  for (let i = 0;i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}

// ../../node_modules/.bun/@loaders.gl+core@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/core/dist/lib/fetch/fetch-file.js
function isNodePath(url) {
  return !isRequestURL(url) && !isDataURL(url);
}
function isRequestURL(url) {
  return url.startsWith("http:") || url.startsWith("https:");
}
function isDataURL(url) {
  return url.startsWith("data:");
}
async function fetchFile(urlOrData, fetchOptions) {
  if (typeof urlOrData === "string") {
    const url = resolvePath(urlOrData);
    if (isNodePath(url)) {
      if (globalThis.loaders?.fetchNode) {
        return globalThis.loaders?.fetchNode(url, fetchOptions);
      }
    }
    return await fetch(url, fetchOptions);
  }
  return await makeResponse(urlOrData);
}

// ../../node_modules/.bun/@loaders.gl+core@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/core/dist/lib/loader-utils/loggers.js
var probeLog = new Log({ id: "loaders.gl" });

class NullLog {
  log() {
    return () => {};
  }
  info() {
    return () => {};
  }
  warn() {
    return () => {};
  }
  error() {
    return () => {};
  }
}

class ConsoleLog {
  console;
  constructor() {
    this.console = console;
  }
  log(...args) {
    return this.console.log.bind(this.console, ...args);
  }
  info(...args) {
    return this.console.info.bind(this.console, ...args);
  }
  warn(...args) {
    return this.console.warn.bind(this.console, ...args);
  }
  error(...args) {
    return this.console.error.bind(this.console, ...args);
  }
}

// ../../node_modules/.bun/@loaders.gl+core@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/core/dist/lib/loader-utils/option-defaults.js
var DEFAULT_LOADER_OPTIONS = {
  fetch: null,
  mimeType: undefined,
  nothrow: false,
  log: new ConsoleLog,
  useLocalLibraries: false,
  CDN: "https://unpkg.com/@loaders.gl",
  worker: true,
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  reuseWorkers: isBrowser,
  _nodeWorkers: false,
  _workerType: "",
  limit: 0,
  _limitMB: 0,
  batchSize: "auto",
  batchDebounceMs: 0,
  metadata: false,
  transforms: []
};
var REMOVED_LOADER_OPTIONS = {
  throws: "nothrow",
  dataType: "(no longer used)",
  uri: "baseUri",
  method: "fetch.method",
  headers: "fetch.headers",
  body: "fetch.body",
  mode: "fetch.mode",
  credentials: "fetch.credentials",
  cache: "fetch.cache",
  redirect: "fetch.redirect",
  referrer: "fetch.referrer",
  referrerPolicy: "fetch.referrerPolicy",
  integrity: "fetch.integrity",
  keepalive: "fetch.keepalive",
  signal: "fetch.signal"
};

// ../../node_modules/.bun/@loaders.gl+core@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/core/dist/lib/loader-utils/option-utils.js
function getGlobalLoaderState() {
  globalThis.loaders = globalThis.loaders || {};
  const { loaders } = globalThis;
  if (!loaders._state) {
    loaders._state = {};
  }
  return loaders._state;
}
function getGlobalLoaderOptions() {
  const state = getGlobalLoaderState();
  state.globalOptions = state.globalOptions || { ...DEFAULT_LOADER_OPTIONS };
  return state.globalOptions;
}
function normalizeOptions(options, loader, loaders, url) {
  loaders = loaders || [];
  loaders = Array.isArray(loaders) ? loaders : [loaders];
  validateOptions(options, loaders);
  return normalizeOptionsInternal(loader, options, url);
}
function validateOptions(options, loaders) {
  validateOptionsObject(options, null, DEFAULT_LOADER_OPTIONS, REMOVED_LOADER_OPTIONS, loaders);
  for (const loader of loaders) {
    const idOptions = options && options[loader.id] || {};
    const loaderOptions = loader.options && loader.options[loader.id] || {};
    const deprecatedOptions = loader.deprecatedOptions && loader.deprecatedOptions[loader.id] || {};
    validateOptionsObject(idOptions, loader.id, loaderOptions, deprecatedOptions, loaders);
  }
}
function validateOptionsObject(options, id, defaultOptions, deprecatedOptions, loaders) {
  const loaderName = id || "Top level";
  const prefix = id ? `${id}.` : "";
  for (const key in options) {
    const isSubOptions = !id && isObject(options[key]);
    const isBaseUriOption = key === "baseUri" && !id;
    const isWorkerUrlOption = key === "workerUrl" && id;
    if (!(key in defaultOptions) && !isBaseUriOption && !isWorkerUrlOption) {
      if (key in deprecatedOptions) {
        probeLog.warn(`${loaderName} loader option '${prefix}${key}' no longer supported, use '${deprecatedOptions[key]}'`)();
      } else if (!isSubOptions) {
        const suggestion = findSimilarOption(key, loaders);
        probeLog.warn(`${loaderName} loader option '${prefix}${key}' not recognized. ${suggestion}`)();
      }
    }
  }
}
function findSimilarOption(optionKey, loaders) {
  const lowerCaseOptionKey = optionKey.toLowerCase();
  let bestSuggestion = "";
  for (const loader of loaders) {
    for (const key in loader.options) {
      if (optionKey === key) {
        return `Did you mean '${loader.id}.${key}'?`;
      }
      const lowerCaseKey = key.toLowerCase();
      const isPartialMatch = lowerCaseOptionKey.startsWith(lowerCaseKey) || lowerCaseKey.startsWith(lowerCaseOptionKey);
      if (isPartialMatch) {
        bestSuggestion = bestSuggestion || `Did you mean '${loader.id}.${key}'?`;
      }
    }
  }
  return bestSuggestion;
}
function normalizeOptionsInternal(loader, options, url) {
  const loaderDefaultOptions = loader.options || {};
  const mergedOptions = { ...loaderDefaultOptions };
  addUrlOptions(mergedOptions, url);
  if (mergedOptions.log === null) {
    mergedOptions.log = new NullLog;
  }
  mergeNestedFields(mergedOptions, getGlobalLoaderOptions());
  mergeNestedFields(mergedOptions, options);
  return mergedOptions;
}
function mergeNestedFields(mergedOptions, options) {
  for (const key in options) {
    if (key in options) {
      const value = options[key];
      if (isPureObject(value) && isPureObject(mergedOptions[key])) {
        mergedOptions[key] = {
          ...mergedOptions[key],
          ...options[key]
        };
      } else {
        mergedOptions[key] = options[key];
      }
    }
  }
}
function addUrlOptions(options, url) {
  if (url && !("baseUri" in options)) {
    options.baseUri = url;
  }
}

// ../../node_modules/.bun/@loaders.gl+core@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/core/dist/lib/loader-utils/normalize-loader.js
function isLoaderObject(loader) {
  if (!loader) {
    return false;
  }
  if (Array.isArray(loader)) {
    loader = loader[0];
  }
  const hasExtensions = Array.isArray(loader?.extensions);
  return hasExtensions;
}
function normalizeLoader(loader) {
  assert(loader, "null loader");
  assert(isLoaderObject(loader), "invalid loader");
  let options;
  if (Array.isArray(loader)) {
    options = loader[1];
    loader = loader[0];
    loader = {
      ...loader,
      options: { ...loader.options, ...options }
    };
  }
  if (loader?.parseTextSync || loader?.parseText) {
    loader.text = true;
  }
  if (!loader.text) {
    loader.binary = true;
  }
  return loader;
}

// ../../node_modules/.bun/@loaders.gl+core@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/core/dist/lib/api/register-loaders.js
var getGlobalLoaderRegistry = () => {
  const state = getGlobalLoaderState();
  state.loaderRegistry = state.loaderRegistry || [];
  return state.loaderRegistry;
};
function getRegisteredLoaders() {
  return getGlobalLoaderRegistry();
}

// ../../node_modules/.bun/@loaders.gl+core@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/core/dist/lib/api/select-loader.js
var EXT_PATTERN = /\.([^.]+)$/;
async function selectLoader(data, loaders = [], options, context) {
  if (!validHTTPResponse(data)) {
    return null;
  }
  let loader = selectLoaderSync(data, loaders, { ...options, nothrow: true }, context);
  if (loader) {
    return loader;
  }
  if (isBlob(data)) {
    data = await data.slice(0, 10).arrayBuffer();
    loader = selectLoaderSync(data, loaders, options, context);
  }
  if (!loader && !options?.nothrow) {
    throw new Error(getNoValidLoaderMessage(data));
  }
  return loader;
}
function selectLoaderSync(data, loaders = [], options, context) {
  if (!validHTTPResponse(data)) {
    return null;
  }
  if (loaders && !Array.isArray(loaders)) {
    return normalizeLoader(loaders);
  }
  let candidateLoaders = [];
  if (loaders) {
    candidateLoaders = candidateLoaders.concat(loaders);
  }
  if (!options?.ignoreRegisteredLoaders) {
    candidateLoaders.push(...getRegisteredLoaders());
  }
  normalizeLoaders(candidateLoaders);
  const loader = selectLoaderInternal(data, candidateLoaders, options, context);
  if (!loader && !options?.nothrow) {
    throw new Error(getNoValidLoaderMessage(data));
  }
  return loader;
}
function selectLoaderInternal(data, loaders, options, context) {
  const url = getResourceUrl(data);
  const type = getResourceMIMEType(data);
  const testUrl = stripQueryString(url) || context?.url;
  let loader = null;
  let reason = "";
  if (options?.mimeType) {
    loader = findLoaderByMIMEType(loaders, options?.mimeType);
    reason = `match forced by supplied MIME type ${options?.mimeType}`;
  }
  loader = loader || findLoaderByUrl(loaders, testUrl);
  reason = reason || (loader ? `matched url ${testUrl}` : "");
  loader = loader || findLoaderByMIMEType(loaders, type);
  reason = reason || (loader ? `matched MIME type ${type}` : "");
  loader = loader || findLoaderByInitialBytes(loaders, data);
  reason = reason || (loader ? `matched initial data ${getFirstCharacters2(data)}` : "");
  if (options?.fallbackMimeType) {
    loader = loader || findLoaderByMIMEType(loaders, options?.fallbackMimeType);
    reason = reason || (loader ? `matched fallback MIME type ${type}` : "");
  }
  if (reason) {
    log.log(1, `selectLoader selected ${loader?.name}: ${reason}.`);
  }
  return loader;
}
function validHTTPResponse(data) {
  if (data instanceof Response) {
    if (data.status === 204) {
      return false;
    }
  }
  return true;
}
function getNoValidLoaderMessage(data) {
  const url = getResourceUrl(data);
  const type = getResourceMIMEType(data);
  let message = "No valid loader found (";
  message += url ? `${exports_path.filename(url)}, ` : "no url provided, ";
  message += `MIME type: ${type ? `"${type}"` : "not provided"}, `;
  const firstCharacters = data ? getFirstCharacters2(data) : "";
  message += firstCharacters ? ` first bytes: "${firstCharacters}"` : "first bytes: not available";
  message += ")";
  return message;
}
function normalizeLoaders(loaders) {
  for (const loader of loaders) {
    normalizeLoader(loader);
  }
}
function findLoaderByUrl(loaders, url) {
  const match = url && EXT_PATTERN.exec(url);
  const extension = match && match[1];
  return extension ? findLoaderByExtension(loaders, extension) : null;
}
function findLoaderByExtension(loaders, extension) {
  extension = extension.toLowerCase();
  for (const loader of loaders) {
    for (const loaderExtension of loader.extensions) {
      if (loaderExtension.toLowerCase() === extension) {
        return loader;
      }
    }
  }
  return null;
}
function findLoaderByMIMEType(loaders, mimeType) {
  for (const loader of loaders) {
    if (loader.mimeTypes?.some((mimeType1) => compareMIMETypes(mimeType, mimeType1))) {
      return loader;
    }
    if (compareMIMETypes(mimeType, `application/x.${loader.id}`)) {
      return loader;
    }
  }
  return null;
}
function findLoaderByInitialBytes(loaders, data) {
  if (!data) {
    return null;
  }
  for (const loader of loaders) {
    if (typeof data === "string") {
      if (testDataAgainstText(data, loader)) {
        return loader;
      }
    } else if (ArrayBuffer.isView(data)) {
      if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) {
        return loader;
      }
    } else if (data instanceof ArrayBuffer) {
      const byteOffset = 0;
      if (testDataAgainstBinary(data, byteOffset, loader)) {
        return loader;
      }
    }
  }
  return null;
}
function testDataAgainstText(data, loader) {
  if (loader.testText) {
    return loader.testText(data);
  }
  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
  return tests.some((test) => data.startsWith(test));
}
function testDataAgainstBinary(data, byteOffset, loader) {
  const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
  return tests.some((test) => testBinary(data, byteOffset, loader, test));
}
function testBinary(data, byteOffset, loader, test) {
  if (test instanceof ArrayBuffer) {
    return compareArrayBuffers(test, data, test.byteLength);
  }
  switch (typeof test) {
    case "function":
      return test(data);
    case "string":
      const magic = getMagicString2(data, byteOffset, test.length);
      return test === magic;
    default:
      return false;
  }
}
function getFirstCharacters2(data, length = 5) {
  if (typeof data === "string") {
    return data.slice(0, length);
  } else if (ArrayBuffer.isView(data)) {
    return getMagicString2(data.buffer, data.byteOffset, length);
  } else if (data instanceof ArrayBuffer) {
    const byteOffset = 0;
    return getMagicString2(data, byteOffset, length);
  }
  return "";
}
function getMagicString2(arrayBuffer, byteOffset, length) {
  if (arrayBuffer.byteLength < byteOffset + length) {
    return "";
  }
  const dataView = new DataView(arrayBuffer);
  let magic = "";
  for (let i = 0;i < length; i++) {
    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));
  }
  return magic;
}

// ../../node_modules/.bun/@loaders.gl+core@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-string-iterator.js
var DEFAULT_CHUNK_SIZE = 256 * 1024;
function* makeStringIterator(string, options) {
  const chunkSize = options?.chunkSize || DEFAULT_CHUNK_SIZE;
  let offset = 0;
  const textEncoder = new TextEncoder;
  while (offset < string.length) {
    const chunkLength = Math.min(string.length - offset, chunkSize);
    const chunk = string.slice(offset, offset + chunkLength);
    offset += chunkLength;
    yield textEncoder.encode(chunk);
  }
}

// ../../node_modules/.bun/@loaders.gl+core@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-array-buffer-iterator.js
var DEFAULT_CHUNK_SIZE2 = 256 * 1024;
function* makeArrayBufferIterator(arrayBuffer, options = {}) {
  const { chunkSize = DEFAULT_CHUNK_SIZE2 } = options;
  let byteOffset = 0;
  while (byteOffset < arrayBuffer.byteLength) {
    const chunkByteLength = Math.min(arrayBuffer.byteLength - byteOffset, chunkSize);
    const chunk = new ArrayBuffer(chunkByteLength);
    const sourceArray = new Uint8Array(arrayBuffer, byteOffset, chunkByteLength);
    const chunkArray = new Uint8Array(chunk);
    chunkArray.set(sourceArray);
    byteOffset += chunkByteLength;
    yield chunk;
  }
}

// ../../node_modules/.bun/@loaders.gl+core@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-blob-iterator.js
var DEFAULT_CHUNK_SIZE3 = 1024 * 1024;
async function* makeBlobIterator(blob, options) {
  const chunkSize = options?.chunkSize || DEFAULT_CHUNK_SIZE3;
  let offset = 0;
  while (offset < blob.size) {
    const end = offset + chunkSize;
    const chunk = await blob.slice(offset, end).arrayBuffer();
    offset = end;
    yield chunk;
  }
}

// ../../node_modules/.bun/@loaders.gl+core@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-stream-iterator.js
function makeStreamIterator(stream, options) {
  return isBrowser ? makeBrowserStreamIterator(stream, options) : makeNodeStreamIterator(stream, options);
}
async function* makeBrowserStreamIterator(stream, options) {
  const reader = stream.getReader();
  let nextBatchPromise;
  try {
    while (true) {
      const currentBatchPromise = nextBatchPromise || reader.read();
      if (options?._streamReadAhead) {
        nextBatchPromise = reader.read();
      }
      const { done, value } = await currentBatchPromise;
      if (done) {
        return;
      }
      yield toArrayBuffer2(value);
    }
  } catch (error) {
    reader.releaseLock();
  }
}
async function* makeNodeStreamIterator(stream, options) {
  for await (const chunk of stream) {
    yield toArrayBuffer2(chunk);
  }
}

// ../../node_modules/.bun/@loaders.gl+core@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/core/dist/iterators/make-iterator/make-iterator.js
function makeIterator(data, options) {
  if (typeof data === "string") {
    return makeStringIterator(data, options);
  }
  if (data instanceof ArrayBuffer) {
    return makeArrayBufferIterator(data, options);
  }
  if (isBlob(data)) {
    return makeBlobIterator(data, options);
  }
  if (isReadableStream(data)) {
    return makeStreamIterator(data, options);
  }
  if (isResponse(data)) {
    const response = data;
    return makeStreamIterator(response.body, options);
  }
  throw new Error("makeIterator");
}

// ../../node_modules/.bun/@loaders.gl+core@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/core/dist/lib/loader-utils/get-data.js
var ERR_DATA = "Cannot convert supplied data type";
function getArrayBufferOrStringFromDataSync(data, loader, options) {
  if (loader.text && typeof data === "string") {
    return data;
  }
  if (isBuffer2(data)) {
    data = data.buffer;
  }
  if (data instanceof ArrayBuffer) {
    const arrayBuffer = data;
    if (loader.text && !loader.binary) {
      const textDecoder = new TextDecoder("utf8");
      return textDecoder.decode(arrayBuffer);
    }
    return arrayBuffer;
  }
  if (ArrayBuffer.isView(data)) {
    if (loader.text && !loader.binary) {
      const textDecoder = new TextDecoder("utf8");
      return textDecoder.decode(data);
    }
    let arrayBuffer = data.buffer;
    const byteLength = data.byteLength || data.length;
    if (data.byteOffset !== 0 || byteLength !== arrayBuffer.byteLength) {
      arrayBuffer = arrayBuffer.slice(data.byteOffset, data.byteOffset + byteLength);
    }
    return arrayBuffer;
  }
  throw new Error(ERR_DATA);
}
async function getArrayBufferOrStringFromData(data, loader, options) {
  const isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);
  if (typeof data === "string" || isArrayBuffer) {
    return getArrayBufferOrStringFromDataSync(data, loader, options);
  }
  if (isBlob(data)) {
    data = await makeResponse(data);
  }
  if (isResponse(data)) {
    const response = data;
    await checkResponse(response);
    return loader.binary ? await response.arrayBuffer() : await response.text();
  }
  if (isReadableStream(data)) {
    data = makeIterator(data, options);
  }
  if (isIterable(data) || isAsyncIterable(data)) {
    return concatenateArrayBuffersAsync(data);
  }
  throw new Error(ERR_DATA);
}

// ../../node_modules/.bun/@loaders.gl+core@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/core/dist/lib/loader-utils/get-fetch-function.js
function getFetchFunction(options, context) {
  const globalOptions = getGlobalLoaderOptions();
  const loaderOptions = options || globalOptions;
  if (typeof loaderOptions.fetch === "function") {
    return loaderOptions.fetch;
  }
  if (isObject(loaderOptions.fetch)) {
    return (url) => fetchFile(url, loaderOptions.fetch);
  }
  if (context?.fetch) {
    return context?.fetch;
  }
  return fetchFile;
}

// ../../node_modules/.bun/@loaders.gl+core@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/core/dist/lib/loader-utils/loader-context.js
function getLoaderContext(context, options, parentContext) {
  if (parentContext) {
    return parentContext;
  }
  const newContext = {
    fetch: getFetchFunction(options, context),
    ...context
  };
  if (newContext.url) {
    const baseUrl = stripQueryString(newContext.url);
    newContext.baseUrl = baseUrl;
    newContext.queryString = extractQueryString(newContext.url);
    newContext.filename = exports_path.filename(baseUrl);
    newContext.baseUrl = exports_path.dirname(baseUrl);
  }
  if (!Array.isArray(newContext.loaders)) {
    newContext.loaders = null;
  }
  return newContext;
}
function getLoadersFromContext(loaders, context) {
  if (loaders && !Array.isArray(loaders)) {
    return loaders;
  }
  let candidateLoaders;
  if (loaders) {
    candidateLoaders = Array.isArray(loaders) ? loaders : [loaders];
  }
  if (context && context.loaders) {
    const contextLoaders = Array.isArray(context.loaders) ? context.loaders : [context.loaders];
    candidateLoaders = candidateLoaders ? [...candidateLoaders, ...contextLoaders] : contextLoaders;
  }
  return candidateLoaders && candidateLoaders.length ? candidateLoaders : undefined;
}

// ../../node_modules/.bun/@loaders.gl+core@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/core/dist/lib/api/parse.js
async function parse(data, loaders, options, context) {
  if (loaders && !Array.isArray(loaders) && !isLoaderObject(loaders)) {
    context = undefined;
    options = loaders;
    loaders = undefined;
  }
  data = await data;
  options = options || {};
  const url = getResourceUrl(data);
  const typedLoaders = loaders;
  const candidateLoaders = getLoadersFromContext(typedLoaders, context);
  const loader = await selectLoader(data, candidateLoaders, options);
  if (!loader) {
    return null;
  }
  options = normalizeOptions(options, loader, candidateLoaders, url);
  context = getLoaderContext({ url, _parse: parse, loaders: candidateLoaders }, options, context || null);
  return await parseWithLoader(loader, data, options, context);
}
async function parseWithLoader(loader, data, options, context) {
  validateWorkerVersion(loader);
  options = mergeLoaderOptions(loader.options, options);
  if (isResponse(data)) {
    const response = data;
    const { ok, redirected, status, statusText, type, url } = response;
    const headers = Object.fromEntries(response.headers.entries());
    context.response = { headers, ok, redirected, status, statusText, type, url };
  }
  data = await getArrayBufferOrStringFromData(data, loader, options);
  const loaderWithParser = loader;
  if (loaderWithParser.parseTextSync && typeof data === "string") {
    return loaderWithParser.parseTextSync(data, options, context);
  }
  if (canParseWithWorker(loader, options)) {
    return await parseWithWorker(loader, data, options, context, parse);
  }
  if (loaderWithParser.parseText && typeof data === "string") {
    return await loaderWithParser.parseText(data, options, context);
  }
  if (loaderWithParser.parse) {
    return await loaderWithParser.parse(data, options, context);
  }
  assert3(!loaderWithParser.parseSync);
  throw new Error(`${loader.id} loader - no parser found and worker is disabled`);
}

// ../../node_modules/.bun/@loaders.gl+schema@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/schema/dist/lib/table/simple-table/data-type.js
function getDataTypeFromTypedArray(array) {
  switch (array.constructor) {
    case Int8Array:
      return "int8";
    case Uint8Array:
    case Uint8ClampedArray:
      return "uint8";
    case Int16Array:
      return "int16";
    case Uint16Array:
      return "uint16";
    case Int32Array:
      return "int32";
    case Uint32Array:
      return "uint32";
    case Float32Array:
      return "float32";
    case Float64Array:
      return "float64";
    default:
      return "null";
  }
}

// ../../node_modules/.bun/@loaders.gl+schema@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/schema/dist/lib/mesh/mesh-utils.js
function getMeshBoundingBox(attributes) {
  let minX = Infinity;
  let minY = Infinity;
  let minZ = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  let maxZ = -Infinity;
  const positions = attributes.POSITION ? attributes.POSITION.value : [];
  const len = positions && positions.length;
  for (let i = 0;i < len; i += 3) {
    const x = positions[i];
    const y = positions[i + 1];
    const z = positions[i + 2];
    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    minZ = z < minZ ? z : minZ;
    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    maxZ = z > maxZ ? z : maxZ;
  }
  return [
    [minX, minY, minZ],
    [maxX, maxY, maxZ]
  ];
}
// ../../node_modules/.bun/@loaders.gl+schema@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/schema/dist/lib/mesh/deduce-mesh-schema.js
function deduceMeshField(name, attribute, optionalMetadata) {
  const type = getDataTypeFromTypedArray(attribute.value);
  const metadata = optionalMetadata ? optionalMetadata : makeMeshAttributeMetadata(attribute);
  return {
    name,
    type: { type: "fixed-size-list", listSize: attribute.size, children: [{ name: "value", type }] },
    nullable: false,
    metadata
  };
}
function makeMeshAttributeMetadata(attribute) {
  const result = {};
  if ("byteOffset" in attribute) {
    result.byteOffset = attribute.byteOffset.toString(10);
  }
  if ("byteStride" in attribute) {
    result.byteStride = attribute.byteStride.toString(10);
  }
  if ("normalized" in attribute) {
    result.normalized = attribute.normalized.toString();
  }
  return result;
}
// ../../node_modules/.bun/@loaders.gl+core@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/core/dist/lib/api/load.js
async function load(url, loaders, options, context) {
  let resolvedLoaders;
  let resolvedOptions;
  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {
    resolvedLoaders = [];
    resolvedOptions = loaders;
    context = undefined;
  } else {
    resolvedLoaders = loaders;
    resolvedOptions = options;
  }
  const fetch2 = getFetchFunction(resolvedOptions);
  let data = url;
  if (typeof url === "string") {
    data = await fetch2(url);
  }
  if (isBlob(url)) {
    data = await fetch2(url);
  }
  return Array.isArray(resolvedLoaders) ? await parse(data, resolvedLoaders, resolvedOptions) : await parse(data, resolvedLoaders, resolvedOptions);
}
// ../../node_modules/.bun/@loaders.gl+gltf@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/gltf/dist/lib/extensions/EXT_mesh_features.js
var exports_EXT_mesh_features = {};
__export(exports_EXT_mesh_features, {
  name: () => name,
  encode: () => encode,
  decode: () => decode,
  createExtMeshFeatures: () => createExtMeshFeatures
});

// ../../node_modules/.bun/@loaders.gl+images@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/images/dist/lib/utils/version.js
var VERSION4 = "4.3.3";

// ../../node_modules/.bun/@loaders.gl+images@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/images/dist/lib/category-api/image-type.js
var parseImageNode = globalThis.loaders?.parseImageNode;
var IMAGE_SUPPORTED = typeof Image !== "undefined";
var IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== "undefined";
var NODE_IMAGE_SUPPORTED = Boolean(parseImageNode);
var DATA_SUPPORTED = isBrowser ? true : NODE_IMAGE_SUPPORTED;
function isImageTypeSupported(type) {
  switch (type) {
    case "auto":
      return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;
    case "imagebitmap":
      return IMAGE_BITMAP_SUPPORTED;
    case "image":
      return IMAGE_SUPPORTED;
    case "data":
      return DATA_SUPPORTED;
    default:
      throw new Error(`@loaders.gl/images: image ${type} not supported in this environment`);
  }
}
function getDefaultImageType() {
  if (IMAGE_BITMAP_SUPPORTED) {
    return "imagebitmap";
  }
  if (IMAGE_SUPPORTED) {
    return "image";
  }
  if (DATA_SUPPORTED) {
    return "data";
  }
  throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js");
}

// ../../node_modules/.bun/@loaders.gl+images@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/images/dist/lib/category-api/parsed-image-api.js
function getImageType(image) {
  const format = getImageTypeOrNull(image);
  if (!format) {
    throw new Error("Not an image");
  }
  return format;
}
function getImageData(image) {
  switch (getImageType(image)) {
    case "data":
      return image;
    case "image":
    case "imagebitmap":
      const canvas = document.createElement("canvas");
      const context = canvas.getContext("2d");
      if (!context) {
        throw new Error("getImageData");
      }
      canvas.width = image.width;
      canvas.height = image.height;
      context.drawImage(image, 0, 0);
      return context.getImageData(0, 0, image.width, image.height);
    default:
      throw new Error("getImageData");
  }
}
function getImageTypeOrNull(image) {
  if (typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
    return "imagebitmap";
  }
  if (typeof Image !== "undefined" && image instanceof Image) {
    return "image";
  }
  if (image && typeof image === "object" && image.data && image.width && image.height) {
    return "data";
  }
  return null;
}

// ../../node_modules/.bun/@loaders.gl+images@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/images/dist/lib/parsers/svg-utils.js
var SVG_DATA_URL_PATTERN = /^data:image\/svg\+xml/;
var SVG_URL_PATTERN = /\.svg((\?|#).*)?$/;
function isSVG(url) {
  return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));
}
function getBlobOrSVGDataUrl(arrayBuffer, url) {
  if (isSVG(url)) {
    const textDecoder = new TextDecoder;
    let xmlText = textDecoder.decode(arrayBuffer);
    try {
      if (typeof unescape === "function" && typeof encodeURIComponent === "function") {
        xmlText = unescape(encodeURIComponent(xmlText));
      }
    } catch (error) {
      throw new Error(error.message);
    }
    const src = `data:image/svg+xml;base64,${btoa(xmlText)}`;
    return src;
  }
  return getBlob(arrayBuffer, url);
}
function getBlob(arrayBuffer, url) {
  if (isSVG(url)) {
    throw new Error("SVG cannot be parsed directly to imagebitmap");
  }
  return new Blob([new Uint8Array(arrayBuffer)]);
}

// ../../node_modules/.bun/@loaders.gl+images@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/images/dist/lib/parsers/parse-to-image.js
async function parseToImage(arrayBuffer, options, url) {
  const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer, url);
  const URL2 = self.URL || self.webkitURL;
  const objectUrl = typeof blobOrDataUrl !== "string" && URL2.createObjectURL(blobOrDataUrl);
  try {
    return await loadToImage(objectUrl || blobOrDataUrl, options);
  } finally {
    if (objectUrl) {
      URL2.revokeObjectURL(objectUrl);
    }
  }
}
async function loadToImage(url, options) {
  const image = new Image;
  image.src = url;
  if (options.image && options.image.decode && image.decode) {
    await image.decode();
    return image;
  }
  return await new Promise((resolve2, reject) => {
    try {
      image.onload = () => resolve2(image);
      image.onerror = (error) => {
        const message = error instanceof Error ? error.message : "error";
        reject(new Error(message));
      };
    } catch (error) {
      reject(error);
    }
  });
}

// ../../node_modules/.bun/@loaders.gl+images@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/images/dist/lib/parsers/parse-to-image-bitmap.js
var EMPTY_OBJECT = {};
var imagebitmapOptionsSupported = true;
async function parseToImageBitmap(arrayBuffer, options, url) {
  let blob;
  if (isSVG(url)) {
    const image = await parseToImage(arrayBuffer, options, url);
    blob = image;
  } else {
    blob = getBlob(arrayBuffer, url);
  }
  const imagebitmapOptions = options && options.imagebitmap;
  return await safeCreateImageBitmap(blob, imagebitmapOptions);
}
async function safeCreateImageBitmap(blob, imagebitmapOptions = null) {
  if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {
    imagebitmapOptions = null;
  }
  if (imagebitmapOptions) {
    try {
      return await createImageBitmap(blob, imagebitmapOptions);
    } catch (error) {
      console.warn(error);
      imagebitmapOptionsSupported = false;
    }
  }
  return await createImageBitmap(blob);
}
function isEmptyObject(object) {
  for (const key in object || EMPTY_OBJECT) {
    return false;
  }
  return true;
}

// ../../node_modules/.bun/@loaders.gl+images@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/images/dist/lib/category-api/parse-isobmff-binary.js
function getISOBMFFMediaType(buffer) {
  if (!checkString(buffer, "ftyp", 4)) {
    return null;
  }
  if ((buffer[8] & 96) === 0) {
    return null;
  }
  return decodeMajorBrand(buffer);
}
function decodeMajorBrand(buffer) {
  const brandMajor = getUTF8String(buffer, 8, 12).replace("\x00", " ").trim();
  switch (brandMajor) {
    case "avif":
    case "avis":
      return { extension: "avif", mimeType: "image/avif" };
    default:
      return null;
  }
}
function getUTF8String(array, start, end) {
  return String.fromCharCode(...array.slice(start, end));
}
function stringToBytes(string) {
  return [...string].map((character) => character.charCodeAt(0));
}
function checkString(buffer, header, offset = 0) {
  const headerBytes = stringToBytes(header);
  for (let i = 0;i < headerBytes.length; ++i) {
    if (headerBytes[i] !== buffer[i + offset]) {
      return false;
    }
  }
  return true;
}

// ../../node_modules/.bun/@loaders.gl+images@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/images/dist/lib/category-api/binary-image-api.js
var BIG_ENDIAN = false;
var LITTLE_ENDIAN = true;
function getBinaryImageMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  return getPngMetadata(dataView) || getJpegMetadata(dataView) || getGifMetadata(dataView) || getBmpMetadata(dataView) || getISOBMFFMetadata(dataView);
}
function getISOBMFFMetadata(binaryData) {
  const buffer = new Uint8Array(binaryData instanceof DataView ? binaryData.buffer : binaryData);
  const mediaType = getISOBMFFMediaType(buffer);
  if (!mediaType) {
    return null;
  }
  return {
    mimeType: mediaType.mimeType,
    width: 0,
    height: 0
  };
}
function getPngMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 2303741511;
  if (!isPng) {
    return null;
  }
  return {
    mimeType: "image/png",
    width: dataView.getUint32(16, BIG_ENDIAN),
    height: dataView.getUint32(20, BIG_ENDIAN)
  };
}
function getGifMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 1195984440;
  if (!isGif) {
    return null;
  }
  return {
    mimeType: "image/gif",
    width: dataView.getUint16(6, LITTLE_ENDIAN),
    height: dataView.getUint16(8, LITTLE_ENDIAN)
  };
}
function getBmpMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isBmp = dataView.byteLength >= 14 && dataView.getUint16(0, BIG_ENDIAN) === 16973 && dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;
  if (!isBmp) {
    return null;
  }
  return {
    mimeType: "image/bmp",
    width: dataView.getUint32(18, LITTLE_ENDIAN),
    height: dataView.getUint32(22, LITTLE_ENDIAN)
  };
}
function getJpegMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isJpeg = dataView.byteLength >= 3 && dataView.getUint16(0, BIG_ENDIAN) === 65496 && dataView.getUint8(2) === 255;
  if (!isJpeg) {
    return null;
  }
  const { tableMarkers, sofMarkers } = getJpegMarkers();
  let i = 2;
  while (i + 9 < dataView.byteLength) {
    const marker = dataView.getUint16(i, BIG_ENDIAN);
    if (sofMarkers.has(marker)) {
      return {
        mimeType: "image/jpeg",
        height: dataView.getUint16(i + 5, BIG_ENDIAN),
        width: dataView.getUint16(i + 7, BIG_ENDIAN)
      };
    }
    if (!tableMarkers.has(marker)) {
      return null;
    }
    i += 2;
    i += dataView.getUint16(i, BIG_ENDIAN);
  }
  return null;
}
function getJpegMarkers() {
  const tableMarkers = new Set([65499, 65476, 65484, 65501, 65534]);
  for (let i = 65504;i < 65520; ++i) {
    tableMarkers.add(i);
  }
  const sofMarkers = new Set([
    65472,
    65473,
    65474,
    65475,
    65477,
    65478,
    65479,
    65481,
    65482,
    65483,
    65485,
    65486,
    65487,
    65502
  ]);
  return { tableMarkers, sofMarkers };
}
function toDataView(data) {
  if (data instanceof DataView) {
    return data;
  }
  if (ArrayBuffer.isView(data)) {
    return new DataView(data.buffer);
  }
  if (data instanceof ArrayBuffer) {
    return new DataView(data);
  }
  throw new Error("toDataView");
}

// ../../node_modules/.bun/@loaders.gl+images@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/images/dist/lib/parsers/parse-to-node-image.js
async function parseToNodeImage(arrayBuffer, options) {
  const { mimeType } = getBinaryImageMetadata(arrayBuffer) || {};
  const parseImageNode2 = globalThis.loaders?.parseImageNode;
  assert(parseImageNode2);
  return await parseImageNode2(arrayBuffer, mimeType);
}

// ../../node_modules/.bun/@loaders.gl+images@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/images/dist/lib/parsers/parse-image.js
async function parseImage(arrayBuffer, options, context) {
  options = options || {};
  const imageOptions = options.image || {};
  const imageType = imageOptions.type || "auto";
  const { url } = context || {};
  const loadType = getLoadableImageType(imageType);
  let image;
  switch (loadType) {
    case "imagebitmap":
      image = await parseToImageBitmap(arrayBuffer, options, url);
      break;
    case "image":
      image = await parseToImage(arrayBuffer, options, url);
      break;
    case "data":
      image = await parseToNodeImage(arrayBuffer, options);
      break;
    default:
      assert(false);
  }
  if (imageType === "data") {
    image = getImageData(image);
  }
  return image;
}
function getLoadableImageType(type) {
  switch (type) {
    case "auto":
    case "data":
      return getDefaultImageType();
    default:
      isImageTypeSupported(type);
      return type;
  }
}

// ../../node_modules/.bun/@loaders.gl+images@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/images/dist/image-loader.js
var EXTENSIONS = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg", "avif"];
var MIME_TYPES = [
  "image/png",
  "image/jpeg",
  "image/gif",
  "image/webp",
  "image/avif",
  "image/bmp",
  "image/vnd.microsoft.icon",
  "image/svg+xml"
];
var DEFAULT_IMAGE_LOADER_OPTIONS = {
  image: {
    type: "auto",
    decode: true
  }
};
var ImageLoader = {
  dataType: null,
  batchType: null,
  id: "image",
  module: "images",
  name: "Images",
  version: VERSION4,
  mimeTypes: MIME_TYPES,
  extensions: EXTENSIONS,
  parse: parseImage,
  tests: [(arrayBuffer) => Boolean(getBinaryImageMetadata(new DataView(arrayBuffer)))],
  options: DEFAULT_IMAGE_LOADER_OPTIONS
};
// ../../node_modules/.bun/@loaders.gl+images@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/images/dist/lib/category-api/image-format.js
var mimeTypeSupportedSync = {};
function isImageFormatSupported(mimeType) {
  if (mimeTypeSupportedSync[mimeType] === undefined) {
    const supported = isBrowser ? checkBrowserImageFormatSupport(mimeType) : checkNodeImageFormatSupport(mimeType);
    mimeTypeSupportedSync[mimeType] = supported;
  }
  return mimeTypeSupportedSync[mimeType];
}
function checkNodeImageFormatSupport(mimeType) {
  const NODE_FORMAT_SUPPORT = ["image/png", "image/jpeg", "image/gif"];
  const imageFormatsNode = globalThis.loaders?.imageFormatsNode || NODE_FORMAT_SUPPORT;
  const parseImageNode2 = globalThis.loaders?.parseImageNode;
  return Boolean(parseImageNode2) && imageFormatsNode.includes(mimeType);
}
function checkBrowserImageFormatSupport(mimeType) {
  switch (mimeType) {
    case "image/avif":
    case "image/webp":
      return testBrowserImageFormatSupport(mimeType);
    default:
      return true;
  }
}
function testBrowserImageFormatSupport(mimeType) {
  try {
    const element = document.createElement("canvas");
    const dataURL = element.toDataURL(mimeType);
    return dataURL.indexOf(`data:${mimeType}`) === 0;
  } catch {
    return false;
  }
}
// ../../node_modules/.bun/@loaders.gl+gltf@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/gltf/dist/lib/utils/assert.js
function assert4(condition, message) {
  if (!condition) {
    throw new Error(message || "assert failed: gltf");
  }
}

// ../../node_modules/.bun/@loaders.gl+gltf@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/gltf/dist/lib/gltf-utils/gltf-constants.js
var COMPONENTS = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
var BYTES = {
  5120: 1,
  5121: 1,
  5122: 2,
  5123: 2,
  5125: 4,
  5126: 4
};

// ../../node_modules/.bun/@loaders.gl+gltf@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/gltf/dist/lib/gltf-utils/gltf-utils.js
var TYPES = ["SCALAR", "VEC2", "VEC3", "VEC4"];
var ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT = [
  [Int8Array, 5120],
  [Uint8Array, 5121],
  [Int16Array, 5122],
  [Uint16Array, 5123],
  [Uint32Array, 5125],
  [Float32Array, 5126],
  [Float64Array, 5130]
];
var ARRAY_TO_COMPONENT_TYPE = new Map(ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT);
var ATTRIBUTE_TYPE_TO_COMPONENTS = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
var ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE = {
  5120: 1,
  5121: 1,
  5122: 2,
  5123: 2,
  5125: 4,
  5126: 4
};
var ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
function getAccessorTypeFromSize(size) {
  const type = TYPES[size - 1];
  return type || TYPES[0];
}
function getComponentTypeFromArray(typedArray) {
  const componentType = ARRAY_TO_COMPONENT_TYPE.get(typedArray.constructor);
  if (!componentType) {
    throw new Error("Illegal typed array");
  }
  return componentType;
}
function getAccessorArrayTypeAndLength(accessor, bufferView) {
  const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];
  const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];
  const bytesPerComponent = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE[accessor.componentType];
  const length = accessor.count * components;
  const byteLength = accessor.count * components * bytesPerComponent;
  assert4(byteLength >= 0 && byteLength <= bufferView.byteLength);
  const componentByteSize = BYTES[accessor.componentType];
  const numberOfComponentsInElement = COMPONENTS[accessor.type];
  return { ArrayType, length, byteLength, componentByteSize, numberOfComponentsInElement };
}

// ../../node_modules/.bun/@loaders.gl+gltf@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/gltf/dist/lib/gltf-utils/get-typed-array.js
function getTypedArrayForBufferView(json, buffers, bufferViewIndex) {
  const bufferView = json.bufferViews[bufferViewIndex];
  assert4(bufferView);
  const bufferIndex = bufferView.buffer;
  const binChunk = buffers[bufferIndex];
  assert4(binChunk);
  const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;
  return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);
}
function getTypedArrayForAccessor(json, buffers, accessor) {
  const gltfAccessor = typeof accessor === "number" ? json.accessors?.[accessor] : accessor;
  if (!gltfAccessor) {
    throw new Error(`No gltf accessor ${JSON.stringify(accessor)}`);
  }
  const bufferView = json.bufferViews?.[gltfAccessor.bufferView || 0];
  if (!bufferView) {
    throw new Error(`No gltf buffer view for accessor ${bufferView}`);
  }
  const { arrayBuffer, byteOffset: bufferByteOffset } = buffers[bufferView.buffer];
  const byteOffset = (bufferByteOffset || 0) + (gltfAccessor.byteOffset || 0) + (bufferView.byteOffset || 0);
  const { ArrayType, length, componentByteSize, numberOfComponentsInElement } = getAccessorArrayTypeAndLength(gltfAccessor, bufferView);
  const elementByteSize = componentByteSize * numberOfComponentsInElement;
  const elementAddressScale = bufferView.byteStride || elementByteSize;
  if (typeof bufferView.byteStride === "undefined" || bufferView.byteStride === elementByteSize) {
    const result2 = new ArrayType(arrayBuffer, byteOffset, length);
    return result2;
  }
  const result = new ArrayType(length);
  for (let i = 0;i < gltfAccessor.count; i++) {
    const values = new ArrayType(arrayBuffer, byteOffset + i * elementAddressScale, numberOfComponentsInElement);
    result.set(values, i * numberOfComponentsInElement);
  }
  return result;
}

// ../../node_modules/.bun/@loaders.gl+gltf@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/gltf/dist/lib/api/gltf-scenegraph.js
function makeDefaultGLTFJson() {
  return {
    asset: {
      version: "2.0",
      generator: "loaders.gl"
    },
    buffers: [],
    extensions: {},
    extensionsRequired: [],
    extensionsUsed: []
  };
}

class GLTFScenegraph {
  gltf;
  sourceBuffers;
  byteLength;
  constructor(gltf) {
    this.gltf = {
      json: gltf?.json || makeDefaultGLTFJson(),
      buffers: gltf?.buffers || [],
      images: gltf?.images || []
    };
    this.sourceBuffers = [];
    this.byteLength = 0;
    if (this.gltf.buffers && this.gltf.buffers[0]) {
      this.byteLength = this.gltf.buffers[0].byteLength;
      this.sourceBuffers = [this.gltf.buffers[0]];
    }
  }
  get json() {
    return this.gltf.json;
  }
  getApplicationData(key) {
    const data = this.json[key];
    return data;
  }
  getExtraData(key) {
    const extras = this.json.extras || {};
    return extras[key];
  }
  hasExtension(extensionName) {
    const isUsedExtension = this.getUsedExtensions().find((name) => name === extensionName);
    const isRequiredExtension = this.getRequiredExtensions().find((name) => name === extensionName);
    return typeof isUsedExtension === "string" || typeof isRequiredExtension === "string";
  }
  getExtension(extensionName) {
    const isExtension = this.getUsedExtensions().find((name) => name === extensionName);
    const extensions = this.json.extensions || {};
    return isExtension ? extensions[extensionName] : null;
  }
  getRequiredExtension(extensionName) {
    const isRequired = this.getRequiredExtensions().find((name) => name === extensionName);
    return isRequired ? this.getExtension(extensionName) : null;
  }
  getRequiredExtensions() {
    return this.json.extensionsRequired || [];
  }
  getUsedExtensions() {
    return this.json.extensionsUsed || [];
  }
  getRemovedExtensions() {
    return this.json.extensionsRemoved || [];
  }
  getObjectExtension(object, extensionName) {
    const extensions = object.extensions || {};
    return extensions[extensionName];
  }
  getScene(index) {
    return this.getObject("scenes", index);
  }
  getNode(index) {
    return this.getObject("nodes", index);
  }
  getSkin(index) {
    return this.getObject("skins", index);
  }
  getMesh(index) {
    return this.getObject("meshes", index);
  }
  getMaterial(index) {
    return this.getObject("materials", index);
  }
  getAccessor(index) {
    return this.getObject("accessors", index);
  }
  getTexture(index) {
    return this.getObject("textures", index);
  }
  getSampler(index) {
    return this.getObject("samplers", index);
  }
  getImage(index) {
    return this.getObject("images", index);
  }
  getBufferView(index) {
    return this.getObject("bufferViews", index);
  }
  getBuffer(index) {
    return this.getObject("buffers", index);
  }
  getObject(array, index) {
    if (typeof index === "object") {
      return index;
    }
    const object = this.json[array] && this.json[array][index];
    if (!object) {
      throw new Error(`glTF file error: Could not find ${array}[${index}]`);
    }
    return object;
  }
  getTypedArrayForBufferView(bufferView) {
    bufferView = this.getBufferView(bufferView);
    const bufferIndex = bufferView.buffer;
    const binChunk = this.gltf.buffers[bufferIndex];
    assert4(binChunk);
    const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;
    return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);
  }
  getTypedArrayForAccessor(accessor) {
    const gltfAccessor = this.getAccessor(accessor);
    return getTypedArrayForAccessor(this.gltf.json, this.gltf.buffers, gltfAccessor);
  }
  getTypedArrayForImageData(image) {
    image = this.getAccessor(image);
    const bufferView = this.getBufferView(image.bufferView);
    const buffer = this.getBuffer(bufferView.buffer);
    const arrayBuffer = buffer.data;
    const byteOffset = bufferView.byteOffset || 0;
    return new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);
  }
  addApplicationData(key, data) {
    this.json[key] = data;
    return this;
  }
  addExtraData(key, data) {
    this.json.extras = this.json.extras || {};
    this.json.extras[key] = data;
    return this;
  }
  addObjectExtension(object, extensionName, data) {
    object.extensions = object.extensions || {};
    object.extensions[extensionName] = data;
    this.registerUsedExtension(extensionName);
    return this;
  }
  setObjectExtension(object, extensionName, data) {
    const extensions = object.extensions || {};
    extensions[extensionName] = data;
  }
  removeObjectExtension(object, extensionName) {
    const extensions = object?.extensions || {};
    if (extensions[extensionName]) {
      this.json.extensionsRemoved = this.json.extensionsRemoved || [];
      const extensionsRemoved = this.json.extensionsRemoved;
      if (!extensionsRemoved.includes(extensionName)) {
        extensionsRemoved.push(extensionName);
      }
    }
    delete extensions[extensionName];
  }
  addExtension(extensionName, extensionData = {}) {
    assert4(extensionData);
    this.json.extensions = this.json.extensions || {};
    this.json.extensions[extensionName] = extensionData;
    this.registerUsedExtension(extensionName);
    return extensionData;
  }
  addRequiredExtension(extensionName, extensionData = {}) {
    assert4(extensionData);
    this.addExtension(extensionName, extensionData);
    this.registerRequiredExtension(extensionName);
    return extensionData;
  }
  registerUsedExtension(extensionName) {
    this.json.extensionsUsed = this.json.extensionsUsed || [];
    if (!this.json.extensionsUsed.find((ext) => ext === extensionName)) {
      this.json.extensionsUsed.push(extensionName);
    }
  }
  registerRequiredExtension(extensionName) {
    this.registerUsedExtension(extensionName);
    this.json.extensionsRequired = this.json.extensionsRequired || [];
    if (!this.json.extensionsRequired.find((ext) => ext === extensionName)) {
      this.json.extensionsRequired.push(extensionName);
    }
  }
  removeExtension(extensionName) {
    if (this.json.extensions?.[extensionName]) {
      this.json.extensionsRemoved = this.json.extensionsRemoved || [];
      const extensionsRemoved = this.json.extensionsRemoved;
      if (!extensionsRemoved.includes(extensionName)) {
        extensionsRemoved.push(extensionName);
      }
    }
    if (this.json.extensions) {
      delete this.json.extensions[extensionName];
    }
    if (this.json.extensionsRequired) {
      this._removeStringFromArray(this.json.extensionsRequired, extensionName);
    }
    if (this.json.extensionsUsed) {
      this._removeStringFromArray(this.json.extensionsUsed, extensionName);
    }
  }
  setDefaultScene(sceneIndex) {
    this.json.scene = sceneIndex;
  }
  addScene(scene) {
    const { nodeIndices } = scene;
    this.json.scenes = this.json.scenes || [];
    this.json.scenes.push({ nodes: nodeIndices });
    return this.json.scenes.length - 1;
  }
  addNode(node) {
    const { meshIndex, matrix } = node;
    this.json.nodes = this.json.nodes || [];
    const nodeData = { mesh: meshIndex };
    if (matrix) {
      nodeData.matrix = matrix;
    }
    this.json.nodes.push(nodeData);
    return this.json.nodes.length - 1;
  }
  addMesh(mesh) {
    const { attributes, indices, material, mode = 4 } = mesh;
    const accessors = this._addAttributes(attributes);
    const glTFMesh = {
      primitives: [
        {
          attributes: accessors,
          mode
        }
      ]
    };
    if (indices) {
      const indicesAccessor = this._addIndices(indices);
      glTFMesh.primitives[0].indices = indicesAccessor;
    }
    if (Number.isFinite(material)) {
      glTFMesh.primitives[0].material = material;
    }
    this.json.meshes = this.json.meshes || [];
    this.json.meshes.push(glTFMesh);
    return this.json.meshes.length - 1;
  }
  addPointCloud(attributes) {
    const accessorIndices = this._addAttributes(attributes);
    const glTFMesh = {
      primitives: [
        {
          attributes: accessorIndices,
          mode: 0
        }
      ]
    };
    this.json.meshes = this.json.meshes || [];
    this.json.meshes.push(glTFMesh);
    return this.json.meshes.length - 1;
  }
  addImage(imageData, mimeTypeOpt) {
    const metadata = getBinaryImageMetadata(imageData);
    const mimeType = mimeTypeOpt || metadata?.mimeType;
    const bufferViewIndex = this.addBufferView(imageData);
    const glTFImage = {
      bufferView: bufferViewIndex,
      mimeType
    };
    this.json.images = this.json.images || [];
    this.json.images.push(glTFImage);
    return this.json.images.length - 1;
  }
  addBufferView(buffer, bufferIndex = 0, byteOffset = this.byteLength) {
    const byteLength = buffer.byteLength;
    assert4(Number.isFinite(byteLength));
    this.sourceBuffers = this.sourceBuffers || [];
    this.sourceBuffers.push(buffer);
    const glTFBufferView = {
      buffer: bufferIndex,
      byteOffset,
      byteLength
    };
    this.byteLength += padToNBytes(byteLength, 4);
    this.json.bufferViews = this.json.bufferViews || [];
    this.json.bufferViews.push(glTFBufferView);
    return this.json.bufferViews.length - 1;
  }
  addAccessor(bufferViewIndex, accessor) {
    const glTFAccessor = {
      bufferView: bufferViewIndex,
      type: getAccessorTypeFromSize(accessor.size),
      componentType: accessor.componentType,
      count: accessor.count,
      max: accessor.max,
      min: accessor.min
    };
    this.json.accessors = this.json.accessors || [];
    this.json.accessors.push(glTFAccessor);
    return this.json.accessors.length - 1;
  }
  addBinaryBuffer(sourceBuffer, accessor = { size: 3 }) {
    const bufferViewIndex = this.addBufferView(sourceBuffer);
    let minMax = { min: accessor.min, max: accessor.max };
    if (!minMax.min || !minMax.max) {
      minMax = this._getAccessorMinMax(sourceBuffer, accessor.size);
    }
    const accessorDefaults = {
      size: accessor.size,
      componentType: getComponentTypeFromArray(sourceBuffer),
      count: Math.round(sourceBuffer.length / accessor.size),
      min: minMax.min,
      max: minMax.max
    };
    return this.addAccessor(bufferViewIndex, Object.assign(accessorDefaults, accessor));
  }
  addTexture(texture) {
    const { imageIndex } = texture;
    const glTFTexture = {
      source: imageIndex
    };
    this.json.textures = this.json.textures || [];
    this.json.textures.push(glTFTexture);
    return this.json.textures.length - 1;
  }
  addMaterial(pbrMaterialInfo) {
    this.json.materials = this.json.materials || [];
    this.json.materials.push(pbrMaterialInfo);
    return this.json.materials.length - 1;
  }
  createBinaryChunk() {
    const totalByteLength = this.byteLength;
    const arrayBuffer = new ArrayBuffer(totalByteLength);
    const targetArray = new Uint8Array(arrayBuffer);
    let dstByteOffset = 0;
    for (const sourceBuffer of this.sourceBuffers || []) {
      dstByteOffset = copyToArray(sourceBuffer, targetArray, dstByteOffset);
    }
    if (this.json?.buffers?.[0]) {
      this.json.buffers[0].byteLength = totalByteLength;
    } else {
      this.json.buffers = [{ byteLength: totalByteLength }];
    }
    this.gltf.binary = arrayBuffer;
    this.sourceBuffers = [arrayBuffer];
    this.gltf.buffers = [{ arrayBuffer, byteOffset: 0, byteLength: arrayBuffer.byteLength }];
  }
  _removeStringFromArray(array, string) {
    let found = true;
    while (found) {
      const index = array.indexOf(string);
      if (index > -1) {
        array.splice(index, 1);
      } else {
        found = false;
      }
    }
  }
  _addAttributes(attributes = {}) {
    const result = {};
    for (const attributeKey in attributes) {
      const attributeData = attributes[attributeKey];
      const attrName = this._getGltfAttributeName(attributeKey);
      const accessor = this.addBinaryBuffer(attributeData.value, attributeData);
      result[attrName] = accessor;
    }
    return result;
  }
  _addIndices(indices) {
    return this.addBinaryBuffer(indices, { size: 1 });
  }
  _getGltfAttributeName(attributeName) {
    switch (attributeName.toLowerCase()) {
      case "position":
      case "positions":
      case "vertices":
        return "POSITION";
      case "normal":
      case "normals":
        return "NORMAL";
      case "color":
      case "colors":
        return "COLOR_0";
      case "texcoord":
      case "texcoords":
        return "TEXCOORD_0";
      default:
        return attributeName;
    }
  }
  _getAccessorMinMax(buffer, size) {
    const result = { min: null, max: null };
    if (buffer.length < size) {
      return result;
    }
    result.min = [];
    result.max = [];
    const initValues = buffer.subarray(0, size);
    for (const value of initValues) {
      result.min.push(value);
      result.max.push(value);
    }
    for (let index = size;index < buffer.length; index += size) {
      for (let componentIndex = 0;componentIndex < size; componentIndex++) {
        result.min[0 + componentIndex] = Math.min(result.min[0 + componentIndex], buffer[index + componentIndex]);
        result.max[0 + componentIndex] = Math.max(result.max[0 + componentIndex], buffer[index + componentIndex]);
      }
    }
    return result;
  }
}

// ../../node_modules/.bun/@loaders.gl+gltf@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/gltf/dist/lib/extensions/utils/3d-tiles-utils.js
function emod(n) {
  return (n % 1 + 1) % 1;
}
var ATTRIBUTE_TYPE_TO_COMPONENTS2 = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16,
  BOOLEAN: 1,
  STRING: 1,
  ENUM: 1
};
var ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY2 = {
  INT8: Int8Array,
  UINT8: Uint8Array,
  INT16: Int16Array,
  UINT16: Uint16Array,
  INT32: Int32Array,
  UINT32: Uint32Array,
  INT64: BigInt64Array,
  UINT64: BigUint64Array,
  FLOAT32: Float32Array,
  FLOAT64: Float64Array
};
var ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE2 = {
  INT8: 1,
  UINT8: 1,
  INT16: 2,
  UINT16: 2,
  INT32: 4,
  UINT32: 4,
  INT64: 8,
  UINT64: 8,
  FLOAT32: 4,
  FLOAT64: 8
};
function getArrayElementByteSize(attributeType, componentType) {
  return ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE2[componentType] * ATTRIBUTE_TYPE_TO_COMPONENTS2[attributeType];
}
function getOffsetsForProperty(scenegraph, bufferViewIndex, offsetType, numberOfElements) {
  if (offsetType !== "UINT8" && offsetType !== "UINT16" && offsetType !== "UINT32" && offsetType !== "UINT64") {
    return null;
  }
  const arrayOffsetsBytes = scenegraph.getTypedArrayForBufferView(bufferViewIndex);
  const arrayOffsets = convertRawBufferToMetadataArray(arrayOffsetsBytes, "SCALAR", offsetType, numberOfElements + 1);
  if (arrayOffsets instanceof BigInt64Array || arrayOffsets instanceof BigUint64Array) {
    return null;
  }
  return arrayOffsets;
}
function convertRawBufferToMetadataArray(data, attributeType, componentType, elementCount = 1) {
  const numberOfComponents = ATTRIBUTE_TYPE_TO_COMPONENTS2[attributeType];
  const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY2[componentType];
  const size = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE2[componentType];
  const length = elementCount * numberOfComponents;
  const byteLength = length * size;
  let buffer = data.buffer;
  let offset = data.byteOffset;
  if (offset % size !== 0) {
    const bufferArray = new Uint8Array(buffer);
    buffer = bufferArray.slice(offset, offset + byteLength).buffer;
    offset = 0;
  }
  return new ArrayType(buffer, offset, length);
}
function getPrimitiveTextureData(scenegraph, textureInfo, primitive) {
  const texCoordAccessorKey = `TEXCOORD_${textureInfo.texCoord || 0}`;
  const texCoordAccessorIndex = primitive.attributes[texCoordAccessorKey];
  const textureCoordinates = scenegraph.getTypedArrayForAccessor(texCoordAccessorIndex);
  const json = scenegraph.gltf.json;
  const textureIndex = textureInfo.index;
  const imageIndex = json.textures?.[textureIndex]?.source;
  if (typeof imageIndex !== "undefined") {
    const mimeType = json.images?.[imageIndex]?.mimeType;
    const parsedImage = scenegraph.gltf.images?.[imageIndex];
    if (parsedImage && typeof parsedImage.width !== "undefined") {
      const textureData = [];
      for (let index = 0;index < textureCoordinates.length; index += 2) {
        const value = getImageValueByCoordinates(parsedImage, mimeType, textureCoordinates, index, textureInfo.channels);
        textureData.push(value);
      }
      return textureData;
    }
  }
  return [];
}
function primitivePropertyDataToAttributes(scenegraph, attributeName, propertyData, featureTable, primitive) {
  if (!propertyData?.length) {
    return;
  }
  const featureIndices = [];
  for (const texelData of propertyData) {
    let index = featureTable.findIndex((item) => item === texelData);
    if (index === -1) {
      index = featureTable.push(texelData) - 1;
    }
    featureIndices.push(index);
  }
  const typedArray = new Uint32Array(featureIndices);
  const bufferIndex = scenegraph.gltf.buffers.push({
    arrayBuffer: typedArray.buffer,
    byteOffset: typedArray.byteOffset,
    byteLength: typedArray.byteLength
  }) - 1;
  const bufferViewIndex = scenegraph.addBufferView(typedArray, bufferIndex, 0);
  const accessorIndex = scenegraph.addAccessor(bufferViewIndex, {
    size: 1,
    componentType: getComponentTypeFromArray(typedArray),
    count: typedArray.length
  });
  primitive.attributes[attributeName] = accessorIndex;
}
function getImageValueByCoordinates(parsedImage, mimeType, textureCoordinates, index, channels = [0]) {
  const CHANNELS_MAP = {
    r: { offset: 0, shift: 0 },
    g: { offset: 1, shift: 8 },
    b: { offset: 2, shift: 16 },
    a: { offset: 3, shift: 24 }
  };
  const u = textureCoordinates[index];
  const v = textureCoordinates[index + 1];
  let components = 1;
  if (mimeType && (mimeType.indexOf("image/jpeg") !== -1 || mimeType.indexOf("image/png") !== -1))
    components = 4;
  const offset = coordinatesToOffset(u, v, parsedImage, components);
  let value = 0;
  for (const c of channels) {
    const map = typeof c === "number" ? Object.values(CHANNELS_MAP)[c] : CHANNELS_MAP[c];
    const imageOffset = offset + map.offset;
    const imageData = getImageData(parsedImage);
    if (imageData.data.length <= imageOffset) {
      throw new Error(`${imageData.data.length} <= ${imageOffset}`);
    }
    const imageValue = imageData.data[imageOffset];
    value |= imageValue << map.shift;
  }
  return value;
}
function coordinatesToOffset(u, v, parsedImage, componentsCount = 1) {
  const w = parsedImage.width;
  const iX = emod(u) * (w - 1);
  const indX = Math.round(iX);
  const h = parsedImage.height;
  const iY = emod(v) * (h - 1);
  const indY = Math.round(iY);
  const components = parsedImage.components ? parsedImage.components : componentsCount;
  const offset = (indY * w + indX) * components;
  return offset;
}
function parseVariableLengthArrayNumeric(valuesData, numberOfElements, arrayOffsets, valuesDataBytesLength, valueSize) {
  const attributeValueArray = [];
  for (let index = 0;index < numberOfElements; index++) {
    const arrayOffset = arrayOffsets[index];
    const arrayByteSize = arrayOffsets[index + 1] - arrayOffsets[index];
    if (arrayByteSize + arrayOffset > valuesDataBytesLength) {
      break;
    }
    const typedArrayOffset = arrayOffset / valueSize;
    const elementCount = arrayByteSize / valueSize;
    attributeValueArray.push(valuesData.slice(typedArrayOffset, typedArrayOffset + elementCount));
  }
  return attributeValueArray;
}
function parseFixedLengthArrayNumeric(valuesData, numberOfElements, arrayCount) {
  const attributeValueArray = [];
  for (let index = 0;index < numberOfElements; index++) {
    const elementOffset = index * arrayCount;
    attributeValueArray.push(valuesData.slice(elementOffset, elementOffset + arrayCount));
  }
  return attributeValueArray;
}
function getPropertyDataString(numberOfElements, valuesDataBytes, arrayOffsets, stringOffsets) {
  if (arrayOffsets) {
    throw new Error("Not implemented - arrayOffsets for strings is specified");
  }
  if (stringOffsets) {
    const stringsArray = [];
    const textDecoder = new TextDecoder("utf8");
    let stringOffset = 0;
    for (let index = 0;index < numberOfElements; index++) {
      const stringByteSize = stringOffsets[index + 1] - stringOffsets[index];
      if (stringByteSize + stringOffset <= valuesDataBytes.length) {
        const stringData = valuesDataBytes.subarray(stringOffset, stringByteSize + stringOffset);
        const stringAttribute = textDecoder.decode(stringData);
        stringsArray.push(stringAttribute);
        stringOffset += stringByteSize;
      }
    }
    return stringsArray;
  }
  return [];
}

// ../../node_modules/.bun/@loaders.gl+gltf@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/gltf/dist/lib/extensions/EXT_mesh_features.js
var EXT_MESH_FEATURES_NAME = "EXT_mesh_features";
var name = EXT_MESH_FEATURES_NAME;
async function decode(gltfData, options) {
  const scenegraph = new GLTFScenegraph(gltfData);
  decodeExtMeshFeatures(scenegraph, options);
}
function encode(gltfData, options) {
  const scenegraph = new GLTFScenegraph(gltfData);
  encodeExtMeshFeatures(scenegraph, options);
  scenegraph.createBinaryChunk();
  return scenegraph.gltf;
}
function decodeExtMeshFeatures(scenegraph, options) {
  const json = scenegraph.gltf.json;
  if (!json.meshes) {
    return;
  }
  for (const mesh of json.meshes) {
    for (const primitive of mesh.primitives) {
      processMeshPrimitiveFeatures(scenegraph, primitive, options);
    }
  }
}
function processMeshPrimitiveFeatures(scenegraph, primitive, options) {
  if (!options?.gltf?.loadBuffers) {
    return;
  }
  const extension = primitive.extensions?.[EXT_MESH_FEATURES_NAME];
  const featureIds = extension?.featureIds;
  if (!featureIds) {
    return;
  }
  for (const featureId of featureIds) {
    let featureIdData;
    if (typeof featureId.attribute !== "undefined") {
      const accessorKey = `_FEATURE_ID_${featureId.attribute}`;
      const accessorIndex = primitive.attributes[accessorKey];
      featureIdData = scenegraph.getTypedArrayForAccessor(accessorIndex);
    } else if (typeof featureId.texture !== "undefined" && options?.gltf?.loadImages) {
      featureIdData = getPrimitiveTextureData(scenegraph, featureId.texture, primitive);
    } else {
      featureIdData = [];
    }
    featureId.data = featureIdData;
  }
}
function encodeExtMeshFeatures(scenegraph, options) {
  const meshes = scenegraph.gltf.json.meshes;
  if (!meshes) {
    return;
  }
  for (const mesh of meshes) {
    for (const primitive of mesh.primitives) {
      encodeExtMeshFeaturesForPrimitive(scenegraph, primitive);
    }
  }
}
function createExtMeshFeatures(scenegraph, primitive, featureIdArray, propertyTableIndex) {
  if (!primitive.extensions) {
    primitive.extensions = {};
  }
  let extension = primitive.extensions[EXT_MESH_FEATURES_NAME];
  if (!extension) {
    extension = { featureIds: [] };
    primitive.extensions[EXT_MESH_FEATURES_NAME] = extension;
  }
  const { featureIds } = extension;
  const featureId = {
    featureCount: featureIdArray.length,
    propertyTable: propertyTableIndex,
    data: featureIdArray
  };
  featureIds.push(featureId);
  scenegraph.addObjectExtension(primitive, EXT_MESH_FEATURES_NAME, extension);
}
function encodeExtMeshFeaturesForPrimitive(scenegraph, primitive) {
  const extension = primitive.extensions?.[EXT_MESH_FEATURES_NAME];
  if (!extension) {
    return;
  }
  const featureIds = extension.featureIds;
  featureIds.forEach((featureId, elementIndex) => {
    if (featureId.data) {
      const { accessorKey, index } = createAccessorKey(primitive.attributes);
      const typedArray = new Uint32Array(featureId.data);
      featureIds[elementIndex] = {
        featureCount: typedArray.length,
        propertyTable: featureId.propertyTable,
        attribute: index
      };
      scenegraph.gltf.buffers.push({
        arrayBuffer: typedArray.buffer,
        byteOffset: typedArray.byteOffset,
        byteLength: typedArray.byteLength
      });
      const bufferViewIndex = scenegraph.addBufferView(typedArray);
      const accessorIndex = scenegraph.addAccessor(bufferViewIndex, {
        size: 1,
        componentType: getComponentTypeFromArray(typedArray),
        count: typedArray.length
      });
      primitive.attributes[accessorKey] = accessorIndex;
    }
  });
}
function createAccessorKey(attributes) {
  const prefix = "_FEATURE_ID_";
  const attrs = Object.keys(attributes).filter((item) => item.indexOf(prefix) === 0);
  let max = -1;
  for (const a of attrs) {
    const n = Number(a.substring(prefix.length));
    if (n > max) {
      max = n;
    }
  }
  max++;
  const accessorKey = `${prefix}${max}`;
  return { accessorKey, index: max };
}

// ../../node_modules/.bun/@loaders.gl+gltf@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/gltf/dist/lib/extensions/EXT_structural_metadata.js
var exports_EXT_structural_metadata = {};
__export(exports_EXT_structural_metadata, {
  name: () => name2,
  encode: () => encode2,
  decode: () => decode2,
  createExtStructuralMetadata: () => createExtStructuralMetadata
});
var EXT_STRUCTURAL_METADATA_NAME = "EXT_structural_metadata";
var name2 = EXT_STRUCTURAL_METADATA_NAME;
async function decode2(gltfData, options) {
  const scenegraph = new GLTFScenegraph(gltfData);
  decodeExtStructuralMetadata(scenegraph, options);
}
function encode2(gltfData, options) {
  const scenegraph = new GLTFScenegraph(gltfData);
  encodeExtStructuralMetadata(scenegraph, options);
  scenegraph.createBinaryChunk();
  return scenegraph.gltf;
}
function decodeExtStructuralMetadata(scenegraph, options) {
  if (!options.gltf?.loadBuffers) {
    return;
  }
  const extension = scenegraph.getExtension(EXT_STRUCTURAL_METADATA_NAME);
  if (!extension) {
    return;
  }
  if (options.gltf?.loadImages) {
    decodePropertyTextures(scenegraph, extension);
  }
  decodePropertyTables(scenegraph, extension);
}
function decodePropertyTextures(scenegraph, extension) {
  const propertyTextures = extension.propertyTextures;
  const json = scenegraph.gltf.json;
  if (propertyTextures && json.meshes) {
    for (const mesh of json.meshes) {
      for (const primitive of mesh.primitives) {
        processPrimitivePropertyTextures(scenegraph, propertyTextures, primitive, extension);
      }
    }
  }
}
function decodePropertyTables(scenegraph, extension) {
  const schema = extension.schema;
  if (!schema) {
    return;
  }
  const schemaClasses = schema.classes;
  const propertyTables = extension.propertyTables;
  if (schemaClasses && propertyTables) {
    for (const schemaName in schemaClasses) {
      const propertyTable = findPropertyTableByClass(propertyTables, schemaName);
      if (propertyTable) {
        processPropertyTable(scenegraph, schema, propertyTable);
      }
    }
  }
}
function findPropertyTableByClass(propertyTables, schemaClassName) {
  for (const propertyTable of propertyTables) {
    if (propertyTable.class === schemaClassName) {
      return propertyTable;
    }
  }
  return null;
}
function processPrimitivePropertyTextures(scenegraph, propertyTextures, primitive, extension) {
  if (!propertyTextures) {
    return;
  }
  const primitiveExtension = primitive.extensions?.[EXT_STRUCTURAL_METADATA_NAME];
  const primitivePropertyTextureIndices = primitiveExtension?.propertyTextures;
  if (!primitivePropertyTextureIndices) {
    return;
  }
  for (const primitivePropertyTextureIndex of primitivePropertyTextureIndices) {
    const propertyTexture = propertyTextures[primitivePropertyTextureIndex];
    processPrimitivePropertyTexture(scenegraph, propertyTexture, primitive, extension);
  }
}
function processPrimitivePropertyTexture(scenegraph, propertyTexture, primitive, extension) {
  if (!propertyTexture.properties) {
    return;
  }
  if (!extension.dataAttributeNames) {
    extension.dataAttributeNames = [];
  }
  const className = propertyTexture.class;
  for (const propertyName in propertyTexture.properties) {
    const attributeName = `${className}_${propertyName}`;
    const textureInfoTopLevel = propertyTexture.properties?.[propertyName];
    if (!textureInfoTopLevel) {
      continue;
    }
    if (!textureInfoTopLevel.data) {
      textureInfoTopLevel.data = [];
    }
    const featureTextureTable = textureInfoTopLevel.data;
    const propertyData = getPrimitiveTextureData(scenegraph, textureInfoTopLevel, primitive);
    if (propertyData === null) {
      continue;
    }
    primitivePropertyDataToAttributes(scenegraph, attributeName, propertyData, featureTextureTable, primitive);
    textureInfoTopLevel.data = featureTextureTable;
    extension.dataAttributeNames.push(attributeName);
  }
}
function processPropertyTable(scenegraph, schema, propertyTable) {
  const schemaClass = schema.classes?.[propertyTable.class];
  if (!schemaClass) {
    throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${propertyTable.class}`);
  }
  const numberOfElements = propertyTable.count;
  for (const propertyName in schemaClass.properties) {
    const classProperty = schemaClass.properties[propertyName];
    const propertyTableProperty = propertyTable.properties?.[propertyName];
    if (propertyTableProperty) {
      const data = getPropertyDataFromBinarySource(scenegraph, schema, classProperty, numberOfElements, propertyTableProperty);
      propertyTableProperty.data = data;
    }
  }
}
function getPropertyDataFromBinarySource(scenegraph, schema, classProperty, numberOfElements, propertyTableProperty) {
  let data = [];
  const valuesBufferView = propertyTableProperty.values;
  const valuesDataBytes = scenegraph.getTypedArrayForBufferView(valuesBufferView);
  const arrayOffsets = getArrayOffsetsForProperty(scenegraph, classProperty, propertyTableProperty, numberOfElements);
  const stringOffsets = getStringOffsetsForProperty(scenegraph, propertyTableProperty, numberOfElements);
  switch (classProperty.type) {
    case "SCALAR":
    case "VEC2":
    case "VEC3":
    case "VEC4":
    case "MAT2":
    case "MAT3":
    case "MAT4": {
      data = getPropertyDataNumeric(classProperty, numberOfElements, valuesDataBytes, arrayOffsets);
      break;
    }
    case "BOOLEAN": {
      throw new Error(`Not implemented - classProperty.type=${classProperty.type}`);
    }
    case "STRING": {
      data = getPropertyDataString(numberOfElements, valuesDataBytes, arrayOffsets, stringOffsets);
      break;
    }
    case "ENUM": {
      data = getPropertyDataENUM(schema, classProperty, numberOfElements, valuesDataBytes, arrayOffsets);
      break;
    }
    default:
      throw new Error(`Unknown classProperty type ${classProperty.type}`);
  }
  return data;
}
function getArrayOffsetsForProperty(scenegraph, classProperty, propertyTableProperty, numberOfElements) {
  if (classProperty.array && typeof classProperty.count === "undefined" && typeof propertyTableProperty.arrayOffsets !== "undefined") {
    return getOffsetsForProperty(scenegraph, propertyTableProperty.arrayOffsets, propertyTableProperty.arrayOffsetType || "UINT32", numberOfElements);
  }
  return null;
}
function getStringOffsetsForProperty(scenegraph, propertyTableProperty, numberOfElements) {
  if (typeof propertyTableProperty.stringOffsets !== "undefined") {
    return getOffsetsForProperty(scenegraph, propertyTableProperty.stringOffsets, propertyTableProperty.stringOffsetType || "UINT32", numberOfElements);
  }
  return null;
}
function getPropertyDataNumeric(classProperty, numberOfElements, valuesDataBytes, arrayOffsets) {
  const isArray = classProperty.array;
  const arrayCount = classProperty.count;
  const elementSize = getArrayElementByteSize(classProperty.type, classProperty.componentType);
  const elementCount = valuesDataBytes.byteLength / elementSize;
  let valuesData;
  if (classProperty.componentType) {
    valuesData = convertRawBufferToMetadataArray(valuesDataBytes, classProperty.type, classProperty.componentType, elementCount);
  } else {
    valuesData = valuesDataBytes;
  }
  if (isArray) {
    if (arrayOffsets) {
      return parseVariableLengthArrayNumeric(valuesData, numberOfElements, arrayOffsets, valuesDataBytes.length, elementSize);
    }
    if (arrayCount) {
      return parseFixedLengthArrayNumeric(valuesData, numberOfElements, arrayCount);
    }
    return [];
  }
  return valuesData;
}
function getPropertyDataENUM(schema, classProperty, numberOfElements, valuesDataBytes, arrayOffsets) {
  const enumType = classProperty.enumType;
  if (!enumType) {
    throw new Error("Incorrect data in the EXT_structural_metadata extension: classProperty.enumType is not set for type ENUM");
  }
  const enumEntry = schema.enums?.[enumType];
  if (!enumEntry) {
    throw new Error(`Incorrect data in the EXT_structural_metadata extension: schema.enums does't contain ${enumType}`);
  }
  const enumValueType = enumEntry.valueType || "UINT16";
  const elementSize = getArrayElementByteSize(classProperty.type, enumValueType);
  const elementCount = valuesDataBytes.byteLength / elementSize;
  let valuesData = convertRawBufferToMetadataArray(valuesDataBytes, classProperty.type, enumValueType, elementCount);
  if (!valuesData) {
    valuesData = valuesDataBytes;
  }
  if (classProperty.array) {
    if (arrayOffsets) {
      return parseVariableLengthArrayENUM({
        valuesData,
        numberOfElements,
        arrayOffsets,
        valuesDataBytesLength: valuesDataBytes.length,
        elementSize,
        enumEntry
      });
    }
    const arrayCount = classProperty.count;
    if (arrayCount) {
      return parseFixedLengthArrayENUM(valuesData, numberOfElements, arrayCount, enumEntry);
    }
    return [];
  }
  return getEnumsArray(valuesData, 0, numberOfElements, enumEntry);
}
function parseVariableLengthArrayENUM(params) {
  const { valuesData, numberOfElements, arrayOffsets, valuesDataBytesLength, elementSize, enumEntry } = params;
  const attributeValueArray = [];
  for (let index = 0;index < numberOfElements; index++) {
    const arrayOffset = arrayOffsets[index];
    const arrayByteSize = arrayOffsets[index + 1] - arrayOffsets[index];
    if (arrayByteSize + arrayOffset > valuesDataBytesLength) {
      break;
    }
    const typedArrayOffset = arrayOffset / elementSize;
    const elementCount = arrayByteSize / elementSize;
    const array = getEnumsArray(valuesData, typedArrayOffset, elementCount, enumEntry);
    attributeValueArray.push(array);
  }
  return attributeValueArray;
}
function parseFixedLengthArrayENUM(valuesData, numberOfElements, arrayCount, enumEntry) {
  const attributeValueArray = [];
  for (let index = 0;index < numberOfElements; index++) {
    const elementOffset = arrayCount * index;
    const array = getEnumsArray(valuesData, elementOffset, arrayCount, enumEntry);
    attributeValueArray.push(array);
  }
  return attributeValueArray;
}
function getEnumsArray(valuesData, offset, count, enumEntry) {
  const array = [];
  for (let i = 0;i < count; i++) {
    if (valuesData instanceof BigInt64Array || valuesData instanceof BigUint64Array) {
      array.push("");
    } else {
      const value = valuesData[offset + i];
      const enumObject = getEnumByValue(enumEntry, value);
      if (enumObject) {
        array.push(enumObject.name);
      } else {
        array.push("");
      }
    }
  }
  return array;
}
function getEnumByValue(enumEntry, value) {
  for (const enumValue of enumEntry.values) {
    if (enumValue.value === value) {
      return enumValue;
    }
  }
  return null;
}
var SCHEMA_CLASS_ID_DEFAULT = "schemaClassId";
function encodeExtStructuralMetadata(scenegraph, options) {
  const extension = scenegraph.getExtension(EXT_STRUCTURAL_METADATA_NAME);
  if (!extension) {
    return;
  }
  if (extension.propertyTables) {
    for (const table of extension.propertyTables) {
      const classId = table.class;
      const schemaClass = extension.schema?.classes?.[classId];
      if (table.properties && schemaClass) {
        encodeProperties(table, schemaClass, scenegraph);
      }
    }
  }
}
function encodeProperties(table, schemaClass, scenegraph) {
  for (const propertyName in table.properties) {
    const data = table.properties[propertyName].data;
    if (data) {
      const classProperty = schemaClass.properties[propertyName];
      if (classProperty) {
        const tableProperty = createPropertyTableProperty(data, classProperty, scenegraph);
        table.properties[propertyName] = tableProperty;
      }
    }
  }
}
function createExtStructuralMetadata(scenegraph, propertyAttributes, classId = SCHEMA_CLASS_ID_DEFAULT) {
  let extension = scenegraph.getExtension(EXT_STRUCTURAL_METADATA_NAME);
  if (!extension) {
    extension = scenegraph.addExtension(EXT_STRUCTURAL_METADATA_NAME);
  }
  extension.schema = createSchema(propertyAttributes, classId, extension.schema);
  const table = createPropertyTable(propertyAttributes, classId, extension.schema);
  if (!extension.propertyTables) {
    extension.propertyTables = [];
  }
  return extension.propertyTables.push(table) - 1;
}
function createSchema(propertyAttributes, classId, schemaToUpdate) {
  const schema = schemaToUpdate ?? {
    id: "schema_id"
  };
  const schemaClass = {
    properties: {}
  };
  for (const attribute of propertyAttributes) {
    const classProperty = {
      type: attribute.elementType,
      componentType: attribute.componentType
    };
    schemaClass.properties[attribute.name] = classProperty;
  }
  schema.classes = {};
  schema.classes[classId] = schemaClass;
  return schema;
}
function createPropertyTable(propertyAttributes, classId, schema) {
  const table = {
    class: classId,
    count: 0
  };
  let count = 0;
  const schemaClass = schema.classes?.[classId];
  for (const attribute of propertyAttributes) {
    if (count === 0) {
      count = attribute.values.length;
    }
    if (count !== attribute.values.length && attribute.values.length) {
      throw new Error("Illegal values in attributes");
    }
    const classProperty = schemaClass?.properties[attribute.name];
    if (classProperty) {
      if (!table.properties) {
        table.properties = {};
      }
      table.properties[attribute.name] = { values: 0, data: attribute.values };
    }
  }
  table.count = count;
  return table;
}
function createPropertyTableProperty(values, classProperty, scenegraph) {
  const prop = { values: 0 };
  if (classProperty.type === "STRING") {
    const { stringData, stringOffsets } = createPropertyDataString(values);
    prop.stringOffsets = createBufferView(stringOffsets, scenegraph);
    prop.values = createBufferView(stringData, scenegraph);
  } else if (classProperty.type === "SCALAR" && classProperty.componentType) {
    const data = createPropertyDataScalar(values, classProperty.componentType);
    prop.values = createBufferView(data, scenegraph);
  }
  return prop;
}
var COMPONENT_TYPE_TO_ARRAY_CONSTRUCTOR = {
  INT8: Int8Array,
  UINT8: Uint8Array,
  INT16: Int16Array,
  UINT16: Uint16Array,
  INT32: Int32Array,
  UINT32: Uint32Array,
  INT64: Int32Array,
  UINT64: Uint32Array,
  FLOAT32: Float32Array,
  FLOAT64: Float64Array
};
function createPropertyDataScalar(array, componentType) {
  const numberArray = [];
  for (const value of array) {
    numberArray.push(Number(value));
  }
  const Construct = COMPONENT_TYPE_TO_ARRAY_CONSTRUCTOR[componentType];
  if (!Construct) {
    throw new Error("Illegal component type");
  }
  return new Construct(numberArray);
}
function createPropertyDataString(strings) {
  const utf8Encode = new TextEncoder;
  const arr = [];
  let len = 0;
  for (const str of strings) {
    const uint8Array = utf8Encode.encode(str);
    len += uint8Array.length;
    arr.push(uint8Array);
  }
  const strArray = new Uint8Array(len);
  const strOffsets = [];
  let offset = 0;
  for (const str of arr) {
    strArray.set(str, offset);
    strOffsets.push(offset);
    offset += str.length;
  }
  strOffsets.push(offset);
  const stringOffsetsTypedArray = new Uint32Array(strOffsets);
  return { stringData: strArray, stringOffsets: stringOffsetsTypedArray };
}
function createBufferView(typedArray, scenegraph) {
  scenegraph.gltf.buffers.push({
    arrayBuffer: typedArray.buffer,
    byteOffset: typedArray.byteOffset,
    byteLength: typedArray.byteLength
  });
  return scenegraph.addBufferView(typedArray);
}

// ../../node_modules/.bun/@loaders.gl+gltf@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/gltf/dist/lib/extensions/deprecated/EXT_feature_metadata.js
var exports_EXT_feature_metadata = {};
__export(exports_EXT_feature_metadata, {
  name: () => name3,
  decode: () => decode3
});
var EXT_FEATURE_METADATA_NAME = "EXT_feature_metadata";
var name3 = EXT_FEATURE_METADATA_NAME;
async function decode3(gltfData, options) {
  const scenegraph = new GLTFScenegraph(gltfData);
  decodeExtFeatureMetadata(scenegraph, options);
}
function decodeExtFeatureMetadata(scenegraph, options) {
  if (!options.gltf?.loadBuffers) {
    return;
  }
  const extension = scenegraph.getExtension(EXT_FEATURE_METADATA_NAME);
  if (!extension) {
    return;
  }
  if (options.gltf?.loadImages) {
    decodePropertyTextures2(scenegraph, extension);
  }
  decodePropertyTables2(scenegraph, extension);
}
function decodePropertyTextures2(scenegraph, extension) {
  const schema = extension.schema;
  if (!schema) {
    return;
  }
  const schemaClasses = schema.classes;
  const { featureTextures } = extension;
  if (schemaClasses && featureTextures) {
    for (const schemaName in schemaClasses) {
      const schemaClass = schemaClasses[schemaName];
      const featureTexture = findFeatureTextureByClass(featureTextures, schemaName);
      if (featureTexture) {
        handleFeatureTextureProperties(scenegraph, featureTexture, schemaClass);
      }
    }
  }
}
function decodePropertyTables2(scenegraph, extension) {
  const schema = extension.schema;
  if (!schema) {
    return;
  }
  const schemaClasses = schema.classes;
  const propertyTables = extension.featureTables;
  if (schemaClasses && propertyTables) {
    for (const schemaName in schemaClasses) {
      const propertyTable = findPropertyTableByClass2(propertyTables, schemaName);
      if (propertyTable) {
        processPropertyTable2(scenegraph, schema, propertyTable);
      }
    }
  }
}
function findPropertyTableByClass2(propertyTables, schemaClassName) {
  for (const propertyTableName in propertyTables) {
    const propertyTable = propertyTables[propertyTableName];
    if (propertyTable.class === schemaClassName) {
      return propertyTable;
    }
  }
  return null;
}
function findFeatureTextureByClass(featureTextures, schemaClassName) {
  for (const featureTexturesName in featureTextures) {
    const featureTable = featureTextures[featureTexturesName];
    if (featureTable.class === schemaClassName) {
      return featureTable;
    }
  }
  return null;
}
function processPropertyTable2(scenegraph, schema, propertyTable) {
  if (!propertyTable.class) {
    return;
  }
  const schemaClass = schema.classes?.[propertyTable.class];
  if (!schemaClass) {
    throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${propertyTable.class}`);
  }
  const numberOfElements = propertyTable.count;
  for (const propertyName in schemaClass.properties) {
    const classProperty = schemaClass.properties[propertyName];
    const propertyTableProperty = propertyTable.properties?.[propertyName];
    if (propertyTableProperty) {
      const data = getPropertyDataFromBinarySource2(scenegraph, schema, classProperty, numberOfElements, propertyTableProperty);
      propertyTableProperty.data = data;
    }
  }
}
function handleFeatureTextureProperties(scenegraph, featureTexture, schemaClass) {
  const attributeName = featureTexture.class;
  for (const propertyName in schemaClass.properties) {
    const featureTextureProperty = featureTexture?.properties?.[propertyName];
    if (featureTextureProperty) {
      const data = getPropertyDataFromTexture(scenegraph, featureTextureProperty, attributeName);
      featureTextureProperty.data = data;
    }
  }
}
function getPropertyDataFromBinarySource2(scenegraph, schema, classProperty, numberOfFeatures, featureTableProperty) {
  let data = [];
  const bufferView = featureTableProperty.bufferView;
  const dataArray = scenegraph.getTypedArrayForBufferView(bufferView);
  const arrayOffsets = getArrayOffsetsForProperty2(scenegraph, classProperty, featureTableProperty, numberOfFeatures);
  const stringOffsets = getStringOffsetsForProperty2(scenegraph, classProperty, featureTableProperty, numberOfFeatures);
  if (classProperty.type === "STRING" || classProperty.componentType === "STRING") {
    data = getPropertyDataString(numberOfFeatures, dataArray, arrayOffsets, stringOffsets);
  } else if (isNumericProperty(classProperty)) {
    data = getPropertyDataNumeric2(classProperty, numberOfFeatures, dataArray, arrayOffsets);
  }
  return data;
}
function getArrayOffsetsForProperty2(scenegraph, classProperty, propertyTableProperty, numberOfElements) {
  if (classProperty.type === "ARRAY" && typeof classProperty.componentCount === "undefined" && typeof propertyTableProperty.arrayOffsetBufferView !== "undefined") {
    return getOffsetsForProperty(scenegraph, propertyTableProperty.arrayOffsetBufferView, propertyTableProperty.offsetType || "UINT32", numberOfElements);
  }
  return null;
}
function getStringOffsetsForProperty2(scenegraph, classProperty, propertyTableProperty, numberOfElements) {
  if (typeof propertyTableProperty.stringOffsetBufferView !== "undefined") {
    return getOffsetsForProperty(scenegraph, propertyTableProperty.stringOffsetBufferView, propertyTableProperty.offsetType || "UINT32", numberOfElements);
  }
  return null;
}
function isNumericProperty(schemaProperty) {
  const types = [
    "UINT8",
    "INT16",
    "UINT16",
    "INT32",
    "UINT32",
    "INT64",
    "UINT64",
    "FLOAT32",
    "FLOAT64"
  ];
  return types.includes(schemaProperty.type) || typeof schemaProperty.componentType !== "undefined" && types.includes(schemaProperty.componentType);
}
function getPropertyDataNumeric2(classProperty, numberOfElements, valuesDataBytes, arrayOffsets) {
  const isArray = classProperty.type === "ARRAY";
  const arrayCount = classProperty.componentCount;
  const attributeType = "SCALAR";
  const componentType = classProperty.componentType || classProperty.type;
  const elementSize = getArrayElementByteSize(attributeType, componentType);
  const elementCount = valuesDataBytes.byteLength / elementSize;
  const valuesData = convertRawBufferToMetadataArray(valuesDataBytes, attributeType, componentType, elementCount);
  if (isArray) {
    if (arrayOffsets) {
      return parseVariableLengthArrayNumeric(valuesData, numberOfElements, arrayOffsets, valuesDataBytes.length, elementSize);
    }
    if (arrayCount) {
      return parseFixedLengthArrayNumeric(valuesData, numberOfElements, arrayCount);
    }
    return [];
  }
  return valuesData;
}
function getPropertyDataFromTexture(scenegraph, featureTextureProperty, attributeName) {
  const json = scenegraph.gltf.json;
  if (!json.meshes) {
    return [];
  }
  const featureTextureTable = [];
  for (const mesh of json.meshes) {
    for (const primitive of mesh.primitives) {
      processPrimitiveTextures(scenegraph, attributeName, featureTextureProperty, featureTextureTable, primitive);
    }
  }
  return featureTextureTable;
}
function processPrimitiveTextures(scenegraph, attributeName, featureTextureProperty, featureTextureTable, primitive) {
  const textureInfoTopLevel = {
    channels: featureTextureProperty.channels,
    ...featureTextureProperty.texture
  };
  const propertyData = getPrimitiveTextureData(scenegraph, textureInfoTopLevel, primitive);
  if (!propertyData) {
    return;
  }
  primitivePropertyDataToAttributes(scenegraph, attributeName, propertyData, featureTextureTable, primitive);
}

// ../../node_modules/.bun/@loaders.gl+gltf@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/gltf/dist/lib/utils/version.js
var VERSION5 = "4.3.3";

// ../../node_modules/.bun/@loaders.gl+textures@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/textures/dist/lib/utils/version.js
var VERSION6 = "4.3.3";

// ../../node_modules/.bun/@loaders.gl+textures@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/textures/dist/lib/parsers/basis-module-loader.js
var BASIS_EXTERNAL_LIBRARIES = {
  TRANSCODER: "basis_transcoder.js",
  TRANSCODER_WASM: "basis_transcoder.wasm",
  ENCODER: "basis_encoder.js",
  ENCODER_WASM: "basis_encoder.wasm"
};
var loadBasisTranscoderPromise;
async function loadBasisTranscoderModule(options) {
  registerJSModules(options.modules);
  const basis = getJSModuleOrNull("basis");
  if (basis) {
    return basis;
  }
  loadBasisTranscoderPromise ||= loadBasisTranscoder(options);
  return await loadBasisTranscoderPromise;
}
async function loadBasisTranscoder(options) {
  let BASIS = null;
  let wasmBinary = null;
  [BASIS, wasmBinary] = await Promise.all([
    await loadLibrary(BASIS_EXTERNAL_LIBRARIES.TRANSCODER, "textures", options),
    await loadLibrary(BASIS_EXTERNAL_LIBRARIES.TRANSCODER_WASM, "textures", options)
  ]);
  BASIS = BASIS || globalThis.BASIS;
  return await initializeBasisTranscoderModule(BASIS, wasmBinary);
}
function initializeBasisTranscoderModule(BasisModule, wasmBinary) {
  const options = {};
  if (wasmBinary) {
    options.wasmBinary = wasmBinary;
  }
  return new Promise((resolve2) => {
    BasisModule(options).then((module) => {
      const { BasisFile, initializeBasis } = module;
      initializeBasis();
      resolve2({ BasisFile });
    });
  });
}
var loadBasisEncoderPromise;
async function loadBasisEncoderModule(options) {
  const modules = options.modules || {};
  if (modules.basisEncoder) {
    return modules.basisEncoder;
  }
  loadBasisEncoderPromise = loadBasisEncoderPromise || loadBasisEncoder(options);
  return await loadBasisEncoderPromise;
}
async function loadBasisEncoder(options) {
  let BASIS_ENCODER = null;
  let wasmBinary = null;
  [BASIS_ENCODER, wasmBinary] = await Promise.all([
    await loadLibrary(BASIS_EXTERNAL_LIBRARIES.ENCODER, "textures", options),
    await loadLibrary(BASIS_EXTERNAL_LIBRARIES.ENCODER_WASM, "textures", options)
  ]);
  BASIS_ENCODER = BASIS_ENCODER || globalThis.BASIS;
  return await initializeBasisEncoderModule(BASIS_ENCODER, wasmBinary);
}
function initializeBasisEncoderModule(BasisEncoderModule, wasmBinary) {
  const options = {};
  if (wasmBinary) {
    options.wasmBinary = wasmBinary;
  }
  return new Promise((resolve2) => {
    BasisEncoderModule(options).then((module) => {
      const { BasisFile, KTX2File, initializeBasis, BasisEncoder } = module;
      initializeBasis();
      resolve2({ BasisFile, KTX2File, BasisEncoder });
    });
  });
}

// ../../node_modules/.bun/@loaders.gl+textures@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/textures/dist/lib/gl-extensions.js
var GL_EXTENSIONS_CONSTANTS = {
  COMPRESSED_RGB_S3TC_DXT1_EXT: 33776,
  COMPRESSED_RGBA_S3TC_DXT1_EXT: 33777,
  COMPRESSED_RGBA_S3TC_DXT3_EXT: 33778,
  COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,
  COMPRESSED_R11_EAC: 37488,
  COMPRESSED_SIGNED_R11_EAC: 37489,
  COMPRESSED_RG11_EAC: 37490,
  COMPRESSED_SIGNED_RG11_EAC: 37491,
  COMPRESSED_RGB8_ETC2: 37492,
  COMPRESSED_RGBA8_ETC2_EAC: 37493,
  COMPRESSED_SRGB8_ETC2: 37494,
  COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 37495,
  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37496,
  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37497,
  COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840,
  COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842,
  COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 35841,
  COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 35843,
  COMPRESSED_RGB_ETC1_WEBGL: 36196,
  COMPRESSED_RGB_ATC_WEBGL: 35986,
  COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 35987,
  COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 34798,
  COMPRESSED_RGBA_ASTC_4X4_KHR: 37808,
  COMPRESSED_RGBA_ASTC_5X4_KHR: 37809,
  COMPRESSED_RGBA_ASTC_5X5_KHR: 37810,
  COMPRESSED_RGBA_ASTC_6X5_KHR: 37811,
  COMPRESSED_RGBA_ASTC_6X6_KHR: 37812,
  COMPRESSED_RGBA_ASTC_8X5_KHR: 37813,
  COMPRESSED_RGBA_ASTC_8X6_KHR: 37814,
  COMPRESSED_RGBA_ASTC_8X8_KHR: 37815,
  COMPRESSED_RGBA_ASTC_10X5_KHR: 37816,
  COMPRESSED_RGBA_ASTC_10X6_KHR: 37817,
  COMPRESSED_RGBA_ASTC_10X8_KHR: 37818,
  COMPRESSED_RGBA_ASTC_10X10_KHR: 37819,
  COMPRESSED_RGBA_ASTC_12X10_KHR: 37820,
  COMPRESSED_RGBA_ASTC_12X12_KHR: 37821,
  COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR: 37840,
  COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR: 37841,
  COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR: 37842,
  COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR: 37843,
  COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR: 37844,
  COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR: 37845,
  COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR: 37846,
  COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR: 37847,
  COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR: 37848,
  COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR: 37849,
  COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR: 37850,
  COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR: 37851,
  COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR: 37852,
  COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR: 37853,
  COMPRESSED_RED_RGTC1_EXT: 36283,
  COMPRESSED_SIGNED_RED_RGTC1_EXT: 36284,
  COMPRESSED_RED_GREEN_RGTC2_EXT: 36285,
  COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT: 36286,
  COMPRESSED_SRGB_S3TC_DXT1_EXT: 35916,
  COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: 35917,
  COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: 35918,
  COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: 35919
};

// ../../node_modules/.bun/@loaders.gl+textures@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/textures/dist/lib/utils/texture-formats.js
var BROWSER_PREFIXES = ["", "WEBKIT_", "MOZ_"];
var WEBGL_EXTENSIONS = {
  WEBGL_compressed_texture_s3tc: "dxt",
  WEBGL_compressed_texture_s3tc_srgb: "dxt-srgb",
  WEBGL_compressed_texture_etc1: "etc1",
  WEBGL_compressed_texture_etc: "etc2",
  WEBGL_compressed_texture_pvrtc: "pvrtc",
  WEBGL_compressed_texture_atc: "atc",
  WEBGL_compressed_texture_astc: "astc",
  EXT_texture_compression_rgtc: "rgtc"
};
var formats = null;
function getSupportedGPUTextureFormats(gl) {
  if (!formats) {
    gl = gl || getWebGLContext() || undefined;
    formats = new Set;
    for (const prefix of BROWSER_PREFIXES) {
      for (const extension in WEBGL_EXTENSIONS) {
        if (gl && gl.getExtension(`${prefix}${extension}`)) {
          const gpuTextureFormat = WEBGL_EXTENSIONS[extension];
          formats.add(gpuTextureFormat);
        }
      }
    }
  }
  return formats;
}
function getWebGLContext() {
  try {
    const canvas = document.createElement("canvas");
    return canvas.getContext("webgl");
  } catch (error) {
    return null;
  }
}

// ../../node_modules/.bun/@loaders.gl+textures@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/textures/dist/lib/parsers/parse-ktx.js
var KTX2_ID = [
  171,
  75,
  84,
  88,
  32,
  50,
  48,
  187,
  13,
  10,
  26,
  10
];
function isKTX(data) {
  const id = new Uint8Array(data);
  const notKTX = id.byteLength < KTX2_ID.length || id[0] !== KTX2_ID[0] || id[1] !== KTX2_ID[1] || id[2] !== KTX2_ID[2] || id[3] !== KTX2_ID[3] || id[4] !== KTX2_ID[4] || id[5] !== KTX2_ID[5] || id[6] !== KTX2_ID[6] || id[7] !== KTX2_ID[7] || id[8] !== KTX2_ID[8] || id[9] !== KTX2_ID[9] || id[10] !== KTX2_ID[10] || id[11] !== KTX2_ID[11];
  return !notKTX;
}

// ../../node_modules/.bun/@loaders.gl+textures@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/textures/dist/lib/parsers/parse-basis.js
var OutputFormat = {
  etc1: {
    basisFormat: 0,
    compressed: true,
    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_ETC1_WEBGL
  },
  etc2: { basisFormat: 1, compressed: true },
  bc1: {
    basisFormat: 2,
    compressed: true,
    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT
  },
  bc3: {
    basisFormat: 3,
    compressed: true,
    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT
  },
  bc4: { basisFormat: 4, compressed: true },
  bc5: { basisFormat: 5, compressed: true },
  "bc7-m6-opaque-only": { basisFormat: 6, compressed: true },
  "bc7-m5": { basisFormat: 7, compressed: true },
  "pvrtc1-4-rgb": {
    basisFormat: 8,
    compressed: true,
    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
  },
  "pvrtc1-4-rgba": {
    basisFormat: 9,
    compressed: true,
    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
  },
  "astc-4x4": {
    basisFormat: 10,
    compressed: true,
    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4X4_KHR
  },
  "atc-rgb": { basisFormat: 11, compressed: true },
  "atc-rgba-interpolated-alpha": { basisFormat: 12, compressed: true },
  rgba32: { basisFormat: 13, compressed: false },
  rgb565: { basisFormat: 14, compressed: false },
  bgr565: { basisFormat: 15, compressed: false },
  rgba4444: { basisFormat: 16, compressed: false }
};
async function parseBasis(data, options) {
  if (options.basis.containerFormat === "auto") {
    if (isKTX(data)) {
      const fileConstructors = await loadBasisEncoderModule(options);
      return parseKTX2File(fileConstructors.KTX2File, data, options);
    }
    const { BasisFile } = await loadBasisTranscoderModule(options);
    return parseBasisFile(BasisFile, data, options);
  }
  switch (options.basis.module) {
    case "encoder":
      const fileConstructors = await loadBasisEncoderModule(options);
      switch (options.basis.containerFormat) {
        case "ktx2":
          return parseKTX2File(fileConstructors.KTX2File, data, options);
        case "basis":
        default:
          return parseBasisFile(fileConstructors.BasisFile, data, options);
      }
    case "transcoder":
    default:
      const { BasisFile } = await loadBasisTranscoderModule(options);
      return parseBasisFile(BasisFile, data, options);
  }
}
function parseBasisFile(BasisFile, data, options) {
  const basisFile = new BasisFile(new Uint8Array(data));
  try {
    if (!basisFile.startTranscoding()) {
      throw new Error("Failed to start basis transcoding");
    }
    const imageCount = basisFile.getNumImages();
    const images = [];
    for (let imageIndex = 0;imageIndex < imageCount; imageIndex++) {
      const levelsCount = basisFile.getNumLevels(imageIndex);
      const levels = [];
      for (let levelIndex = 0;levelIndex < levelsCount; levelIndex++) {
        levels.push(transcodeImage(basisFile, imageIndex, levelIndex, options));
      }
      images.push(levels);
    }
    return images;
  } finally {
    basisFile.close();
    basisFile.delete();
  }
}
function transcodeImage(basisFile, imageIndex, levelIndex, options) {
  const width = basisFile.getImageWidth(imageIndex, levelIndex);
  const height = basisFile.getImageHeight(imageIndex, levelIndex);
  const hasAlpha = basisFile.getHasAlpha();
  const { compressed, format, basisFormat } = getBasisOptions(options, hasAlpha);
  const decodedSize = basisFile.getImageTranscodedSizeInBytes(imageIndex, levelIndex, basisFormat);
  const decodedData = new Uint8Array(decodedSize);
  if (!basisFile.transcodeImage(decodedData, imageIndex, levelIndex, basisFormat, 0, 0)) {
    throw new Error("failed to start Basis transcoding");
  }
  return {
    width,
    height,
    data: decodedData,
    compressed,
    format,
    hasAlpha
  };
}
function parseKTX2File(KTX2File, data, options) {
  const ktx2File = new KTX2File(new Uint8Array(data));
  try {
    if (!ktx2File.startTranscoding()) {
      throw new Error("failed to start KTX2 transcoding");
    }
    const levelsCount = ktx2File.getLevels();
    const levels = [];
    for (let levelIndex = 0;levelIndex < levelsCount; levelIndex++) {
      levels.push(transcodeKTX2Image(ktx2File, levelIndex, options));
    }
    return [levels];
  } finally {
    ktx2File.close();
    ktx2File.delete();
  }
}
function transcodeKTX2Image(ktx2File, levelIndex, options) {
  const { alphaFlag, height, width } = ktx2File.getImageLevelInfo(levelIndex, 0, 0);
  const { compressed, format, basisFormat } = getBasisOptions(options, alphaFlag);
  const decodedSize = ktx2File.getImageTranscodedSizeInBytes(levelIndex, 0, 0, basisFormat);
  const decodedData = new Uint8Array(decodedSize);
  if (!ktx2File.transcodeImage(decodedData, levelIndex, 0, 0, basisFormat, 0, -1, -1)) {
    throw new Error("Failed to transcode KTX2 image");
  }
  return {
    width,
    height,
    data: decodedData,
    compressed,
    levelSize: decodedSize,
    hasAlpha: alphaFlag,
    format
  };
}
function getBasisOptions(options, hasAlpha) {
  let format = options && options.basis && options.basis.format;
  if (format === "auto") {
    format = selectSupportedBasisFormat();
  }
  if (typeof format === "object") {
    format = hasAlpha ? format.alpha : format.noAlpha;
  }
  format = format.toLowerCase();
  return OutputFormat[format];
}
function selectSupportedBasisFormat() {
  const supportedFormats = getSupportedGPUTextureFormats();
  if (supportedFormats.has("astc")) {
    return "astc-4x4";
  } else if (supportedFormats.has("dxt")) {
    return {
      alpha: "bc3",
      noAlpha: "bc1"
    };
  } else if (supportedFormats.has("pvrtc")) {
    return {
      alpha: "pvrtc1-4-rgba",
      noAlpha: "pvrtc1-4-rgb"
    };
  } else if (supportedFormats.has("etc1")) {
    return "etc1";
  } else if (supportedFormats.has("etc2")) {
    return "etc2";
  }
  return "rgb565";
}

// ../../node_modules/.bun/@loaders.gl+textures@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/textures/dist/basis-loader.js
var BasisWorkerLoader = {
  dataType: null,
  batchType: null,
  name: "Basis",
  id: "basis",
  module: "textures",
  version: VERSION6,
  worker: true,
  extensions: ["basis", "ktx2"],
  mimeTypes: ["application/octet-stream", "image/ktx2"],
  tests: ["sB"],
  binary: true,
  options: {
    basis: {
      format: "auto",
      libraryPath: "libs/",
      containerFormat: "auto",
      module: "transcoder"
    }
  }
};
var BasisLoader = {
  ...BasisWorkerLoader,
  parse: parseBasis
};
// ../../node_modules/.bun/@loaders.gl+gltf@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/gltf/dist/lib/parsers/parse-glb.js
var LITTLE_ENDIAN2 = true;
var MAGIC_glTF = 1735152710;
var GLB_FILE_HEADER_SIZE = 12;
var GLB_CHUNK_HEADER_SIZE = 8;
var GLB_CHUNK_TYPE_JSON = 1313821514;
var GLB_CHUNK_TYPE_BIN = 5130562;
var GLB_V1_CONTENT_FORMAT_JSON = 0;
var GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED = 0;
var GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED = 1;
function getMagicString3(dataView, byteOffset = 0) {
  return `${String.fromCharCode(dataView.getUint8(byteOffset + 0))}${String.fromCharCode(dataView.getUint8(byteOffset + 1))}${String.fromCharCode(dataView.getUint8(byteOffset + 2))}${String.fromCharCode(dataView.getUint8(byteOffset + 3))}`;
}
function isGLB(arrayBuffer, byteOffset = 0, options = {}) {
  const dataView = new DataView(arrayBuffer);
  const { magic = MAGIC_glTF } = options;
  const magic1 = dataView.getUint32(byteOffset, false);
  return magic1 === magic || magic1 === MAGIC_glTF;
}
function parseGLBSync(glb, arrayBuffer, byteOffset = 0, options = {}) {
  const dataView = new DataView(arrayBuffer);
  const type = getMagicString3(dataView, byteOffset + 0);
  const version2 = dataView.getUint32(byteOffset + 4, LITTLE_ENDIAN2);
  const byteLength = dataView.getUint32(byteOffset + 8, LITTLE_ENDIAN2);
  Object.assign(glb, {
    header: {
      byteOffset,
      byteLength,
      hasBinChunk: false
    },
    type,
    version: version2,
    json: {},
    binChunks: []
  });
  byteOffset += GLB_FILE_HEADER_SIZE;
  switch (glb.version) {
    case 1:
      return parseGLBV1(glb, dataView, byteOffset);
    case 2:
      return parseGLBV2(glb, dataView, byteOffset, options = {});
    default:
      throw new Error(`Invalid GLB version ${glb.version}. Only supports version 1 and 2.`);
  }
}
function parseGLBV1(glb, dataView, byteOffset) {
  assert(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);
  const contentLength = dataView.getUint32(byteOffset + 0, LITTLE_ENDIAN2);
  const contentFormat = dataView.getUint32(byteOffset + 4, LITTLE_ENDIAN2);
  byteOffset += GLB_CHUNK_HEADER_SIZE;
  assert(contentFormat === GLB_V1_CONTENT_FORMAT_JSON);
  parseJSONChunk(glb, dataView, byteOffset, contentLength);
  byteOffset += contentLength;
  byteOffset += parseBINChunk(glb, dataView, byteOffset, glb.header.byteLength);
  return byteOffset;
}
function parseGLBV2(glb, dataView, byteOffset, options) {
  assert(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);
  parseGLBChunksSync(glb, dataView, byteOffset, options);
  return byteOffset + glb.header.byteLength;
}
function parseGLBChunksSync(glb, dataView, byteOffset, options) {
  while (byteOffset + 8 <= glb.header.byteLength) {
    const chunkLength = dataView.getUint32(byteOffset + 0, LITTLE_ENDIAN2);
    const chunkFormat = dataView.getUint32(byteOffset + 4, LITTLE_ENDIAN2);
    byteOffset += GLB_CHUNK_HEADER_SIZE;
    switch (chunkFormat) {
      case GLB_CHUNK_TYPE_JSON:
        parseJSONChunk(glb, dataView, byteOffset, chunkLength);
        break;
      case GLB_CHUNK_TYPE_BIN:
        parseBINChunk(glb, dataView, byteOffset, chunkLength);
        break;
      case GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED:
        if (!options.strict) {
          parseJSONChunk(glb, dataView, byteOffset, chunkLength);
        }
        break;
      case GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED:
        if (!options.strict) {
          parseBINChunk(glb, dataView, byteOffset, chunkLength);
        }
        break;
      default:
        break;
    }
    byteOffset += padToNBytes(chunkLength, 4);
  }
  return byteOffset;
}
function parseJSONChunk(glb, dataView, byteOffset, chunkLength) {
  const jsonChunk = new Uint8Array(dataView.buffer, byteOffset, chunkLength);
  const textDecoder = new TextDecoder("utf8");
  const jsonText = textDecoder.decode(jsonChunk);
  glb.json = JSON.parse(jsonText);
  return padToNBytes(chunkLength, 4);
}
function parseBINChunk(glb, dataView, byteOffset, chunkLength) {
  glb.header.hasBinChunk = true;
  glb.binChunks.push({
    byteOffset,
    byteLength: chunkLength,
    arrayBuffer: dataView.buffer
  });
  return padToNBytes(chunkLength, 4);
}

// ../../node_modules/.bun/@loaders.gl+gltf@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/gltf/dist/lib/gltf-utils/resolve-url.js
function resolveUrl(url, options) {
  const absolute = url.startsWith("data:") || url.startsWith("http:") || url.startsWith("https:");
  if (absolute) {
    return url;
  }
  const baseUrl = options.baseUri || options.uri;
  if (!baseUrl) {
    throw new Error(`'baseUri' must be provided to resolve relative url ${url}`);
  }
  return baseUrl.substr(0, baseUrl.lastIndexOf("/") + 1) + url;
}

// ../../node_modules/.bun/@loaders.gl+gltf@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/gltf/dist/lib/extensions/EXT_meshopt_compression.js
var exports_EXT_meshopt_compression = {};
__export(exports_EXT_meshopt_compression, {
  name: () => name4,
  decode: () => decode5
});

// ../../node_modules/.bun/@loaders.gl+gltf@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/gltf/dist/meshopt/meshopt-decoder.js
var wasm_base = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB";
var wasm_simd = "B9h9z9tFBBBF8dL9gBB9gLaaaaaFa9gEaaaB9gGaaB9gFaFaEQSBBFBFFGEGEGIILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBNn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBcI9z9iqlBMc/j9JSIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMkRIbaG97FaK978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAnDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAnDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBRnCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBHiCFD9tAiAPD9OD9hD9RHiDQBTFtGmEYIPLdKeOnH8ZAIAQJDBIBHpCFD9tApAPD9OD9hD9RHpAIASJDBIBHyCFD9tAyAPD9OD9hD9RHyDQBTFtGmEYIPLdKeOnH8cDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAnD9uHnDyBjGBAEAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnA8ZA8cDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNiV8ZcpMyS8cQ8df8eb8fHdApAyDQNiV8ZcpMyS8cQ8df8eb8fHiDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/xLGEaK978jUUUUBCAlHE8kUUUUBGXGXAGCI9HQBGXAFC98ZHI9FQBABRGCBRLEXAGAGDBBBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMBBAGCTJRGALCIJHLAI9JQBMMAIAF9PQFAEAFCEZHLCGWHGqCBCTAGl/8MBAEABAICGWJHIAG/8cBBGXAL9FQBAEAEDBIBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMIBMAIAEAG/8cBBSFMABAFC98ZHGT+HUUUBAGAF9PQBAEAFCEZHICEWHLJCBCAALl/8MBAEABAGCEWJHGAL/8cBBAEAIT+HUUUBAGAEAL/8cBBMAECAJ8kUUUUBM+yEGGaO97GXAF9FQBCBRGEXABCTJHEAEDBBBHICBDtHLCUU98D8cFCUU98D8cEHKD9OABDBBBHOAIDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAOAIDQBFGENVcMTtmYi8ZpyHICTD+sFD/6FHND/gFAICTD+rFCTD+sFD/6FHVD/gFD/kFD/lFHI9DB/+g6DYAVAIALD+2FHLAVCUUUU94DtHcD9OD9RD/kFHVAVD/mFAIAID/mFANALANAcD9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHLD/kFCTD+rFAVAND/mFALD/kFCggEDtD9OD9QHVAIAND/mFALD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHIDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAOAKD9OAVAIDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM94FEa8jUUUUBCAlHE8kUUUUBABAFC98ZHIT+JUUUBGXAIAF9PQBAEAFCEZHLCEWHFJCBCAAFl/8MBAEABAICEWJHBAF/8cBBAEALT+JUUUBABAEAF/8cBBMAECAJ8kUUUUBM/hEIGaF97FaL978jUUUUBCTlRGGXAF9FQBCBREEXAGABDBBBHIABCTJHLDBBBHKDQILKOSQfbPden8c8d8e8fHOCTD+sFHNCID+rFDMIBAB9DBBU8/DY9D/zI818/DYANCEDtD9QD/6FD/nFHNAIAKDQBFGENVcMTtmYi8ZpyHICTD+rFCTD+sFD/6FD/mFHKAKD/mFANAICTD+sFD/6FD/mFHVAVD/mFANAOCTD+rFCTD+sFD/6FD/mFHOAOD/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHND/mF9DBBX9LDYHID/kFCggEDtHcD9OAVAND/mFAID/kFCTD+rFD9QHVAOAND/mFAID/kFCTD+rFAKAND/mFAID/kFAcD9OD9QHNDQBFTtGEmYILPdKOenHID8dBAGDBIBDyB+t+J83EBABCNJAID8dFAGDBIBDyF+t+J83EBALAVANDQNVi8ZcMpySQ8c8dfb8e8fHND8dBAGDBIBDyG+t+J83EBABCiJAND8dFAGDBIBDyE+t+J83EBABCAJRBAECIJHEAF9JQBMMM/3FGEaF978jUUUUBCoBlREGXAGCGrAF9sHIC98ZHL9FQBCBRGABRFEXAFAFDBBBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBAFCTJRFAGCIJHGAL9JQBMMGXALAI9PQBAEAICEZHGCGWHFqCBCoBAFl/8MBAEABALCGWJHLAF/8cBBGXAG9FQBAEAEDBIBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMIBMALAEAF/8cBBMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB";
var detector = new Uint8Array([
  0,
  97,
  115,
  109,
  1,
  0,
  0,
  0,
  1,
  4,
  1,
  96,
  0,
  0,
  3,
  3,
  2,
  0,
  0,
  5,
  3,
  1,
  0,
  1,
  12,
  1,
  0,
  10,
  22,
  2,
  12,
  0,
  65,
  0,
  65,
  0,
  65,
  0,
  252,
  10,
  0,
  0,
  11,
  7,
  0,
  65,
  0,
  253,
  15,
  26,
  11
]);
var wasmpack = new Uint8Array([
  32,
  0,
  65,
  253,
  3,
  1,
  2,
  34,
  4,
  106,
  6,
  5,
  11,
  8,
  7,
  20,
  13,
  33,
  12,
  16,
  128,
  9,
  116,
  64,
  19,
  113,
  127,
  15,
  10,
  21,
  22,
  14,
  255,
  66,
  24,
  54,
  136,
  107,
  18,
  23,
  192,
  26,
  114,
  118,
  132,
  17,
  77,
  101,
  130,
  144,
  27,
  87,
  131,
  44,
  45,
  74,
  156,
  154,
  70,
  167
]);
var FILTERS = {
  0: "",
  1: "meshopt_decodeFilterOct",
  2: "meshopt_decodeFilterQuat",
  3: "meshopt_decodeFilterExp",
  NONE: "",
  OCTAHEDRAL: "meshopt_decodeFilterOct",
  QUATERNION: "meshopt_decodeFilterQuat",
  EXPONENTIAL: "meshopt_decodeFilterExp"
};
var DECODERS = {
  0: "meshopt_decodeVertexBuffer",
  1: "meshopt_decodeIndexBuffer",
  2: "meshopt_decodeIndexSequence",
  ATTRIBUTES: "meshopt_decodeVertexBuffer",
  TRIANGLES: "meshopt_decodeIndexBuffer",
  INDICES: "meshopt_decodeIndexSequence"
};
async function meshoptDecodeGltfBuffer(target, count, size, source, mode, filter = "NONE") {
  const instance = await loadWasmInstance();
  decode4(instance, instance.exports[DECODERS[mode]], target, count, size, source, instance.exports[FILTERS[filter || "NONE"]]);
}
var wasmPromise;
async function loadWasmInstance() {
  if (!wasmPromise) {
    wasmPromise = loadWasmModule();
  }
  return wasmPromise;
}
async function loadWasmModule() {
  let wasm = wasm_base;
  if (WebAssembly.validate(detector)) {
    wasm = wasm_simd;
    console.log("Warning: meshopt_decoder is using experimental SIMD support");
  }
  const result = await WebAssembly.instantiate(unpack(wasm), {});
  await result.instance.exports.__wasm_call_ctors();
  return result.instance;
}
function unpack(data) {
  const result = new Uint8Array(data.length);
  for (let i = 0;i < data.length; ++i) {
    const ch = data.charCodeAt(i);
    result[i] = ch > 96 ? ch - 71 : ch > 64 ? ch - 65 : ch > 47 ? ch + 4 : ch > 46 ? 63 : 62;
  }
  let write = 0;
  for (let i = 0;i < data.length; ++i) {
    result[write++] = result[i] < 60 ? wasmpack[result[i]] : (result[i] - 60) * 64 + result[++i];
  }
  return result.buffer.slice(0, write);
}
function decode4(instance, fun, target, count, size, source, filter) {
  const sbrk = instance.exports.sbrk;
  const count4 = count + 3 & ~3;
  const tp = sbrk(count4 * size);
  const sp = sbrk(source.length);
  const heap = new Uint8Array(instance.exports.memory.buffer);
  heap.set(source, sp);
  const res = fun(tp, count, size, sp, source.length);
  if (res === 0 && filter) {
    filter(tp, count4, size);
  }
  target.set(heap.subarray(tp, tp + count * size));
  sbrk(tp - sbrk(0));
  if (res !== 0) {
    throw new Error(`Malformed buffer data: ${res}`);
  }
}

// ../../node_modules/.bun/@loaders.gl+gltf@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/gltf/dist/lib/extensions/EXT_meshopt_compression.js
var EXT_MESHOPT_COMPRESSION = "EXT_meshopt_compression";
var name4 = EXT_MESHOPT_COMPRESSION;
async function decode5(gltfData, options) {
  const scenegraph = new GLTFScenegraph(gltfData);
  if (!options?.gltf?.decompressMeshes || !options.gltf?.loadBuffers) {
    return;
  }
  const promises = [];
  for (const bufferViewIndex of gltfData.json.bufferViews || []) {
    promises.push(decodeMeshoptBufferView(scenegraph, bufferViewIndex));
  }
  await Promise.all(promises);
  scenegraph.removeExtension(EXT_MESHOPT_COMPRESSION);
}
async function decodeMeshoptBufferView(scenegraph, bufferView) {
  const meshoptExtension = scenegraph.getObjectExtension(bufferView, EXT_MESHOPT_COMPRESSION);
  if (meshoptExtension) {
    const { byteOffset = 0, byteLength = 0, byteStride, count, mode, filter = "NONE", buffer: bufferIndex } = meshoptExtension;
    const buffer = scenegraph.gltf.buffers[bufferIndex];
    const source = new Uint8Array(buffer.arrayBuffer, buffer.byteOffset + byteOffset, byteLength);
    const result = new Uint8Array(scenegraph.gltf.buffers[bufferView.buffer].arrayBuffer, bufferView.byteOffset, bufferView.byteLength);
    await meshoptDecodeGltfBuffer(result, count, byteStride, source, mode, filter);
    scenegraph.removeObjectExtension(bufferView, EXT_MESHOPT_COMPRESSION);
  }
}

// ../../node_modules/.bun/@loaders.gl+gltf@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/gltf/dist/lib/extensions/EXT_texture_webp.js
var exports_EXT_texture_webp = {};
__export(exports_EXT_texture_webp, {
  preprocess: () => preprocess,
  name: () => name5
});
var EXT_TEXTURE_WEBP = "EXT_texture_webp";
var name5 = EXT_TEXTURE_WEBP;
function preprocess(gltfData, options) {
  const scenegraph = new GLTFScenegraph(gltfData);
  if (!isImageFormatSupported("image/webp")) {
    if (scenegraph.getRequiredExtensions().includes(EXT_TEXTURE_WEBP)) {
      throw new Error(`gltf: Required extension ${EXT_TEXTURE_WEBP} not supported by browser`);
    }
    return;
  }
  const { json } = scenegraph;
  for (const texture of json.textures || []) {
    const extension = scenegraph.getObjectExtension(texture, EXT_TEXTURE_WEBP);
    if (extension) {
      texture.source = extension.source;
    }
    scenegraph.removeObjectExtension(texture, EXT_TEXTURE_WEBP);
  }
  scenegraph.removeExtension(EXT_TEXTURE_WEBP);
}

// ../../node_modules/.bun/@loaders.gl+gltf@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/gltf/dist/lib/extensions/KHR_texture_basisu.js
var exports_KHR_texture_basisu = {};
__export(exports_KHR_texture_basisu, {
  preprocess: () => preprocess2,
  name: () => name6
});
var KHR_TEXTURE_BASISU = "KHR_texture_basisu";
var name6 = KHR_TEXTURE_BASISU;
function preprocess2(gltfData, options) {
  const scene = new GLTFScenegraph(gltfData);
  const { json } = scene;
  for (const texture of json.textures || []) {
    const extension = scene.getObjectExtension(texture, KHR_TEXTURE_BASISU);
    if (extension) {
      texture.source = extension.source;
      scene.removeObjectExtension(texture, KHR_TEXTURE_BASISU);
    }
  }
  scene.removeExtension(KHR_TEXTURE_BASISU);
}

// ../../node_modules/.bun/@loaders.gl+gltf@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/gltf/dist/lib/extensions/KHR_draco_mesh_compression.js
var exports_KHR_draco_mesh_compression = {};
__export(exports_KHR_draco_mesh_compression, {
  preprocess: () => preprocess3,
  name: () => name7,
  encode: () => encode3,
  decode: () => decode6
});

// ../../node_modules/.bun/@loaders.gl+draco@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/draco/dist/lib/utils/version.js
var VERSION7 = "4.3.3";

// ../../node_modules/.bun/@loaders.gl+draco@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/draco/dist/draco-loader.js
var DracoLoader = {
  dataType: null,
  batchType: null,
  name: "Draco",
  id: "draco",
  module: "draco",
  version: VERSION7,
  worker: true,
  extensions: ["drc"],
  mimeTypes: ["application/octet-stream"],
  binary: true,
  tests: ["DRACO"],
  options: {
    draco: {
      decoderType: typeof WebAssembly === "object" ? "wasm" : "js",
      libraryPath: "libs/",
      extraAttributes: {},
      attributeNameEntry: undefined
    }
  }
};

// ../../node_modules/.bun/@loaders.gl+draco@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/draco/dist/lib/utils/get-draco-schema.js
function getDracoSchema(attributes, loaderData, indices) {
  const metadata = makeMetadata(loaderData.metadata);
  const fields = [];
  const namedLoaderDataAttributes = transformAttributesLoaderData(loaderData.attributes);
  for (const attributeName in attributes) {
    const attribute = attributes[attributeName];
    const field = getArrowFieldFromAttribute(attributeName, attribute, namedLoaderDataAttributes[attributeName]);
    fields.push(field);
  }
  if (indices) {
    const indicesField = getArrowFieldFromAttribute("indices", indices);
    fields.push(indicesField);
  }
  return { fields, metadata };
}
function transformAttributesLoaderData(loaderData) {
  const result = {};
  for (const key in loaderData) {
    const dracoAttribute = loaderData[key];
    result[dracoAttribute.name || "undefined"] = dracoAttribute;
  }
  return result;
}
function getArrowFieldFromAttribute(attributeName, attribute, loaderData) {
  const metadataMap = loaderData ? makeMetadata(loaderData.metadata) : undefined;
  const field = deduceMeshField(attributeName, attribute, metadataMap);
  return field;
}
function makeMetadata(metadata) {
  Object.entries(metadata);
  const serializedMetadata = {};
  for (const key in metadata) {
    serializedMetadata[`${key}.string`] = JSON.stringify(metadata[key]);
  }
  return serializedMetadata;
}

// ../../node_modules/.bun/@loaders.gl+draco@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/draco/dist/lib/draco-parser.js
var DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {
  POSITION: "POSITION",
  NORMAL: "NORMAL",
  COLOR: "COLOR_0",
  TEX_COORD: "TEXCOORD_0"
};
var DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {
  1: Int8Array,
  2: Uint8Array,
  3: Int16Array,
  4: Uint16Array,
  5: Int32Array,
  6: Uint32Array,
  9: Float32Array
};
var INDEX_ITEM_SIZE = 4;

class DracoParser {
  draco;
  decoder;
  metadataQuerier;
  constructor(draco) {
    this.draco = draco;
    this.decoder = new this.draco.Decoder;
    this.metadataQuerier = new this.draco.MetadataQuerier;
  }
  destroy() {
    this.draco.destroy(this.decoder);
    this.draco.destroy(this.metadataQuerier);
  }
  parseSync(arrayBuffer, options = {}) {
    const buffer = new this.draco.DecoderBuffer;
    buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);
    this._disableAttributeTransforms(options);
    const geometry_type = this.decoder.GetEncodedGeometryType(buffer);
    const dracoGeometry = geometry_type === this.draco.TRIANGULAR_MESH ? new this.draco.Mesh : new this.draco.PointCloud;
    try {
      let dracoStatus;
      switch (geometry_type) {
        case this.draco.TRIANGULAR_MESH:
          dracoStatus = this.decoder.DecodeBufferToMesh(buffer, dracoGeometry);
          break;
        case this.draco.POINT_CLOUD:
          dracoStatus = this.decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);
          break;
        default:
          throw new Error("DRACO: Unknown geometry type.");
      }
      if (!dracoStatus.ok() || !dracoGeometry.ptr) {
        const message = `DRACO decompression failed: ${dracoStatus.error_msg()}`;
        throw new Error(message);
      }
      const loaderData = this._getDracoLoaderData(dracoGeometry, geometry_type, options);
      const geometry = this._getMeshData(dracoGeometry, loaderData, options);
      const boundingBox = getMeshBoundingBox(geometry.attributes);
      const schema = getDracoSchema(geometry.attributes, loaderData, geometry.indices);
      const data = {
        loader: "draco",
        loaderData,
        header: {
          vertexCount: dracoGeometry.num_points(),
          boundingBox
        },
        ...geometry,
        schema
      };
      return data;
    } finally {
      this.draco.destroy(buffer);
      if (dracoGeometry) {
        this.draco.destroy(dracoGeometry);
      }
    }
  }
  _getDracoLoaderData(dracoGeometry, geometry_type, options) {
    const metadata = this._getTopLevelMetadata(dracoGeometry);
    const attributes = this._getDracoAttributes(dracoGeometry, options);
    return {
      geometry_type,
      num_attributes: dracoGeometry.num_attributes(),
      num_points: dracoGeometry.num_points(),
      num_faces: dracoGeometry instanceof this.draco.Mesh ? dracoGeometry.num_faces() : 0,
      metadata,
      attributes
    };
  }
  _getDracoAttributes(dracoGeometry, options) {
    const dracoAttributes = {};
    for (let attributeId = 0;attributeId < dracoGeometry.num_attributes(); attributeId++) {
      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);
      const metadata = this._getAttributeMetadata(dracoGeometry, attributeId);
      dracoAttributes[dracoAttribute.unique_id()] = {
        unique_id: dracoAttribute.unique_id(),
        attribute_type: dracoAttribute.attribute_type(),
        data_type: dracoAttribute.data_type(),
        num_components: dracoAttribute.num_components(),
        byte_offset: dracoAttribute.byte_offset(),
        byte_stride: dracoAttribute.byte_stride(),
        normalized: dracoAttribute.normalized(),
        attribute_index: attributeId,
        metadata
      };
      const quantization = this._getQuantizationTransform(dracoAttribute, options);
      if (quantization) {
        dracoAttributes[dracoAttribute.unique_id()].quantization_transform = quantization;
      }
      const octahedron = this._getOctahedronTransform(dracoAttribute, options);
      if (octahedron) {
        dracoAttributes[dracoAttribute.unique_id()].octahedron_transform = octahedron;
      }
    }
    return dracoAttributes;
  }
  _getMeshData(dracoGeometry, loaderData, options) {
    const attributes = this._getMeshAttributes(loaderData, dracoGeometry, options);
    const positionAttribute = attributes.POSITION;
    if (!positionAttribute) {
      throw new Error("DRACO: No position attribute found.");
    }
    if (dracoGeometry instanceof this.draco.Mesh) {
      switch (options.topology) {
        case "triangle-strip":
          return {
            topology: "triangle-strip",
            mode: 4,
            attributes,
            indices: {
              value: this._getTriangleStripIndices(dracoGeometry),
              size: 1
            }
          };
        case "triangle-list":
        default:
          return {
            topology: "triangle-list",
            mode: 5,
            attributes,
            indices: {
              value: this._getTriangleListIndices(dracoGeometry),
              size: 1
            }
          };
      }
    }
    return {
      topology: "point-list",
      mode: 0,
      attributes
    };
  }
  _getMeshAttributes(loaderData, dracoGeometry, options) {
    const attributes = {};
    for (const loaderAttribute of Object.values(loaderData.attributes)) {
      const attributeName = this._deduceAttributeName(loaderAttribute, options);
      loaderAttribute.name = attributeName;
      const values = this._getAttributeValues(dracoGeometry, loaderAttribute);
      if (values) {
        const { value, size } = values;
        attributes[attributeName] = {
          value,
          size,
          byteOffset: loaderAttribute.byte_offset,
          byteStride: loaderAttribute.byte_stride,
          normalized: loaderAttribute.normalized
        };
      }
    }
    return attributes;
  }
  _getTriangleListIndices(dracoGeometry) {
    const numFaces = dracoGeometry.num_faces();
    const numIndices = numFaces * 3;
    const byteLength = numIndices * INDEX_ITEM_SIZE;
    const ptr = this.draco._malloc(byteLength);
    try {
      this.decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);
      return new Uint32Array(this.draco.HEAPF32.buffer, ptr, numIndices).slice();
    } finally {
      this.draco._free(ptr);
    }
  }
  _getTriangleStripIndices(dracoGeometry) {
    const dracoArray = new this.draco.DracoInt32Array;
    try {
      this.decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);
      return getUint32Array(dracoArray);
    } finally {
      this.draco.destroy(dracoArray);
    }
  }
  _getAttributeValues(dracoGeometry, attribute) {
    const TypedArrayCtor = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[attribute.data_type];
    if (!TypedArrayCtor) {
      console.warn(`DRACO: Unsupported attribute type ${attribute.data_type}`);
      return null;
    }
    const numComponents = attribute.num_components;
    const numPoints = dracoGeometry.num_points();
    const numValues = numPoints * numComponents;
    const byteLength = numValues * TypedArrayCtor.BYTES_PER_ELEMENT;
    const dataType = getDracoDataType(this.draco, TypedArrayCtor);
    let value;
    const ptr = this.draco._malloc(byteLength);
    try {
      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attribute.attribute_index);
      this.decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, dracoAttribute, dataType, byteLength, ptr);
      value = new TypedArrayCtor(this.draco.HEAPF32.buffer, ptr, numValues).slice();
    } finally {
      this.draco._free(ptr);
    }
    return { value, size: numComponents };
  }
  _deduceAttributeName(attribute, options) {
    const uniqueId = attribute.unique_id;
    for (const [attributeName, attributeUniqueId] of Object.entries(options.extraAttributes || {})) {
      if (attributeUniqueId === uniqueId) {
        return attributeName;
      }
    }
    const thisAttributeType = attribute.attribute_type;
    for (const dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {
      const attributeType = this.draco[dracoAttributeConstant];
      if (attributeType === thisAttributeType) {
        return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];
      }
    }
    const entryName = options.attributeNameEntry || "name";
    if (attribute.metadata[entryName]) {
      return attribute.metadata[entryName].string;
    }
    return `CUSTOM_ATTRIBUTE_${uniqueId}`;
  }
  _getTopLevelMetadata(dracoGeometry) {
    const dracoMetadata = this.decoder.GetMetadata(dracoGeometry);
    return this._getDracoMetadata(dracoMetadata);
  }
  _getAttributeMetadata(dracoGeometry, attributeId) {
    const dracoMetadata = this.decoder.GetAttributeMetadata(dracoGeometry, attributeId);
    return this._getDracoMetadata(dracoMetadata);
  }
  _getDracoMetadata(dracoMetadata) {
    if (!dracoMetadata || !dracoMetadata.ptr) {
      return {};
    }
    const result = {};
    const numEntries = this.metadataQuerier.NumEntries(dracoMetadata);
    for (let entryIndex = 0;entryIndex < numEntries; entryIndex++) {
      const entryName = this.metadataQuerier.GetEntryName(dracoMetadata, entryIndex);
      result[entryName] = this._getDracoMetadataField(dracoMetadata, entryName);
    }
    return result;
  }
  _getDracoMetadataField(dracoMetadata, entryName) {
    const dracoArray = new this.draco.DracoInt32Array;
    try {
      this.metadataQuerier.GetIntEntryArray(dracoMetadata, entryName, dracoArray);
      const intArray = getInt32Array(dracoArray);
      return {
        int: this.metadataQuerier.GetIntEntry(dracoMetadata, entryName),
        string: this.metadataQuerier.GetStringEntry(dracoMetadata, entryName),
        double: this.metadataQuerier.GetDoubleEntry(dracoMetadata, entryName),
        intArray
      };
    } finally {
      this.draco.destroy(dracoArray);
    }
  }
  _disableAttributeTransforms(options) {
    const { quantizedAttributes = [], octahedronAttributes = [] } = options;
    const skipAttributes = [...quantizedAttributes, ...octahedronAttributes];
    for (const dracoAttributeName of skipAttributes) {
      this.decoder.SkipAttributeTransform(this.draco[dracoAttributeName]);
    }
  }
  _getQuantizationTransform(dracoAttribute, options) {
    const { quantizedAttributes = [] } = options;
    const attribute_type = dracoAttribute.attribute_type();
    const skip = quantizedAttributes.map((type) => this.decoder[type]).includes(attribute_type);
    if (skip) {
      const transform = new this.draco.AttributeQuantizationTransform;
      try {
        if (transform.InitFromAttribute(dracoAttribute)) {
          return {
            quantization_bits: transform.quantization_bits(),
            range: transform.range(),
            min_values: new Float32Array([1, 2, 3]).map((i) => transform.min_value(i))
          };
        }
      } finally {
        this.draco.destroy(transform);
      }
    }
    return null;
  }
  _getOctahedronTransform(dracoAttribute, options) {
    const { octahedronAttributes = [] } = options;
    const attribute_type = dracoAttribute.attribute_type();
    const octahedron = octahedronAttributes.map((type) => this.decoder[type]).includes(attribute_type);
    if (octahedron) {
      const transform = new this.draco.AttributeQuantizationTransform;
      try {
        if (transform.InitFromAttribute(dracoAttribute)) {
          return {
            quantization_bits: transform.quantization_bits()
          };
        }
      } finally {
        this.draco.destroy(transform);
      }
    }
    return null;
  }
}
function getDracoDataType(draco, attributeType) {
  switch (attributeType) {
    case Float32Array:
      return draco.DT_FLOAT32;
    case Int8Array:
      return draco.DT_INT8;
    case Int16Array:
      return draco.DT_INT16;
    case Int32Array:
      return draco.DT_INT32;
    case Uint8Array:
      return draco.DT_UINT8;
    case Uint16Array:
      return draco.DT_UINT16;
    case Uint32Array:
      return draco.DT_UINT32;
    default:
      return draco.DT_INVALID;
  }
}
function getInt32Array(dracoArray) {
  const numValues = dracoArray.size();
  const intArray = new Int32Array(numValues);
  for (let i = 0;i < numValues; i++) {
    intArray[i] = dracoArray.GetValue(i);
  }
  return intArray;
}
function getUint32Array(dracoArray) {
  const numValues = dracoArray.size();
  const intArray = new Int32Array(numValues);
  for (let i = 0;i < numValues; i++) {
    intArray[i] = dracoArray.GetValue(i);
  }
  return intArray;
}

// ../../node_modules/.bun/@loaders.gl+draco@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/draco/dist/lib/draco-module-loader.js
var DRACO_DECODER_VERSION = "1.5.6";
var DRACO_ENCODER_VERSION = "1.4.1";
var STATIC_DECODER_URL = `https://www.gstatic.com/draco/versioned/decoders/${DRACO_DECODER_VERSION}`;
var DRACO_EXTERNAL_LIBRARIES = {
  DECODER: "draco_wasm_wrapper.js",
  DECODER_WASM: "draco_decoder.wasm",
  FALLBACK_DECODER: "draco_decoder.js",
  ENCODER: "draco_encoder.js"
};
var DRACO_EXTERNAL_LIBRARY_URLS = {
  [DRACO_EXTERNAL_LIBRARIES.DECODER]: `${STATIC_DECODER_URL}/${DRACO_EXTERNAL_LIBRARIES.DECODER}`,
  [DRACO_EXTERNAL_LIBRARIES.DECODER_WASM]: `${STATIC_DECODER_URL}/${DRACO_EXTERNAL_LIBRARIES.DECODER_WASM}`,
  [DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER]: `${STATIC_DECODER_URL}/${DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER}`,
  [DRACO_EXTERNAL_LIBRARIES.ENCODER]: `https://raw.githubusercontent.com/google/draco/${DRACO_ENCODER_VERSION}/javascript/${DRACO_EXTERNAL_LIBRARIES.ENCODER}`
};
var loadDecoderPromise;
async function loadDracoDecoderModule(options) {
  const modules = options.modules || {};
  if (modules.draco3d) {
    loadDecoderPromise ||= modules.draco3d.createDecoderModule({}).then((draco) => {
      return { draco };
    });
  } else {
    loadDecoderPromise ||= loadDracoDecoder(options);
  }
  return await loadDecoderPromise;
}
async function loadDracoDecoder(options) {
  let DracoDecoderModule;
  let wasmBinary;
  switch (options.draco && options.draco.decoderType) {
    case "js":
      DracoDecoderModule = await loadLibrary(DRACO_EXTERNAL_LIBRARY_URLS[DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER], "draco", options, DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER);
      break;
    case "wasm":
    default:
      [DracoDecoderModule, wasmBinary] = await Promise.all([
        await loadLibrary(DRACO_EXTERNAL_LIBRARY_URLS[DRACO_EXTERNAL_LIBRARIES.DECODER], "draco", options, DRACO_EXTERNAL_LIBRARIES.DECODER),
        await loadLibrary(DRACO_EXTERNAL_LIBRARY_URLS[DRACO_EXTERNAL_LIBRARIES.DECODER_WASM], "draco", options, DRACO_EXTERNAL_LIBRARIES.DECODER_WASM)
      ]);
  }
  DracoDecoderModule = DracoDecoderModule || globalThis.DracoDecoderModule;
  return await initializeDracoDecoder(DracoDecoderModule, wasmBinary);
}
function initializeDracoDecoder(DracoDecoderModule, wasmBinary) {
  const options = {};
  if (wasmBinary) {
    options.wasmBinary = wasmBinary;
  }
  return new Promise((resolve2) => {
    DracoDecoderModule({
      ...options,
      onModuleLoaded: (draco) => resolve2({ draco })
    });
  });
}

// ../../node_modules/.bun/@loaders.gl+draco@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/draco/dist/index.js
var DracoLoader2 = {
  ...DracoLoader,
  parse: parse2
};
async function parse2(arrayBuffer, options) {
  const { draco } = await loadDracoDecoderModule(options);
  const dracoParser = new DracoParser(draco);
  try {
    return dracoParser.parseSync(arrayBuffer, options?.draco);
  } finally {
    dracoParser.destroy();
  }
}

// ../../node_modules/.bun/@loaders.gl+gltf@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/gltf/dist/lib/gltf-utils/gltf-attribute-utils.js
function getGLTFAccessors(attributes) {
  const accessors = {};
  for (const name7 in attributes) {
    const attribute = attributes[name7];
    if (name7 !== "indices") {
      const glTFAccessor = getGLTFAccessor(attribute);
      accessors[name7] = glTFAccessor;
    }
  }
  return accessors;
}
function getGLTFAccessor(attribute) {
  const { buffer, size, count } = getAccessorData(attribute);
  const glTFAccessor = {
    value: buffer,
    size,
    byteOffset: 0,
    count,
    type: getAccessorTypeFromSize(size),
    componentType: getComponentTypeFromArray(buffer)
  };
  return glTFAccessor;
}
function getAccessorData(attribute) {
  let buffer = attribute;
  let size = 1;
  let count = 0;
  if (attribute && attribute.value) {
    buffer = attribute.value;
    size = attribute.size || 1;
  }
  if (buffer) {
    if (!ArrayBuffer.isView(buffer)) {
      buffer = toTypedArray(buffer, Float32Array);
    }
    count = buffer.length / size;
  }
  return { buffer, size, count };
}
function toTypedArray(array, ArrayType, convertTypedArrays = false) {
  if (!array) {
    return null;
  }
  if (Array.isArray(array)) {
    return new ArrayType(array);
  }
  if (convertTypedArrays && !(array instanceof ArrayType)) {
    return new ArrayType(array);
  }
  return array;
}

// ../../node_modules/.bun/@loaders.gl+gltf@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/gltf/dist/lib/extensions/KHR_draco_mesh_compression.js
var KHR_DRACO_MESH_COMPRESSION = "KHR_draco_mesh_compression";
var name7 = KHR_DRACO_MESH_COMPRESSION;
function preprocess3(gltfData, options, context) {
  const scenegraph = new GLTFScenegraph(gltfData);
  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {
    if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {}
  }
}
async function decode6(gltfData, options, context) {
  if (!options?.gltf?.decompressMeshes) {
    return;
  }
  const scenegraph = new GLTFScenegraph(gltfData);
  const promises = [];
  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {
    if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {
      promises.push(decompressPrimitive(scenegraph, primitive, options, context));
    }
  }
  await Promise.all(promises);
  scenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);
}
function encode3(gltfData, options = {}) {
  const scenegraph = new GLTFScenegraph(gltfData);
  for (const mesh of scenegraph.json.meshes || []) {
    compressMesh(mesh, options);
    scenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);
  }
}
async function decompressPrimitive(scenegraph, primitive, options, context) {
  const dracoExtension = scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION);
  if (!dracoExtension) {
    return;
  }
  const buffer = scenegraph.getTypedArrayForBufferView(dracoExtension.bufferView);
  const bufferCopy = sliceArrayBuffer(buffer.buffer, buffer.byteOffset);
  const dracoOptions = { ...options };
  delete dracoOptions["3d-tiles"];
  const decodedData = await parseFromContext(bufferCopy, DracoLoader2, dracoOptions, context);
  const decodedAttributes = getGLTFAccessors(decodedData.attributes);
  for (const [attributeName, decodedAttribute] of Object.entries(decodedAttributes)) {
    if (attributeName in primitive.attributes) {
      const accessorIndex = primitive.attributes[attributeName];
      const accessor = scenegraph.getAccessor(accessorIndex);
      if (accessor?.min && accessor?.max) {
        decodedAttribute.min = accessor.min;
        decodedAttribute.max = accessor.max;
      }
    }
  }
  primitive.attributes = decodedAttributes;
  if (decodedData.indices) {
    primitive.indices = getGLTFAccessor(decodedData.indices);
  }
  scenegraph.removeObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION);
  checkPrimitive(primitive);
}
function compressMesh(attributes, indices, mode = 4, options, context) {
  if (!options.DracoWriter) {
    throw new Error("options.gltf.DracoWriter not provided");
  }
  const compressedData = options.DracoWriter.encodeSync({ attributes });
  const decodedData = context?.parseSync?.({ attributes });
  const fauxAccessors = options._addFauxAttributes(decodedData.attributes);
  const bufferViewIndex = options.addBufferView(compressedData);
  const glTFMesh = {
    primitives: [
      {
        attributes: fauxAccessors,
        mode,
        extensions: {
          [KHR_DRACO_MESH_COMPRESSION]: {
            bufferView: bufferViewIndex,
            attributes: fauxAccessors
          }
        }
      }
    ]
  };
  return glTFMesh;
}
function checkPrimitive(primitive) {
  if (!primitive.attributes && Object.keys(primitive.attributes).length > 0) {
    throw new Error("glTF: Empty primitive detected: Draco decompression failure?");
  }
}
function* makeMeshPrimitiveIterator(scenegraph) {
  for (const mesh of scenegraph.json.meshes || []) {
    for (const primitive of mesh.primitives) {
      yield primitive;
    }
  }
}

// ../../node_modules/.bun/@loaders.gl+gltf@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/gltf/dist/lib/extensions/KHR_texture_transform.js
var exports_KHR_texture_transform = {};
__export(exports_KHR_texture_transform, {
  name: () => name8,
  decode: () => decode7
});

// ../../node_modules/.bun/@math.gl+core@4.1.0/node_modules/@math.gl/core/dist/lib/common.js
var RADIANS_TO_DEGREES = 1 / Math.PI * 180;
var DEGREES_TO_RADIANS = 1 / 180 * Math.PI;
var DEFAULT_CONFIG = {
  EPSILON: 0.000000000001,
  debug: false,
  precision: 4,
  printTypes: false,
  printDegrees: false,
  printRowMajor: true,
  _cartographicRadians: false
};
globalThis.mathgl = globalThis.mathgl || { config: { ...DEFAULT_CONFIG } };
var config = globalThis.mathgl.config;
function formatValue(value, { precision = config.precision } = {}) {
  value = round(value);
  return `${parseFloat(value.toPrecision(precision))}`;
}
function isArray(value) {
  return Array.isArray(value) || ArrayBuffer.isView(value) && !(value instanceof DataView);
}
function equals(a, b, epsilon) {
  const oldEpsilon = config.EPSILON;
  if (epsilon) {
    config.EPSILON = epsilon;
  }
  try {
    if (a === b) {
      return true;
    }
    if (isArray(a) && isArray(b)) {
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0;i < a.length; ++i) {
        if (!equals(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    if (a && a.equals) {
      return a.equals(b);
    }
    if (b && b.equals) {
      return b.equals(a);
    }
    if (typeof a === "number" && typeof b === "number") {
      return Math.abs(a - b) <= config.EPSILON * Math.max(1, Math.abs(a), Math.abs(b));
    }
    return false;
  } finally {
    config.EPSILON = oldEpsilon;
  }
}
function round(value) {
  return Math.round(value / config.EPSILON) * config.EPSILON;
}

// ../../node_modules/.bun/@math.gl+core@4.1.0/node_modules/@math.gl/core/dist/classes/base/math-array.js
class MathArray extends Array {
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(array, offset = 0) {
    for (let i = 0;i < this.ELEMENTS; ++i) {
      this[i] = array[i + offset];
    }
    return this.check();
  }
  toArray(targetArray = [], offset = 0) {
    for (let i = 0;i < this.ELEMENTS; ++i) {
      targetArray[offset + i] = this[i];
    }
    return targetArray;
  }
  toObject(targetObject) {
    return targetObject;
  }
  from(arrayOrObject) {
    return Array.isArray(arrayOrObject) ? this.copy(arrayOrObject) : this.fromObject(arrayOrObject);
  }
  to(arrayOrObject) {
    if (arrayOrObject === this) {
      return this;
    }
    return isArray(arrayOrObject) ? this.toArray(arrayOrObject) : this.toObject(arrayOrObject);
  }
  toTarget(target) {
    return target ? this.to(target) : this;
  }
  toFloat32Array() {
    return new Float32Array(this);
  }
  toString() {
    return this.formatString(config);
  }
  formatString(opts) {
    let string = "";
    for (let i = 0;i < this.ELEMENTS; ++i) {
      string += (i > 0 ? ", " : "") + formatValue(this[i], opts);
    }
    return `${opts.printTypes ? this.constructor.name : ""}[${string}]`;
  }
  equals(array) {
    if (!array || this.length !== array.length) {
      return false;
    }
    for (let i = 0;i < this.ELEMENTS; ++i) {
      if (!equals(this[i], array[i])) {
        return false;
      }
    }
    return true;
  }
  exactEquals(array) {
    if (!array || this.length !== array.length) {
      return false;
    }
    for (let i = 0;i < this.ELEMENTS; ++i) {
      if (this[i] !== array[i]) {
        return false;
      }
    }
    return true;
  }
  negate() {
    for (let i = 0;i < this.ELEMENTS; ++i) {
      this[i] = -this[i];
    }
    return this.check();
  }
  lerp(a, b, t) {
    if (t === undefined) {
      return this.lerp(this, a, b);
    }
    for (let i = 0;i < this.ELEMENTS; ++i) {
      const ai = a[i];
      const endValue = typeof b === "number" ? b : b[i];
      this[i] = ai + t * (endValue - ai);
    }
    return this.check();
  }
  min(vector) {
    for (let i = 0;i < this.ELEMENTS; ++i) {
      this[i] = Math.min(vector[i], this[i]);
    }
    return this.check();
  }
  max(vector) {
    for (let i = 0;i < this.ELEMENTS; ++i) {
      this[i] = Math.max(vector[i], this[i]);
    }
    return this.check();
  }
  clamp(minVector, maxVector) {
    for (let i = 0;i < this.ELEMENTS; ++i) {
      this[i] = Math.min(Math.max(this[i], minVector[i]), maxVector[i]);
    }
    return this.check();
  }
  add(...vectors) {
    for (const vector of vectors) {
      for (let i = 0;i < this.ELEMENTS; ++i) {
        this[i] += vector[i];
      }
    }
    return this.check();
  }
  subtract(...vectors) {
    for (const vector of vectors) {
      for (let i = 0;i < this.ELEMENTS; ++i) {
        this[i] -= vector[i];
      }
    }
    return this.check();
  }
  scale(scale) {
    if (typeof scale === "number") {
      for (let i = 0;i < this.ELEMENTS; ++i) {
        this[i] *= scale;
      }
    } else {
      for (let i = 0;i < this.ELEMENTS && i < scale.length; ++i) {
        this[i] *= scale[i];
      }
    }
    return this.check();
  }
  multiplyByScalar(scalar) {
    for (let i = 0;i < this.ELEMENTS; ++i) {
      this[i] *= scalar;
    }
    return this.check();
  }
  check() {
    if (config.debug && !this.validate()) {
      throw new Error(`math.gl: ${this.constructor.name} some fields set to invalid numbers'`);
    }
    return this;
  }
  validate() {
    let valid = this.length === this.ELEMENTS;
    for (let i = 0;i < this.ELEMENTS; ++i) {
      valid = valid && Number.isFinite(this[i]);
    }
    return valid;
  }
  sub(a) {
    return this.subtract(a);
  }
  setScalar(a) {
    for (let i = 0;i < this.ELEMENTS; ++i) {
      this[i] = a;
    }
    return this.check();
  }
  addScalar(a) {
    for (let i = 0;i < this.ELEMENTS; ++i) {
      this[i] += a;
    }
    return this.check();
  }
  subScalar(a) {
    return this.addScalar(-a);
  }
  multiplyScalar(scalar) {
    for (let i = 0;i < this.ELEMENTS; ++i) {
      this[i] *= scalar;
    }
    return this.check();
  }
  divideScalar(a) {
    return this.multiplyByScalar(1 / a);
  }
  clampScalar(min, max) {
    for (let i = 0;i < this.ELEMENTS; ++i) {
      this[i] = Math.min(Math.max(this[i], min), max);
    }
    return this.check();
  }
  get elements() {
    return this;
  }
}

// ../../node_modules/.bun/@math.gl+core@4.1.0/node_modules/@math.gl/core/dist/lib/validators.js
function validateVector(v, length) {
  if (v.length !== length) {
    return false;
  }
  for (let i = 0;i < v.length; ++i) {
    if (!Number.isFinite(v[i])) {
      return false;
    }
  }
  return true;
}
function checkNumber(value) {
  if (!Number.isFinite(value)) {
    throw new Error(`Invalid number ${JSON.stringify(value)}`);
  }
  return value;
}
function checkVector(v, length, callerName = "") {
  if (config.debug && !validateVector(v, length)) {
    throw new Error(`math.gl: ${callerName} some fields set to invalid numbers'`);
  }
  return v;
}

// ../../node_modules/.bun/@math.gl+core@4.1.0/node_modules/@math.gl/core/dist/lib/assert.js
function assert5(condition, message) {
  if (!condition) {
    throw new Error(`math.gl assertion ${message}`);
  }
}

// ../../node_modules/.bun/@math.gl+core@4.1.0/node_modules/@math.gl/core/dist/classes/base/vector.js
class Vector extends MathArray {
  get x() {
    return this[0];
  }
  set x(value) {
    this[0] = checkNumber(value);
  }
  get y() {
    return this[1];
  }
  set y(value) {
    this[1] = checkNumber(value);
  }
  len() {
    return Math.sqrt(this.lengthSquared());
  }
  magnitude() {
    return this.len();
  }
  lengthSquared() {
    let length = 0;
    for (let i = 0;i < this.ELEMENTS; ++i) {
      length += this[i] * this[i];
    }
    return length;
  }
  magnitudeSquared() {
    return this.lengthSquared();
  }
  distance(mathArray) {
    return Math.sqrt(this.distanceSquared(mathArray));
  }
  distanceSquared(mathArray) {
    let length = 0;
    for (let i = 0;i < this.ELEMENTS; ++i) {
      const dist = this[i] - mathArray[i];
      length += dist * dist;
    }
    return checkNumber(length);
  }
  dot(mathArray) {
    let product = 0;
    for (let i = 0;i < this.ELEMENTS; ++i) {
      product += this[i] * mathArray[i];
    }
    return checkNumber(product);
  }
  normalize() {
    const length = this.magnitude();
    if (length !== 0) {
      for (let i = 0;i < this.ELEMENTS; ++i) {
        this[i] /= length;
      }
    }
    return this.check();
  }
  multiply(...vectors) {
    for (const vector of vectors) {
      for (let i = 0;i < this.ELEMENTS; ++i) {
        this[i] *= vector[i];
      }
    }
    return this.check();
  }
  divide(...vectors) {
    for (const vector of vectors) {
      for (let i = 0;i < this.ELEMENTS; ++i) {
        this[i] /= vector[i];
      }
    }
    return this.check();
  }
  lengthSq() {
    return this.lengthSquared();
  }
  distanceTo(vector) {
    return this.distance(vector);
  }
  distanceToSquared(vector) {
    return this.distanceSquared(vector);
  }
  getComponent(i) {
    assert5(i >= 0 && i < this.ELEMENTS, "index is out of range");
    return checkNumber(this[i]);
  }
  setComponent(i, value) {
    assert5(i >= 0 && i < this.ELEMENTS, "index is out of range");
    this[i] = value;
    return this.check();
  }
  addVectors(a, b) {
    return this.copy(a).add(b);
  }
  subVectors(a, b) {
    return this.copy(a).subtract(b);
  }
  multiplyVectors(a, b) {
    return this.copy(a).multiply(b);
  }
  addScaledVector(a, b) {
    return this.add(new this.constructor(a).multiplyScalar(b));
  }
}

// ../../node_modules/.bun/@math.gl+core@4.1.0/node_modules/@math.gl/core/dist/gl-matrix/common.js
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var degree = Math.PI / 180;

// ../../node_modules/.bun/@math.gl+core@4.1.0/node_modules/@math.gl/core/dist/gl-matrix/vec2.js
function create() {
  const out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
function transformMat3(out, a, m) {
  const x = a[0];
  const y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
var forEach2 = function() {
  const vec = create();
  return function(a, stride, offset, count, fn, arg) {
    let i;
    let l;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset;i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }
    return a;
  };
}();

// ../../node_modules/.bun/@math.gl+core@4.1.0/node_modules/@math.gl/core/dist/lib/gl-matrix-extras.js
function vec3_transformMat4AsVector(out, a, m) {
  const x = a[0];
  const y = a[1];
  const z = a[2];
  const w = m[3] * x + m[7] * y + m[11] * z || 1;
  out[0] = (m[0] * x + m[4] * y + m[8] * z) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z) / w;
  return out;
}
function vec3_transformMat2(out, a, m) {
  const x = a[0];
  const y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  out[2] = a[2];
  return out;
}
function vec4_transformMat3(out, a, m) {
  const x = a[0];
  const y = a[1];
  const z = a[2];
  out[0] = m[0] * x + m[3] * y + m[6] * z;
  out[1] = m[1] * x + m[4] * y + m[7] * z;
  out[2] = m[2] * x + m[5] * y + m[8] * z;
  out[3] = a[3];
  return out;
}

// ../../node_modules/.bun/@math.gl+core@4.1.0/node_modules/@math.gl/core/dist/gl-matrix/vec3.js
function create2() {
  const out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cross(out, a, b) {
  const ax = a[0];
  const ay = a[1];
  const az = a[2];
  const bx = b[0];
  const by = b[1];
  const bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function transformMat4(out, a, m) {
  const x = a[0];
  const y = a[1];
  const z = a[2];
  let w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
function transformMat32(out, a, m) {
  const x = a[0];
  const y = a[1];
  const z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
function transformQuat(out, a, q) {
  const qx = q[0];
  const qy = q[1];
  const qz = q[2];
  const qw = q[3];
  const x = a[0];
  const y = a[1];
  const z = a[2];
  let uvx = qy * z - qz * y;
  let uvy = qz * x - qx * z;
  let uvz = qx * y - qy * x;
  let uuvx = qy * uvz - qz * uvy;
  let uuvy = qz * uvx - qx * uvz;
  let uuvz = qx * uvy - qy * uvx;
  const w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
function rotateX(out, a, b, rad) {
  const p = [];
  const r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateY(out, a, b, rad) {
  const p = [];
  const r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateZ(out, a, b, rad) {
  const p = [];
  const r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2];
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function angle(a, b) {
  const ax = a[0];
  const ay = a[1];
  const az = a[2];
  const bx = b[0];
  const by = b[1];
  const bz = b[2];
  const mag = Math.sqrt((ax * ax + ay * ay + az * az) * (bx * bx + by * by + bz * bz));
  const cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
var forEach3 = function() {
  const vec = create2();
  return function(a, stride, offset, count, fn, arg) {
    let i;
    let l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset;i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }
    return a;
  };
}();

// ../../node_modules/.bun/@math.gl+core@4.1.0/node_modules/@math.gl/core/dist/classes/vector3.js
var ORIGIN = [0, 0, 0];
var ZERO;

class Vector32 extends Vector {
  static get ZERO() {
    if (!ZERO) {
      ZERO = new Vector32(0, 0, 0);
      Object.freeze(ZERO);
    }
    return ZERO;
  }
  constructor(x = 0, y = 0, z = 0) {
    super(-0, -0, -0);
    if (arguments.length === 1 && isArray(x)) {
      this.copy(x);
    } else {
      if (config.debug) {
        checkNumber(x);
        checkNumber(y);
        checkNumber(z);
      }
      this[0] = x;
      this[1] = y;
      this[2] = z;
    }
  }
  set(x, y, z) {
    this[0] = x;
    this[1] = y;
    this[2] = z;
    return this.check();
  }
  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    return this.check();
  }
  fromObject(object) {
    if (config.debug) {
      checkNumber(object.x);
      checkNumber(object.y);
      checkNumber(object.z);
    }
    this[0] = object.x;
    this[1] = object.y;
    this[2] = object.z;
    return this.check();
  }
  toObject(object) {
    object.x = this[0];
    object.y = this[1];
    object.z = this[2];
    return object;
  }
  get ELEMENTS() {
    return 3;
  }
  get z() {
    return this[2];
  }
  set z(value) {
    this[2] = checkNumber(value);
  }
  angle(vector) {
    return angle(this, vector);
  }
  cross(vector) {
    cross(this, this, vector);
    return this.check();
  }
  rotateX({ radians, origin = ORIGIN }) {
    rotateX(this, this, origin, radians);
    return this.check();
  }
  rotateY({ radians, origin = ORIGIN }) {
    rotateY(this, this, origin, radians);
    return this.check();
  }
  rotateZ({ radians, origin = ORIGIN }) {
    rotateZ(this, this, origin, radians);
    return this.check();
  }
  transform(matrix4) {
    return this.transformAsPoint(matrix4);
  }
  transformAsPoint(matrix4) {
    transformMat4(this, this, matrix4);
    return this.check();
  }
  transformAsVector(matrix4) {
    vec3_transformMat4AsVector(this, this, matrix4);
    return this.check();
  }
  transformByMatrix3(matrix3) {
    transformMat32(this, this, matrix3);
    return this.check();
  }
  transformByMatrix2(matrix2) {
    vec3_transformMat2(this, this, matrix2);
    return this.check();
  }
  transformByQuaternion(quaternion) {
    transformQuat(this, this, quaternion);
    return this.check();
  }
}
// ../../node_modules/.bun/@math.gl+core@4.1.0/node_modules/@math.gl/core/dist/classes/base/matrix.js
class Matrix extends MathArray {
  toString() {
    let string = "[";
    if (config.printRowMajor) {
      string += "row-major:";
      for (let row = 0;row < this.RANK; ++row) {
        for (let col = 0;col < this.RANK; ++col) {
          string += ` ${this[col * this.RANK + row]}`;
        }
      }
    } else {
      string += "column-major:";
      for (let i = 0;i < this.ELEMENTS; ++i) {
        string += ` ${this[i]}`;
      }
    }
    string += "]";
    return string;
  }
  getElementIndex(row, col) {
    return col * this.RANK + row;
  }
  getElement(row, col) {
    return this[col * this.RANK + row];
  }
  setElement(row, col, value) {
    this[col * this.RANK + row] = checkNumber(value);
    return this;
  }
  getColumn(columnIndex, result = new Array(this.RANK).fill(-0)) {
    const firstIndex = columnIndex * this.RANK;
    for (let i = 0;i < this.RANK; ++i) {
      result[i] = this[firstIndex + i];
    }
    return result;
  }
  setColumn(columnIndex, columnVector) {
    const firstIndex = columnIndex * this.RANK;
    for (let i = 0;i < this.RANK; ++i) {
      this[firstIndex + i] = columnVector[i];
    }
    return this;
  }
}

// ../../node_modules/.bun/@math.gl+core@4.1.0/node_modules/@math.gl/core/dist/gl-matrix/mat3.js
function transpose(out, a) {
  if (out === a) {
    const a01 = a[1];
    const a02 = a[2];
    const a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }
  return out;
}
function invert(out, a) {
  const a00 = a[0];
  const a01 = a[1];
  const a02 = a[2];
  const a10 = a[3];
  const a11 = a[4];
  const a12 = a[5];
  const a20 = a[6];
  const a21 = a[7];
  const a22 = a[8];
  const b01 = a22 * a11 - a12 * a21;
  const b11 = -a22 * a10 + a12 * a20;
  const b21 = a21 * a10 - a11 * a20;
  let det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
function determinant(a) {
  const a00 = a[0];
  const a01 = a[1];
  const a02 = a[2];
  const a10 = a[3];
  const a11 = a[4];
  const a12 = a[5];
  const a20 = a[6];
  const a21 = a[7];
  const a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
function multiply(out, a, b) {
  const a00 = a[0];
  const a01 = a[1];
  const a02 = a[2];
  const a10 = a[3];
  const a11 = a[4];
  const a12 = a[5];
  const a20 = a[6];
  const a21 = a[7];
  const a22 = a[8];
  const b00 = b[0];
  const b01 = b[1];
  const b02 = b[2];
  const b10 = b[3];
  const b11 = b[4];
  const b12 = b[5];
  const b20 = b[6];
  const b21 = b[7];
  const b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function translate(out, a, v) {
  const a00 = a[0];
  const a01 = a[1];
  const a02 = a[2];
  const a10 = a[3];
  const a11 = a[4];
  const a12 = a[5];
  const a20 = a[6];
  const a21 = a[7];
  const a22 = a[8];
  const x = v[0];
  const y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
function rotate(out, a, rad) {
  const a00 = a[0];
  const a01 = a[1];
  const a02 = a[2];
  const a10 = a[3];
  const a11 = a[4];
  const a12 = a[5];
  const a20 = a[6];
  const a21 = a[7];
  const a22 = a[8];
  const s = Math.sin(rad);
  const c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
function scale(out, a, v) {
  const x = v[0];
  const y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
function fromQuat(out, q) {
  const x = q[0];
  const y = q[1];
  const z = q[2];
  const w = q[3];
  const x2 = x + x;
  const y2 = y + y;
  const z2 = z + z;
  const xx = x * x2;
  const yx = y * x2;
  const yy = y * y2;
  const zx = z * x2;
  const zy = z * y2;
  const zz = z * z2;
  const wx = w * x2;
  const wy = w * y2;
  const wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}

// ../../node_modules/.bun/@math.gl+core@4.1.0/node_modules/@math.gl/core/dist/classes/matrix3.js
var INDICES;
(function(INDICES2) {
  INDICES2[INDICES2["COL0ROW0"] = 0] = "COL0ROW0";
  INDICES2[INDICES2["COL0ROW1"] = 1] = "COL0ROW1";
  INDICES2[INDICES2["COL0ROW2"] = 2] = "COL0ROW2";
  INDICES2[INDICES2["COL1ROW0"] = 3] = "COL1ROW0";
  INDICES2[INDICES2["COL1ROW1"] = 4] = "COL1ROW1";
  INDICES2[INDICES2["COL1ROW2"] = 5] = "COL1ROW2";
  INDICES2[INDICES2["COL2ROW0"] = 6] = "COL2ROW0";
  INDICES2[INDICES2["COL2ROW1"] = 7] = "COL2ROW1";
  INDICES2[INDICES2["COL2ROW2"] = 8] = "COL2ROW2";
})(INDICES || (INDICES = {}));
var IDENTITY_MATRIX = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);

class Matrix3 extends Matrix {
  static get IDENTITY() {
    return getIdentityMatrix();
  }
  static get ZERO() {
    return getZeroMatrix();
  }
  get ELEMENTS() {
    return 9;
  }
  get RANK() {
    return 3;
  }
  get INDICES() {
    return INDICES;
  }
  constructor(array, ...args) {
    super(-0, -0, -0, -0, -0, -0, -0, -0, -0);
    if (arguments.length === 1 && Array.isArray(array)) {
      this.copy(array);
    } else if (args.length > 0) {
      this.copy([array, ...args]);
    } else {
      this.identity();
    }
  }
  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    this[3] = array[3];
    this[4] = array[4];
    this[5] = array[5];
    this[6] = array[6];
    this[7] = array[7];
    this[8] = array[8];
    return this.check();
  }
  identity() {
    return this.copy(IDENTITY_MATRIX);
  }
  fromObject(object) {
    return this.check();
  }
  fromQuaternion(q) {
    fromQuat(this, q);
    return this.check();
  }
  set(m00, m10, m20, m01, m11, m21, m02, m12, m22) {
    this[0] = m00;
    this[1] = m10;
    this[2] = m20;
    this[3] = m01;
    this[4] = m11;
    this[5] = m21;
    this[6] = m02;
    this[7] = m12;
    this[8] = m22;
    return this.check();
  }
  setRowMajor(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    this[0] = m00;
    this[1] = m10;
    this[2] = m20;
    this[3] = m01;
    this[4] = m11;
    this[5] = m21;
    this[6] = m02;
    this[7] = m12;
    this[8] = m22;
    return this.check();
  }
  determinant() {
    return determinant(this);
  }
  transpose() {
    transpose(this, this);
    return this.check();
  }
  invert() {
    invert(this, this);
    return this.check();
  }
  multiplyLeft(a) {
    multiply(this, a, this);
    return this.check();
  }
  multiplyRight(a) {
    multiply(this, this, a);
    return this.check();
  }
  rotate(radians) {
    rotate(this, this, radians);
    return this.check();
  }
  scale(factor) {
    if (Array.isArray(factor)) {
      scale(this, this, factor);
    } else {
      scale(this, this, [factor, factor]);
    }
    return this.check();
  }
  translate(vec) {
    translate(this, this, vec);
    return this.check();
  }
  transform(vector, result) {
    let out;
    switch (vector.length) {
      case 2:
        out = transformMat3(result || [-0, -0], vector, this);
        break;
      case 3:
        out = transformMat32(result || [-0, -0, -0], vector, this);
        break;
      case 4:
        out = vec4_transformMat3(result || [-0, -0, -0, -0], vector, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    checkVector(out, vector.length);
    return out;
  }
  transformVector(vector, result) {
    return this.transform(vector, result);
  }
  transformVector2(vector, result) {
    return this.transform(vector, result);
  }
  transformVector3(vector, result) {
    return this.transform(vector, result);
  }
}
var ZERO_MATRIX3;
var IDENTITY_MATRIX3 = null;
function getZeroMatrix() {
  if (!ZERO_MATRIX3) {
    ZERO_MATRIX3 = new Matrix3([0, 0, 0, 0, 0, 0, 0, 0, 0]);
    Object.freeze(ZERO_MATRIX3);
  }
  return ZERO_MATRIX3;
}
function getIdentityMatrix() {
  if (!IDENTITY_MATRIX3) {
    IDENTITY_MATRIX3 = new Matrix3;
    Object.freeze(IDENTITY_MATRIX3);
  }
  return IDENTITY_MATRIX3;
}
// ../../node_modules/.bun/@loaders.gl+gltf@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/gltf/dist/lib/extensions/KHR_texture_transform.js
var KHR_TEXTURE_TRANSFORM = "KHR_texture_transform";
var name8 = KHR_TEXTURE_TRANSFORM;
var scratchVector = new Vector32;
var scratchRotationMatrix = new Matrix3;
var scratchScaleMatrix = new Matrix3;
async function decode7(gltfData, options) {
  const gltfScenegraph = new GLTFScenegraph(gltfData);
  const hasExtension = gltfScenegraph.hasExtension(KHR_TEXTURE_TRANSFORM);
  if (!hasExtension || !options.gltf?.loadBuffers) {
    return;
  }
  const materials = gltfData.json.materials || [];
  for (let i = 0;i < materials.length; i++) {
    transformTexCoords(i, gltfData);
  }
}
function transformTexCoords(materialIndex, gltfData) {
  const material = gltfData.json.materials?.[materialIndex];
  const materialTextures = [
    material?.pbrMetallicRoughness?.baseColorTexture,
    material?.emissiveTexture,
    material?.normalTexture,
    material?.occlusionTexture,
    material?.pbrMetallicRoughness?.metallicRoughnessTexture
  ];
  const processedTexCoords = [];
  for (const textureInfo of materialTextures) {
    if (textureInfo && textureInfo?.extensions?.[KHR_TEXTURE_TRANSFORM]) {
      transformPrimitives(gltfData, materialIndex, textureInfo, processedTexCoords);
    }
  }
}
function transformPrimitives(gltfData, materialIndex, texture, processedTexCoords) {
  const transformParameters = getTransformParameters(texture, processedTexCoords);
  if (!transformParameters) {
    return;
  }
  const meshes = gltfData.json.meshes || [];
  for (const mesh of meshes) {
    for (const primitive of mesh.primitives) {
      const material = primitive.material;
      if (Number.isFinite(material) && materialIndex === material) {
        transformPrimitive(gltfData, primitive, transformParameters);
      }
    }
  }
}
function getTransformParameters(texture, processedTexCoords) {
  const textureInfo = texture.extensions?.[KHR_TEXTURE_TRANSFORM];
  const { texCoord: originalTexCoord = 0 } = texture;
  const { texCoord = originalTexCoord } = textureInfo;
  const isProcessed = processedTexCoords.findIndex(([original, newTexCoord]) => original === originalTexCoord && newTexCoord === texCoord) !== -1;
  if (!isProcessed) {
    const matrix = makeTransformationMatrix(textureInfo);
    if (originalTexCoord !== texCoord) {
      texture.texCoord = texCoord;
    }
    processedTexCoords.push([originalTexCoord, texCoord]);
    return { originalTexCoord, texCoord, matrix };
  }
  return null;
}
function transformPrimitive(gltfData, primitive, transformParameters) {
  const { originalTexCoord, texCoord, matrix } = transformParameters;
  const texCoordAccessor = primitive.attributes[`TEXCOORD_${originalTexCoord}`];
  if (Number.isFinite(texCoordAccessor)) {
    const accessor = gltfData.json.accessors?.[texCoordAccessor];
    if (accessor && accessor.bufferView) {
      const bufferView = gltfData.json.bufferViews?.[accessor.bufferView];
      if (bufferView) {
        const { arrayBuffer, byteOffset: bufferByteOffset } = gltfData.buffers[bufferView.buffer];
        const byteOffset = (bufferByteOffset || 0) + (accessor.byteOffset || 0) + (bufferView.byteOffset || 0);
        const { ArrayType, length } = getAccessorArrayTypeAndLength(accessor, bufferView);
        const bytes = BYTES[accessor.componentType];
        const components = COMPONENTS[accessor.type];
        const elementAddressScale = bufferView.byteStride || bytes * components;
        const result = new Float32Array(length);
        for (let i = 0;i < accessor.count; i++) {
          const uv = new ArrayType(arrayBuffer, byteOffset + i * elementAddressScale, 2);
          scratchVector.set(uv[0], uv[1], 1);
          scratchVector.transformByMatrix3(matrix);
          result.set([scratchVector[0], scratchVector[1]], i * components);
        }
        if (originalTexCoord === texCoord) {
          updateGltf(accessor, bufferView, gltfData.buffers, result);
        } else {
          createAttribute(texCoord, accessor, primitive, gltfData, result);
        }
      }
    }
  }
}
function updateGltf(accessor, bufferView, buffers, newTexCoordArray) {
  accessor.componentType = 5126;
  buffers.push({
    arrayBuffer: newTexCoordArray.buffer,
    byteOffset: 0,
    byteLength: newTexCoordArray.buffer.byteLength
  });
  bufferView.buffer = buffers.length - 1;
  bufferView.byteLength = newTexCoordArray.buffer.byteLength;
  bufferView.byteOffset = 0;
  delete bufferView.byteStride;
}
function createAttribute(newTexCoord, originalAccessor, primitive, gltfData, newTexCoordArray) {
  gltfData.buffers.push({
    arrayBuffer: newTexCoordArray.buffer,
    byteOffset: 0,
    byteLength: newTexCoordArray.buffer.byteLength
  });
  const bufferViews = gltfData.json.bufferViews;
  if (!bufferViews) {
    return;
  }
  bufferViews.push({
    buffer: gltfData.buffers.length - 1,
    byteLength: newTexCoordArray.buffer.byteLength,
    byteOffset: 0
  });
  const accessors = gltfData.json.accessors;
  if (!accessors) {
    return;
  }
  accessors.push({
    bufferView: bufferViews?.length - 1,
    byteOffset: 0,
    componentType: 5126,
    count: originalAccessor.count,
    type: "VEC2"
  });
  primitive.attributes[`TEXCOORD_${newTexCoord}`] = accessors.length - 1;
}
function makeTransformationMatrix(extensionData) {
  const { offset = [0, 0], rotation = 0, scale: scale2 = [1, 1] } = extensionData;
  const translationMatrix = new Matrix3().set(1, 0, 0, 0, 1, 0, offset[0], offset[1], 1);
  const rotationMatrix = scratchRotationMatrix.set(Math.cos(rotation), Math.sin(rotation), 0, -Math.sin(rotation), Math.cos(rotation), 0, 0, 0, 1);
  const scaleMatrix = scratchScaleMatrix.set(scale2[0], 0, 0, 0, scale2[1], 0, 0, 0, 1);
  return translationMatrix.multiplyRight(rotationMatrix).multiplyRight(scaleMatrix);
}

// ../../node_modules/.bun/@loaders.gl+gltf@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/gltf/dist/lib/extensions/deprecated/KHR_lights_punctual.js
var exports_KHR_lights_punctual = {};
__export(exports_KHR_lights_punctual, {
  name: () => name9,
  encode: () => encode4,
  decode: () => decode8
});
var KHR_LIGHTS_PUNCTUAL = "KHR_lights_punctual";
var name9 = KHR_LIGHTS_PUNCTUAL;
async function decode8(gltfData) {
  const gltfScenegraph = new GLTFScenegraph(gltfData);
  const { json } = gltfScenegraph;
  const extension = gltfScenegraph.getExtension(KHR_LIGHTS_PUNCTUAL);
  if (extension) {
    gltfScenegraph.json.lights = extension.lights;
    gltfScenegraph.removeExtension(KHR_LIGHTS_PUNCTUAL);
  }
  for (const node of json.nodes || []) {
    const nodeExtension = gltfScenegraph.getObjectExtension(node, KHR_LIGHTS_PUNCTUAL);
    if (nodeExtension) {
      node.light = nodeExtension.light;
    }
    gltfScenegraph.removeObjectExtension(node, KHR_LIGHTS_PUNCTUAL);
  }
}
async function encode4(gltfData) {
  const gltfScenegraph = new GLTFScenegraph(gltfData);
  const { json } = gltfScenegraph;
  if (json.lights) {
    const extension = gltfScenegraph.addExtension(KHR_LIGHTS_PUNCTUAL);
    assert4(!extension.lights);
    extension.lights = json.lights;
    delete json.lights;
  }
  if (gltfScenegraph.json.lights) {
    for (const light of gltfScenegraph.json.lights) {
      const node = light.node;
      gltfScenegraph.addObjectExtension(node, KHR_LIGHTS_PUNCTUAL, light);
    }
    delete gltfScenegraph.json.lights;
  }
}

// ../../node_modules/.bun/@loaders.gl+gltf@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/gltf/dist/lib/extensions/deprecated/KHR_materials_unlit.js
var exports_KHR_materials_unlit = {};
__export(exports_KHR_materials_unlit, {
  name: () => name10,
  encode: () => encode5,
  decode: () => decode9
});
var KHR_MATERIALS_UNLIT = "KHR_materials_unlit";
var name10 = KHR_MATERIALS_UNLIT;
async function decode9(gltfData) {
  const gltfScenegraph = new GLTFScenegraph(gltfData);
  const { json } = gltfScenegraph;
  for (const material of json.materials || []) {
    const extension = material.extensions && material.extensions.KHR_materials_unlit;
    if (extension) {
      material.unlit = true;
    }
    gltfScenegraph.removeObjectExtension(material, KHR_MATERIALS_UNLIT);
  }
  gltfScenegraph.removeExtension(KHR_MATERIALS_UNLIT);
}
function encode5(gltfData) {
  const gltfScenegraph = new GLTFScenegraph(gltfData);
  const { json } = gltfScenegraph;
  if (gltfScenegraph.materials) {
    for (const material of json.materials || []) {
      if (material.unlit) {
        delete material.unlit;
        gltfScenegraph.addObjectExtension(material, KHR_MATERIALS_UNLIT, {});
        gltfScenegraph.addExtension(KHR_MATERIALS_UNLIT);
      }
    }
  }
}

// ../../node_modules/.bun/@loaders.gl+gltf@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/gltf/dist/lib/extensions/deprecated/KHR_techniques_webgl.js
var exports_KHR_techniques_webgl = {};
__export(exports_KHR_techniques_webgl, {
  name: () => name11,
  encode: () => encode6,
  decode: () => decode10
});
var KHR_TECHNIQUES_WEBGL = "KHR_techniques_webgl";
var name11 = KHR_TECHNIQUES_WEBGL;
async function decode10(gltfData) {
  const gltfScenegraph = new GLTFScenegraph(gltfData);
  const { json } = gltfScenegraph;
  const extension = gltfScenegraph.getExtension(KHR_TECHNIQUES_WEBGL);
  if (extension) {
    const techniques = resolveTechniques(extension, gltfScenegraph);
    for (const material of json.materials || []) {
      const materialExtension = gltfScenegraph.getObjectExtension(material, KHR_TECHNIQUES_WEBGL);
      if (materialExtension) {
        material.technique = Object.assign({}, materialExtension, techniques[materialExtension.technique]);
        material.technique.values = resolveValues(material.technique, gltfScenegraph);
      }
      gltfScenegraph.removeObjectExtension(material, KHR_TECHNIQUES_WEBGL);
    }
    gltfScenegraph.removeExtension(KHR_TECHNIQUES_WEBGL);
  }
}
async function encode6(gltfData, options) {}
function resolveTechniques(techniquesExtension, gltfScenegraph) {
  const { programs = [], shaders = [], techniques = [] } = techniquesExtension;
  const textDecoder = new TextDecoder;
  shaders.forEach((shader) => {
    if (Number.isFinite(shader.bufferView)) {
      shader.code = textDecoder.decode(gltfScenegraph.getTypedArrayForBufferView(shader.bufferView));
    } else {
      throw new Error("KHR_techniques_webgl: no shader code");
    }
  });
  programs.forEach((program) => {
    program.fragmentShader = shaders[program.fragmentShader];
    program.vertexShader = shaders[program.vertexShader];
  });
  techniques.forEach((technique) => {
    technique.program = programs[technique.program];
  });
  return techniques;
}
function resolveValues(technique, gltfScenegraph) {
  const values = Object.assign({}, technique.values);
  Object.keys(technique.uniforms || {}).forEach((uniform) => {
    if (technique.uniforms[uniform].value && !(uniform in values)) {
      values[uniform] = technique.uniforms[uniform].value;
    }
  });
  Object.keys(values).forEach((uniform) => {
    if (typeof values[uniform] === "object" && values[uniform].index !== undefined) {
      values[uniform].texture = gltfScenegraph.getTexture(values[uniform].index);
    }
  });
  return values;
}

// ../../node_modules/.bun/@loaders.gl+gltf@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/gltf/dist/lib/api/gltf-extensions.js
var EXTENSIONS2 = [
  exports_EXT_structural_metadata,
  exports_EXT_mesh_features,
  exports_EXT_meshopt_compression,
  exports_EXT_texture_webp,
  exports_KHR_texture_basisu,
  exports_KHR_draco_mesh_compression,
  exports_KHR_lights_punctual,
  exports_KHR_materials_unlit,
  exports_KHR_techniques_webgl,
  exports_KHR_texture_transform,
  exports_EXT_feature_metadata
];
function preprocessExtensions(gltf, options = {}, context) {
  const extensions = EXTENSIONS2.filter((extension) => useExtension(extension.name, options));
  for (const extension of extensions) {
    extension.preprocess?.(gltf, options, context);
  }
}
async function decodeExtensions(gltf, options = {}, context) {
  const extensions = EXTENSIONS2.filter((extension) => useExtension(extension.name, options));
  for (const extension of extensions) {
    await extension.decode?.(gltf, options, context);
  }
}
function useExtension(extensionName, options) {
  const excludes = options?.gltf?.excludeExtensions || {};
  const exclude = extensionName in excludes && !excludes[extensionName];
  return !exclude;
}

// ../../node_modules/.bun/@loaders.gl+gltf@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/gltf/dist/lib/extensions/KHR_binary_gltf.js
var KHR_BINARY_GLTF = "KHR_binary_glTF";
function preprocess4(gltfData) {
  const gltfScenegraph = new GLTFScenegraph(gltfData);
  const { json } = gltfScenegraph;
  for (const image of json.images || []) {
    const extension = gltfScenegraph.getObjectExtension(image, KHR_BINARY_GLTF);
    if (extension) {
      Object.assign(image, extension);
    }
    gltfScenegraph.removeObjectExtension(image, KHR_BINARY_GLTF);
  }
  if (json.buffers && json.buffers[0]) {
    delete json.buffers[0].uri;
  }
  gltfScenegraph.removeExtension(KHR_BINARY_GLTF);
}

// ../../node_modules/.bun/@loaders.gl+gltf@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/gltf/dist/lib/api/normalize-gltf-v1.js
var GLTF_ARRAYS = {
  accessors: "accessor",
  animations: "animation",
  buffers: "buffer",
  bufferViews: "bufferView",
  images: "image",
  materials: "material",
  meshes: "mesh",
  nodes: "node",
  samplers: "sampler",
  scenes: "scene",
  skins: "skin",
  textures: "texture"
};
var GLTF_KEYS = {
  accessor: "accessors",
  animations: "animation",
  buffer: "buffers",
  bufferView: "bufferViews",
  image: "images",
  material: "materials",
  mesh: "meshes",
  node: "nodes",
  sampler: "samplers",
  scene: "scenes",
  skin: "skins",
  texture: "textures"
};

class GLTFV1Normalizer {
  idToIndexMap = {
    animations: {},
    accessors: {},
    buffers: {},
    bufferViews: {},
    images: {},
    materials: {},
    meshes: {},
    nodes: {},
    samplers: {},
    scenes: {},
    skins: {},
    textures: {}
  };
  json;
  normalize(gltf, options) {
    this.json = gltf.json;
    const json = gltf.json;
    switch (json.asset && json.asset.version) {
      case "2.0":
        return;
      case undefined:
      case "1.0":
        break;
      default:
        console.warn(`glTF: Unknown version ${json.asset.version}`);
        return;
    }
    if (!options.normalize) {
      throw new Error("glTF v1 is not supported.");
    }
    console.warn("Converting glTF v1 to glTF v2 format. This is experimental and may fail.");
    this._addAsset(json);
    this._convertTopLevelObjectsToArrays(json);
    preprocess4(gltf);
    this._convertObjectIdsToArrayIndices(json);
    this._updateObjects(json);
    this._updateMaterial(json);
  }
  _addAsset(json) {
    json.asset = json.asset || {};
    json.asset.version = "2.0";
    json.asset.generator = json.asset.generator || "Normalized to glTF 2.0 by loaders.gl";
  }
  _convertTopLevelObjectsToArrays(json) {
    for (const arrayName in GLTF_ARRAYS) {
      this._convertTopLevelObjectToArray(json, arrayName);
    }
  }
  _convertTopLevelObjectToArray(json, mapName) {
    const objectMap = json[mapName];
    if (!objectMap || Array.isArray(objectMap)) {
      return;
    }
    json[mapName] = [];
    for (const id in objectMap) {
      const object = objectMap[id];
      object.id = object.id || id;
      const index = json[mapName].length;
      json[mapName].push(object);
      this.idToIndexMap[mapName][id] = index;
    }
  }
  _convertObjectIdsToArrayIndices(json) {
    for (const arrayName in GLTF_ARRAYS) {
      this._convertIdsToIndices(json, arrayName);
    }
    if ("scene" in json) {
      json.scene = this._convertIdToIndex(json.scene, "scene");
    }
    for (const texture of json.textures) {
      this._convertTextureIds(texture);
    }
    for (const mesh of json.meshes) {
      this._convertMeshIds(mesh);
    }
    for (const node of json.nodes) {
      this._convertNodeIds(node);
    }
    for (const node of json.scenes) {
      this._convertSceneIds(node);
    }
  }
  _convertTextureIds(texture) {
    if (texture.source) {
      texture.source = this._convertIdToIndex(texture.source, "image");
    }
  }
  _convertMeshIds(mesh) {
    for (const primitive of mesh.primitives) {
      const { attributes, indices, material } = primitive;
      for (const attributeName in attributes) {
        attributes[attributeName] = this._convertIdToIndex(attributes[attributeName], "accessor");
      }
      if (indices) {
        primitive.indices = this._convertIdToIndex(indices, "accessor");
      }
      if (material) {
        primitive.material = this._convertIdToIndex(material, "material");
      }
    }
  }
  _convertNodeIds(node) {
    if (node.children) {
      node.children = node.children.map((child) => this._convertIdToIndex(child, "node"));
    }
    if (node.meshes) {
      node.meshes = node.meshes.map((mesh) => this._convertIdToIndex(mesh, "mesh"));
    }
  }
  _convertSceneIds(scene) {
    if (scene.nodes) {
      scene.nodes = scene.nodes.map((node) => this._convertIdToIndex(node, "node"));
    }
  }
  _convertIdsToIndices(json, topLevelArrayName) {
    if (!json[topLevelArrayName]) {
      console.warn(`gltf v1: json doesn't contain attribute ${topLevelArrayName}`);
      json[topLevelArrayName] = [];
    }
    for (const object of json[topLevelArrayName]) {
      for (const key in object) {
        const id = object[key];
        const index = this._convertIdToIndex(id, key);
        object[key] = index;
      }
    }
  }
  _convertIdToIndex(id, key) {
    const arrayName = GLTF_KEYS[key];
    if (arrayName in this.idToIndexMap) {
      const index = this.idToIndexMap[arrayName][id];
      if (!Number.isFinite(index)) {
        throw new Error(`gltf v1: failed to resolve ${key} with id ${id}`);
      }
      return index;
    }
    return id;
  }
  _updateObjects(json) {
    for (const buffer of this.json.buffers) {
      delete buffer.type;
    }
  }
  _updateMaterial(json) {
    for (const material of json.materials) {
      material.pbrMetallicRoughness = {
        baseColorFactor: [1, 1, 1, 1],
        metallicFactor: 1,
        roughnessFactor: 1
      };
      const textureId = material.values?.tex || material.values?.texture2d_0 || material.values?.diffuseTex;
      const textureIndex = json.textures.findIndex((texture) => texture.id === textureId);
      if (textureIndex !== -1) {
        material.pbrMetallicRoughness.baseColorTexture = { index: textureIndex };
      }
    }
  }
}
function normalizeGLTFV1(gltf, options = {}) {
  return new GLTFV1Normalizer().normalize(gltf, options);
}

// ../../node_modules/.bun/@loaders.gl+gltf@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/gltf/dist/lib/parsers/parse-gltf.js
async function parseGLTF(gltf, arrayBufferOrString, byteOffset = 0, options, context) {
  parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);
  normalizeGLTFV1(gltf, { normalize: options?.gltf?.normalize });
  preprocessExtensions(gltf, options, context);
  if (options?.gltf?.loadBuffers && gltf.json.buffers) {
    await loadBuffers(gltf, options, context);
  }
  if (options?.gltf?.loadImages) {
    await loadImages(gltf, options, context);
  }
  await decodeExtensions(gltf, options, context);
  return gltf;
}
function parseGLTFContainerSync(gltf, data, byteOffset, options) {
  if (options.uri) {
    gltf.baseUri = options.uri;
  }
  if (data instanceof ArrayBuffer && !isGLB(data, byteOffset, options)) {
    const textDecoder = new TextDecoder;
    data = textDecoder.decode(data);
  }
  if (typeof data === "string") {
    gltf.json = parseJSON(data);
  } else if (data instanceof ArrayBuffer) {
    const glb = {};
    byteOffset = parseGLBSync(glb, data, byteOffset, options.glb);
    assert4(glb.type === "glTF", `Invalid GLB magic string ${glb.type}`);
    gltf._glb = glb;
    gltf.json = glb.json;
  } else {
    assert4(false, "GLTF: must be ArrayBuffer or string");
  }
  const buffers = gltf.json.buffers || [];
  gltf.buffers = new Array(buffers.length).fill(null);
  if (gltf._glb && gltf._glb.header.hasBinChunk) {
    const { binChunks } = gltf._glb;
    gltf.buffers[0] = {
      arrayBuffer: binChunks[0].arrayBuffer,
      byteOffset: binChunks[0].byteOffset,
      byteLength: binChunks[0].byteLength
    };
  }
  const images = gltf.json.images || [];
  gltf.images = new Array(images.length).fill({});
}
async function loadBuffers(gltf, options, context) {
  const buffers = gltf.json.buffers || [];
  for (let i = 0;i < buffers.length; ++i) {
    const buffer = buffers[i];
    if (buffer.uri) {
      const { fetch: fetch2 } = context;
      assert4(fetch2);
      const uri = resolveUrl(buffer.uri, options);
      const response = await context?.fetch?.(uri);
      const arrayBuffer = await response?.arrayBuffer?.();
      gltf.buffers[i] = {
        arrayBuffer,
        byteOffset: 0,
        byteLength: arrayBuffer.byteLength
      };
      delete buffer.uri;
    } else if (gltf.buffers[i] === null) {
      gltf.buffers[i] = {
        arrayBuffer: new ArrayBuffer(buffer.byteLength),
        byteOffset: 0,
        byteLength: buffer.byteLength
      };
    }
  }
}
async function loadImages(gltf, options, context) {
  const imageIndices = getReferencesImageIndices(gltf);
  const images = gltf.json.images || [];
  const promises = [];
  for (const imageIndex of imageIndices) {
    promises.push(loadImage(gltf, images[imageIndex], imageIndex, options, context));
  }
  return await Promise.all(promises);
}
function getReferencesImageIndices(gltf) {
  const imageIndices = new Set;
  const textures = gltf.json.textures || [];
  for (const texture of textures) {
    if (texture.source !== undefined) {
      imageIndices.add(texture.source);
    }
  }
  return Array.from(imageIndices).sort();
}
async function loadImage(gltf, image, index, options, context) {
  let arrayBuffer;
  if (image.uri && !image.hasOwnProperty("bufferView")) {
    const uri = resolveUrl(image.uri, options);
    const { fetch: fetch2 } = context;
    const response = await fetch2(uri);
    arrayBuffer = await response.arrayBuffer();
    image.bufferView = {
      data: arrayBuffer
    };
  }
  if (Number.isFinite(image.bufferView)) {
    const array = getTypedArrayForBufferView(gltf.json, gltf.buffers, image.bufferView);
    arrayBuffer = sliceArrayBuffer(array.buffer, array.byteOffset, array.byteLength);
  }
  assert4(arrayBuffer, "glTF image has no data");
  let parsedImage = await parseFromContext(arrayBuffer, [ImageLoader, BasisLoader], {
    ...options,
    mimeType: image.mimeType,
    basis: options.basis || { format: selectSupportedBasisFormat() }
  }, context);
  if (parsedImage && parsedImage[0]) {
    parsedImage = {
      compressed: true,
      mipmaps: false,
      width: parsedImage[0].width,
      height: parsedImage[0].height,
      data: parsedImage[0]
    };
  }
  gltf.images = gltf.images || [];
  gltf.images[index] = parsedImage;
}

// ../../node_modules/.bun/@loaders.gl+gltf@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/gltf/dist/gltf-loader.js
var GLTFLoader = {
  dataType: null,
  batchType: null,
  name: "glTF",
  id: "gltf",
  module: "gltf",
  version: VERSION5,
  extensions: ["gltf", "glb"],
  mimeTypes: ["model/gltf+json", "model/gltf-binary"],
  text: true,
  binary: true,
  tests: ["glTF"],
  parse: parse3,
  options: {
    gltf: {
      normalize: true,
      loadBuffers: true,
      loadImages: true,
      decompressMeshes: true
    },
    log: console
  }
};
async function parse3(arrayBuffer, options = {}, context) {
  options = { ...GLTFLoader.options, ...options };
  options.gltf = { ...GLTFLoader.options.gltf, ...options.gltf };
  const { byteOffset = 0 } = options;
  const gltf = {};
  return await parseGLTF(gltf, arrayBuffer, byteOffset, options, context);
}
// ../../node_modules/.bun/@loaders.gl+gltf@4.3.4+bf9a53f44563e878/node_modules/@loaders.gl/gltf/dist/lib/api/post-process-gltf.js
var COMPONENTS2 = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
var BYTES2 = {
  5120: 1,
  5121: 1,
  5122: 2,
  5123: 2,
  5125: 4,
  5126: 4
};
var GL_SAMPLER = {
  TEXTURE_MAG_FILTER: 10240,
  TEXTURE_MIN_FILTER: 10241,
  TEXTURE_WRAP_S: 10242,
  TEXTURE_WRAP_T: 10243,
  REPEAT: 10497,
  LINEAR: 9729,
  NEAREST_MIPMAP_LINEAR: 9986
};
var SAMPLER_PARAMETER_GLTF_TO_GL = {
  magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,
  minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,
  wrapS: GL_SAMPLER.TEXTURE_WRAP_S,
  wrapT: GL_SAMPLER.TEXTURE_WRAP_T
};
var DEFAULT_SAMPLER_PARAMETERS = {
  [GL_SAMPLER.TEXTURE_MAG_FILTER]: GL_SAMPLER.LINEAR,
  [GL_SAMPLER.TEXTURE_MIN_FILTER]: GL_SAMPLER.NEAREST_MIPMAP_LINEAR,
  [GL_SAMPLER.TEXTURE_WRAP_S]: GL_SAMPLER.REPEAT,
  [GL_SAMPLER.TEXTURE_WRAP_T]: GL_SAMPLER.REPEAT
};
function makeDefaultSampler() {
  return {
    id: "default-sampler",
    parameters: DEFAULT_SAMPLER_PARAMETERS
  };
}
function getBytesFromComponentType(componentType) {
  return BYTES2[componentType];
}
function getSizeFromAccessorType(type) {
  return COMPONENTS2[type];
}

class GLTFPostProcessor {
  baseUri = "";
  jsonUnprocessed;
  json;
  buffers = [];
  images = [];
  postProcess(gltf, options = {}) {
    const { json, buffers = [], images = [] } = gltf;
    const { baseUri = "" } = gltf;
    assert4(json);
    this.baseUri = baseUri;
    this.buffers = buffers;
    this.images = images;
    this.jsonUnprocessed = json;
    this.json = this._resolveTree(gltf.json, options);
    return this.json;
  }
  _resolveTree(gltf, options = {}) {
    const json = { ...gltf };
    this.json = json;
    if (gltf.bufferViews) {
      json.bufferViews = gltf.bufferViews.map((bufView, i) => this._resolveBufferView(bufView, i));
    }
    if (gltf.images) {
      json.images = gltf.images.map((image, i) => this._resolveImage(image, i));
    }
    if (gltf.samplers) {
      json.samplers = gltf.samplers.map((sampler, i) => this._resolveSampler(sampler, i));
    }
    if (gltf.textures) {
      json.textures = gltf.textures.map((texture, i) => this._resolveTexture(texture, i));
    }
    if (gltf.accessors) {
      json.accessors = gltf.accessors.map((accessor, i) => this._resolveAccessor(accessor, i));
    }
    if (gltf.materials) {
      json.materials = gltf.materials.map((material, i) => this._resolveMaterial(material, i));
    }
    if (gltf.meshes) {
      json.meshes = gltf.meshes.map((mesh, i) => this._resolveMesh(mesh, i));
    }
    if (gltf.nodes) {
      json.nodes = gltf.nodes.map((node, i) => this._resolveNode(node, i));
      json.nodes = json.nodes.map((node, i) => this._resolveNodeChildren(node));
    }
    if (gltf.skins) {
      json.skins = gltf.skins.map((skin, i) => this._resolveSkin(skin, i));
    }
    if (gltf.scenes) {
      json.scenes = gltf.scenes.map((scene, i) => this._resolveScene(scene, i));
    }
    if (typeof this.json.scene === "number" && json.scenes) {
      json.scene = json.scenes[this.json.scene];
    }
    return json;
  }
  getScene(index) {
    return this._get(this.json.scenes, index);
  }
  getNode(index) {
    return this._get(this.json.nodes, index);
  }
  getSkin(index) {
    return this._get(this.json.skins, index);
  }
  getMesh(index) {
    return this._get(this.json.meshes, index);
  }
  getMaterial(index) {
    return this._get(this.json.materials, index);
  }
  getAccessor(index) {
    return this._get(this.json.accessors, index);
  }
  getCamera(index) {
    return this._get(this.json.cameras, index);
  }
  getTexture(index) {
    return this._get(this.json.textures, index);
  }
  getSampler(index) {
    return this._get(this.json.samplers, index);
  }
  getImage(index) {
    return this._get(this.json.images, index);
  }
  getBufferView(index) {
    return this._get(this.json.bufferViews, index);
  }
  getBuffer(index) {
    return this._get(this.json.buffers, index);
  }
  _get(array, index) {
    if (typeof index === "object") {
      return index;
    }
    const object = array && array[index];
    if (!object) {
      console.warn(`glTF file error: Could not find ${array}[${index}]`);
    }
    return object;
  }
  _resolveScene(scene, index) {
    return {
      ...scene,
      id: scene.id || `scene-${index}`,
      nodes: (scene.nodes || []).map((node) => this.getNode(node))
    };
  }
  _resolveNode(gltfNode, index) {
    const node = {
      ...gltfNode,
      id: gltfNode?.id || `node-${index}`
    };
    if (gltfNode.mesh !== undefined) {
      node.mesh = this.getMesh(gltfNode.mesh);
    }
    if (gltfNode.camera !== undefined) {
      node.camera = this.getCamera(gltfNode.camera);
    }
    if (gltfNode.skin !== undefined) {
      node.skin = this.getSkin(gltfNode.skin);
    }
    if (gltfNode.meshes !== undefined && gltfNode.meshes.length) {
      node.mesh = gltfNode.meshes.reduce((accum, meshIndex) => {
        const mesh = this.getMesh(meshIndex);
        accum.id = mesh.id;
        accum.primitives = accum.primitives.concat(mesh.primitives);
        return accum;
      }, { primitives: [] });
    }
    return node;
  }
  _resolveNodeChildren(node) {
    if (node.children) {
      node.children = node.children.map((child) => this.getNode(child));
    }
    return node;
  }
  _resolveSkin(gltfSkin, index) {
    const inverseBindMatrices = typeof gltfSkin.inverseBindMatrices === "number" ? this.getAccessor(gltfSkin.inverseBindMatrices) : undefined;
    return {
      ...gltfSkin,
      id: gltfSkin.id || `skin-${index}`,
      inverseBindMatrices
    };
  }
  _resolveMesh(gltfMesh, index) {
    const mesh = {
      ...gltfMesh,
      id: gltfMesh.id || `mesh-${index}`,
      primitives: []
    };
    if (gltfMesh.primitives) {
      mesh.primitives = gltfMesh.primitives.map((gltfPrimitive) => {
        const primitive = {
          ...gltfPrimitive,
          attributes: {},
          indices: undefined,
          material: undefined
        };
        const attributes = gltfPrimitive.attributes;
        for (const attribute in attributes) {
          primitive.attributes[attribute] = this.getAccessor(attributes[attribute]);
        }
        if (gltfPrimitive.indices !== undefined) {
          primitive.indices = this.getAccessor(gltfPrimitive.indices);
        }
        if (gltfPrimitive.material !== undefined) {
          primitive.material = this.getMaterial(gltfPrimitive.material);
        }
        return primitive;
      });
    }
    return mesh;
  }
  _resolveMaterial(gltfMaterial, index) {
    const material = {
      ...gltfMaterial,
      id: gltfMaterial.id || `material-${index}`
    };
    if (material.normalTexture) {
      material.normalTexture = { ...material.normalTexture };
      material.normalTexture.texture = this.getTexture(material.normalTexture.index);
    }
    if (material.occlusionTexture) {
      material.occlusionTexture = { ...material.occlusionTexture };
      material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);
    }
    if (material.emissiveTexture) {
      material.emissiveTexture = { ...material.emissiveTexture };
      material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);
    }
    if (!material.emissiveFactor) {
      material.emissiveFactor = material.emissiveTexture ? [1, 1, 1] : [0, 0, 0];
    }
    if (material.pbrMetallicRoughness) {
      material.pbrMetallicRoughness = { ...material.pbrMetallicRoughness };
      const mr = material.pbrMetallicRoughness;
      if (mr.baseColorTexture) {
        mr.baseColorTexture = { ...mr.baseColorTexture };
        mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);
      }
      if (mr.metallicRoughnessTexture) {
        mr.metallicRoughnessTexture = { ...mr.metallicRoughnessTexture };
        mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);
      }
    }
    return material;
  }
  _resolveAccessor(gltfAccessor, index) {
    const bytesPerComponent = getBytesFromComponentType(gltfAccessor.componentType);
    const components = getSizeFromAccessorType(gltfAccessor.type);
    const bytesPerElement = bytesPerComponent * components;
    const accessor = {
      ...gltfAccessor,
      id: gltfAccessor.id || `accessor-${index}`,
      bytesPerComponent,
      components,
      bytesPerElement,
      value: undefined,
      bufferView: undefined,
      sparse: undefined
    };
    if (gltfAccessor.bufferView !== undefined) {
      accessor.bufferView = this.getBufferView(gltfAccessor.bufferView);
    }
    if (accessor.bufferView) {
      const buffer = accessor.bufferView.buffer;
      const { ArrayType, byteLength } = getAccessorArrayTypeAndLength(accessor, accessor.bufferView);
      const byteOffset = (accessor.bufferView.byteOffset || 0) + (accessor.byteOffset || 0) + buffer.byteOffset;
      let cutBuffer = buffer.arrayBuffer.slice(byteOffset, byteOffset + byteLength);
      if (accessor.bufferView.byteStride) {
        cutBuffer = this._getValueFromInterleavedBuffer(buffer, byteOffset, accessor.bufferView.byteStride, accessor.bytesPerElement, accessor.count);
      }
      accessor.value = new ArrayType(cutBuffer);
    }
    return accessor;
  }
  _getValueFromInterleavedBuffer(buffer, byteOffset, byteStride, bytesPerElement, count) {
    const result = new Uint8Array(count * bytesPerElement);
    for (let i = 0;i < count; i++) {
      const elementOffset = byteOffset + i * byteStride;
      result.set(new Uint8Array(buffer.arrayBuffer.slice(elementOffset, elementOffset + bytesPerElement)), i * bytesPerElement);
    }
    return result.buffer;
  }
  _resolveTexture(gltfTexture, index) {
    return {
      ...gltfTexture,
      id: gltfTexture.id || `texture-${index}`,
      sampler: typeof gltfTexture.sampler === "number" ? this.getSampler(gltfTexture.sampler) : makeDefaultSampler(),
      source: typeof gltfTexture.source === "number" ? this.getImage(gltfTexture.source) : undefined
    };
  }
  _resolveSampler(gltfSampler, index) {
    const sampler = {
      id: gltfSampler.id || `sampler-${index}`,
      ...gltfSampler,
      parameters: {}
    };
    for (const key in sampler) {
      const glEnum = this._enumSamplerParameter(key);
      if (glEnum !== undefined) {
        sampler.parameters[glEnum] = sampler[key];
      }
    }
    return sampler;
  }
  _enumSamplerParameter(key) {
    return SAMPLER_PARAMETER_GLTF_TO_GL[key];
  }
  _resolveImage(gltfImage, index) {
    const image = {
      ...gltfImage,
      id: gltfImage.id || `image-${index}`,
      image: null,
      bufferView: gltfImage.bufferView !== undefined ? this.getBufferView(gltfImage.bufferView) : undefined
    };
    const preloadedImage = this.images[index];
    if (preloadedImage) {
      image.image = preloadedImage;
    }
    return image;
  }
  _resolveBufferView(gltfBufferView, index) {
    const bufferIndex = gltfBufferView.buffer;
    const arrayBuffer = this.buffers[bufferIndex].arrayBuffer;
    let byteOffset = this.buffers[bufferIndex].byteOffset || 0;
    if (gltfBufferView.byteOffset) {
      byteOffset += gltfBufferView.byteOffset;
    }
    const bufferView = {
      id: `bufferView-${index}`,
      ...gltfBufferView,
      buffer: this.buffers[bufferIndex],
      data: new Uint8Array(arrayBuffer, byteOffset, gltfBufferView.byteLength)
    };
    return bufferView;
  }
  _resolveCamera(gltfCamera, index) {
    const camera = {
      ...gltfCamera,
      id: gltfCamera.id || `camera-${index}`
    };
    if (camera.perspective) {}
    if (camera.orthographic) {}
    return camera;
  }
}
function postProcessGLTF(gltf, options) {
  return new GLTFPostProcessor().postProcess(gltf, options);
}
// ../../src/core/animation/Bone.ts
class Bone {
  name;
  index;
  parent = null;
  children = [];
  bindPosition;
  bindRotation;
  bindScale;
  inverseBindMatrix;
  _position;
  _rotation;
  _scale;
  _localMatrix = new Matrix4;
  _worldMatrix = new Matrix4;
  _finalMatrix = new Matrix4;
  _localMatrixDirty = true;
  _worldMatrixDirty = true;
  constructor(data) {
    this.name = data.name;
    this.index = data.index;
    this.bindPosition = data.localBindPose.position.clone();
    this.bindRotation = data.localBindPose.rotation.clone();
    this.bindScale = data.localBindPose.scale.clone();
    this.inverseBindMatrix = data.inverseBindMatrix.clone();
    this._position = this.bindPosition.clone();
    this._rotation = this.bindRotation.clone();
    this._scale = this.bindScale.clone();
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position.copy(value);
    this._markLocalDirty();
  }
  get rotation() {
    return this._rotation;
  }
  set rotation(value) {
    this._rotation.copy(value);
    this._markLocalDirty();
  }
  get scale() {
    return this._scale;
  }
  set scale(value) {
    this._scale.copy(value);
    this._markLocalDirty();
  }
  get localMatrix() {
    if (this._localMatrixDirty) {
      this.updateLocalMatrix();
    }
    return this._localMatrix;
  }
  get worldMatrix() {
    if (this._worldMatrixDirty) {
      this.updateWorldMatrix();
    }
    return this._worldMatrix;
  }
  get finalMatrix() {
    if (this._worldMatrixDirty) {
      this.updateWorldMatrix();
    }
    return this._finalMatrix;
  }
  updateLocalMatrix() {
    this._localMatrix.compose(this._position, this._rotation.toMatrix4(), this._scale);
    this._localMatrixDirty = false;
  }
  updateWorldMatrix() {
    if (this._localMatrixDirty) {
      this.updateLocalMatrix();
    }
    if (this.parent) {
      this._worldMatrix.multiplyMatrices(this.parent.worldMatrix, this._localMatrix);
    } else {
      this._worldMatrix.copy(this._localMatrix);
    }
    this._finalMatrix.multiplyMatrices(this._worldMatrix, this.inverseBindMatrix);
    this._worldMatrixDirty = false;
  }
  copyBindPose() {
    this._position.copy(this.bindPosition);
    this._rotation.copy(this.bindRotation);
    this._scale.copy(this.bindScale);
    this._markLocalDirty();
  }
  setPosition(x, y, z) {
    this._position.set(x, y, z);
    this._markLocalDirty();
  }
  setRotation(x, y, z, w) {
    this._rotation.x = x;
    this._rotation.y = y;
    this._rotation.z = z;
    this._rotation.w = w;
    this._markLocalDirty();
  }
  setScale(x, y, z) {
    this._scale.set(x, y, z);
    this._markLocalDirty();
  }
  addChild(bone) {
    if (bone.parent) {
      bone.parent.removeChild(bone);
    }
    bone.parent = this;
    this.children.push(bone);
    bone._markWorldDirty();
  }
  removeChild(bone) {
    const index = this.children.indexOf(bone);
    if (index !== -1) {
      this.children.splice(index, 1);
      bone.parent = null;
    }
  }
  _markLocalDirty() {
    this._localMatrixDirty = true;
    this._markWorldDirty();
  }
  _markWorldDirty() {
    this._worldMatrixDirty = true;
    for (const child of this.children) {
      child._markWorldDirty();
    }
  }
  clone() {
    const cloned = new Bone({
      name: this.name,
      index: this.index,
      parentIndex: this.parent?.index ?? -1,
      localBindPose: {
        position: this.bindPosition.clone(),
        rotation: this.bindRotation.clone(),
        scale: this.bindScale.clone()
      },
      inverseBindMatrix: this.inverseBindMatrix.clone()
    });
    cloned._position.copy(this._position);
    cloned._rotation.copy(this._rotation);
    cloned._scale.copy(this._scale);
    return cloned;
  }
  toString() {
    return `Bone(${this.name}, index=${this.index}, parent=${this.parent?.name ?? "none"})`;
  }
}
// ../../src/core/animation/Skeleton.ts
var MAX_BONES = 128;

class Skeleton {
  bones = [];
  bonesByName = new Map;
  rootBones = [];
  boneMatricesBuffer = null;
  bindGroup = null;
  _boneMatrices;
  _gpuDirty = true;
  _device = null;
  constructor(bonesData) {
    this._boneMatrices = new Float32Array(MAX_BONES * 16);
    for (const data of bonesData) {
      const bone = new Bone(data);
      this.bones[bone.index] = bone;
      this.bonesByName.set(bone.name, bone);
    }
    for (const data of bonesData) {
      const bone = this.bones[data.index];
      if (data.parentIndex >= 0 && data.parentIndex < this.bones.length) {
        const parent = this.bones[data.parentIndex];
        if (parent) {
          parent.addChild(bone);
        }
      } else {
        this.rootBones.push(bone);
      }
    }
  }
  getBone(name12) {
    return this.bonesByName.get(name12) ?? null;
  }
  getBoneIndex(name12) {
    const bone = this.bonesByName.get(name12);
    return bone?.index ?? -1;
  }
  get boneCount() {
    return this.bones.length;
  }
  update() {
    for (const root of this.rootBones) {
      this._updateBoneRecursive(root);
    }
    this._gpuDirty = true;
  }
  _updateBoneRecursive(bone) {
    bone.updateWorldMatrix();
    for (const child of bone.children) {
      this._updateBoneRecursive(child);
    }
  }
  initGPU(device) {
    if (this._device === device && this.boneMatricesBuffer) {
      return;
    }
    this._device = device;
    this.boneMatricesBuffer = device.createBuffer({
      label: `Skeleton Bone Matrices (${this.boneCount} bones)`,
      size: MAX_BONES * 16 * 4,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
    });
    this.uploadToGPU(device);
  }
  static createBindGroupLayout(device) {
    return device.createBindGroupLayout({
      label: "Skeleton Bind Group Layout",
      entries: [
        {
          binding: 0,
          visibility: GPUShaderStage.VERTEX,
          buffer: {
            type: "read-only-storage"
          }
        }
      ]
    });
  }
  createBindGroup(device, layout) {
    if (!this.boneMatricesBuffer) {
      this.initGPU(device);
    }
    this.bindGroup = device.createBindGroup({
      label: "Skeleton Bind Group",
      layout,
      entries: [
        {
          binding: 0,
          resource: { buffer: this.boneMatricesBuffer }
        }
      ]
    });
    return this.bindGroup;
  }
  uploadToGPU(device) {
    if (!this._gpuDirty)
      return;
    if (!this.boneMatricesBuffer) {
      this.initGPU(device);
    }
    for (let i = 0;i < this.bones.length; i++) {
      const bone = this.bones[i];
      if (bone) {
        const matrix = bone.finalMatrix;
        const offset = i * 16;
        this._boneMatrices.set(matrix.elements, offset);
      }
    }
    const identityElements = Matrix4.identity.elements;
    for (let i = this.bones.length;i < MAX_BONES; i++) {
      const offset = i * 16;
      this._boneMatrices.set(identityElements, offset);
    }
    device.queue.writeBuffer(this.boneMatricesBuffer, 0, this._boneMatrices.buffer, this._boneMatrices.byteOffset, this._boneMatrices.byteLength);
    this._gpuDirty = false;
  }
  getBoneMatrices() {
    return this._boneMatrices;
  }
  copyBindPose() {
    for (const bone of this.bones) {
      if (bone) {
        bone.copyBindPose();
      }
    }
    this._gpuDirty = true;
  }
  clone() {
    const bonesData = this.bones.map((bone) => ({
      name: bone.name,
      index: bone.index,
      parentIndex: bone.parent?.index ?? -1,
      localBindPose: {
        position: bone.bindPosition.clone(),
        rotation: bone.bindRotation.clone(),
        scale: bone.bindScale.clone()
      },
      inverseBindMatrix: bone.inverseBindMatrix.clone()
    }));
    const cloned = new Skeleton(bonesData);
    for (let i = 0;i < this.bones.length; i++) {
      const srcBone = this.bones[i];
      const dstBone = cloned.bones[i];
      if (srcBone && dstBone) {
        dstBone.position.copy(srcBone.position);
        dstBone.rotation.copy(srcBone.rotation);
        dstBone.scale.copy(srcBone.scale);
      }
    }
    return cloned;
  }
  traverse(callback) {
    const traverseRecursive = (bone) => {
      callback(bone);
      for (const child of bone.children) {
        traverseRecursive(child);
      }
    };
    for (const root of this.rootBones) {
      traverseRecursive(root);
    }
  }
  destroy() {
    this.boneMatricesBuffer?.destroy();
    this.boneMatricesBuffer = null;
    this.bindGroup = null;
    this._device = null;
  }
  toString() {
    return `Skeleton(${this.boneCount} bones, ${this.rootBones.length} roots)`;
  }
}
// ../../src/core/animation/AnimationTrack.ts
class AnimationTrack {
  targetBoneIndex;
  property;
  interpolation;
  keyframes;
  duration;
  constructor(targetBoneIndex, property, interpolation, times, values) {
    this.targetBoneIndex = targetBoneIndex;
    this.property = property;
    this.interpolation = interpolation;
    this.keyframes = [];
    const componentCount = property === "rotation" ? 4 : 3;
    const keyframeCount = times.length;
    const stride = interpolation === "CUBICSPLINE" ? componentCount * 3 : componentCount;
    for (let i = 0;i < keyframeCount; i++) {
      const time = times[i];
      const valueOffset = i * stride;
      let value;
      let inTangent;
      let outTangent;
      if (interpolation === "CUBICSPLINE") {
        const inOffset = valueOffset;
        const valOffset = valueOffset + componentCount;
        const outOffset = valueOffset + componentCount * 2;
        if (property === "rotation") {
          inTangent = new Quaternion(values[inOffset], values[inOffset + 1], values[inOffset + 2], values[inOffset + 3]);
          value = new Quaternion(values[valOffset], values[valOffset + 1], values[valOffset + 2], values[valOffset + 3]);
          outTangent = new Quaternion(values[outOffset], values[outOffset + 1], values[outOffset + 2], values[outOffset + 3]);
        } else {
          inTangent = new Vector3(values[inOffset], values[inOffset + 1], values[inOffset + 2]);
          value = new Vector3(values[valOffset], values[valOffset + 1], values[valOffset + 2]);
          outTangent = new Vector3(values[outOffset], values[outOffset + 1], values[outOffset + 2]);
        }
      } else {
        if (property === "rotation") {
          value = new Quaternion(values[valueOffset], values[valueOffset + 1], values[valueOffset + 2], values[valueOffset + 3]);
        } else {
          value = new Vector3(values[valueOffset], values[valueOffset + 1], values[valueOffset + 2]);
        }
      }
      this.keyframes.push({ time, value, inTangent, outTangent });
    }
    this.duration = keyframeCount > 0 ? this.keyframes[keyframeCount - 1].time : 0;
  }
  sample(time) {
    if (this.keyframes.length === 0) {
      return this.property === "rotation" ? Quaternion.identity : this.property === "scale" ? Vector3.one : Vector3.zero;
    }
    if (this.keyframes.length === 1) {
      return this.cloneValue(this.keyframes[0].value);
    }
    const firstKeyframe = this.keyframes[0];
    const lastKeyframe = this.keyframes[this.keyframes.length - 1];
    if (time <= firstKeyframe.time) {
      return this.cloneValue(firstKeyframe.value);
    }
    if (time >= lastKeyframe.time) {
      return this.cloneValue(lastKeyframe.value);
    }
    let prevKeyframe = firstKeyframe;
    let nextKeyframe = this.keyframes[1];
    for (let i = 1;i < this.keyframes.length; i++) {
      nextKeyframe = this.keyframes[i];
      if (nextKeyframe.time >= time) {
        prevKeyframe = this.keyframes[i - 1];
        break;
      }
    }
    const duration = nextKeyframe.time - prevKeyframe.time;
    const t = duration > 0 ? (time - prevKeyframe.time) / duration : 0;
    switch (this.interpolation) {
      case "STEP":
        return this.cloneValue(prevKeyframe.value);
      case "CUBICSPLINE":
        return this.cubicSplineInterpolate(prevKeyframe, nextKeyframe, t, duration);
      case "LINEAR":
      default:
        return this.linearInterpolate(prevKeyframe.value, nextKeyframe.value, t);
    }
  }
  linearInterpolate(a, b, t) {
    if (this.property === "rotation") {
      return a.clone().slerp(b, t);
    } else {
      const va = a;
      const vb = b;
      return new Vector3(va.x + (vb.x - va.x) * t, va.y + (vb.y - va.y) * t, va.z + (vb.z - va.z) * t);
    }
  }
  cubicSplineInterpolate(prev, next, t, duration) {
    const t2 = t * t;
    const t3 = t2 * t;
    const h00 = 2 * t3 - 3 * t2 + 1;
    const h10 = t3 - 2 * t2 + t;
    const h01 = -2 * t3 + 3 * t2;
    const h11 = t3 - t2;
    if (this.property === "rotation") {
      const p0 = prev.value;
      const m0 = prev.outTangent;
      const p1 = next.value;
      const m1 = next.inTangent;
      const scaledM0 = new Quaternion(m0.x * duration, m0.y * duration, m0.z * duration, m0.w * duration);
      const scaledM1 = new Quaternion(m1.x * duration, m1.y * duration, m1.z * duration, m1.w * duration);
      const result = new Quaternion(h00 * p0.x + h10 * scaledM0.x + h01 * p1.x + h11 * scaledM1.x, h00 * p0.y + h10 * scaledM0.y + h01 * p1.y + h11 * scaledM1.y, h00 * p0.z + h10 * scaledM0.z + h01 * p1.z + h11 * scaledM1.z, h00 * p0.w + h10 * scaledM0.w + h01 * p1.w + h11 * scaledM1.w);
      return result.normalize();
    } else {
      const p0 = prev.value;
      const m0 = prev.outTangent;
      const p1 = next.value;
      const m1 = next.inTangent;
      const scaledM0 = m0.multiply(duration);
      const scaledM1 = m1.multiply(duration);
      return new Vector3(h00 * p0.x + h10 * scaledM0.x + h01 * p1.x + h11 * scaledM1.x, h00 * p0.y + h10 * scaledM0.y + h01 * p1.y + h11 * scaledM1.y, h00 * p0.z + h10 * scaledM0.z + h01 * p1.z + h11 * scaledM1.z);
    }
  }
  cloneValue(value) {
    if (value instanceof Quaternion) {
      return value.clone();
    }
    return value.clone();
  }
  getStartValue() {
    return this.keyframes.length > 0 ? this.keyframes[0].value : null;
  }
  getEndValue() {
    return this.keyframes.length > 0 ? this.keyframes[this.keyframes.length - 1].value : null;
  }
  toString() {
    return `AnimationTrack(bone=${this.targetBoneIndex}, property=${this.property}, ` + `keyframes=${this.keyframes.length}, duration=${this.duration.toFixed(2)}s)`;
  }
}
// ../../src/core/animation/NodeAnimationTrack.ts
class NodeAnimationTrack {
  targetNode;
  property;
  interpolation;
  keyframes;
  duration;
  constructor(targetNode, property, interpolation, times, values) {
    this.targetNode = targetNode;
    this.property = property;
    this.interpolation = interpolation;
    this.keyframes = [];
    const componentCount = property === "rotation" ? 4 : 3;
    const keyframeCount = times.length;
    const stride = interpolation === "CUBICSPLINE" ? componentCount * 3 : componentCount;
    for (let i = 0;i < keyframeCount; i++) {
      const time = times[i];
      const valueOffset = i * stride;
      let value;
      let inTangent;
      let outTangent;
      if (interpolation === "CUBICSPLINE") {
        const inOffset = valueOffset;
        const valOffset = valueOffset + componentCount;
        const outOffset = valueOffset + componentCount * 2;
        if (property === "rotation") {
          inTangent = new Quaternion(values[inOffset], values[inOffset + 1], values[inOffset + 2], values[inOffset + 3]);
          value = new Quaternion(values[valOffset], values[valOffset + 1], values[valOffset + 2], values[valOffset + 3]);
          outTangent = new Quaternion(values[outOffset], values[outOffset + 1], values[outOffset + 2], values[outOffset + 3]);
        } else {
          inTangent = new Vector3(values[inOffset], values[inOffset + 1], values[inOffset + 2]);
          value = new Vector3(values[valOffset], values[valOffset + 1], values[valOffset + 2]);
          outTangent = new Vector3(values[outOffset], values[outOffset + 1], values[outOffset + 2]);
        }
      } else {
        if (property === "rotation") {
          value = new Quaternion(values[valueOffset], values[valueOffset + 1], values[valueOffset + 2], values[valueOffset + 3]);
        } else {
          value = new Vector3(values[valueOffset], values[valueOffset + 1], values[valueOffset + 2]);
        }
      }
      this.keyframes.push({ time, value, inTangent, outTangent });
    }
    this.duration = keyframeCount > 0 ? this.keyframes[keyframeCount - 1].time : 0;
  }
  sample(time) {
    if (this.keyframes.length === 0) {
      return this.property === "rotation" ? Quaternion.identity : Vector3.zero;
    }
    if (this.keyframes.length === 1) {
      return this.keyframes[0].value;
    }
    const first = this.keyframes[0];
    const last = this.keyframes[this.keyframes.length - 1];
    if (time <= first.time)
      return first.value;
    if (time >= last.time)
      return last.value;
    let prev = first;
    let next = this.keyframes[1];
    for (let i = 1;i < this.keyframes.length; i++) {
      next = this.keyframes[i];
      if (next.time >= time) {
        prev = this.keyframes[i - 1];
        break;
      }
    }
    const duration = next.time - prev.time;
    const t = duration > 0 ? (time - prev.time) / duration : 0;
    switch (this.interpolation) {
      case "STEP":
        return prev.value;
      case "CUBICSPLINE":
        return this.cubicSplineInterpolate(prev, next, t, duration);
      case "LINEAR":
      default:
        return this.linearInterpolate(prev.value, next.value, t);
    }
  }
  apply(time) {
    const value = this.sample(time);
    if (!this._debugLogged) {
      console.log(`NodeAnimationTrack.apply: "${this.targetNode.name}" ${this.property}`, value);
      this._debugLogged = true;
    }
    switch (this.property) {
      case "position":
        this.targetNode.transform.position = value;
        break;
      case "rotation":
        this.targetNode.transform.rotation = value;
        break;
      case "scale":
        this.targetNode.transform.scale = value;
        break;
    }
  }
  _debugLogged = false;
  linearInterpolate(a, b, t) {
    if (a instanceof Quaternion && b instanceof Quaternion) {
      return a.clone().slerp(b, t);
    }
    return a.clone().lerp(b, t);
  }
  cubicSplineInterpolate(prev, next, t, duration) {
    const t2 = t * t;
    const t3 = t2 * t;
    const h00 = 2 * t3 - 3 * t2 + 1;
    const h10 = t3 - 2 * t2 + t;
    const h01 = -2 * t3 + 3 * t2;
    const h11 = t3 - t2;
    if (prev.value instanceof Quaternion) {
      const p0 = prev.value;
      const m0 = prev.outTangent;
      const p1 = next.value;
      const m1 = next.inTangent;
      const m0s = new Quaternion(m0.x * duration, m0.y * duration, m0.z * duration, m0.w * duration);
      const m1s = new Quaternion(m1.x * duration, m1.y * duration, m1.z * duration, m1.w * duration);
      return new Quaternion(h00 * p0.x + h10 * m0s.x + h01 * p1.x + h11 * m1s.x, h00 * p0.y + h10 * m0s.y + h01 * p1.y + h11 * m1s.y, h00 * p0.z + h10 * m0s.z + h01 * p1.z + h11 * m1s.z, h00 * p0.w + h10 * m0s.w + h01 * p1.w + h11 * m1s.w).normalize();
    } else {
      const p0 = prev.value;
      const m0 = prev.outTangent;
      const p1 = next.value;
      const m1 = next.inTangent;
      const m0s = m0.clone().multiply(duration);
      const m1s = m1.clone().multiply(duration);
      return new Vector3(h00 * p0.x + h10 * m0s.x + h01 * p1.x + h11 * m1s.x, h00 * p0.y + h10 * m0s.y + h01 * p1.y + h11 * m1s.y, h00 * p0.z + h10 * m0s.z + h01 * p1.z + h11 * m1s.z);
    }
  }
}
// ../../src/core/animation/AnimationClip.ts
class AnimationClip {
  name;
  duration = 0;
  tracks = [];
  nodeAnimationTracks = [];
  morphWeightsTracks = [];
  _trackMap = new Map;
  constructor(name12 = "animation") {
    this.name = name12;
  }
  addTrack(track) {
    this.tracks.push(track);
    if (track.duration > this.duration) {
      this.duration = track.duration;
    }
    const key = this._getTrackKey(track.targetBoneIndex, track.property);
    this._trackMap.set(key, track);
  }
  addMorphWeightsTrack(track) {
    this.morphWeightsTracks.push(track);
    if (track.duration > this.duration) {
      this.duration = track.duration;
    }
  }
  addNodeAnimationTrack(track) {
    this.nodeAnimationTracks.push(track);
    if (track.duration > this.duration) {
      this.duration = track.duration;
    }
  }
  getTrack(boneIndex, property) {
    const key = this._getTrackKey(boneIndex, property);
    return this._trackMap.get(key) ?? null;
  }
  apply(skeleton, time, weight = 1) {
    if (weight <= 0)
      return;
    if (skeleton) {
      for (const track of this.tracks) {
        const bone = skeleton.bones[track.targetBoneIndex];
        if (!bone)
          continue;
        const value = track.sample(time);
        if (weight >= 1) {
          this._applyValue(bone, track.property, value);
        } else {
          this._blendValue(bone, track.property, value, weight);
        }
      }
    }
    for (const morphTrack of this.morphWeightsTracks) {
      const weights = morphTrack.sample(time);
      if (weight >= 1) {
        morphTrack.targetMesh.setMorphWeights(weights);
      } else {
        const currentWeights = morphTrack.targetMesh.morphTargets.weights;
        const blendedWeights = new Float32Array(weights.length);
        for (let i = 0;i < weights.length; i++) {
          blendedWeights[i] = currentWeights[i] + (weights[i] - currentWeights[i]) * weight;
        }
        morphTrack.targetMesh.setMorphWeights(blendedWeights);
      }
    }
    for (const nodeTrack of this.nodeAnimationTracks) {
      nodeTrack.apply(time);
    }
  }
  _applyValue(bone, property, value) {
    switch (property) {
      case "position":
        bone.position.copy(value);
        break;
      case "rotation":
        bone.rotation.copy(value);
        break;
      case "scale":
        bone.scale.copy(value);
        break;
    }
  }
  _blendValue(bone, property, value, weight) {
    switch (property) {
      case "position": {
        const v = value;
        bone.position.set(bone.position.x + (v.x - bone.position.x) * weight, bone.position.y + (v.y - bone.position.y) * weight, bone.position.z + (v.z - bone.position.z) * weight);
        break;
      }
      case "rotation": {
        const q = value;
        const blended = bone.rotation.slerp(q, weight);
        bone.rotation.copy(blended);
        break;
      }
      case "scale": {
        const s = value;
        bone.scale.set(bone.scale.x + (s.x - bone.scale.x) * weight, bone.scale.y + (s.y - bone.scale.y) * weight, bone.scale.z + (s.z - bone.scale.z) * weight);
        break;
      }
    }
  }
  _getTrackKey(boneIndex, property) {
    return `${boneIndex}:${property}`;
  }
  getAnimatedBoneIndices() {
    const indices = new Set;
    for (const track of this.tracks) {
      indices.add(track.targetBoneIndex);
    }
    return Array.from(indices);
  }
  animatesBone(boneIndex) {
    return this.tracks.some((t) => t.targetBoneIndex === boneIndex);
  }
  hasMorphTargetAnimations() {
    return this.morphWeightsTracks.length > 0;
  }
  hasNodeAnimations() {
    return this.nodeAnimationTracks.length > 0;
  }
  clone() {
    const cloned = new AnimationClip(this.name);
    cloned.duration = this.duration;
    for (const track of this.tracks) {
      cloned.addTrack(track);
    }
    for (const morphTrack of this.morphWeightsTracks) {
      cloned.addMorphWeightsTrack(morphTrack);
    }
    for (const nodeTrack of this.nodeAnimationTracks) {
      cloned.addNodeAnimationTrack(nodeTrack);
    }
    return cloned;
  }
  trim(startTime, endTime) {
    const cloned = this.clone();
    cloned.duration = Math.min(cloned.duration, endTime - startTime);
    return cloned;
  }
  getStats() {
    let keyframeCount = 0;
    const boneIndices = new Set;
    for (const track of this.tracks) {
      keyframeCount += track.keyframes.length;
      boneIndices.add(track.targetBoneIndex);
    }
    let nodeKeyframeCount = 0;
    for (const nodeTrack of this.nodeAnimationTracks) {
      nodeKeyframeCount += nodeTrack.keyframes.length;
    }
    let morphKeyframeCount = 0;
    for (const morphTrack of this.morphWeightsTracks) {
      morphKeyframeCount += morphTrack.keyframes.length;
    }
    return {
      trackCount: this.tracks.length,
      boneCount: boneIndices.size,
      keyframeCount,
      nodeTrackCount: this.nodeAnimationTracks.length,
      nodeKeyframeCount,
      morphTrackCount: this.morphWeightsTracks.length,
      morphKeyframeCount,
      duration: this.duration
    };
  }
  toString() {
    const stats = this.getStats();
    let str = `AnimationClip("${this.name}", duration=${this.duration.toFixed(2)}s, ` + `boneTracks=${stats.trackCount}, bones=${stats.boneCount}`;
    if (stats.nodeTrackCount > 0) {
      str += `, nodeTracks=${stats.nodeTrackCount}`;
    }
    if (stats.morphTrackCount > 0) {
      str += `, morphTracks=${stats.morphTrackCount}`;
    }
    str += ")";
    return str;
  }
}
// ../../src/core/animation/AnimationAction.ts
class AnimationAction {
  clip;
  mixer;
  _time = 0;
  _timeScale = 1;
  _weight = 1;
  _effectiveWeight = 1;
  _loop = "repeat";
  _paused = false;
  _enabled = true;
  _clampWhenFinished = false;
  _direction = 1;
  _fadeStartTime = 0;
  _fadeDuration = 0;
  _fadeStartWeight = 0;
  _fadeTargetWeight = 0;
  _isFading = false;
  _repetitions = Infinity;
  _currentRepetition = 0;
  constructor(mixer, clip) {
    this.mixer = mixer;
    this.clip = clip;
  }
  get time() {
    return this._time;
  }
  set time(value) {
    this._time = value;
  }
  get timeScale() {
    return this._timeScale;
  }
  set timeScale(value) {
    this._timeScale = value;
  }
  get weight() {
    return this._weight;
  }
  set weight(value) {
    this._weight = Math.max(0, Math.min(1, value));
  }
  get effectiveWeight() {
    return this._effectiveWeight;
  }
  get loop() {
    return this._loop;
  }
  set loop(value) {
    this._loop = value;
  }
  get paused() {
    return this._paused;
  }
  set paused(value) {
    this._paused = value;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get clampWhenFinished() {
    return this._clampWhenFinished;
  }
  set clampWhenFinished(value) {
    this._clampWhenFinished = value;
  }
  get repetitions() {
    return this._repetitions;
  }
  set repetitions(value) {
    this._repetitions = value;
  }
  isRunning() {
    return this._enabled && !this._paused && this._effectiveWeight > 0;
  }
  isScheduled() {
    return this._enabled;
  }
  play() {
    this._enabled = true;
    this._paused = false;
    this.mixer._addAction(this);
    return this;
  }
  stop() {
    this._enabled = false;
    this._time = 0;
    this._currentRepetition = 0;
    this._direction = 1;
    this._isFading = false;
    return this;
  }
  reset() {
    this._time = 0;
    this._currentRepetition = 0;
    this._direction = 1;
    this._paused = false;
    this._enabled = true;
    this._isFading = false;
    this._effectiveWeight = this._weight;
    return this;
  }
  halt() {
    this._paused = true;
    return this;
  }
  fadeIn(duration) {
    return this._fade(0, this._weight, duration);
  }
  fadeOut(duration) {
    return this._fade(this._effectiveWeight, 0, duration);
  }
  crossFadeTo(otherAction, duration, warp = false) {
    this.fadeOut(duration);
    otherAction.fadeIn(duration);
    otherAction.play();
    return this;
  }
  syncWith(otherAction) {
    this._time = otherAction._time;
    return this;
  }
  _fade(startWeight, endWeight, duration) {
    this._fadeStartTime = 0;
    this._fadeDuration = duration;
    this._fadeStartWeight = startWeight;
    this._fadeTargetWeight = endWeight;
    this._isFading = true;
    this._effectiveWeight = startWeight;
    return this;
  }
  _update(deltaTime, mixerTime) {
    if (!this._enabled || this._paused) {
      return false;
    }
    let finished = false;
    if (this._isFading) {
      this._fadeStartTime += deltaTime;
      const fadeProgress = this._fadeDuration > 0 ? Math.min(1, this._fadeStartTime / this._fadeDuration) : 1;
      this._effectiveWeight = this._fadeStartWeight + (this._fadeTargetWeight - this._fadeStartWeight) * fadeProgress;
      if (fadeProgress >= 1) {
        this._isFading = false;
        this._weight = this._fadeTargetWeight;
        this._effectiveWeight = this._fadeTargetWeight;
        if (this._fadeTargetWeight <= 0) {
          this._enabled = false;
        }
      }
    } else {
      this._effectiveWeight = this._weight;
    }
    const scaledDelta = deltaTime * this._timeScale * this._direction;
    this._time += scaledDelta;
    const duration = this.clip.duration;
    if (duration > 0) {
      switch (this._loop) {
        case "once":
          if (this._time >= duration) {
            this._time = this._clampWhenFinished ? duration : 0;
            this._enabled = this._clampWhenFinished;
            finished = true;
          } else if (this._time < 0) {
            this._time = 0;
            finished = true;
          }
          break;
        case "repeat":
          while (this._time >= duration) {
            this._time -= duration;
            this._currentRepetition++;
            if (this._currentRepetition >= this._repetitions) {
              this._time = this._clampWhenFinished ? duration : 0;
              this._enabled = this._clampWhenFinished;
              finished = true;
              break;
            }
          }
          while (this._time < 0) {
            this._time += duration;
          }
          break;
        case "pingpong":
          while (this._time >= duration || this._time < 0) {
            if (this._time >= duration) {
              this._time = 2 * duration - this._time;
              this._direction = -1;
              this._currentRepetition++;
            } else if (this._time < 0) {
              this._time = -this._time;
              this._direction = 1;
              this._currentRepetition++;
            }
            if (this._currentRepetition >= this._repetitions * 2) {
              this._time = this._clampWhenFinished ? this._direction > 0 ? 0 : duration : 0;
              this._enabled = this._clampWhenFinished;
              finished = true;
              break;
            }
          }
          break;
      }
    }
    return finished;
  }
  _apply() {
    if (!this._enabled || this._effectiveWeight <= 0) {
      return;
    }
    this.clip.apply(this.mixer.skeleton, this._time, this._effectiveWeight);
  }
  toString() {
    return `AnimationAction("${this.clip.name}", time=${this._time.toFixed(2)}, ` + `weight=${this._effectiveWeight.toFixed(2)}, enabled=${this._enabled})`;
  }
}
// ../../src/core/animation/AnimationMixer.ts
class AnimationMixer {
  skeleton;
  _actions = [];
  _actionsByClip = new Map;
  _time = 0;
  _listeners = new Map;
  _device = null;
  constructor(skeleton) {
    this.skeleton = skeleton;
  }
  setDevice(device) {
    this._device = device;
    this.skeleton.initGPU(device);
  }
  clipAction(clip) {
    let action = this._actionsByClip.get(clip);
    if (!action) {
      action = new AnimationAction(this, clip);
      this._actionsByClip.set(clip, action);
    }
    return action;
  }
  existingAction(clip) {
    return this._actionsByClip.get(clip) ?? null;
  }
  get actions() {
    return this._actions.slice();
  }
  get time() {
    return this._time;
  }
  update(deltaTime) {
    this._time += deltaTime;
    this.skeleton.copyBindPose();
    let totalWeight = 0;
    for (const action of this._actions) {
      if (action.enabled && action.effectiveWeight > 0) {
        totalWeight += action.effectiveWeight;
      }
    }
    const finishedActions = [];
    for (const action of this._actions) {
      if (!action.enabled)
        continue;
      const finished = action._update(deltaTime, this._time);
      if (action.effectiveWeight > 0) {
        const normalizedWeight = totalWeight > 1 ? action.effectiveWeight / totalWeight : action.effectiveWeight;
        const originalWeight = action.effectiveWeight;
        action._effectiveWeight = normalizedWeight;
        action._apply();
        action._effectiveWeight = originalWeight;
      }
      if (finished) {
        finishedActions.push(action);
      }
    }
    this.skeleton.update();
    if (this._device) {
      this.skeleton.uploadToGPU(this._device);
    }
    for (const action of finishedActions) {
      this._dispatchEvent({
        type: "finished",
        action,
        direction: 1
      });
    }
  }
  stopAllAction() {
    for (const action of this._actions) {
      action.stop();
    }
    this._actions.length = 0;
  }
  setTimeScaleForAll(scale2) {
    for (const action of this._actions) {
      action.timeScale = scale2;
    }
  }
  getActionByName(name12) {
    for (const [clip, action] of this._actionsByClip) {
      if (clip.name === name12) {
        return action;
      }
    }
    return null;
  }
  addEventListener(type, callback) {
    let listeners = this._listeners.get(type);
    if (!listeners) {
      listeners = [];
      this._listeners.set(type, listeners);
    }
    listeners.push(callback);
  }
  removeEventListener(type, callback) {
    const listeners = this._listeners.get(type);
    if (listeners) {
      const index = listeners.indexOf(callback);
      if (index !== -1) {
        listeners.splice(index, 1);
      }
    }
  }
  isPlaying() {
    return this._actions.some((action) => action.isRunning());
  }
  get activeActionCount() {
    return this._actions.filter((action) => action.isRunning()).length;
  }
  _addAction(action) {
    if (!this._actions.includes(action)) {
      this._actions.push(action);
    }
  }
  _removeAction(action) {
    const index = this._actions.indexOf(action);
    if (index !== -1) {
      this._actions.splice(index, 1);
    }
  }
  _dispatchEvent(event) {
    const listeners = this._listeners.get(event.type);
    if (listeners) {
      for (const callback of listeners) {
        callback(event);
      }
    }
  }
  dispose() {
    this.stopAllAction();
    this._actionsByClip.clear();
    this._listeners.clear();
    this._device = null;
  }
  toString() {
    return `AnimationMixer(skeleton=${this.skeleton.boneCount} bones, ` + `actions=${this._actions.length}, active=${this.activeActionCount})`;
  }
}
// ../../src/core/animation/SkinnedMesh.ts
class SkinnedMesh extends Mesh {
  skeleton = null;
  bindMatrix = new Matrix4;
  bindMatrixInverse = new Matrix4;
  isSkinned = true;
  jointsBuffer = null;
  weightsBuffer = null;
  constructor(geometry, material, skeleton) {
    super(geometry, material);
    this.name = "SkinnedMesh";
    if (skeleton) {
      this.bind(skeleton);
    }
  }
  bind(skeleton, bindMatrix) {
    this.skeleton = skeleton;
    if (bindMatrix) {
      this.bindMatrix.copy(bindMatrix);
    } else {
      this.bindMatrix.identity();
    }
    this.bindMatrixInverse.copy(this.bindMatrix).inverse();
  }
  initSkinningBuffers(device) {
    const jointsData = this.geometry.attributes["joints"];
    if (jointsData && !this.jointsBuffer) {
      const jointsUint = new Uint32Array(jointsData.length);
      for (let i = 0;i < jointsData.length; i++) {
        jointsUint[i] = Math.floor(jointsData[i]);
      }
      this.jointsBuffer = device.createBuffer({
        label: "SkinnedMesh Joints Buffer",
        size: jointsUint.byteLength,
        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
        mappedAtCreation: true
      });
      new Uint32Array(this.jointsBuffer.getMappedRange()).set(jointsUint);
      this.jointsBuffer.unmap();
    }
    const weightsData = this.geometry.attributes["weights"];
    if (weightsData && !this.weightsBuffer) {
      this.weightsBuffer = device.createBuffer({
        label: "SkinnedMesh Weights Buffer",
        size: weightsData.byteLength,
        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
        mappedAtCreation: true
      });
      new Float32Array(this.weightsBuffer.getMappedRange()).set(weightsData);
      this.weightsBuffer.unmap();
    }
    if (this.skeleton) {
      this.skeleton.initGPU(device);
    }
  }
  hasSkinningData() {
    return !!(this.geometry.attributes["joints"] && this.geometry.attributes["weights"] && this.skeleton);
  }
  get skinnedVertexCount() {
    const joints = this.geometry.attributes["joints"];
    return joints ? joints.length / 4 : 0;
  }
  prepareSkinning(device) {
    if (!this.skeleton)
      return;
    if (!this.jointsBuffer || !this.weightsBuffer) {
      this.initSkinningBuffers(device);
    }
    this.skeleton.uploadToGPU(device);
  }
  normalizeWeights() {
    const weights = this.geometry.attributes["weights"];
    if (!weights)
      return;
    const vertexCount = weights.length / 4;
    for (let i = 0;i < vertexCount; i++) {
      const offset = i * 4;
      const w0 = weights[offset];
      const w1 = weights[offset + 1];
      const w2 = weights[offset + 2];
      const w3 = weights[offset + 3];
      const sum = w0 + w1 + w2 + w3;
      if (sum > 0 && Math.abs(sum - 1) > 0.001) {
        const invSum = 1 / sum;
        weights[offset] = w0 * invSum;
        weights[offset + 1] = w1 * invSum;
        weights[offset + 2] = w2 * invSum;
        weights[offset + 3] = w3 * invSum;
      }
    }
    this.geometry.markBuffersDirty();
    if (this.weightsBuffer) {
      this.weightsBuffer.destroy();
      this.weightsBuffer = null;
    }
  }
  clone() {
    const cloned = new SkinnedMesh(this.geometry, this.material, this.skeleton?.clone());
    cloned.transform.position.copy(this.transform.position);
    cloned.transform.rotation.copy(this.transform.rotation);
    cloned.transform.scale.copy(this.transform.scale);
    cloned.bindMatrix.copy(this.bindMatrix);
    cloned.bindMatrixInverse.copy(this.bindMatrixInverse);
    return cloned;
  }
  destroy() {
    this.jointsBuffer?.destroy();
    this.weightsBuffer?.destroy();
    this.jointsBuffer = null;
    this.weightsBuffer = null;
  }
  toString() {
    return `SkinnedMesh("${this.name}", vertices=${this.geometry.vertexCount}, ` + `skeleton=${this.skeleton?.boneCount ?? 0} bones)`;
  }
}
// ../../src/core/animation/skinning/SkinningShader.ts
var SKINNING_UNIFORMS = `
// Bone matrices storage buffer (bind group 2)
@group(2) @binding(0) var<storage, read> boneMatrices: array<mat4x4<f32>, ${MAX_BONES}>;
`;
var SKINNING_RESULT = `
struct SkinningResult {
  position: vec3<f32>,
  normal: vec3<f32>,
}
`;
var APPLY_SKINNING_FUNCTION = `
fn applySkinning(
  position: vec3<f32>,
  normal: vec3<f32>,
  joints: vec4<u32>,
  weights: vec4<f32>
) -> SkinningResult {
  var skinnedPosition = vec3<f32>(0.0);
  var skinnedNormal = vec3<f32>(0.0);

  // Apply up to 4 bone influences
  // Unrolled for performance
  let bone0 = boneMatrices[joints.x];
  let bone1 = boneMatrices[joints.y];
  let bone2 = boneMatrices[joints.z];
  let bone3 = boneMatrices[joints.w];

  let w0 = weights.x;
  let w1 = weights.y;
  let w2 = weights.z;
  let w3 = weights.w;

  // Position skinning
  skinnedPosition += w0 * (bone0 * vec4<f32>(position, 1.0)).xyz;
  skinnedPosition += w1 * (bone1 * vec4<f32>(position, 1.0)).xyz;
  skinnedPosition += w2 * (bone2 * vec4<f32>(position, 1.0)).xyz;
  skinnedPosition += w3 * (bone3 * vec4<f32>(position, 1.0)).xyz;

  // Normal skinning (using 3x3 rotation part of matrix)
  // For uniform scale, this is correct. For non-uniform scale, we'd need inverse transpose.
  skinnedNormal += w0 * (bone0 * vec4<f32>(normal, 0.0)).xyz;
  skinnedNormal += w1 * (bone1 * vec4<f32>(normal, 0.0)).xyz;
  skinnedNormal += w2 * (bone2 * vec4<f32>(normal, 0.0)).xyz;
  skinnedNormal += w3 * (bone3 * vec4<f32>(normal, 0.0)).xyz;

  return SkinningResult(skinnedPosition, normalize(skinnedNormal));
}
`;
function getSkinningShaderHeader() {
  return `
${SKINNING_UNIFORMS}
${SKINNING_RESULT}
${APPLY_SKINNING_FUNCTION}
`;
}
function createSkinnedVertexShader(standardVertexShader) {
  let modifiedShader = standardVertexShader;
  const skinningHeader = getSkinningShaderHeader();
  const vertexInputRegex = /struct VertexInput \{[^}]+\}/;
  const skinnedVertexInput = `struct VertexInput {
  @location(0) position: vec3<f32>,
  @location(1) normal: vec3<f32>,
  @location(2) uv: vec2<f32>,
  @location(3) joints: vec4<u32>,
  @location(4) weights: vec4<f32>,
}`;
  const vertexInputMatch = modifiedShader.match(vertexInputRegex);
  console.log("SkinningShader: VertexInput match:", vertexInputMatch ? "found" : "NOT FOUND");
  modifiedShader = modifiedShader.replace(vertexInputRegex, skinnedVertexInput);
  const vsMainIndex = modifiedShader.indexOf("@vertex");
  console.log("SkinningShader: @vertex found at index:", vsMainIndex);
  if (vsMainIndex > -1) {
    modifiedShader = modifiedShader.slice(0, vsMainIndex) + skinningHeader + `
` + modifiedShader.slice(vsMainIndex);
  }
  const worldPosPattern = /let worldPos = modelMatrix \* vec4<f32>\(input\.position, 1\.0\);/g;
  const worldPosMatch = modifiedShader.match(worldPosPattern);
  console.log("SkinningShader: worldPos (input.position) pattern match:", worldPosMatch ? "found" : "NOT FOUND");
  let skinnedDefined = false;
  if (worldPosMatch) {
    modifiedShader = modifiedShader.replace(worldPosPattern, `let skinned = applySkinning(input.position, input.normal, input.joints, input.weights);
        let worldPos = modelMatrix * vec4<f32>(skinned.position, 1.0);`);
    skinnedDefined = true;
  }
  const localPosPattern = /let worldPos = modelMatrix \* vec4<f32>\(localPos, 1\.0\);/g;
  const localPosMatch = modifiedShader.match(localPosPattern);
  console.log("SkinningShader: worldPos (localPos) pattern match:", localPosMatch ? "found" : "NOT FOUND");
  if (localPosMatch) {
    modifiedShader = modifiedShader.replace(/var localPos = input\.position;/g, `let skinned = applySkinning(input.position, input.normal, input.joints, input.weights);
        var localPos = skinned.position;`);
    skinnedDefined = true;
  }
  const normalPattern = /output\.worldNormal = \(normalMatrix \* vec4<f32>\(input\.normal, 0\.0\)\)\.xyz;/g;
  const normalMatch = modifiedShader.match(normalPattern);
  console.log("SkinningShader: normal pattern match:", normalMatch ? "found" : "NOT FOUND");
  if (skinnedDefined) {
    modifiedShader = modifiedShader.replace(normalPattern, "output.worldNormal = (normalMatrix * vec4<f32>(skinned.normal, 0.0)).xyz;");
  }
  if (skinnedDefined) {
    const prevWorldPosPattern = /let prevWorldPos = prevModelMatrix \* vec4<f32>\(input\.position, 1\.0\);/g;
    modifiedShader = modifiedShader.replace(prevWorldPosPattern, "let prevWorldPos = prevModelMatrix * vec4<f32>(skinned.position, 1.0);");
  }
  return modifiedShader;
}
// ../../src/core/animation/MorphTarget.ts
var MAX_MORPH_TARGETS = 8;
class MorphTargets {
  targets = [];
  weights;
  vertexCount;
  deltasBuffer = null;
  weightsBuffer = null;
  bindGroup = null;
  weightsDirty = true;
  constructor(vertexCount) {
    this.vertexCount = vertexCount;
    this.weights = new Float32Array(MAX_MORPH_TARGETS);
  }
  addTarget(target) {
    if (this.targets.length >= MAX_MORPH_TARGETS) {
      console.warn(`MorphTargets: Maximum of ${MAX_MORPH_TARGETS} morph targets exceeded. Ignoring target "${target.name}".`);
      return;
    }
    const targetVertexCount = target.positionDeltas.length / 3;
    if (targetVertexCount !== this.vertexCount) {
      console.warn(`MorphTargets: Target "${target.name}" has ${targetVertexCount} vertices, expected ${this.vertexCount}`);
    }
    target.index = this.targets.length;
    this.targets.push(target);
  }
  getTarget(name12) {
    return this.targets.find((t) => t.name === name12) ?? null;
  }
  getTargetByIndex(index) {
    return this.targets[index] ?? null;
  }
  setWeight(name12, weight) {
    const target = this.getTarget(name12);
    if (target) {
      this.setWeightByIndex(target.index, weight);
    }
  }
  setWeightByIndex(index, weight) {
    if (index >= 0 && index < MAX_MORPH_TARGETS) {
      const clampedWeight = Math.max(0, Math.min(1, weight));
      if (this.weights[index] !== clampedWeight) {
        this.weights[index] = clampedWeight;
        this.weightsDirty = true;
      }
    }
  }
  setWeights(weights) {
    for (let i = 0;i < Math.min(weights.length, MAX_MORPH_TARGETS); i++) {
      this.weights[i] = Math.max(0, Math.min(1, weights[i]));
    }
    this.weightsDirty = true;
  }
  getWeight(index) {
    return this.weights[index] ?? 0;
  }
  resetWeights() {
    this.weights.fill(0);
    this.weightsDirty = true;
  }
  get targetCount() {
    return this.targets.length;
  }
  get isActive() {
    for (let i = 0;i < this.targets.length; i++) {
      if (this.weights[i] > 0.001) {
        return true;
      }
    }
    return false;
  }
  initGPU(device) {
    if (this.targets.length === 0)
      return;
    const deltasPerTarget = this.vertexCount * 6;
    const totalFloats = MAX_MORPH_TARGETS * deltasPerTarget;
    const deltasData = new Float32Array(totalFloats);
    for (let t = 0;t < this.targets.length; t++) {
      const target = this.targets[t];
      const targetOffset = t * deltasPerTarget;
      for (let v = 0;v < this.vertexCount; v++) {
        const srcPosOffset = v * 3;
        const dstOffset = targetOffset + v * 6;
        deltasData[dstOffset + 0] = target.positionDeltas[srcPosOffset + 0];
        deltasData[dstOffset + 1] = target.positionDeltas[srcPosOffset + 1];
        deltasData[dstOffset + 2] = target.positionDeltas[srcPosOffset + 2];
        if (target.normalDeltas) {
          deltasData[dstOffset + 3] = target.normalDeltas[srcPosOffset + 0];
          deltasData[dstOffset + 4] = target.normalDeltas[srcPosOffset + 1];
          deltasData[dstOffset + 5] = target.normalDeltas[srcPosOffset + 2];
        }
      }
    }
    this.deltasBuffer = device.createBuffer({
      label: "MorphTarget Deltas Buffer",
      size: deltasData.byteLength,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
      mappedAtCreation: true
    });
    new Float32Array(this.deltasBuffer.getMappedRange()).set(deltasData);
    this.deltasBuffer.unmap();
    const weightsBufferSize = Math.ceil(MAX_MORPH_TARGETS / 4) * 16;
    this.weightsBuffer = device.createBuffer({
      label: "MorphTarget Weights Buffer",
      size: weightsBufferSize,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.uploadWeights(device);
  }
  uploadWeights(device) {
    if (!this.weightsBuffer || !this.weightsDirty)
      return;
    const paddedWeights = new Float32Array(Math.ceil(MAX_MORPH_TARGETS / 4) * 4);
    paddedWeights.set(this.weights);
    device.queue.writeBuffer(this.weightsBuffer, 0, paddedWeights);
    this.weightsDirty = false;
  }
  static createBindGroupLayout(device) {
    return device.createBindGroupLayout({
      label: "MorphTarget BindGroup Layout",
      entries: [
        {
          binding: 0,
          visibility: GPUShaderStage.VERTEX,
          buffer: { type: "read-only-storage" }
        },
        {
          binding: 1,
          visibility: GPUShaderStage.VERTEX,
          buffer: { type: "uniform" }
        }
      ]
    });
  }
  createBindGroup(device, layout) {
    if (!this.deltasBuffer || !this.weightsBuffer) {
      console.warn("MorphTargets: Cannot create bind group - buffers not initialized");
      return;
    }
    this.bindGroup = device.createBindGroup({
      label: "MorphTarget BindGroup",
      layout,
      entries: [
        { binding: 0, resource: { buffer: this.deltasBuffer } },
        { binding: 1, resource: { buffer: this.weightsBuffer } }
      ]
    });
  }
  prepare(device) {
    if (this.weightsDirty && this.weightsBuffer) {
      this.uploadWeights(device);
    }
  }
  destroy() {
    this.deltasBuffer?.destroy();
    this.weightsBuffer?.destroy();
    this.deltasBuffer = null;
    this.weightsBuffer = null;
    this.bindGroup = null;
  }
  clone() {
    const cloned = new MorphTargets(this.vertexCount);
    for (const target of this.targets) {
      cloned.targets.push(target);
    }
    cloned.weights.set(this.weights);
    cloned.weightsDirty = true;
    return cloned;
  }
  toString() {
    const activeTargets = this.targets.filter((_, i) => this.weights[i] > 0.001);
    return `MorphTargets(${this.targets.length} targets, ${activeTargets.length} active)`;
  }
}
// ../../src/core/animation/MorphTargetMesh.ts
class MorphTargetMesh extends Mesh {
  morphTargets;
  hasMorphTargets = true;
  morphGPUInitialized = false;
  constructor(geometry, material, morphTargets) {
    super(geometry, material);
    this.name = "MorphTargetMesh";
    if (morphTargets) {
      this.morphTargets = morphTargets;
    } else {
      this.morphTargets = new MorphTargets(geometry.vertexCount);
    }
  }
  addMorphTarget(target) {
    this.morphTargets.addTarget(target);
    this.morphGPUInitialized = false;
  }
  setMorphWeight(name12, weight) {
    this.morphTargets.setWeight(name12, weight);
  }
  setMorphWeightByIndex(index, weight) {
    this.morphTargets.setWeightByIndex(index, weight);
  }
  setMorphWeights(weights) {
    this.morphTargets.setWeights(weights);
  }
  getMorphWeight(index) {
    return this.morphTargets.getWeight(index);
  }
  resetMorphWeights() {
    this.morphTargets.resetWeights();
  }
  get morphTargetCount() {
    return this.morphTargets.targetCount;
  }
  get morphTargetNames() {
    return this.morphTargets.targets.map((t) => t.name);
  }
  get isMorphActive() {
    return this.morphTargets.isActive;
  }
  initMorphGPU(device) {
    if (this.morphGPUInitialized)
      return;
    this.morphTargets.initGPU(device);
    this.morphGPUInitialized = true;
    console.log(`MorphTargetMesh: Initialized GPU for "${this.name}" with ${this.morphTargets.targetCount} targets`);
  }
  createMorphBindGroup(device, layout) {
    if (!this.morphGPUInitialized) {
      this.initMorphGPU(device);
    }
    this.morphTargets.createBindGroup(device, layout);
  }
  prepareMorph(device) {
    if (!this.morphGPUInitialized) {
      this.initMorphGPU(device);
    }
    this.morphTargets.prepare(device);
  }
  clone() {
    const cloned = new MorphTargetMesh(this.geometry, this.material, this.morphTargets.clone());
    cloned.transform.position.copy(this.transform.position);
    cloned.transform.rotation.copy(this.transform.rotation);
    cloned.transform.scale.copy(this.transform.scale);
    return cloned;
  }
  destroy() {
    this.morphTargets.destroy();
  }
  toString() {
    return `MorphTargetMesh("${this.name}", vertices=${this.geometry.vertexCount}, ` + `morphTargets=${this.morphTargets.targetCount})`;
  }
}
// ../../src/core/animation/MorphWeightsTrack.ts
class MorphWeightsTrack {
  targetMesh;
  targetCount;
  interpolation;
  keyframes;
  duration;
  constructor(targetMesh, targetCount, interpolation, times, values) {
    this.targetMesh = targetMesh;
    this.targetCount = targetCount;
    this.interpolation = interpolation;
    this.keyframes = [];
    const keyframeCount = times.length;
    const stride = interpolation === "CUBICSPLINE" ? targetCount * 3 : targetCount;
    for (let i = 0;i < keyframeCount; i++) {
      const time = times[i];
      const valueOffset = i * stride;
      const weights = new Float32Array(targetCount);
      let inTangents;
      let outTangents;
      if (interpolation === "CUBICSPLINE") {
        const inOffset = valueOffset;
        const valOffset = valueOffset + targetCount;
        const outOffset = valueOffset + targetCount * 2;
        inTangents = new Float32Array(targetCount);
        outTangents = new Float32Array(targetCount);
        for (let j = 0;j < targetCount; j++) {
          inTangents[j] = values[inOffset + j];
          weights[j] = values[valOffset + j];
          outTangents[j] = values[outOffset + j];
        }
      } else {
        for (let j = 0;j < targetCount; j++) {
          weights[j] = values[valueOffset + j];
        }
      }
      this.keyframes.push({ time, weights, inTangents, outTangents });
    }
    this.duration = keyframeCount > 0 ? this.keyframes[keyframeCount - 1].time : 0;
  }
  sample(time) {
    if (this.keyframes.length === 0) {
      return new Float32Array(this.targetCount);
    }
    if (this.keyframes.length === 1) {
      return new Float32Array(this.keyframes[0].weights);
    }
    const firstKeyframe = this.keyframes[0];
    const lastKeyframe = this.keyframes[this.keyframes.length - 1];
    if (time <= firstKeyframe.time) {
      return new Float32Array(firstKeyframe.weights);
    }
    if (time >= lastKeyframe.time) {
      return new Float32Array(lastKeyframe.weights);
    }
    let prevKeyframe = firstKeyframe;
    let nextKeyframe = this.keyframes[1];
    for (let i = 1;i < this.keyframes.length; i++) {
      nextKeyframe = this.keyframes[i];
      if (nextKeyframe.time >= time) {
        prevKeyframe = this.keyframes[i - 1];
        break;
      }
    }
    const duration = nextKeyframe.time - prevKeyframe.time;
    const t = duration > 0 ? (time - prevKeyframe.time) / duration : 0;
    switch (this.interpolation) {
      case "STEP":
        return new Float32Array(prevKeyframe.weights);
      case "CUBICSPLINE":
        return this.cubicSplineInterpolate(prevKeyframe, nextKeyframe, t, duration);
      case "LINEAR":
      default:
        return this.linearInterpolate(prevKeyframe.weights, nextKeyframe.weights, t);
    }
  }
  apply(time) {
    const weights = this.sample(time);
    this.targetMesh.setMorphWeights(weights);
  }
  linearInterpolate(a, b, t) {
    const result = new Float32Array(this.targetCount);
    for (let i = 0;i < this.targetCount; i++) {
      result[i] = a[i] + (b[i] - a[i]) * t;
    }
    return result;
  }
  cubicSplineInterpolate(prev, next, t, duration) {
    const t2 = t * t;
    const t3 = t2 * t;
    const h00 = 2 * t3 - 3 * t2 + 1;
    const h10 = t3 - 2 * t2 + t;
    const h01 = -2 * t3 + 3 * t2;
    const h11 = t3 - t2;
    const result = new Float32Array(this.targetCount);
    for (let i = 0;i < this.targetCount; i++) {
      const p0 = prev.weights[i];
      const m0 = (prev.outTangents?.[i] ?? 0) * duration;
      const p1 = next.weights[i];
      const m1 = (next.inTangents?.[i] ?? 0) * duration;
      result[i] = h00 * p0 + h10 * m0 + h01 * p1 + h11 * m1;
    }
    return result;
  }
  getStartWeights() {
    return this.keyframes.length > 0 ? this.keyframes[0].weights : null;
  }
  getEndWeights() {
    return this.keyframes.length > 0 ? this.keyframes[this.keyframes.length - 1].weights : null;
  }
  toString() {
    return `MorphWeightsTrack(mesh="${this.targetMesh.name}", targets=${this.targetCount}, ` + `keyframes=${this.keyframes.length}, duration=${this.duration.toFixed(2)}s)`;
  }
}
// ../../src/core/animation/morphing/MorphTargetShader.ts
var MORPH_TARGET_UNIFORMS = `
// Morph target deltas storage buffer (bind group 2 or 3 depending on skinning)
// Layout: For each target, vertexCount * (3 floats position + 3 floats normal)
@group(2) @binding(0) var<storage, read> morphDeltas: array<f32>;

// Morph weights uniform buffer
// Layout: vec4 * ceil(MAX_MORPH_TARGETS / 4)
@group(2) @binding(1) var<uniform> morphWeights: array<vec4<f32>, ${Math.ceil(MAX_MORPH_TARGETS / 4)}>;

// Constants
const MAX_MORPH_TARGETS: u32 = ${MAX_MORPH_TARGETS}u;
`;
var MORPH_RESULT = `
struct MorphResult {
  position: vec3<f32>,
  normal: vec3<f32>,
}
`;
var APPLY_MORPH_FUNCTION = `
fn applyMorphTargets(
  vertexIndex: u32,
  basePosition: vec3<f32>,
  baseNormal: vec3<f32>,
  vertexCount: u32,
  targetCount: u32
) -> MorphResult {
  var morphedPosition = basePosition;
  var morphedNormal = baseNormal;

  // Each target stores vertexCount * 6 floats (pos.xyz + normal.xyz per vertex)
  let deltasPerTarget = vertexCount * 6u;

  // Apply each morph target
  for (var t = 0u; t < targetCount && t < MAX_MORPH_TARGETS; t++) {
    // Get weight for this target
    let weightIndex = t / 4u;
    let weightComponent = t % 4u;
    var weight: f32;
    switch (weightComponent) {
      case 0u: { weight = morphWeights[weightIndex].x; }
      case 1u: { weight = morphWeights[weightIndex].y; }
      case 2u: { weight = morphWeights[weightIndex].z; }
      default: { weight = morphWeights[weightIndex].w; }
    }

    // Skip if weight is negligible
    if (weight < 0.001) {
      continue;
    }

    // Calculate offset into deltas buffer for this target and vertex
    let targetOffset = t * deltasPerTarget;
    let vertexOffset = targetOffset + vertexIndex * 6u;

    // Read position delta
    let positionDelta = vec3<f32>(
      morphDeltas[vertexOffset + 0u],
      morphDeltas[vertexOffset + 1u],
      morphDeltas[vertexOffset + 2u]
    );

    // Read normal delta
    let normalDelta = vec3<f32>(
      morphDeltas[vertexOffset + 3u],
      morphDeltas[vertexOffset + 4u],
      morphDeltas[vertexOffset + 5u]
    );

    // Apply weighted deltas
    morphedPosition += weight * positionDelta;
    morphedNormal += weight * normalDelta;
  }

  // Normalize the final normal
  return MorphResult(morphedPosition, normalize(morphedNormal));
}
`;
function getOptimizedMorphFunction(targetCount) {
  if (targetCount <= 0)
    return "";
  let code = `
fn applyMorphTargetsOptimized(
  vertexIndex: u32,
  basePosition: vec3<f32>,
  baseNormal: vec3<f32>,
  vertexCount: u32
) -> MorphResult {
  var morphedPosition = basePosition;
  var morphedNormal = baseNormal;
  let deltasPerTarget = vertexCount * 6u;
`;
  for (let t = 0;t < Math.min(targetCount, MAX_MORPH_TARGETS); t++) {
    const weightIndex = Math.floor(t / 4);
    const component = ["x", "y", "z", "w"][t % 4];
    code += `
  // Target ${t}
  {
    let weight = morphWeights[${weightIndex}].${component};
    if (weight > 0.001) {
      let vertexOffset = ${t}u * deltasPerTarget + vertexIndex * 6u;
      morphedPosition += weight * vec3<f32>(
        morphDeltas[vertexOffset],
        morphDeltas[vertexOffset + 1u],
        morphDeltas[vertexOffset + 2u]
      );
      morphedNormal += weight * vec3<f32>(
        morphDeltas[vertexOffset + 3u],
        morphDeltas[vertexOffset + 4u],
        morphDeltas[vertexOffset + 5u]
      );
    }
  }`;
  }
  code += `
  return MorphResult(morphedPosition, normalize(morphedNormal));
}
`;
  return code;
}
function getMorphTargetShaderHeader() {
  return `
${MORPH_TARGET_UNIFORMS}
${MORPH_RESULT}
${APPLY_MORPH_FUNCTION}
`;
}
function createMorphedVertexShader(standardVertexShader, targetCount = MAX_MORPH_TARGETS) {
  let modifiedShader = standardVertexShader;
  const morphHeader = getMorphTargetShaderHeader();
  const optimizedMorphFn = targetCount > 0 && targetCount <= 8 ? getOptimizedMorphFunction(targetCount) : "";
  const vsMainIndex = modifiedShader.indexOf("@vertex");
  if (vsMainIndex > -1) {
    modifiedShader = modifiedShader.slice(0, vsMainIndex) + morphHeader + `
` + optimizedMorphFn + `
` + modifiedShader.slice(vsMainIndex);
  }
  const vsMainFnRegex = /fn vs_main\(input\s*:\s*VertexInput,\s*@builtin\(instance_index\)\s*instanceIndex\s*:\s*u32\)/;
  modifiedShader = modifiedShader.replace(vsMainFnRegex, "fn vs_main(input: VertexInput, @builtin(instance_index) instanceIndex: u32, @builtin(vertex_index) vertexIndex: u32)");
  const morphConfigUniform = `
// Morph configuration: x = vertexCount, y = targetCount
var<private> morphConfig: vec2<u32>;
`;
  const morphHeaderEndIndex = modifiedShader.indexOf(APPLY_MORPH_FUNCTION) + APPLY_MORPH_FUNCTION.length;
  if (morphHeaderEndIndex > APPLY_MORPH_FUNCTION.length) {
    modifiedShader = modifiedShader.slice(0, morphHeaderEndIndex) + morphConfigUniform + modifiedShader.slice(morphHeaderEndIndex);
  }
  const worldPosPattern = /let worldPos = modelMatrix \* vec4<f32>\(input\.position, 1\.0\);/g;
  const worldPosMatch = modifiedShader.match(worldPosPattern);
  let morphedDefined = false;
  if (worldPosMatch) {
    modifiedShader = modifiedShader.replace(worldPosPattern, `// Apply morph targets
        let morphed = applyMorphTargets(vertexIndex, input.position, input.normal, ${targetCount}u, ${targetCount}u);
        let worldPos = modelMatrix * vec4<f32>(morphed.position, 1.0);`);
    morphedDefined = true;
  }
  const localPosPattern = /let worldPos = modelMatrix \* vec4<f32>\(localPos, 1\.0\);/g;
  const localPosMatch = modifiedShader.match(localPosPattern);
  if (localPosMatch) {
    modifiedShader = modifiedShader.replace(/var localPos = input\.position;/g, `let morphed = applyMorphTargets(vertexIndex, input.position, input.normal, ${targetCount}u, ${targetCount}u);
        var localPos = morphed.position;`);
    morphedDefined = true;
  }
  if (morphedDefined) {
    const normalPattern = /output\.worldNormal = \(normalMatrix \* vec4<f32>\(input\.normal, 0\.0\)\)\.xyz;/g;
    modifiedShader = modifiedShader.replace(normalPattern, "output.worldNormal = (normalMatrix * vec4<f32>(morphed.normal, 0.0)).xyz;");
    const prevWorldPosPattern = /let prevWorldPos = prevModelMatrix \* vec4<f32>\(input\.position, 1\.0\);/g;
    modifiedShader = modifiedShader.replace(prevWorldPosPattern, "let prevWorldPos = prevModelMatrix * vec4<f32>(morphed.position, 1.0);");
  }
  return modifiedShader;
}
// ../../src/core/animation/Easing.ts
var linear = (t) => t;
var easeInQuad = (t) => t * t;
var easeOutQuad = (t) => 1 - (1 - t) * (1 - t);
var easeInOutQuad = (t) => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
var easeInCubic = (t) => t * t * t;
var easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);
var easeInOutCubic = (t) => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
var easeInQuart = (t) => t * t * t * t;
var easeOutQuart = (t) => 1 - Math.pow(1 - t, 4);
var easeInOutQuart = (t) => t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2;
var easeInQuint = (t) => t * t * t * t * t;
var easeOutQuint = (t) => 1 - Math.pow(1 - t, 5);
var easeInOutQuint = (t) => t < 0.5 ? 16 * t * t * t * t * t : 1 - Math.pow(-2 * t + 2, 5) / 2;
var easeInSine = (t) => 1 - Math.cos(t * Math.PI / 2);
var easeOutSine = (t) => Math.sin(t * Math.PI / 2);
var easeInOutSine = (t) => -(Math.cos(Math.PI * t) - 1) / 2;
var easeInExpo = (t) => t === 0 ? 0 : Math.pow(2, 10 * t - 10);
var easeOutExpo = (t) => t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
var easeInOutExpo = (t) => t === 0 ? 0 : t === 1 ? 1 : t < 0.5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2;
var easeInCirc = (t) => 1 - Math.sqrt(1 - Math.pow(t, 2));
var easeOutCirc = (t) => Math.sqrt(1 - Math.pow(t - 1, 2));
var easeInOutCirc = (t) => t < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * t, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * t + 2, 2)) + 1) / 2;
var c4 = 2 * Math.PI / 3;
var c5 = 2 * Math.PI / 4.5;
var easeInElastic = (t) => t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * c4);
var easeOutElastic = (t) => t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
var easeInOutElastic = (t) => t === 0 ? 0 : t === 1 ? 1 : t < 0.5 ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * c5)) / 2 : Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * c5) / 2 + 1;
var c1 = 1.70158;
var c2 = c1 * 1.525;
var c3 = c1 + 1;
var easeInBack = (t) => c3 * t * t * t - c1 * t * t;
var easeOutBack = (t) => 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
var easeInOutBack = (t) => t < 0.5 ? Math.pow(2 * t, 2) * ((c2 + 1) * 2 * t - c2) / 2 : (Math.pow(2 * t - 2, 2) * ((c2 + 1) * (t * 2 - 2) + c2) + 2) / 2;
var n1 = 7.5625;
var d1 = 2.75;
var easeOutBounce = (t) => {
  if (t < 1 / d1) {
    return n1 * t * t;
  } else if (t < 2 / d1) {
    return n1 * (t -= 1.5 / d1) * t + 0.75;
  } else if (t < 2.5 / d1) {
    return n1 * (t -= 2.25 / d1) * t + 0.9375;
  } else {
    return n1 * (t -= 2.625 / d1) * t + 0.984375;
  }
};
var easeInBounce = (t) => 1 - easeOutBounce(1 - t);
var easeInOutBounce = (t) => t < 0.5 ? (1 - easeOutBounce(1 - 2 * t)) / 2 : (1 + easeOutBounce(2 * t - 1)) / 2;
var Easing = {
  linear,
  easeInQuad,
  easeOutQuad,
  easeInOutQuad,
  easeInCubic,
  easeOutCubic,
  easeInOutCubic,
  easeInQuart,
  easeOutQuart,
  easeInOutQuart,
  easeInQuint,
  easeOutQuint,
  easeInOutQuint,
  easeInSine,
  easeOutSine,
  easeInOutSine,
  easeInExpo,
  easeOutExpo,
  easeInOutExpo,
  easeInCirc,
  easeOutCirc,
  easeInOutCirc,
  easeInElastic,
  easeOutElastic,
  easeInOutElastic,
  easeInBack,
  easeOutBack,
  easeInOutBack,
  easeInBounce,
  easeOutBounce,
  easeInOutBounce
};
function getEasing(name12) {
  if (typeof name12 === "function") {
    return name12;
  }
  return Easing[name12] ?? linear;
}
// ../../src/core/animation/Tween.ts
function isVector2(value) {
  return value instanceof Vector2 || typeof value === "object" && value !== null && "x" in value && "y" in value && !("z" in value);
}
function isVector3(value) {
  return value instanceof Vector3 || typeof value === "object" && value !== null && "x" in value && "y" in value && "z" in value;
}
function isColor(value) {
  return typeof value === "object" && value !== null && "r" in value && "g" in value && "b" in value;
}
function interpolate(start, end, t) {
  if (typeof start === "number" && typeof end === "number") {
    return start + (end - start) * t;
  }
  if (isVector3(start) && isVector3(end)) {
    return new Vector3(start.x + (end.x - start.x) * t, start.y + (end.y - start.y) * t, start.z + (end.z - start.z) * t);
  }
  if (isVector2(start) && isVector2(end)) {
    return new Vector2(start.x + (end.x - start.x) * t, start.y + (end.y - start.y) * t);
  }
  if (isColor(start) && isColor(end)) {
    return {
      r: start.r + (end.r - start.r) * t,
      g: start.g + (end.g - start.g) * t,
      b: start.b + (end.b - start.b) * t,
      a: (start.a ?? 1) + ((end.a ?? 1) - (start.a ?? 1)) * t
    };
  }
  return start;
}
function cloneValue(value) {
  if (typeof value === "number") {
    return value;
  }
  if (isVector3(value)) {
    return new Vector3(value.x, value.y, value.z);
  }
  if (isVector2(value)) {
    return new Vector2(value.x, value.y);
  }
  if (isColor(value)) {
    return { r: value.r, g: value.g, b: value.b, a: value.a };
  }
  return value;
}
function applyValue(target, key, value) {
  const obj = target;
  const existing = obj[key];
  if (typeof value === "number") {
    obj[key] = value;
  } else if (isVector3(value) && isVector3(existing)) {
    existing.x = value.x;
    existing.y = value.y;
    existing.z = value.z;
  } else if (isVector2(value) && isVector2(existing)) {
    existing.x = value.x;
    existing.y = value.y;
  } else if (isColor(value) && isColor(existing)) {
    existing.r = value.r;
    existing.g = value.g;
    existing.b = value.b;
    if (value.a !== undefined) {
      existing.a = value.a;
    }
  } else {
    obj[key] = value;
  }
}

class Tween {
  target;
  startValues = new Map;
  endValues = new Map;
  _state = "idle";
  _elapsed = 0;
  _delayElapsed = 0;
  _repeatCount = 0;
  _reversed = false;
  _started = false;
  duration = 1;
  delay = 0;
  easing = linear;
  repeat = 0;
  repeatDelay = 0;
  yoyo = false;
  onStartCallback;
  onUpdateCallback;
  onCompleteCallback;
  onRepeatCallback;
  onStopCallback;
  chainedTween;
  _manager;
  constructor(target, options) {
    this.target = target;
    if (options) {
      this.configure(options);
    }
  }
  configure(options) {
    if (options.duration !== undefined)
      this.duration = options.duration;
    if (options.delay !== undefined)
      this.delay = options.delay;
    if (options.easing !== undefined)
      this.easing = getEasing(options.easing);
    if (options.repeat !== undefined)
      this.repeat = options.repeat;
    if (options.repeatDelay !== undefined)
      this.repeatDelay = options.repeatDelay;
    if (options.yoyo !== undefined)
      this.yoyo = options.yoyo;
    if (options.onStart !== undefined)
      this.onStartCallback = options.onStart;
    if (options.onUpdate !== undefined)
      this.onUpdateCallback = options.onUpdate;
    if (options.onComplete !== undefined)
      this.onCompleteCallback = options.onComplete;
    if (options.onRepeat !== undefined)
      this.onRepeatCallback = options.onRepeat;
    if (options.onStop !== undefined)
      this.onStopCallback = options.onStop;
    return this;
  }
  to(values, duration) {
    if (duration !== undefined) {
      this.duration = duration;
    }
    for (const key of Object.keys(values)) {
      const targetValue = this.target[key];
      const endValue = values[key];
      if (targetValue !== undefined && endValue !== undefined) {
        this.startValues.set(key, cloneValue(targetValue));
        this.endValues.set(key, cloneValue(endValue));
      }
    }
    return this;
  }
  from(values) {
    for (const key of Object.keys(values)) {
      const value = values[key];
      if (value !== undefined) {
        this.startValues.set(key, cloneValue(value));
      }
    }
    return this;
  }
  setDuration(duration) {
    this.duration = duration;
    return this;
  }
  setDelay(delay) {
    this.delay = delay;
    return this;
  }
  setEasing(easing) {
    this.easing = getEasing(easing);
    return this;
  }
  setRepeat(count) {
    this.repeat = count;
    return this;
  }
  setRepeatDelay(delay) {
    this.repeatDelay = delay;
    return this;
  }
  setYoyo(enabled) {
    this.yoyo = enabled;
    return this;
  }
  onStart(callback) {
    this.onStartCallback = callback;
    return this;
  }
  onUpdate(callback) {
    this.onUpdateCallback = callback;
    return this;
  }
  onComplete(callback) {
    this.onCompleteCallback = callback;
    return this;
  }
  onRepeat(callback) {
    this.onRepeatCallback = callback;
    return this;
  }
  onStop(callback) {
    this.onStopCallback = callback;
    return this;
  }
  chain(tween) {
    this.chainedTween = tween;
    return tween;
  }
  start() {
    if (this._state === "running")
      return this;
    this._state = "running";
    this._elapsed = 0;
    this._delayElapsed = 0;
    this._repeatCount = 0;
    this._reversed = false;
    this._started = false;
    for (const key of this.endValues.keys()) {
      if (!this.startValues.has(key)) {
        const currentValue = this.target[key];
        if (currentValue !== undefined) {
          this.startValues.set(key, cloneValue(currentValue));
        }
      }
    }
    return this;
  }
  stop() {
    if (this._state !== "running" && this._state !== "paused")
      return this;
    this._state = "completed";
    this.onStopCallback?.();
    if (this._manager) {
      this._manager.remove(this);
    }
    return this;
  }
  pause() {
    if (this._state === "running") {
      this._state = "paused";
    }
    return this;
  }
  resume() {
    if (this._state === "paused") {
      this._state = "running";
    }
    return this;
  }
  reset() {
    this._state = "idle";
    this._elapsed = 0;
    this._delayElapsed = 0;
    this._repeatCount = 0;
    this._reversed = false;
    this._started = false;
    for (const [key, startValue] of this.startValues) {
      applyValue(this.target, key, startValue);
    }
    return this;
  }
  get state() {
    return this._state;
  }
  get progress() {
    if (this.duration === 0)
      return 1;
    return Math.min(this._elapsed / this.duration, 1);
  }
  get elapsed() {
    return this._elapsed;
  }
  get isRunning() {
    return this._state === "running";
  }
  get isComplete() {
    return this._state === "completed";
  }
  setManager(manager) {
    this._manager = manager;
  }
  getTarget() {
    return this.target;
  }
  update(dt) {
    if (this._state !== "running") {
      return this._state !== "completed";
    }
    if (this._delayElapsed < this.delay) {
      this._delayElapsed += dt;
      if (this._delayElapsed < this.delay) {
        return true;
      }
      dt = this._delayElapsed - this.delay;
    }
    if (!this._started) {
      this._started = true;
      this.onStartCallback?.();
    }
    this._elapsed += dt;
    let progress = this.duration > 0 ? Math.min(this._elapsed / this.duration, 1) : 1;
    if (this._reversed) {
      progress = 1 - progress;
    }
    const easedProgress = this.easing(progress);
    for (const [key, startValue] of this.startValues) {
      const endValue = this.endValues.get(key);
      if (endValue !== undefined) {
        const value = interpolate(startValue, endValue, easedProgress);
        applyValue(this.target, key, value);
      }
    }
    this.onUpdateCallback?.(this._reversed ? 1 - progress : progress);
    if (this._elapsed >= this.duration) {
      if (this.repeat === -1 || this._repeatCount < this.repeat) {
        this._repeatCount++;
        this._elapsed = 0;
        if (this.yoyo) {
          this._reversed = !this._reversed;
        }
        if (this.repeatDelay > 0) {
          this._delayElapsed = this.delay - this.repeatDelay;
        }
        this.onRepeatCallback?.(this._repeatCount);
        return true;
      }
      this._state = "completed";
      this.onCompleteCallback?.();
      if (this.chainedTween) {
        this.chainedTween.start();
      }
      return false;
    }
    return true;
  }
}
// ../../src/core/animation/TweenManager.ts
class TweenManager {
  tweens = new Set;
  static _instance = null;
  static get instance() {
    if (!TweenManager._instance) {
      TweenManager._instance = new TweenManager;
    }
    return TweenManager._instance;
  }
  create(target, options) {
    const tween = new Tween(target, options);
    tween.setManager(this);
    this.tweens.add(tween);
    return tween;
  }
  add(tween) {
    tween.setManager(this);
    this.tweens.add(tween);
    return this;
  }
  remove(tween) {
    this.tweens.delete(tween);
    return this;
  }
  update(dt) {
    for (const tween of this.tweens) {
      const shouldContinue = tween.update(dt);
      if (!shouldContinue) {
        this.tweens.delete(tween);
      }
    }
  }
  stopAll() {
    for (const tween of this.tweens) {
      tween.stop();
    }
    this.tweens.clear();
  }
  pauseAll() {
    for (const tween of this.tweens) {
      tween.pause();
    }
  }
  resumeAll() {
    for (const tween of this.tweens) {
      tween.resume();
    }
  }
  getTweensForTarget(target) {
    const result = [];
    for (const tween of this.tweens) {
      if (tween.getTarget() === target) {
        result.push(tween);
      }
    }
    return result;
  }
  stopTweensForTarget(target) {
    const tweens = this.getTweensForTarget(target);
    for (const tween of tweens) {
      tween.stop();
      this.tweens.delete(tween);
    }
  }
  get count() {
    return this.tweens.size;
  }
  get hasActiveTweens() {
    return this.tweens.size > 0;
  }
  clear() {
    this.tweens.clear();
  }
}
// ../../src/loaders/GLTFLoader.ts
class GLTFLoader2 {
  device;
  textures = new Map;
  materials = new Map;
  skeletons = new Map;
  nodeToJointIndex = new Map;
  skinnedMeshes = [];
  morphTargetMeshes = [];
  meshMorphTargetNames = new Map;
  meshIndexToMorphMesh = new Map;
  nodeIndexToNode = new Map;
  constructor(device) {
    this.device = device;
  }
  async load(url) {
    const loaded = await load(url, GLTFLoader, {
      gltf: {
        decompressMeshes: true,
        loadImages: true
      },
      draco: {
        decoderType: "wasm",
        libraryPath: "https://www.gstatic.com/draco/versioned/decoders/1.5.6/"
      }
    });
    const gltf = postProcessGLTF(loaded);
    console.log("GLTFLoader: Post-processed GLTF:", gltf);
    this.textures.clear();
    this.materials.clear();
    this.skeletons.clear();
    this.nodeToJointIndex.clear();
    this.skinnedMeshes = [];
    this.morphTargetMeshes = [];
    this.meshMorphTargetNames.clear();
    this.meshIndexToMorphMesh.clear();
    this.nodeIndexToNode.clear();
    const colorTextureIds = new Set;
    const dataTextureIds = new Set;
    if (gltf.materials) {
      for (const matDef of gltf.materials) {
        const pbr = matDef.pbrMetallicRoughness;
        if (pbr) {
          if (pbr.baseColorTexture?.texture?.id) {
            colorTextureIds.add(pbr.baseColorTexture.texture.id);
          }
          if (pbr.metallicRoughnessTexture?.texture?.id) {
            dataTextureIds.add(pbr.metallicRoughnessTexture.texture.id);
          }
        }
        if (matDef.normalTexture?.texture?.id) {
          dataTextureIds.add(matDef.normalTexture.texture.id);
        }
        if (matDef.emissiveTexture?.texture?.id) {
          colorTextureIds.add(matDef.emissiveTexture.texture.id);
        }
        if (matDef.occlusionTexture?.texture?.id) {
          dataTextureIds.add(matDef.occlusionTexture.texture.id);
        }
      }
    }
    if (gltf.textures) {
      for (const texDef of gltf.textures) {
        if (!texDef.source)
          continue;
        const texId = texDef.id || texDef.index?.toString() || Math.random().toString();
        const isColorTexture = colorTextureIds.has(texId) && !dataTextureIds.has(texId);
        const image = texDef.source.image || texDef.source;
        const texture = new Texture("GLTF Texture", { srgb: isColorTexture });
        if (image) {
          try {
            if (image instanceof ImageBitmap) {
              texture.createFromImageBitmap(this.device, image);
            } else if (image instanceof HTMLImageElement) {
              const bitmap = await createImageBitmap(image);
              texture.createFromImageBitmap(this.device, bitmap);
            }
          } catch (e) {
            console.error("GLTFLoader: Failed to create texture from image", e);
          }
        }
        this.textures.set(texId, texture);
      }
    }
    if (gltf.materials) {
      for (const matDef of gltf.materials) {
        const material = new StandardMaterial;
        const pbr = matDef.pbrMetallicRoughness;
        if (pbr) {
          if (pbr.baseColorFactor) {
            material.albedo = new Vector3(pbr.baseColorFactor[0], pbr.baseColorFactor[1], pbr.baseColorFactor[2]);
            material.opacity = pbr.baseColorFactor[3];
          }
          if (pbr.baseColorTexture) {
            material.albedoMap = this.textures.get(pbr.baseColorTexture.texture.id) || null;
          }
          if (pbr.metallicFactor !== undefined)
            material.metallic = pbr.metallicFactor;
          if (pbr.roughnessFactor !== undefined)
            material.roughness = pbr.roughnessFactor;
          if (pbr.metallicRoughnessTexture) {
            const tex = this.textures.get(pbr.metallicRoughnessTexture.texture.id);
            if (tex) {
              material.roughnessMap = tex;
              material.metallicMap = tex;
            }
          }
        }
        if (matDef.normalTexture) {
          material.normalMap = this.textures.get(matDef.normalTexture.texture.id) || null;
        }
        if (matDef.emissiveFactor) {
          material.emissive = new Vector3(matDef.emissiveFactor[0], matDef.emissiveFactor[1], matDef.emissiveFactor[2]);
        }
        if (matDef.emissiveTexture) {
          material.emissiveMap = this.textures.get(matDef.emissiveTexture.texture.id) || null;
        }
        if (matDef.occlusionTexture) {
          material.occlusionMap = this.textures.get(matDef.occlusionTexture.texture.id) || null;
        }
        if (matDef.alphaMode) {
          if (matDef.alphaMode === "MASK") {
            material.alphaMode = "MASK";
            material.alphaCutoff = matDef.alphaCutoff || 0.5;
          } else if (matDef.alphaMode === "BLEND") {
            material.alphaMode = "BLEND";
          }
        }
        this.materials.set(matDef.id || matDef.index?.toString() || Math.random().toString(), material);
      }
    }
    if (gltf.meshes) {
      console.log(`GLTFLoader: GLTF contains ${gltf.meshes.length} mesh definitions:`);
      gltf.meshes.forEach((mesh, i) => {
        const primCount = mesh.primitives?.length || 0;
        const hasMorphTargets = mesh.primitives?.some((p) => p.targets && p.targets.length > 0);
        console.log(`  [${i}] "${mesh.name || "unnamed"}" - ${primCount} primitives, morphTargets: ${hasMorphTargets}`);
      });
    }
    if (gltf.nodes) {
      console.log(`GLTFLoader: GLTF contains ${gltf.nodes.length} nodes:`);
      gltf.nodes.forEach((node, i) => {
        const hasMesh = node.mesh !== undefined;
        const hasSkin = node.skin !== undefined;
        console.log(`  [${i}] "${node.name || "unnamed"}" - mesh: ${hasMesh ? typeof node.mesh === "object" ? node.mesh.name : node.mesh : "none"}, skin: ${hasSkin ? typeof node.skin === "object" ? "object" : node.skin : "none"}`);
      });
    }
    if (gltf.skins) {
      for (let skinIndex = 0;skinIndex < gltf.skins.length; skinIndex++) {
        const skinDef = gltf.skins[skinIndex];
        const skeleton = this.parseSkin(skinDef, skinIndex, gltf);
        this.skeletons.set(skinIndex, skeleton);
        console.log(`GLTFLoader: Loaded skeleton ${skinIndex} with ${skeleton.boneCount} bones`);
      }
    }
    const rootNode = new Node("GLTF Root");
    const scene = gltf.scene || (gltf.scenes ? gltf.scenes[0] : null);
    if (scene && scene.nodes) {
      for (const nodeDef of scene.nodes) {
        const nodeIndex = this.findNodeIndex(nodeDef, gltf);
        const node = this.processNode(nodeDef, gltf, nodeIndex);
        rootNode.addChild(node);
      }
    } else if (gltf.nodes) {
      console.warn("GLTFLoader: No default scene found.");
    }
    console.log(`GLTFLoader: nodeIndexToNode has ${this.nodeIndexToNode.size} entries`);
    const animations = [];
    if (gltf.animations) {
      for (const animDef of gltf.animations) {
        const clip = this.parseAnimation(animDef, gltf);
        if (clip) {
          animations.push(clip);
          console.log(`GLTFLoader: Loaded animation "${clip.name}" (${clip.duration.toFixed(2)}s, ` + `boneTracks=${clip.tracks.length}, nodeTracks=${clip.nodeAnimationTracks.length}, ` + `morphTracks=${clip.morphWeightsTracks.length})`);
        }
      }
    }
    return {
      rootNode,
      animations,
      skeletons: this.skeletons,
      skinnedMeshes: this.skinnedMeshes,
      morphTargetMeshes: this.morphTargetMeshes
    };
  }
  processNode(nodeDef, gltf, nodeIndex = -1) {
    const node = new Node(nodeDef.name || "GLTF Node");
    if (nodeIndex >= 0) {
      this.nodeIndexToNode.set(nodeIndex, node);
    }
    if (nodeDef.matrix) {
      const mat = new Matrix4(nodeDef.matrix);
      const decomp = mat.decompose();
      node.transform.position = decomp.position;
      node.transform.rotation = Quaternion.fromRotationMatrix(decomp.rotation);
      node.transform.scale = decomp.scale;
    } else {
      if (nodeDef.translation) {
        node.transform.position = new Vector3(nodeDef.translation[0], nodeDef.translation[1], nodeDef.translation[2]);
      }
      if (nodeDef.rotation) {
        node.transform.rotation = new Quaternion(nodeDef.rotation[0], nodeDef.rotation[1], nodeDef.rotation[2], nodeDef.rotation[3]);
      }
      if (nodeDef.scale) {
        node.transform.scale = new Vector3(nodeDef.scale[0], nodeDef.scale[1], nodeDef.scale[2]);
      }
    }
    const skinIndex = this.findSkinIndexForNode(nodeDef, gltf);
    const skeleton = skinIndex >= 0 ? this.skeletons.get(skinIndex) : null;
    if (nodeDef.mesh) {
      console.log(`GLTFLoader: Node "${nodeDef.name || "unnamed"}" has mesh, skin property:`, nodeDef.skin, `-> skinIndex: ${skinIndex}`);
    }
    if (nodeDef.mesh) {
      const meshDef = nodeDef.mesh;
      const baseName = meshDef.name || nodeDef.name || "Mesh";
      let primitiveIndex = 0;
      for (const primitive of meshDef.primitives) {
        const geometry = new Geometry;
        for (const [name12, accessor] of Object.entries(primitive.attributes)) {
          const acc = accessor;
          if (name12 === "POSITION") {
            const data = this.getAccessorData(acc);
            geometry.setAttribute("position", data);
          } else if (name12 === "NORMAL") {
            const data = this.getAccessorData(acc);
            geometry.setAttribute("normal", data);
          } else if (name12 === "TEXCOORD_0") {
            const data = this.getAccessorData(acc);
            geometry.setAttribute("uv", data);
          } else if (name12 === "JOINTS_0") {
            const data = this.getJointsData(acc);
            geometry.setAttribute("joints", data);
          } else if (name12 === "WEIGHTS_0") {
            const data = this.getAccessorData(acc);
            geometry.setAttribute("weights", data);
          }
        }
        if (primitive.indices) {
          const acc = primitive.indices;
          const indices = this.getAccessorData(acc, true);
          if (indices instanceof Uint32Array) {
            geometry.setIndices(indices);
          } else {
            geometry.setIndices(new Uint16Array(indices));
          }
        }
        if (primitive.mode !== undefined && primitive.mode !== 4) {
          console.warn(`GLTFLoader: Primitive mode ${primitive.mode} not fully supported (expected 4 TRIANGLES).`);
        }
        const material = this.materials.get(primitive.material?.id) || new StandardMaterial;
        const morphTargets = this.parseMorphTargets(primitive, meshDef, geometry.vertexCount);
        let mesh;
        const meshName = meshDef.primitives.length > 1 ? `${baseName}_${primitiveIndex}` : baseName;
        const hasJoints = !!geometry.attributes["joints"];
        const hasWeights = !!geometry.attributes["weights"];
        const hasSkeleton = !!skeleton;
        const hasMorphTargets = morphTargets && morphTargets.targetCount > 0;
        console.log(`GLTFLoader: Processing mesh "${meshName}" - skeleton=${hasSkeleton}, joints=${hasJoints}, weights=${hasWeights}, morphTargets=${hasMorphTargets ? morphTargets.targetCount : 0}`);
        let effectiveSkeleton = skeleton;
        if (!effectiveSkeleton && hasJoints && hasWeights && this.skeletons.size > 0) {
          effectiveSkeleton = this.skeletons.values().next().value;
          console.log(`GLTFLoader: Mesh "${meshName}" has joints/weights but no skin on node - using fallback skeleton`);
        }
        if (effectiveSkeleton && hasJoints && hasWeights) {
          const skinnedMesh = new SkinnedMesh(geometry, material, effectiveSkeleton);
          skinnedMesh.name = meshName;
          skinnedMesh.initSkinningBuffers(this.device);
          this.skinnedMeshes.push(skinnedMesh);
          mesh = skinnedMesh;
          if (hasMorphTargets) {
            skinnedMesh.morphTargets = morphTargets;
            morphTargets.initGPU(this.device);
            console.log(`GLTFLoader: SkinnedMesh "${meshName}" also has ${morphTargets.targetCount} morph targets (attached)`);
          }
          console.log(`GLTFLoader: Created SkinnedMesh "${skinnedMesh.name}" with ${effectiveSkeleton.boneCount} bones`);
        } else if (hasMorphTargets) {
          const morphMesh = new MorphTargetMesh(geometry, material, morphTargets);
          morphMesh.name = meshName;
          morphMesh.initMorphGPU(this.device);
          this.morphTargetMeshes.push(morphMesh);
          const meshIndex = this.findMeshIndex(meshDef, gltf);
          if (meshIndex >= 0) {
            this.meshIndexToMorphMesh.set(meshIndex, morphMesh);
          }
          mesh = morphMesh;
          console.log(`GLTFLoader: Created MorphTargetMesh "${morphMesh.name}" with ${morphTargets.targetCount} targets`);
        } else {
          mesh = new Mesh(geometry, material);
          mesh.name = meshName;
          console.log(`GLTFLoader: Created regular Mesh "${meshName}" (no skinning or morph targets)`);
        }
        primitiveIndex++;
        node.addChild(mesh);
      }
    }
    if (nodeDef.children) {
      for (const childDef of nodeDef.children) {
        const childIndex = this.findNodeIndex(childDef, gltf);
        const childNode = this.processNode(childDef, gltf, childIndex);
        node.addChild(childNode);
      }
    }
    return node;
  }
  findSkinIndexForNode(nodeDef, gltf) {
    if (nodeDef.skin !== undefined && nodeDef.skin !== null) {
      if (typeof nodeDef.skin === "number") {
        return nodeDef.skin;
      }
      if (typeof nodeDef.skin === "object" && gltf.skins) {
        let index = gltf.skins.indexOf(nodeDef.skin);
        if (index >= 0)
          return index;
        if (nodeDef.skin.name) {
          for (let i = 0;i < gltf.skins.length; i++) {
            if (gltf.skins[i].name === nodeDef.skin.name) {
              return i;
            }
          }
        }
        if (nodeDef.skin.id !== undefined) {
          for (let i = 0;i < gltf.skins.length; i++) {
            if (gltf.skins[i].id === nodeDef.skin.id) {
              return i;
            }
          }
        }
        if (nodeDef.skin.joints && nodeDef.skin.joints.length > 0) {
          const firstJoint = nodeDef.skin.joints[0];
          for (let i = 0;i < gltf.skins.length; i++) {
            const skin = gltf.skins[i];
            if (skin.joints && skin.joints.length > 0) {
              if (skin.joints[0] === firstJoint || typeof skin.joints[0] === "object" && typeof firstJoint === "object" && skin.joints[0].name === firstJoint.name) {
                return i;
              }
            }
          }
        }
        if (gltf.skins.length === 1) {
          console.log(`GLTFLoader: Assuming single skin match for node "${nodeDef.name}"`);
          return 0;
        }
        if (nodeDef.skin.joints) {
          console.log(`GLTFLoader: Using skin 0 for node "${nodeDef.name}" (has joints)`);
          return 0;
        }
        console.warn(`GLTFLoader: Node "${nodeDef.name}" has skin property but couldn't determine index`, nodeDef.skin);
      }
    }
    return -1;
  }
  parseSkin(skinDef, skinIndex, gltf) {
    const nodeToJoint = new Map;
    this.nodeToJointIndex.set(skinIndex, nodeToJoint);
    const jointNodeIndices = [];
    if (skinDef.joints) {
      for (let i = 0;i < skinDef.joints.length; i++) {
        const joint = skinDef.joints[i];
        const nodeIndex = typeof joint === "number" ? joint : this.findNodeIndex(joint, gltf);
        jointNodeIndices.push(nodeIndex);
        nodeToJoint.set(nodeIndex, i);
      }
    }
    let inverseBindMatrices = null;
    if (skinDef.inverseBindMatrices) {
      const accessor = typeof skinDef.inverseBindMatrices === "number" ? gltf.accessors[skinDef.inverseBindMatrices] : skinDef.inverseBindMatrices;
      inverseBindMatrices = this.getAccessorData(accessor);
    }
    const bonesData = [];
    for (let jointIndex = 0;jointIndex < jointNodeIndices.length; jointIndex++) {
      const nodeIndex = jointNodeIndices[jointIndex];
      const jointNode = this.getNodeByIndex(nodeIndex, gltf);
      if (!jointNode) {
        console.warn(`GLTFLoader: Could not find joint node ${nodeIndex}`);
        continue;
      }
      const localBindPose = this.getNodeTransform(jointNode);
      let inverseBindMatrix = new Matrix4;
      if (inverseBindMatrices) {
        const offset = jointIndex * 16;
        inverseBindMatrix = new Matrix4(Array.from(inverseBindMatrices.slice(offset, offset + 16)));
      }
      let parentIndex = -1;
      const parentNode = this.findParentJointNode(jointNode, jointNodeIndices, gltf);
      if (parentNode !== null) {
        const parentNodeIndex = this.findNodeIndex(parentNode, gltf);
        parentIndex = nodeToJoint.get(parentNodeIndex) ?? -1;
      }
      bonesData.push({
        name: jointNode.name || `joint_${jointIndex}`,
        index: jointIndex,
        parentIndex,
        localBindPose,
        inverseBindMatrix
      });
    }
    return new Skeleton(bonesData);
  }
  parseAnimation(animDef, gltf) {
    const clip = new AnimationClip(animDef.name || "animation");
    if (!animDef.channels || !animDef.samplers) {
      return null;
    }
    for (const channel of animDef.channels) {
      const sampler = animDef.samplers[channel.sampler];
      if (!sampler)
        continue;
      const targetNode = channel.target?.node;
      if (targetNode === undefined)
        continue;
      const targetPath = channel.target?.path;
      if (!targetPath)
        continue;
      const inputAccessor = typeof sampler.input === "number" ? gltf.accessors[sampler.input] : sampler.input;
      const outputAccessor = typeof sampler.output === "number" ? gltf.accessors[sampler.output] : sampler.output;
      const times = this.getAccessorData(inputAccessor);
      const values = this.getAccessorData(outputAccessor);
      let interpolation = "LINEAR";
      if (sampler.interpolation === "STEP")
        interpolation = "STEP";
      else if (sampler.interpolation === "CUBICSPLINE")
        interpolation = "CUBICSPLINE";
      if (targetPath === "weights") {
        const meshDef = this.findMeshForNode(targetNode, gltf);
        if (meshDef) {
          const meshIndex = this.findMeshIndex(meshDef, gltf);
          const morphMesh = this.meshIndexToMorphMesh.get(meshIndex);
          if (morphMesh) {
            const targetCount = morphMesh.morphTargetCount;
            const weightsTrack = new MorphWeightsTrack(morphMesh, targetCount, interpolation, times, values);
            clip.addMorphWeightsTrack(weightsTrack);
            console.log(`GLTFLoader: Added morph weights track for mesh "${morphMesh.name}" with ${targetCount} targets`);
          }
        }
        continue;
      }
      let property = null;
      if (targetPath === "translation")
        property = "position";
      else if (targetPath === "rotation")
        property = "rotation";
      else if (targetPath === "scale")
        property = "scale";
      else
        continue;
      const { boneIndex } = this.findBoneForAnimationTarget(targetNode, gltf);
      if (boneIndex >= 0) {
        const track = new AnimationTrack(boneIndex, property, interpolation, times, values);
        clip.addTrack(track);
      } else {
        const nodeIndex = typeof targetNode === "number" ? targetNode : this.findNodeIndex(targetNode, gltf);
        const targetNodeObj = this.nodeIndexToNode.get(nodeIndex);
        if (targetNodeObj) {
          const nodeTrack = new NodeAnimationTrack(targetNodeObj, property, interpolation, times, values);
          clip.addNodeAnimationTrack(nodeTrack);
          console.log(`GLTFLoader: Added node animation track for "${targetNodeObj.name}" (${property}), keyframes: ${times.length}`);
        } else {
          console.warn(`GLTFLoader: Could not find Node for animation target index ${nodeIndex}`);
        }
      }
    }
    const hasAnyTracks = clip.tracks.length > 0 || clip.nodeAnimationTracks.length > 0 || clip.morphWeightsTracks.length > 0;
    return hasAnyTracks ? clip : null;
  }
  findMeshForNode(targetNode, gltf) {
    const node = typeof targetNode === "number" ? gltf.nodes?.[targetNode] : targetNode;
    if (node && node.mesh) {
      if (typeof node.mesh === "number") {
        return gltf.meshes?.[node.mesh];
      }
      return node.mesh;
    }
    return null;
  }
  findBoneForAnimationTarget(targetNode, gltf) {
    const nodeIndex = typeof targetNode === "number" ? targetNode : this.findNodeIndex(targetNode, gltf);
    for (const [skinIndex, nodeToJoint] of this.nodeToJointIndex) {
      const boneIndex = nodeToJoint.get(nodeIndex);
      if (boneIndex !== undefined) {
        return { boneIndex, skinIndex };
      }
    }
    return { boneIndex: -1, skinIndex: -1 };
  }
  getNodeTransform(nodeDef) {
    let position = Vector3.zero;
    let rotation = Quaternion.identity;
    let scale2 = Vector3.one;
    if (nodeDef.matrix) {
      const mat = new Matrix4(nodeDef.matrix);
      const decomp = mat.decompose();
      position = decomp.position;
      rotation = Quaternion.fromRotationMatrix(decomp.rotation);
      scale2 = decomp.scale;
    } else {
      if (nodeDef.translation) {
        position = new Vector3(nodeDef.translation[0], nodeDef.translation[1], nodeDef.translation[2]);
      }
      if (nodeDef.rotation) {
        rotation = new Quaternion(nodeDef.rotation[0], nodeDef.rotation[1], nodeDef.rotation[2], nodeDef.rotation[3]);
      }
      if (nodeDef.scale) {
        scale2 = new Vector3(nodeDef.scale[0], nodeDef.scale[1], nodeDef.scale[2]);
      }
    }
    return { position, rotation, scale: scale2 };
  }
  findNodeIndex(node, gltf) {
    if (typeof node === "number")
      return node;
    if (!gltf.nodes)
      return -1;
    const index = gltf.nodes.indexOf(node);
    if (index >= 0)
      return index;
    if (node.name) {
      for (let i = 0;i < gltf.nodes.length; i++) {
        if (gltf.nodes[i].name === node.name)
          return i;
      }
    }
    return -1;
  }
  getNodeByIndex(index, gltf) {
    if (!gltf.nodes || index < 0 || index >= gltf.nodes.length) {
      return null;
    }
    return gltf.nodes[index];
  }
  findParentJointNode(jointNode, jointNodeIndices, gltf) {
    if (!gltf.nodes)
      return null;
    const jointIndex = this.findNodeIndex(jointNode, gltf);
    for (let i = 0;i < gltf.nodes.length; i++) {
      const node = gltf.nodes[i];
      if (node.children) {
        for (const child of node.children) {
          const childIndex = typeof child === "number" ? child : this.findNodeIndex(child, gltf);
          if (childIndex === jointIndex) {
            if (jointNodeIndices.includes(i)) {
              return node;
            }
            return this.findParentJointNode(node, jointNodeIndices, gltf);
          }
        }
      }
    }
    return null;
  }
  getJointsData(accessor) {
    if (accessor.value) {
      const value = accessor.value;
      if (value instanceof Float32Array) {
        return value;
      }
      const float32 = new Float32Array(value.length);
      for (let i = 0;i < value.length; i++) {
        float32[i] = value[i];
      }
      return float32;
    }
    const bufferView = accessor.bufferView;
    if (!bufferView) {
      return new Float32Array(0);
    }
    const buffer = bufferView.buffer.arrayBuffer;
    const offset = (bufferView.byteOffset || 0) + (accessor.byteOffset || 0);
    const count = accessor.count;
    const componentType = accessor.componentType;
    const componentCount = this.getComponentCount(accessor.type);
    const stride = bufferView.byteStride || 0;
    const output = new Float32Array(count * componentCount);
    let elementSize = 1;
    if (componentType === 5123)
      elementSize = 2;
    else if (componentType === 5125)
      elementSize = 4;
    const elementByteSize = elementSize * componentCount;
    const effectiveStride = stride || elementByteSize;
    const dataView = new DataView(buffer, offset);
    for (let i = 0;i < count; i++) {
      const itemOffset = i * effectiveStride;
      for (let j = 0;j < componentCount; j++) {
        const valOffset = itemOffset + j * elementSize;
        let value = 0;
        switch (componentType) {
          case 5121:
            value = dataView.getUint8(valOffset);
            break;
          case 5123:
            value = dataView.getUint16(valOffset, true);
            break;
          case 5125:
            value = dataView.getUint32(valOffset, true);
            break;
          default:
            value = dataView.getUint8(valOffset);
        }
        output[i * componentCount + j] = value;
      }
    }
    return output;
  }
  getAccessorData(accessor, isIndices = false) {
    if (accessor.value) {
      return accessor.value;
    }
    const bufferView = accessor.bufferView;
    if (!bufferView) {
      return new Float32Array(0);
    }
    const buffer = bufferView.buffer.arrayBuffer;
    const offset = (bufferView.byteOffset || 0) + (accessor.byteOffset || 0);
    const count = accessor.count;
    const componentType = accessor.componentType;
    const componentCount = this.getComponentCount(accessor.type);
    const stride = bufferView.byteStride || 0;
    const dataView = new DataView(buffer, offset, bufferView.byteLength - (accessor.byteOffset || 0));
    let elementSize = 0;
    switch (componentType) {
      case 5120:
        elementSize = 1;
        break;
      case 5121:
        elementSize = 1;
        break;
      case 5122:
        elementSize = 2;
        break;
      case 5123:
        elementSize = 2;
        break;
      case 5125:
        elementSize = 4;
        break;
      case 5126:
        elementSize = 4;
        break;
      default:
        console.error(`GLTFLoader: Unsupported componentType ${componentType}`);
        return new Float32Array(0);
    }
    if (isIndices) {
      if (componentType === 5125) {
        const arr = new Uint32Array(count);
        for (let i = 0;i < count; i++) {
          const byteOffset = i * (stride || 4);
          arr[i] = dataView.getUint32(byteOffset, true);
        }
        return arr;
      } else {
        const arr = new Uint16Array(count);
        for (let i = 0;i < count; i++) {
          const byteOffset = i * (stride || 2);
          if (componentType === 5123)
            arr[i] = dataView.getUint16(byteOffset, true);
          else if (componentType === 5121)
            arr[i] = dataView.getUint8(byteOffset);
        }
        return arr;
      }
    }
    const output = new Float32Array(count * componentCount);
    const elementByteSize = elementSize * componentCount;
    const effectiveStride = stride || elementByteSize;
    for (let i = 0;i < count; i++) {
      const itemOffset = i * effectiveStride;
      for (let j = 0;j < componentCount; j++) {
        const valOffset = itemOffset + j * elementSize;
        let value = 0;
        switch (componentType) {
          case 5120:
            value = dataView.getInt8(valOffset);
            break;
          case 5121:
            value = dataView.getUint8(valOffset);
            break;
          case 5122:
            value = dataView.getInt16(valOffset, true);
            break;
          case 5123:
            value = dataView.getUint16(valOffset, true);
            break;
          case 5125:
            value = dataView.getUint32(valOffset, true);
            break;
          case 5126:
            value = dataView.getFloat32(valOffset, true);
            break;
        }
        if (accessor.normalized) {
          if (componentType === 5120)
            value = Math.max(value / 127, -1);
          else if (componentType === 5121)
            value = value / 255;
          else if (componentType === 5122)
            value = Math.max(value / 32767, -1);
          else if (componentType === 5123)
            value = value / 65535;
        }
        output[i * componentCount + j] = value;
      }
    }
    return output;
  }
  getComponentCount(type) {
    switch (type) {
      case "SCALAR":
        return 1;
      case "VEC2":
        return 2;
      case "VEC3":
        return 3;
      case "VEC4":
        return 4;
      case "MAT4":
        return 16;
      default:
        return 0;
    }
  }
  parseMorphTargets(primitive, meshDef, vertexCount) {
    if (!primitive.targets || primitive.targets.length === 0) {
      return null;
    }
    const morphTargets = new MorphTargets(vertexCount);
    const targetNames = [];
    if (meshDef.extras && meshDef.extras.targetNames) {
      targetNames.push(...meshDef.extras.targetNames);
    }
    for (let i = 0;i < primitive.targets.length; i++) {
      const target = primitive.targets[i];
      const name12 = targetNames[i] || `morphTarget_${i}`;
      let positionDeltas = null;
      if (target.POSITION) {
        const accessor = target.POSITION;
        console.log(`GLTFLoader: Morph target ${i} POSITION accessor:`, {
          hasValue: !!accessor.value,
          valueLength: accessor.value?.length,
          hasBufferView: !!accessor.bufferView,
          count: accessor.count,
          type: accessor.type
        });
        positionDeltas = this.getAccessorData(accessor);
        console.log(`GLTFLoader: Morph target ${i} positionDeltas length: ${positionDeltas.length}`);
      }
      if (!positionDeltas) {
        console.warn(`GLTFLoader: Morph target ${i} has no POSITION deltas, skipping`);
        continue;
      }
      if (positionDeltas.length === 0) {
        console.warn(`GLTFLoader: Morph target ${i} "${name12}" has empty positionDeltas array`);
        positionDeltas = new Float32Array(vertexCount * 3);
      }
      let normalDeltas = null;
      if (target.NORMAL) {
        const accessor = target.NORMAL;
        normalDeltas = this.getAccessorData(accessor);
      }
      let tangentDeltas = null;
      if (target.TANGENT) {
        const accessor = target.TANGENT;
        tangentDeltas = this.getAccessorData(accessor);
      }
      const morphTargetData = {
        name: name12,
        index: i,
        positionDeltas,
        normalDeltas,
        tangentDeltas
      };
      morphTargets.addTarget(morphTargetData);
    }
    if (meshDef.weights && meshDef.weights.length > 0) {
      morphTargets.setWeights(meshDef.weights);
    }
    if (morphTargets.targetCount > 0) {
      const meshIndex = this.findMeshIndexFromDef(meshDef);
      if (meshIndex >= 0) {
        this.meshMorphTargetNames.set(meshIndex, morphTargets.targets.map((t) => t.name));
      }
    }
    return morphTargets.targetCount > 0 ? morphTargets : null;
  }
  findMeshIndexFromDef(meshDef) {
    if (meshDef.id !== undefined) {
      const parsed = parseInt(meshDef.id, 10);
      if (!isNaN(parsed))
        return parsed;
    }
    if (meshDef.index !== undefined) {
      return meshDef.index;
    }
    return -1;
  }
  findMeshIndex(meshDef, gltf) {
    if (!gltf.meshes)
      return -1;
    const index = gltf.meshes.indexOf(meshDef);
    if (index >= 0)
      return index;
    if (meshDef.name) {
      for (let i = 0;i < gltf.meshes.length; i++) {
        if (gltf.meshes[i].name === meshDef.name)
          return i;
      }
    }
    return this.findMeshIndexFromDef(meshDef);
  }
}

// ../../src/core/procedural/instancing/InstancedGLBMesh.ts
var INSTANCE_STRIDE2 = 12;

class InstancedGLBMesh extends Node {
  config;
  device = null;
  globalResources = null;
  initialized = false;
  pipeline = null;
  shadowPipeline = null;
  shadowBindGroup = null;
  shadowUniformBuffer = null;
  instanceBuffer = null;
  vertexBuffer = null;
  indexBuffer = null;
  uniformBuffer = null;
  bindGroup = null;
  albedoTexture = null;
  albedoTextureView = null;
  sampler = null;
  vertexCount = 0;
  indexCount = 0;
  indexFormat = "uint16";
  instances = [];
  instanceData = null;
  instanceCount = 0;
  time = 0;
  constructor(config2) {
    super();
    this.config = {
      windEnabled: false,
      windStrength: 0.3,
      windSpeed: 1,
      alphaCutoff: 0.5,
      receiveShadows: true,
      doubleSided: true,
      ...config2
    };
  }
  async init(device, globalResources) {
    this.device = device;
    this.globalResources = globalResources || null;
    const loader = new GLTFLoader2(device);
    const result = await loader.load(this.config.url);
    if (!result || !result.rootNode) {
      throw new Error(`Failed to load GLB: ${this.config.url}`);
    }
    let meshFound = false;
    result.rootNode.traverse((node) => {
      if (meshFound)
        return;
      if (node instanceof Mesh && node.geometry) {
        this.extractMeshData(node);
        meshFound = true;
      }
    });
    if (!meshFound) {
      throw new Error(`No mesh found in GLB: ${this.config.url}`);
    }
    const instanceBufferSize = this.config.maxInstances * INSTANCE_STRIDE2 * 4;
    this.instanceBuffer = device.createBuffer({
      label: `InstancedGLB Instance Buffer: ${this.config.url}`,
      size: instanceBufferSize,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
    });
    this.instanceData = new Float32Array(this.config.maxInstances * INSTANCE_STRIDE2);
    this.uniformBuffer = device.createBuffer({
      label: "InstancedGLB Uniform Buffer",
      size: 32,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.sampler = device.createSampler({
      label: "InstancedGLB Sampler",
      magFilter: "linear",
      minFilter: "linear",
      mipmapFilter: "linear",
      addressModeU: "repeat",
      addressModeV: "repeat"
    });
    this.createPipeline();
    this.createShadowPipeline();
    this.initialized = true;
    console.log(`[InstancedGLBMesh] Initialized: ${this.config.url}, vertices=${this.vertexCount}, maxInstances=${this.config.maxInstances}`);
  }
  extractMeshData(mesh) {
    const geometry = mesh.geometry;
    const material = mesh.material;
    const positions = geometry.attributes["position"];
    const normals = geometry.attributes["normal"];
    const uvs = geometry.attributes["uv"];
    const indices = geometry.indices;
    if (!positions) {
      throw new Error("Mesh has no position attribute");
    }
    const vertexCount = positions.length / 3;
    this.vertexCount = vertexCount;
    const vertexData = new Float32Array(vertexCount * 8);
    for (let i = 0;i < vertexCount; i++) {
      vertexData[i * 8 + 0] = positions[i * 3 + 0];
      vertexData[i * 8 + 1] = positions[i * 3 + 1];
      vertexData[i * 8 + 2] = positions[i * 3 + 2];
      vertexData[i * 8 + 3] = normals ? normals[i * 3 + 0] : 0;
      vertexData[i * 8 + 4] = normals ? normals[i * 3 + 1] : 1;
      vertexData[i * 8 + 5] = normals ? normals[i * 3 + 2] : 0;
      vertexData[i * 8 + 6] = uvs ? uvs[i * 2 + 0] : 0;
      vertexData[i * 8 + 7] = uvs ? uvs[i * 2 + 1] : 0;
    }
    this.vertexBuffer = this.device.createBuffer({
      label: "InstancedGLB Vertex Buffer",
      size: vertexData.byteLength,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
      mappedAtCreation: true
    });
    new Float32Array(this.vertexBuffer.getMappedRange()).set(vertexData);
    this.vertexBuffer.unmap();
    if (indices) {
      this.indexCount = indices.length;
      this.indexFormat = indices instanceof Uint32Array ? "uint32" : "uint16";
      this.indexBuffer = this.device.createBuffer({
        label: "InstancedGLB Index Buffer",
        size: indices.byteLength,
        usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,
        mappedAtCreation: true
      });
      if (indices instanceof Uint32Array) {
        new Uint32Array(this.indexBuffer.getMappedRange()).set(indices);
      } else {
        new Uint16Array(this.indexBuffer.getMappedRange()).set(indices);
      }
      this.indexBuffer.unmap();
    }
    if (material && "albedoMap" in material && material.albedoMap) {
      const albedoMap = material.albedoMap;
      if (albedoMap.gpuTexture) {
        this.albedoTexture = albedoMap.gpuTexture;
        this.albedoTextureView = this.albedoTexture.createView();
      }
    }
    if (!this.albedoTexture) {
      this.albedoTexture = this.device.createTexture({
        label: "InstancedGLB Default Texture",
        size: [1, 1],
        format: "rgba8unorm",
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
      });
      this.device.queue.writeTexture({ texture: this.albedoTexture }, new Uint8Array([255, 255, 255, 255]), { bytesPerRow: 4 }, [1, 1]);
      this.albedoTextureView = this.albedoTexture.createView();
    }
  }
  createPipeline() {
    if (!this.device || !this.globalResources)
      return;
    const shaderModule = this.device.createShaderModule({
      label: "InstancedGLB Shader",
      code: this.getShaderCode()
    });
    const bindGroupLayout = this.device.createBindGroupLayout({
      label: "InstancedGLB Bind Group Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "float" } },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "filtering" } }
      ]
    });
    const pipelineLayout = this.device.createPipelineLayout({
      label: "InstancedGLB Pipeline Layout",
      bindGroupLayouts: [
        this.globalResources.renderBindGroupLayout,
        bindGroupLayout
      ]
    });
    this.pipeline = this.device.createRenderPipeline({
      label: "InstancedGLB Render Pipeline",
      layout: pipelineLayout,
      vertex: {
        module: shaderModule,
        entryPoint: "vs_main",
        buffers: [
          {
            arrayStride: 32,
            stepMode: "vertex",
            attributes: [
              { shaderLocation: 0, offset: 0, format: "float32x3" },
              { shaderLocation: 1, offset: 12, format: "float32x3" },
              { shaderLocation: 2, offset: 24, format: "float32x2" }
            ]
          },
          {
            arrayStride: 48,
            stepMode: "instance",
            attributes: [
              { shaderLocation: 3, offset: 0, format: "float32x4" },
              { shaderLocation: 4, offset: 16, format: "float32x4" },
              { shaderLocation: 5, offset: 32, format: "float32x4" }
            ]
          }
        ]
      },
      fragment: {
        module: shaderModule,
        entryPoint: "fs_main",
        targets: [
          { format: "rgba16float" },
          { format: "rgba16float" },
          { format: "rgba16float" },
          { format: "rgba16float" },
          { format: "rg16float" }
        ]
      },
      primitive: {
        topology: "triangle-list",
        cullMode: this.config.doubleSided ? "none" : "back"
      },
      depthStencil: {
        format: "depth24plus",
        depthWriteEnabled: true,
        depthCompare: "less"
      },
      multisample: {
        count: 1,
        alphaToCoverageEnabled: false
      }
    });
    this.bindGroup = this.device.createBindGroup({
      label: "InstancedGLB Bind Group",
      layout: bindGroupLayout,
      entries: [
        { binding: 0, resource: { buffer: this.uniformBuffer } },
        { binding: 1, resource: this.albedoTextureView },
        { binding: 2, resource: this.sampler }
      ]
    });
  }
  createShadowPipeline() {
    if (!this.device)
      return;
    const shadowShaderCode = `
      struct ShadowUniforms {
        lightViewProj: mat4x4<f32>,
        alphaCutoff: f32,
        time: f32,
        windStrength: f32,
        windSpeed: f32,
      }

      @group(0) @binding(0) var<uniform> shadow: ShadowUniforms;
      @group(0) @binding(1) var albedoTexture: texture_2d<f32>;
      @group(0) @binding(2) var texSampler: sampler;

      struct VertexInput {
        @location(0) position: vec3f,
        @location(1) normal: vec3f,
        @location(2) uv: vec2f,
        @location(3) instancePosRot: vec4f,
        @location(4) instanceScale: vec4f,
        @location(5) instanceColor: vec4f,
      }

      struct VertexOutput {
        @builtin(position) position: vec4f,
        @location(0) uv: vec2f,
      }

      @vertex
      fn vs_main(input: VertexInput) -> VertexOutput {
        var output: VertexOutput;

        let instancePos = input.instancePosRot.xyz;
        let rotation = input.instancePosRot.w;
        let scale = input.instanceScale.xyz;

        // Rotation matrix (Y-axis)
        let cosR = cos(rotation);
        let sinR = sin(rotation);
        let rotMat = mat3x3f(
          vec3f(cosR, 0.0, sinR),
          vec3f(0.0, 1.0, 0.0),
          vec3f(-sinR, 0.0, cosR)
        );

        var localPos = input.position * scale;

        // Wind animation (same as main shader)
        if (shadow.windStrength > 0.0) {
          let windPhase = shadow.time * shadow.windSpeed + instancePos.x * 0.1 + instancePos.z * 0.1;
          let windOffset = sin(windPhase) * shadow.windStrength * localPos.y * 0.1;
          localPos.x += windOffset;
          localPos.z += windOffset * 0.3;
        }

        let worldPos = rotMat * localPos + instancePos;
        output.position = shadow.lightViewProj * vec4f(worldPos, 1.0);
        output.uv = input.uv;

        return output;
      }

      @fragment
      fn fs_main(input: VertexOutput) {
        let alpha = textureSample(albedoTexture, texSampler, input.uv).a;
        if (alpha < shadow.alphaCutoff) {
          discard;
        }
      }
    `;
    const shaderModule = this.device.createShaderModule({
      label: "InstancedGLB Shadow Shader",
      code: shadowShaderCode
    });
    this.shadowUniformBuffer = this.device.createBuffer({
      label: "InstancedGLB Shadow Uniform Buffer",
      size: 96,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.shadowPipeline = this.device.createRenderPipeline({
      label: "InstancedGLB Shadow Pipeline",
      layout: "auto",
      vertex: {
        module: shaderModule,
        entryPoint: "vs_main",
        buffers: [
          {
            arrayStride: 32,
            stepMode: "vertex",
            attributes: [
              { shaderLocation: 0, offset: 0, format: "float32x3" },
              { shaderLocation: 1, offset: 12, format: "float32x3" },
              { shaderLocation: 2, offset: 24, format: "float32x2" }
            ]
          },
          {
            arrayStride: 48,
            stepMode: "instance",
            attributes: [
              { shaderLocation: 3, offset: 0, format: "float32x4" },
              { shaderLocation: 4, offset: 16, format: "float32x4" },
              { shaderLocation: 5, offset: 32, format: "float32x4" }
            ]
          }
        ]
      },
      fragment: {
        module: shaderModule,
        entryPoint: "fs_main",
        targets: []
      },
      primitive: {
        topology: "triangle-list",
        cullMode: "none"
      },
      depthStencil: {
        format: "depth32float",
        depthWriteEnabled: true,
        depthCompare: "less"
      }
    });
    this.shadowBindGroup = this.device.createBindGroup({
      label: "InstancedGLB Shadow Bind Group",
      layout: this.shadowPipeline.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: { buffer: this.shadowUniformBuffer } },
        { binding: 1, resource: this.albedoTextureView },
        { binding: 2, resource: this.sampler }
      ]
    });
  }
  getShaderCode() {
    return `
      // Scene uniforms (group 0) - matches GlobalResources layout
      struct SceneUniforms {
        viewMatrix: mat4x4<f32>,
        projectionMatrix: mat4x4<f32>,
        lightViewProj: mat4x4<f32>,
        prevViewProj: mat4x4<f32>,
        inverseProjectionMatrix: mat4x4<f32>,
        cameraPosition: vec3f,
        time: f32,
        lightCount: u32,
        debugMode: u32,
        flags: u32,
        environmentIntensity: f32,
        fogColor: vec3f,
        fogDensity: f32,
        fogType: u32,
        fogSkyFalloff: f32,
        cloudShadowIntensity: f32,
        cloudShadowScale: f32,
        cloudShadowSpeed: f32,
        cloudShadowCoverage: f32,
        cloudShadowSoftness: f32,
        cloudShadowWindDir: f32,
        _padding: vec2f,
      }

      @group(0) @binding(0) var<uniform> scene: SceneUniforms;

      // Material uniforms (group 1)
      struct MaterialUniforms {
        time: f32,
        windStrength: f32,
        windSpeed: f32,
        alphaCutoff: f32,
        windDirX: f32,
        windDirZ: f32,
        _padding: vec2f,
      }

      @group(1) @binding(0) var<uniform> material: MaterialUniforms;
      @group(1) @binding(1) var albedoTexture: texture_2d<f32>;
      @group(1) @binding(2) var texSampler: sampler;

      struct VertexInput {
        @location(0) position: vec3f,
        @location(1) normal: vec3f,
        @location(2) uv: vec2f,
        // Instance data
        @location(3) instancePosRot: vec4f,  // position.xyz, rotation
        @location(4) instanceScale: vec4f,   // scale.xyz, unused
        @location(5) instanceColor: vec4f,   // color.rgb, unused
      }

      struct VertexOutput {
        @builtin(position) position: vec4f,
        @location(0) worldPosition: vec3f,
        @location(1) worldNormal: vec3f,
        @location(2) uv: vec2f,
        @location(3) color: vec3f,
      }

      struct FragmentInput {
        @builtin(position) position: vec4f,
        @builtin(front_facing) frontFacing: bool,
        @location(0) worldPosition: vec3f,
        @location(1) worldNormal: vec3f,
        @location(2) uv: vec2f,
        @location(3) color: vec3f,
      }

      @vertex
      fn vs_main(input: VertexInput) -> VertexOutput {
        var output: VertexOutput;

        // Extract instance data
        let instancePos = input.instancePosRot.xyz;
        let rotation = input.instancePosRot.w;
        let scale = input.instanceScale.xyz;
        let color = input.instanceColor.rgb;

        // Create rotation matrix (Y-axis only)
        let cosR = cos(rotation);
        let sinR = sin(rotation);
        let rotMat = mat3x3f(
          vec3f(cosR, 0.0, sinR),
          vec3f(0.0, 1.0, 0.0),
          vec3f(-sinR, 0.0, cosR)
        );

        // Apply scale, rotation, then translation
        var localPos = input.position * scale;

        // Wind animation (based on vertex height)
        if (material.windStrength > 0.0) {
          let windPhase = material.time * material.windSpeed + instancePos.x * 0.1 + instancePos.z * 0.1;
          let windOffset = sin(windPhase) * material.windStrength * localPos.y * 0.1;
          localPos.x += windOffset * material.windDirX;
          localPos.z += windOffset * material.windDirZ;
        }

        let worldPos = rotMat * localPos + instancePos;
        let worldNormal = rotMat * input.normal;

        output.worldPosition = worldPos;
        output.worldNormal = normalize(worldNormal);
        output.uv = input.uv;
        output.color = color;
        output.position = scene.projectionMatrix * scene.viewMatrix * vec4f(worldPos, 1.0);

        return output;
      }

      // G-Buffer output - must match GeometryPass color attachment order:
      // 0: albedo, 1: normal, 2: position, 3: emissive, 4: velocity
      struct GBufferOutput {
        @location(0) albedo: vec4f,
        @location(1) normal: vec4f,
        @location(2) position: vec4f,
        @location(3) emissive: vec4f,
        @location(4) velocity: vec2f,
      }

      @fragment
      fn fs_main(input: FragmentInput) -> GBufferOutput {
        var output: GBufferOutput;

        // Sample texture
        let texColor = textureSample(albedoTexture, texSampler, input.uv);

        // Alpha test
        if (texColor.a < material.alphaCutoff) {
          discard;
        }

        // Apply instance color tint
        let finalColor = texColor.rgb * input.color;

        // Two-sided lighting: flip normal for back faces
        var N = normalize(input.worldNormal);
        if (!input.frontFacing) {
          N = -N;
        }

        // Material properties for natural objects (grass, rocks, flowers)
        let roughness = 0.85;   // Rough, natural surface
        let metallic = 0.0;     // Non-metallic
        let occlusion = 1.0;    // No ambient occlusion
        let ambientIntensity = 1.0; // Full ambient light contribution

        // Write to G-Buffer (matching StandardMaterial format exactly)
        // albedo.a = roughness, normal.a = metallic, position.a = occlusion, emissive.a = ambientIntensity
        output.albedo = vec4f(finalColor, roughness);
        output.normal = vec4f(N * 0.5 + 0.5, metallic);
        output.position = vec4f(input.worldPosition, occlusion);
        output.emissive = vec4f(0.0, 0.0, 0.0, ambientIntensity);
        output.velocity = vec2f(0.0, 0.0);

        return output;
      }
    `;
  }
  addInstance(instance) {
    if (this.instances.length >= this.config.maxInstances) {
      console.warn(`[InstancedGLBMesh] Max instances (${this.config.maxInstances}) reached`);
      return;
    }
    this.instances.push(instance);
  }
  clearInstances() {
    this.instances = [];
    this.instanceCount = 0;
  }
  uploadInstances() {
    if (!this.device || !this.instanceBuffer || !this.instanceData)
      return;
    const count = this.instances.length;
    this.instanceCount = count;
    for (let i = 0;i < count; i++) {
      const inst = this.instances[i];
      const offset = i * INSTANCE_STRIDE2;
      this.instanceData[offset + 0] = inst.position.x;
      this.instanceData[offset + 1] = inst.position.y;
      this.instanceData[offset + 2] = inst.position.z;
      this.instanceData[offset + 3] = inst.rotation;
      if (typeof inst.scale === "number") {
        this.instanceData[offset + 4] = inst.scale;
        this.instanceData[offset + 5] = inst.scale;
        this.instanceData[offset + 6] = inst.scale;
      } else {
        this.instanceData[offset + 4] = inst.scale.x;
        this.instanceData[offset + 5] = inst.scale.y;
        this.instanceData[offset + 6] = inst.scale.z;
      }
      this.instanceData[offset + 7] = 0;
      this.instanceData[offset + 8] = inst.color.x;
      this.instanceData[offset + 9] = inst.color.y;
      this.instanceData[offset + 10] = inst.color.z;
      this.instanceData[offset + 11] = 0;
    }
    this.device.queue.writeBuffer(this.instanceBuffer, 0, this.instanceData.buffer, 0, count * INSTANCE_STRIDE2 * 4);
  }
  update(deltaTime) {
    this.time += deltaTime;
    if (!this.device || !this.uniformBuffer)
      return;
    const uniformData = new Float32Array([
      this.time,
      this.config.windEnabled ? this.config.windStrength : 0,
      this.config.windSpeed,
      this.config.alphaCutoff,
      1,
      0.3,
      0,
      0
    ]);
    this.device.queue.writeBuffer(this.uniformBuffer, 0, uniformData);
  }
  render(passEncoder, globalBindGroup) {
    if (!this.initialized || !this.pipeline || !this.bindGroup)
      return;
    if (this.instanceCount === 0)
      return;
    passEncoder.setPipeline(this.pipeline);
    passEncoder.setBindGroup(0, globalBindGroup);
    passEncoder.setBindGroup(1, this.bindGroup);
    passEncoder.setVertexBuffer(0, this.vertexBuffer);
    passEncoder.setVertexBuffer(1, this.instanceBuffer);
    if (this.indexBuffer) {
      passEncoder.setIndexBuffer(this.indexBuffer, this.indexFormat);
      passEncoder.drawIndexed(this.indexCount, this.instanceCount);
    } else {
      passEncoder.draw(this.vertexCount, this.instanceCount);
    }
  }
  renderShadow(passEncoder, lightViewProj) {
    if (!this.initialized || !this.shadowPipeline || !this.shadowBindGroup || !this.device)
      return;
    if (this.instanceCount === 0)
      return;
    const shadowUniforms = new Float32Array(24);
    shadowUniforms.set(lightViewProj, 0);
    shadowUniforms[16] = this.config.alphaCutoff;
    shadowUniforms[17] = this.time;
    shadowUniforms[18] = this.config.windEnabled ? this.config.windStrength : 0;
    shadowUniforms[19] = this.config.windSpeed;
    this.device.queue.writeBuffer(this.shadowUniformBuffer, 0, shadowUniforms);
    passEncoder.setPipeline(this.shadowPipeline);
    passEncoder.setBindGroup(0, this.shadowBindGroup);
    passEncoder.setVertexBuffer(0, this.vertexBuffer);
    passEncoder.setVertexBuffer(1, this.instanceBuffer);
    if (this.indexBuffer) {
      passEncoder.setIndexBuffer(this.indexBuffer, this.indexFormat);
      passEncoder.drawIndexed(this.indexCount, this.instanceCount);
    } else {
      passEncoder.draw(this.vertexCount, this.instanceCount);
    }
  }
  getInstanceCount() {
    return this.instanceCount;
  }
  setWind(enabled, strength, speed) {
    this.config.windEnabled = enabled;
    if (strength !== undefined)
      this.config.windStrength = strength;
    if (speed !== undefined)
      this.config.windSpeed = speed;
  }
  destroy() {
    this.instanceBuffer?.destroy();
    this.vertexBuffer?.destroy();
    this.indexBuffer?.destroy();
    this.uniformBuffer?.destroy();
    this.instanceBuffer = null;
    this.vertexBuffer = null;
    this.indexBuffer = null;
    this.uniformBuffer = null;
    this.pipeline = null;
    this.bindGroup = null;
    this.device = null;
    this.initialized = false;
    this.instances = [];
    this.instanceData = null;
  }
}

// ../../src/core/InstancedMesh.ts
var FLOATS_PER_INSTANCE = 12;
var BYTES_PER_INSTANCE = FLOATS_PER_INSTANCE * 4;

class InstancedMesh extends Node {
  geometry;
  material;
  maxInstances;
  instanceBuffer = null;
  _instanceCount = 0;
  instances = [];
  instanceData = null;
  dirty = false;
  constructor(geometry, material, maxInstances) {
    super();
    this.geometry = geometry;
    this.material = material;
    this.maxInstances = maxInstances;
  }
  init(device) {
    this.instanceBuffer = device.createBuffer({
      label: `InstancedMesh Instance Buffer (${this.maxInstances} max)`,
      size: this.maxInstances * BYTES_PER_INSTANCE,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
    });
    this.instanceData = new Float32Array(this.maxInstances * FLOATS_PER_INSTANCE);
  }
  addInstance(data) {
    if (this.instances.length >= this.maxInstances) {
      console.warn(`[InstancedMesh] Max instances (${this.maxInstances}) reached`);
      return;
    }
    this.instances.push({
      position: data.position,
      rotation: data.rotation,
      scale: data.scale,
      color: data.color ?? new Vector3(1, 1, 1)
    });
    this.dirty = true;
  }
  clearInstances() {
    this.instances = [];
    this._instanceCount = 0;
    this.dirty = true;
  }
  uploadInstances(device) {
    if (!this.instanceBuffer || !this.instanceData) {
      console.warn("[InstancedMesh] Not initialized");
      return;
    }
    const count = this.instances.length;
    this._instanceCount = count;
    if (count === 0)
      return;
    for (let i = 0;i < count; i++) {
      const inst = this.instances[i];
      const offset = i * FLOATS_PER_INSTANCE;
      this.instanceData[offset + 0] = inst.position.x;
      this.instanceData[offset + 1] = inst.position.y;
      this.instanceData[offset + 2] = inst.position.z;
      this.instanceData[offset + 3] = inst.rotation;
      if (typeof inst.scale === "number") {
        this.instanceData[offset + 4] = inst.scale;
        this.instanceData[offset + 5] = inst.scale;
        this.instanceData[offset + 6] = inst.scale;
      } else {
        this.instanceData[offset + 4] = inst.scale.x;
        this.instanceData[offset + 5] = inst.scale.y;
        this.instanceData[offset + 6] = inst.scale.z;
      }
      this.instanceData[offset + 7] = 0;
      const color = inst.color ?? new Vector3(1, 1, 1);
      this.instanceData[offset + 8] = color.x;
      this.instanceData[offset + 9] = color.y;
      this.instanceData[offset + 10] = color.z;
      this.instanceData[offset + 11] = 0;
    }
    this.dirty = false;
  }
  _writeToGPU(device) {
    if (!this.instanceBuffer || !this.instanceData || this._instanceCount === 0)
      return;
    device.queue.writeBuffer(this.instanceBuffer, 0, this.instanceData.buffer, 0, this._instanceCount * BYTES_PER_INSTANCE);
  }
  get instanceCount() {
    return this._instanceCount;
  }
  get isDirty() {
    return this.dirty;
  }
  destroy() {
    this.instanceBuffer?.destroy();
    this.instanceBuffer = null;
    this.instanceData = null;
    this.instances = [];
    this._instanceCount = 0;
  }
  getDebugInstanceData() {
    if (!this.instanceData || this._instanceCount === 0)
      return null;
    const result = [];
    const numToShow = Math.min(3, this._instanceCount);
    for (let i = 0;i < numToShow; i++) {
      const offset = i * FLOATS_PER_INSTANCE;
      result.push({
        position: [
          this.instanceData[offset + 0],
          this.instanceData[offset + 1],
          this.instanceData[offset + 2]
        ],
        rotation: this.instanceData[offset + 3],
        scale: [
          this.instanceData[offset + 4],
          this.instanceData[offset + 5],
          this.instanceData[offset + 6]
        ]
      });
    }
    return result;
  }
}

// ../../src/core/renderer/GeometryPass.ts
class GeometryPass {
  gBuffer;
  static hasLoggedPipeline = false;
  static hasLoggedBindGroup = false;
  static hasLoggedSkinnedPipeline = false;
  hasLoggedExecution = false;
  frustum = new Frustum;
  viewProjectionMatrix = new Matrix4;
  skinnedPipelines = new Map;
  skeletonBindGroupLayout = null;
  morphedPipelines = new Map;
  morphTargetBindGroupLayout = null;
  static hasLoggedMorphedPipeline = false;
  static hasLoggedMorphedMesh = false;
  instancedPipelines = new Map;
  instancedBindGroups = new WeakMap;
  static hasLoggedInstancedPipeline = false;
  constructor(gBuffer) {
    this.gBuffer = gBuffer;
  }
  init(device, context, presentationFormat) {}
  resize(width, height) {
    console.log(`GeometryPass: Resizing GBuffer to ${width}x${height}`);
    this.gBuffer.resize(width, height);
  }
  execute(commandEncoder, context, globalResources) {
    const needsVelocity = !this.gBuffer.useComputedVelocity;
    if (!this.gBuffer.albedoTexture || !this.gBuffer.normalTexture || !this.gBuffer.positionTexture || !this.gBuffer.emissiveTexture || !this.gBuffer.depthTexture || needsVelocity && !this.gBuffer.velocityTexture) {
      console.warn("GeometryPass: GBuffer textures not initialized");
      return;
    }
    if (!globalResources.renderBindGroup) {
      console.warn("GeometryPass: Global render bind group not initialized");
      return;
    }
    const { scene } = context;
    if (!this.hasLoggedExecution) {
      console.log("GeometryPass: Depth Texture Debug", {
        format: this.gBuffer.depthTexture.format,
        width: this.gBuffer.depthTexture.width,
        height: this.gBuffer.depthTexture.height,
        usage: this.gBuffer.depthTexture.usage,
        depthOrArrayLayers: this.gBuffer.depthTexture.depthOrArrayLayers,
        mipLevelCount: this.gBuffer.depthTexture.mipLevelCount
      });
    }
    const useFrustumCulling = scene.render.frustumCulling;
    if (useFrustumCulling) {
      this.viewProjectionMatrix.multiplyMatrices(context.camera.projectionMatrix, context.camera.viewMatrix);
      this.frustum.setFromProjectionMatrix(this.viewProjectionMatrix);
    }
    let meshCount = 0;
    const meshesToRender = [];
    const grassToRender = [];
    const flowersToRender = [];
    const instancedGLBToRender = [];
    const instancedMeshesToRender = [];
    const activeSubScene = context.activeSubScene;
    scene.traverse((node) => {
      if (!node.visible)
        return false;
      if (node instanceof SubScene) {
        if (activeSubScene && node === activeSubScene) {
          return;
        }
        return false;
      }
      const isDeferredMaterial = node instanceof Mesh && (node.material instanceof StandardMaterial || node.material instanceof TerrainMaterial);
      if (isDeferredMaterial) {
        const material = node.material;
        if (material.getRenderingPath() === "deferred") {
          if (useFrustumCulling) {
            const bounds = node.worldBounds;
            if (!this.frustum.intersectsBox(bounds.min.x, bounds.min.y, bounds.min.z, bounds.max.x, bounds.max.y, bounds.max.z)) {
              return;
            }
          }
          meshesToRender.push(node);
        }
      } else if (node instanceof Grass) {
        grassToRender.push(node);
      } else if (node instanceof Flower) {
        flowersToRender.push(node);
      } else if (node instanceof InstancedMesh) {
        if (node.instanceCount > 0) {
          instancedMeshesToRender.push(node);
        }
      } else if (node instanceof InstancedGLBMesh) {
        instancedGLBToRender.push(node);
      }
    });
    const colorAttachments = [
      { view: this.gBuffer.albedoTexture.createView(), clearValue: { r: 0, g: 0, b: 0, a: 0 }, loadOp: "clear", storeOp: "store" },
      { view: this.gBuffer.normalTexture.createView(), clearValue: { r: 0, g: 0, b: 0, a: 0 }, loadOp: "clear", storeOp: "store" },
      { view: this.gBuffer.positionTexture.createView(), clearValue: { r: 0, g: 0, b: 0, a: 0 }, loadOp: "clear", storeOp: "store" },
      { view: this.gBuffer.emissiveTexture.createView(), clearValue: { r: 0, g: 0, b: 0, a: 0 }, loadOp: "clear", storeOp: "store" }
    ];
    if (needsVelocity) {
      colorAttachments.push({ view: this.gBuffer.velocityTexture.createView(), clearValue: { r: 0, g: 0, b: 0, a: 0 }, loadOp: "clear", storeOp: "store" });
    }
    const passDescriptor = {
      colorAttachments,
      depthStencilAttachment: {
        view: this.gBuffer.depthTexture.createView(),
        depthClearValue: 1,
        depthLoadOp: "clear",
        depthStoreOp: "store"
      }
    };
    const passEncoder = commandEncoder.beginRenderPass(passDescriptor);
    passEncoder.setBindGroup(0, globalResources.renderBindGroup);
    for (const mesh of meshesToRender) {
      this.renderMesh(mesh, context, passEncoder, globalResources);
      meshCount++;
    }
    for (const grass of grassToRender) {
      grass.render(passEncoder, globalResources.renderBindGroup);
    }
    for (const flower of flowersToRender) {
      flower.render(passEncoder, globalResources.renderBindGroup);
    }
    for (const instancedGLB of instancedGLBToRender) {
      instancedGLB.render(passEncoder, globalResources.renderBindGroup);
      if (context.frameStats) {
        context.frameStats.drawCalls++;
      }
    }
    for (const instancedMesh of instancedMeshesToRender) {
      this.renderInstancedMesh(instancedMesh, context, passEncoder, globalResources);
    }
    passEncoder.end();
    if (!this.hasLoggedExecution) {
      console.log(`GeometryPass: Rendered ${meshCount} deferred meshes, ${grassToRender.length} grass fields, ${flowersToRender.length} flower fields, ${instancedGLBToRender.length} instanced GLB meshes, ${instancedMeshesToRender.length} proper instanced meshes`);
      this.hasLoggedExecution = true;
    }
  }
  static hasLoggedSkinnedMesh = false;
  renderMesh(mesh, context, passEncoder, globalResources) {
    const device = this.gBuffer.device;
    if (!device)
      return;
    if (mesh instanceof SkinnedMesh && mesh.skeleton) {
      if (!GeometryPass.hasLoggedSkinnedMesh) {
        console.log("GeometryPass: Rendering skinned mesh:", mesh.name);
        GeometryPass.hasLoggedSkinnedMesh = true;
      }
      this.renderSkinnedMesh(mesh, context, passEncoder, globalResources);
      return;
    }
    if (mesh instanceof MorphTargetMesh && mesh.morphTargetCount > 0) {
      if (!GeometryPass.hasLoggedMorphedMesh) {
        console.log("GeometryPass: Rendering morph target mesh:", mesh.name);
        GeometryPass.hasLoggedMorphedMesh = true;
      }
      this.renderMorphTargetMesh(mesh, context, passEncoder, globalResources);
      return;
    }
    const hasVertexBuffers = Object.keys(mesh.geometry.attributes).every((name12) => mesh.geometry.vertexBuffers[name12]);
    const needsInit = mesh.geometry.buffersDirty || !hasVertexBuffers;
    if (needsInit) {
      this.initGeometryBuffers(device, mesh.geometry);
      return;
    }
    if (!mesh.material.pipeline) {
      this.initMaterialPipeline(device, mesh.material, mesh.geometry, globalResources);
    }
    if (!mesh.uniformBuffer || !mesh.bindGroup) {
      this.initMeshUniforms(device, mesh);
    }
    this.updateMeshUniforms(device, mesh, context);
    if (mesh.material.pipeline && mesh.bindGroup) {
      passEncoder.setPipeline(mesh.material.pipeline);
      passEncoder.setBindGroup(1, mesh.bindGroup);
      if (mesh.geometry.vertexBuffers["position"]) {
        passEncoder.setVertexBuffer(0, mesh.geometry.vertexBuffers["position"]);
      }
      if (mesh.geometry.vertexBuffers["normal"]) {
        passEncoder.setVertexBuffer(1, mesh.geometry.vertexBuffers["normal"]);
      }
      if (mesh.geometry.vertexBuffers["uv"]) {
        passEncoder.setVertexBuffer(2, mesh.geometry.vertexBuffers["uv"]);
      }
      const useIndirect = context.scene.render.indirectDraw;
      if (mesh.geometry.indexBuffer) {
        const indexFormat = mesh.geometry.indices instanceof Uint32Array ? "uint32" : "uint16";
        passEncoder.setIndexBuffer(mesh.geometry.indexBuffer, indexFormat);
        if (useIndirect) {
          const offset = mesh.renderIndex * IndirectDrawBuffer.STRIDE;
          passEncoder.drawIndexedIndirect(globalResources.indirectDrawBuffer.buffer, offset);
        } else {
          passEncoder.drawIndexed(mesh.geometry.indexCount, 1, 0, 0, mesh.renderIndex);
        }
      } else {
        if (useIndirect) {
          const offset = mesh.renderIndex * IndirectDrawBuffer.STRIDE;
          passEncoder.drawIndirect(globalResources.indirectDrawBuffer.buffer, offset);
        } else {
          passEncoder.draw(mesh.geometry.vertexCount, 1, 0, mesh.renderIndex);
        }
      }
      if (context.frameStats) {
        context.frameStats.drawCalls++;
        context.frameStats.triangles += mesh.geometry.triangleCount;
      }
    }
  }
  renderInstancedMesh(instancedMesh, context, passEncoder, globalResources) {
    const device = this.gBuffer.device;
    if (!device)
      return;
    const { geometry, material } = instancedMesh;
    const needsGeomInit = geometry.buffersDirty || Object.keys(geometry.attributes).some((name12) => !geometry.vertexBuffers[name12]);
    if (needsGeomInit) {
      this.initGeometryBuffers(device, geometry);
      return;
    }
    if (!instancedMesh.instanceBuffer) {
      console.warn("GeometryPass: InstancedMesh instance buffer not initialized");
      return;
    }
    instancedMesh._writeToGPU(device);
    const pipelineKey = `instanced_${material.getTextureFlags()}_${material.doubleSided ? "ds" : "ss"}`;
    let pipeline = this.instancedPipelines.get(pipelineKey);
    if (!pipeline) {
      if (!GeometryPass.hasLoggedInstancedPipeline) {
        console.log("GeometryPass: Creating instanced pipeline for", pipelineKey);
        GeometryPass.hasLoggedInstancedPipeline = true;
      }
      pipeline = this.initInstancedPipeline(device, material, geometry, globalResources) ?? undefined;
      if (pipeline) {
        this.instancedPipelines.set(pipelineKey, pipeline);
      } else {
        console.error("GeometryPass: Failed to create instanced pipeline!");
        return;
      }
    }
    let bindGroup = this.instancedBindGroups.get(instancedMesh);
    if (!bindGroup) {
      const uniformBuffer = device.createBuffer({
        label: "InstancedMesh Material Uniform Buffer",
        size: material.getUniformBufferSize(),
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
      });
      const materialLayout = material.createBindGroupLayout(device);
      bindGroup = device.createBindGroup({
        label: "InstancedMesh Material Bind Group",
        layout: materialLayout,
        entries: material.getBindGroupEntries(device, uniformBuffer)
      });
      this.instancedBindGroups.set(instancedMesh, bindGroup);
      material.updateUniforms(device, uniformBuffer, 0, context);
    }
    passEncoder.setPipeline(pipeline);
    passEncoder.setBindGroup(1, bindGroup);
    if (geometry.vertexBuffers["position"]) {
      passEncoder.setVertexBuffer(0, geometry.vertexBuffers["position"]);
    }
    if (geometry.vertexBuffers["normal"]) {
      passEncoder.setVertexBuffer(1, geometry.vertexBuffers["normal"]);
    }
    if (geometry.vertexBuffers["uv"]) {
      passEncoder.setVertexBuffer(2, geometry.vertexBuffers["uv"]);
    }
    passEncoder.setVertexBuffer(3, instancedMesh.instanceBuffer);
    if (geometry.indexBuffer) {
      const indexFormat = geometry.indices instanceof Uint32Array ? "uint32" : "uint16";
      passEncoder.setIndexBuffer(geometry.indexBuffer, indexFormat);
      passEncoder.drawIndexed(geometry.indexCount, instancedMesh.instanceCount);
    } else {
      passEncoder.draw(geometry.vertexCount, instancedMesh.instanceCount);
    }
    if (context.frameStats) {
      context.frameStats.drawCalls++;
      context.frameStats.triangles += geometry.triangleCount * instancedMesh.instanceCount;
    }
  }
  initInstancedPipeline(device, material, geometry, globalResources) {
    const includeVelocity = !this.gBuffer.useComputedVelocity;
    const vertexShader = material.getInstancedVertexShader("deferred");
    const fragmentShader = material.getInstancedFragmentShader("deferred");
    const vertexModule = createShaderModuleSafe(device, {
      label: "Instanced Material Vertex Shader",
      code: vertexShader
    });
    const fragmentModule = createShaderModuleSafe(device, {
      label: "Instanced Material Fragment Shader",
      code: fragmentShader
    });
    const buffers = [
      {
        arrayStride: 3 * 4,
        attributes: [{ shaderLocation: 0, offset: 0, format: "float32x3" }]
      },
      {
        arrayStride: 3 * 4,
        attributes: [{ shaderLocation: 1, offset: 0, format: "float32x3" }]
      },
      {
        arrayStride: 2 * 4,
        attributes: [{ shaderLocation: 2, offset: 0, format: "float32x2" }]
      },
      {
        arrayStride: 48,
        stepMode: "instance",
        attributes: [
          { shaderLocation: 3, offset: 0, format: "float32x4" },
          { shaderLocation: 4, offset: 16, format: "float32x4" },
          { shaderLocation: 5, offset: 32, format: "float32x4" }
        ]
      }
    ];
    const materialLayout = material.createBindGroupLayout(device);
    const pipelineLayout = device.createPipelineLayout({
      label: "Instanced Deferred Pipeline Layout",
      bindGroupLayouts: [
        globalResources.renderBindGroupLayout,
        materialLayout
      ]
    });
    const colorTargets = [
      { format: "rgba16float" },
      { format: "rgba16float" },
      { format: "rgba16float" },
      { format: "rgba16float" }
    ];
    if (includeVelocity) {
      colorTargets.push({ format: "rg16float" });
    }
    try {
      return device.createRenderPipeline({
        label: "Instanced Deferred Geometry Pipeline",
        layout: pipelineLayout,
        vertex: {
          module: vertexModule,
          entryPoint: "vs_main",
          buffers
        },
        fragment: {
          module: fragmentModule,
          entryPoint: "fs_main",
          targets: colorTargets
        },
        primitive: {
          topology: "triangle-list",
          cullMode: material.doubleSided ? "none" : "back"
        },
        depthStencil: {
          depthWriteEnabled: true,
          depthCompare: "less",
          format: "depth24plus"
        }
      });
    } catch (e) {
      console.error("GeometryPass: Failed to create instanced pipeline:", e);
      return null;
    }
  }
  renderSkinnedMesh(mesh, context, passEncoder, globalResources) {
    const device = this.gBuffer.device;
    if (!device || !mesh.skeleton)
      return;
    const needsInit = mesh.geometry.buffersDirty || Object.keys(mesh.geometry.attributes).some((name12) => !mesh.geometry.vertexBuffers[name12]);
    if (needsInit) {
      this.initGeometryBuffers(device, mesh.geometry);
      return;
    }
    mesh.prepareSkinning(device);
    if (!GeometryPass.hasLoggedSkinnedPipeline) {
      console.log("GeometryPass: Skinned mesh buffers:", {
        jointsBuffer: !!mesh.jointsBuffer,
        weightsBuffer: !!mesh.weightsBuffer,
        skeletonBuffer: !!mesh.skeleton.boneMatricesBuffer
      });
    }
    const material = mesh.material;
    const pipelineKey = `skinned_${material.constructor.name}_${material.getTextureFlags()}`;
    let pipeline = this.skinnedPipelines.get(pipelineKey);
    if (!pipeline) {
      console.log("GeometryPass: Creating skinned pipeline for", pipelineKey);
      pipeline = this.initSkinnedPipeline(device, material, mesh.geometry, globalResources) ?? undefined;
      if (pipeline) {
        this.skinnedPipelines.set(pipelineKey, pipeline);
        console.log("GeometryPass: Skinned pipeline created successfully");
      } else {
        console.error("GeometryPass: Failed to create skinned pipeline!");
      }
    }
    if (!pipeline)
      return;
    if (!mesh.uniformBuffer || !mesh.bindGroup) {
      this.initMeshUniforms(device, mesh, true);
    }
    this.updateMeshUniforms(device, mesh, context);
    if (!this.skeletonBindGroupLayout) {
      this.skeletonBindGroupLayout = Skeleton.createBindGroupLayout(device);
    }
    if (!mesh.skeleton.bindGroup) {
      mesh.skeleton.createBindGroup(device, this.skeletonBindGroupLayout);
    }
    if (!mesh.bindGroup || !mesh.skeleton.bindGroup)
      return;
    passEncoder.setPipeline(pipeline);
    passEncoder.setBindGroup(1, mesh.bindGroup);
    passEncoder.setBindGroup(2, mesh.skeleton.bindGroup);
    if (mesh.geometry.vertexBuffers["position"]) {
      passEncoder.setVertexBuffer(0, mesh.geometry.vertexBuffers["position"]);
    }
    if (mesh.geometry.vertexBuffers["normal"]) {
      passEncoder.setVertexBuffer(1, mesh.geometry.vertexBuffers["normal"]);
    }
    if (mesh.geometry.vertexBuffers["uv"]) {
      passEncoder.setVertexBuffer(2, mesh.geometry.vertexBuffers["uv"]);
    }
    if (mesh.jointsBuffer) {
      passEncoder.setVertexBuffer(3, mesh.jointsBuffer);
    }
    if (mesh.weightsBuffer) {
      passEncoder.setVertexBuffer(4, mesh.weightsBuffer);
    }
    if (mesh.geometry.indexBuffer) {
      const indexFormat = mesh.geometry.indices instanceof Uint32Array ? "uint32" : "uint16";
      passEncoder.setIndexBuffer(mesh.geometry.indexBuffer, indexFormat);
      passEncoder.drawIndexed(mesh.geometry.indexCount, 1, 0, 0, mesh.renderIndex);
    } else {
      passEncoder.draw(mesh.geometry.vertexCount, 1, 0, mesh.renderIndex);
    }
    if (context.frameStats) {
      context.frameStats.drawCalls++;
      context.frameStats.triangles += mesh.geometry.triangleCount;
    }
  }
  initSkinnedPipeline(device, material, geometry, globalResources) {
    const includeVelocity = !this.gBuffer.useComputedVelocity;
    const baseVertexShader = material.getVertexShader("deferred", { includeVelocity });
    const skinnedVertexShader = createSkinnedVertexShader(baseVertexShader);
    const vertexModule = createShaderModuleSafe(device, {
      label: "Skinned Material Vertex Shader",
      code: skinnedVertexShader
    });
    const fragmentModule = createShaderModuleSafe(device, {
      label: "Standard Material Fragment Shader (Skinned)",
      code: material.getFragmentShader("deferred", { includeVelocity })
    });
    const buffers = [
      {
        arrayStride: 3 * 4,
        attributes: [{ shaderLocation: 0, offset: 0, format: "float32x3" }]
      },
      {
        arrayStride: 3 * 4,
        attributes: [{ shaderLocation: 1, offset: 0, format: "float32x3" }]
      },
      {
        arrayStride: 2 * 4,
        attributes: [{ shaderLocation: 2, offset: 0, format: "float32x2" }]
      },
      {
        arrayStride: 4 * 4,
        attributes: [{ shaderLocation: 3, offset: 0, format: "uint32x4" }]
      },
      {
        arrayStride: 4 * 4,
        attributes: [{ shaderLocation: 4, offset: 0, format: "float32x4" }]
      }
    ];
    if (!this.skeletonBindGroupLayout) {
      this.skeletonBindGroupLayout = Skeleton.createBindGroupLayout(device);
    }
    const materialLayout = material.createBindGroupLayout(device);
    const pipelineLayout = device.createPipelineLayout({
      label: "Skinned Deferred Pipeline Layout",
      bindGroupLayouts: [
        globalResources.renderBindGroupLayout,
        materialLayout,
        this.skeletonBindGroupLayout
      ]
    });
    if (!GeometryPass.hasLoggedSkinnedPipeline) {
      console.log("GeometryPass: Creating skinned pipeline for skeletal animation");
      GeometryPass.hasLoggedSkinnedPipeline = true;
    }
    if (!GeometryPass.hasLoggedSkinnedPipeline) {
      console.log("GeometryPass: Skinned vertex shader (first 500 chars):", skinnedVertexShader.substring(0, 500));
      GeometryPass.hasLoggedSkinnedPipeline = true;
    }
    try {
      return device.createRenderPipeline({
        label: "Skinned Deferred Geometry Pipeline",
        layout: pipelineLayout,
        vertex: {
          module: vertexModule,
          entryPoint: "vs_main",
          buffers
        },
        fragment: {
          module: fragmentModule,
          entryPoint: "fs_main",
          targets: this.gBuffer.useComputedVelocity ? [
            { format: "rgba16float" },
            { format: "rgba16float" },
            { format: "rgba16float" },
            { format: this.gBuffer.emissiveFormat }
          ] : [
            { format: "rgba16float" },
            { format: "rgba16float" },
            { format: "rgba16float" },
            { format: this.gBuffer.emissiveFormat },
            { format: "rg16float" }
          ]
        },
        primitive: {
          topology: "triangle-list",
          cullMode: "none"
        },
        depthStencil: {
          depthWriteEnabled: true,
          depthCompare: "less",
          format: "depth24plus"
        }
      });
    } catch (e) {
      console.error("GeometryPass: Failed to create skinned pipeline:", e);
      console.error("GeometryPass: Skinned vertex shader:", skinnedVertexShader);
      return null;
    }
  }
  renderMorphTargetMesh(mesh, context, passEncoder, globalResources) {
    const device = this.gBuffer.device;
    if (!device)
      return;
    const material = mesh.material;
    const geometry = mesh.geometry;
    const needsInit = geometry.buffersDirty || Object.keys(geometry.attributes).some((name12) => !geometry.vertexBuffers[name12]);
    if (needsInit) {
      this.initGeometryBuffers(device, geometry);
    }
    mesh.prepareMorph(device);
    const pipelineKey = `morphed_${material.constructor.name}_${material.getTextureFlags()}_${mesh.morphTargetCount}`;
    let pipeline = this.morphedPipelines.get(pipelineKey);
    if (!pipeline) {
      pipeline = this.initMorphedPipeline(device, material, geometry, mesh.morphTargetCount, globalResources) ?? undefined;
      if (pipeline) {
        this.morphedPipelines.set(pipelineKey, pipeline);
        console.log("GeometryPass: Morphed pipeline created successfully");
      } else {
        console.error("GeometryPass: Failed to create morphed pipeline!");
      }
    }
    if (!pipeline)
      return;
    if (!mesh.uniformBuffer || !mesh.bindGroup) {
      this.initMeshUniforms(device, mesh, false);
    }
    this.updateMeshUniforms(device, mesh, context);
    if (!this.morphTargetBindGroupLayout) {
      this.morphTargetBindGroupLayout = MorphTargets.createBindGroupLayout(device);
    }
    if (!mesh.morphTargets.bindGroup) {
      mesh.morphTargets.createBindGroup(device, this.morphTargetBindGroupLayout);
    }
    if (!mesh.bindGroup || !mesh.morphTargets.bindGroup)
      return;
    passEncoder.setPipeline(pipeline);
    passEncoder.setBindGroup(1, mesh.bindGroup);
    passEncoder.setBindGroup(2, mesh.morphTargets.bindGroup);
    if (geometry.vertexBuffers["position"]) {
      passEncoder.setVertexBuffer(0, geometry.vertexBuffers["position"]);
    }
    if (geometry.vertexBuffers["normal"]) {
      passEncoder.setVertexBuffer(1, geometry.vertexBuffers["normal"]);
    }
    if (geometry.vertexBuffers["uv"]) {
      passEncoder.setVertexBuffer(2, geometry.vertexBuffers["uv"]);
    }
    if (geometry.indexBuffer) {
      const indexFormat = geometry.indices instanceof Uint32Array ? "uint32" : "uint16";
      passEncoder.setIndexBuffer(geometry.indexBuffer, indexFormat);
      passEncoder.drawIndexed(geometry.indexCount, 1, 0, 0, mesh.renderIndex);
    } else {
      passEncoder.draw(geometry.vertexCount, 1, 0, mesh.renderIndex);
    }
    if (context.frameStats) {
      context.frameStats.drawCalls++;
      context.frameStats.triangles += geometry.triangleCount;
    }
  }
  initMorphedPipeline(device, material, geometry, targetCount, globalResources) {
    const includeVelocity = !this.gBuffer.useComputedVelocity;
    const baseVertexShader = material.getVertexShader("deferred", { includeVelocity });
    const morphedVertexShader = createMorphedVertexShader(baseVertexShader, targetCount);
    const vertexModule = createShaderModuleSafe(device, {
      label: "Morphed Material Vertex Shader",
      code: morphedVertexShader
    });
    const fragmentModule = createShaderModuleSafe(device, {
      label: "Standard Material Fragment Shader (Morphed)",
      code: material.getFragmentShader("deferred", { includeVelocity })
    });
    const buffers = [
      {
        arrayStride: 3 * 4,
        attributes: [{ shaderLocation: 0, offset: 0, format: "float32x3" }]
      },
      {
        arrayStride: 3 * 4,
        attributes: [{ shaderLocation: 1, offset: 0, format: "float32x3" }]
      },
      {
        arrayStride: 2 * 4,
        attributes: [{ shaderLocation: 2, offset: 0, format: "float32x2" }]
      }
    ];
    if (!this.morphTargetBindGroupLayout) {
      this.morphTargetBindGroupLayout = MorphTargets.createBindGroupLayout(device);
    }
    const materialLayout = material.createBindGroupLayout(device);
    const pipelineLayout = device.createPipelineLayout({
      label: "Morphed Deferred Pipeline Layout",
      bindGroupLayouts: [
        globalResources.renderBindGroupLayout,
        materialLayout,
        this.morphTargetBindGroupLayout
      ]
    });
    if (!GeometryPass.hasLoggedMorphedPipeline) {
      console.log("GeometryPass: Creating morphed pipeline for morph targets");
      GeometryPass.hasLoggedMorphedPipeline = true;
    }
    try {
      return device.createRenderPipeline({
        label: "Morphed Deferred Geometry Pipeline",
        layout: pipelineLayout,
        vertex: {
          module: vertexModule,
          entryPoint: "vs_main",
          buffers
        },
        fragment: {
          module: fragmentModule,
          entryPoint: "fs_main",
          targets: this.gBuffer.useComputedVelocity ? [
            { format: "rgba16float" },
            { format: "rgba16float" },
            { format: "rgba16float" },
            { format: this.gBuffer.emissiveFormat }
          ] : [
            { format: "rgba16float" },
            { format: "rgba16float" },
            { format: "rgba16float" },
            { format: this.gBuffer.emissiveFormat },
            { format: "rg16float" }
          ]
        },
        primitive: {
          topology: "triangle-list",
          cullMode: "none"
        },
        depthStencil: {
          depthWriteEnabled: true,
          depthCompare: "less",
          format: "depth24plus"
        }
      });
    } catch (e) {
      console.error("GeometryPass: Failed to create morphed pipeline:", e);
      console.error("GeometryPass: Morphed vertex shader:", morphedVertexShader);
      return null;
    }
  }
  initGeometryBuffers(device, geometry) {
    if (geometry.buffersDirty) {
      for (const key in geometry.vertexBuffers) {
        geometry.vertexBuffers[key]?.destroy();
        delete geometry.vertexBuffers[key];
      }
      if (geometry.indexBuffer) {
        geometry.indexBuffer.destroy();
        geometry.indexBuffer = null;
      }
    }
    for (const [name12, data] of Object.entries(geometry.attributes)) {
      if (!geometry.vertexBuffers[name12]) {
        geometry.vertexBuffers[name12] = createBufferWithData(device, data, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST, `${name12} Buffer`);
      }
    }
    if (!geometry.attributes["normal"] && !geometry.vertexBuffers["normal"] && geometry.attributes["position"]) {
      const vertexCount = geometry.attributes["position"].length / 3;
      const defaultNormals = new Float32Array(vertexCount * 3);
      for (let i = 0;i < vertexCount; i++) {
        defaultNormals[i * 3 + 1] = 1;
      }
      geometry.vertexBuffers["normal"] = createBufferWithData(device, defaultNormals, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST, "Default Normal Buffer");
    }
    if (!geometry.attributes["uv"] && !geometry.vertexBuffers["uv"] && geometry.attributes["position"]) {
      const vertexCount = geometry.attributes["position"].length / 3;
      const defaultUVs = new Float32Array(vertexCount * 2);
      geometry.vertexBuffers["uv"] = createBufferWithData(device, defaultUVs, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST, "Default UV Buffer");
    }
    if (geometry.indices && !geometry.indexBuffer) {
      geometry.indexBuffer = createBufferWithData(device, geometry.indices, GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST, "Index Buffer");
    }
    geometry.markBuffersClean();
  }
  initMaterialPipeline(device, material, geometry, globalResources) {
    const includeVelocity = !this.gBuffer.useComputedVelocity;
    const vertexModule = createShaderModuleSafe(device, {
      label: "Standard Material Vertex Shader",
      code: material.getVertexShader("deferred", { includeVelocity })
    });
    const fragmentModule = createShaderModuleSafe(device, {
      label: "Standard Material Fragment Shader",
      code: material.getFragmentShader("deferred", { includeVelocity })
    });
    const buffers = [
      {
        arrayStride: 3 * 4,
        attributes: [{ shaderLocation: 0, offset: 0, format: "float32x3" }]
      },
      {
        arrayStride: 3 * 4,
        attributes: [{ shaderLocation: 1, offset: 0, format: "float32x3" }]
      },
      {
        arrayStride: 2 * 4,
        attributes: [{ shaderLocation: 2, offset: 0, format: "float32x2" }]
      }
    ];
    const materialLayout = material.createBindGroupLayout(device);
    const pipelineLayout = device.createPipelineLayout({
      label: "Deferred Pipeline Layout",
      bindGroupLayouts: [globalResources.renderBindGroupLayout, materialLayout]
    });
    if (!GeometryPass.hasLoggedPipeline) {
      console.log("GeometryPass: Creating pipeline with depth writes enabled");
      GeometryPass.hasLoggedPipeline = true;
    }
    material.pipeline = device.createRenderPipeline({
      label: "Deferred Geometry Pipeline",
      layout: pipelineLayout,
      vertex: {
        module: vertexModule,
        entryPoint: "vs_main",
        buffers
      },
      fragment: {
        module: fragmentModule,
        entryPoint: "fs_main",
        targets: this.gBuffer.useComputedVelocity ? [
          { format: "rgba16float" },
          { format: "rgba16float" },
          { format: "rgba16float" },
          { format: this.gBuffer.emissiveFormat }
        ] : [
          { format: "rgba16float" },
          { format: "rgba16float" },
          { format: "rgba16float" },
          { format: this.gBuffer.emissiveFormat },
          { format: "rg16float" }
        ]
      },
      primitive: {
        topology: "triangle-list",
        cullMode: "none"
      },
      depthStencil: {
        depthWriteEnabled: true,
        depthCompare: "less",
        format: "depth24plus"
      }
    });
  }
  initMeshUniforms(device, mesh, forSkinned = false) {
    if (!forSkinned && !mesh.material.pipeline)
      return;
    const material = mesh.material;
    const uniformBufferSize = material.getUniformBufferSize();
    mesh.uniformBuffer = device.createBuffer({
      label: "Material Uniform Buffer",
      size: uniformBufferSize,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    const layout = material.createBindGroupLayout(device);
    const entries = material.getBindGroupEntries(device, mesh.uniformBuffer);
    if (!GeometryPass.hasLoggedBindGroup) {
      const isStandardMaterial = material instanceof StandardMaterial;
      console.log("GeometryPass: Creating material bind group (first mesh)", {
        materialType: material.constructor.name,
        hasAlbedoMap: isStandardMaterial ? !!material.albedoMap : "N/A (TerrainMaterial)",
        hasNormalMap: isStandardMaterial ? !!material.normalMap : "N/A (TerrainMaterial)",
        textureFlags: material.getTextureFlags(),
        entries: entries.map((e) => ({ binding: e.binding, hasResource: !!e.resource }))
      });
      GeometryPass.hasLoggedBindGroup = true;
    }
    mesh.bindGroup = device.createBindGroup({
      label: "Material Bind Group",
      layout,
      entries
    });
  }
  updateMeshUniforms(device, mesh, parentContext) {
    if (!mesh.uniformBuffer)
      return;
    const context = {
      ...parentContext,
      modelMatrix: mesh.transform.worldMatrix
    };
    mesh.material.updateUniforms(device, mesh.uniformBuffer, 0, context);
  }
}

// ../../src/core/renderer/DeferredLightingPass.ts
class DeferredLightingPass {
  gBuffer;
  pipeline = null;
  bindGroup = null;
  gBufferLayout = null;
  canvasContext = null;
  hasLoggedExecution = false;
  constructor(gBuffer) {
    this.gBuffer = gBuffer;
  }
  init(device, context, presentationFormat) {
    this.canvasContext = context;
  }
  resize(width, height) {
    this.bindGroup = null;
  }
  execute(commandEncoder, context, globalResources) {
    const device = this.gBuffer.device;
    if (!device || !this.canvasContext) {
      console.warn("DeferredLightingPass: Missing device or canvas context");
      return;
    }
    if (!this.pipeline) {
      this.createPipeline(device, "rgba16float", globalResources);
      console.log("DeferredLightingPass: Pipeline created");
    }
    if (!this.bindGroup) {
      this.createBindGroup(device);
      console.log("DeferredLightingPass: Bind group created");
    }
    const textureView = this.gBuffer.accumulationTexture?.createView();
    if (!textureView) {
      console.warn("DeferredLightingPass: Missing accumulation texture");
      return;
    }
    const renderPassDescriptor = {
      colorAttachments: [
        {
          view: textureView,
          clearValue: { r: 0, g: 0, b: 0, a: 1 },
          loadOp: "clear",
          storeOp: "store"
        }
      ]
    };
    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
    if (this.pipeline) {
      passEncoder.setPipeline(this.pipeline);
    }
    passEncoder.setBindGroup(0, globalResources.renderBindGroup);
    if (this.bindGroup) {
      passEncoder.setBindGroup(1, this.bindGroup);
    }
    passEncoder.draw(3);
    passEncoder.end();
    if (!this.hasLoggedExecution) {
      console.log("DeferredLightingPass: Executed fullscreen pass");
      this.hasLoggedExecution = true;
    }
  }
  createPipeline(device, format, globalResources) {
    const code = `
      struct Light {
        position: vec3f,
        _pad1: f32,
        direction: vec3f,
        _pad2: f32,
        color: vec3f,
        intensity: f32,
        attenuation: vec3f,
        lightType: u32,
        coneAngles: vec2f,
        shadowIndex: i32,  // -1 = no shadow, 0-3 = shadow atlas layer
        shadowRadius: f32, // Shadow softness/blur radius (higher = softer)
        shadowIntensity: f32, // How dark shadows get (0=no shadow, 1=fully dark)
        _pad3: f32,
        _pad4: f32,
        _pad5: f32,
      }

      struct SceneUniforms {
        viewMatrix : mat4x4<f32>,
        projectionMatrix : mat4x4<f32>,
        lightViewProj : mat4x4<f32>,
        prevViewProj : mat4x4<f32>,
        inverseProjectionMatrix : mat4x4<f32>,
        cameraPosition : vec3f,
        time : f32,
        lightCount : u32,
        debugMode : u32,
        flags : u32,
        environmentIntensity : f32,
        fogColor: vec3f,
        fogDensity: f32,
        fogParams: vec4f,     // x=start, y=end, z=height, w=heightFalloff
        fogSettings: vec4u,   // x=type, y=enabled, z=pad, w=pad
        cloudShadowParams: vec4f,  // x=enabled, y=intensity, z=scale, w=speed
        cloudShadowParams2: vec4f, // x=coverage, y=softness, z=windDirX, w=windDirZ
        // Fog2 (Three.js-style fog)
        fog2Color: vec3f,     // Fog color
        fog2Density: f32,     // FogExp2 density for objects
        fog2Params: vec4f,    // x=near, y=far, z=type (0=LINEAR, 1=EXP2), w=enabled
        fog2SkyFalloff: f32,  // How high fog extends into sky (0=none, 1=zenith)
        _fog2Pad1: f32,       // padding
        _fog2Pad2: f32,       // padding
        _fog2Pad3: f32,       // padding
        lights : array<Light, 8>, // Match MAX_LIGHTS
      }

      struct ShadowLight {
        viewProj: mat4x4<f32>,
        atlasLayer: u32,
        bias: f32,
        normalBias: f32,
        _pad: u32,
      }

      struct ShadowUniforms {
        lights: array<ShadowLight, 4>,
        shadowLightCount: u32,
        atlasResolution: f32,
        _pad: vec2<f32>,
      }

      @group(0) @binding(0) var<uniform> scene : SceneUniforms;
      // Binding 1: Objects
      // Binding 2: Hi-Z

      // Light Storage Buffer - supports up to 1024 lights (vs 8 in SceneUniforms)
      struct LightStorage {
        lightCount: u32,
        _pad1: u32,
        _pad2: u32,
        _pad3: u32,
        lights: array<Light, 1024>,
      }
      @group(0) @binding(3) var<storage, read> lightStorage : LightStorage;

      @group(0) @binding(4) var shadowTex: texture_depth_2d_array;
      @group(0) @binding(5) var shadowSamp: sampler_comparison;
      @group(0) @binding(6) var envMap: texture_cube<f32>;
      @group(0) @binding(7) var envSamp: sampler;
      @group(0) @binding(8) var<uniform> shadowUniforms: ShadowUniforms;
      @group(0) @binding(9) var pointShadowTex: texture_2d_array<f32>;
      @group(0) @binding(10) var pointShadowSamp: sampler;

      // Cascade Shadow Map uniforms for directional lights
      struct CascadeUniforms {
        viewProj: array<mat4x4<f32>, 4>,  // View-proj matrix for each cascade
        splits: vec4<f32>,                 // View-space depth thresholds
        biases: vec4<f32>,                 // Per-cascade depth bias
      }
      @group(0) @binding(11) var<uniform> cascadeUniforms: CascadeUniforms;

      @group(1) @binding(0) var albedoTex: texture_2d<f32>;
      @group(1) @binding(1) var normalTex: texture_2d<f32>;
      @group(1) @binding(2) var positionTex: texture_2d<f32>;
      @group(1) @binding(3) var depthTex: texture_depth_2d;
      @group(1) @binding(4) var emissiveTex: texture_2d<f32>;
      @group(1) @binding(5) var samp: sampler;
      @group(1) @binding(6) var ssaoTex: texture_2d<f32>;
      @group(1) @binding(7) var ssgiTex: texture_2d<f32>;
      @group(1) @binding(8) var ssgiRawTex: texture_2d<f32>;

      const PI = 3.14159265359;

      // ==========================================
      // Cloud Shadow Noise Functions (FBM)
      // ==========================================

      // Simple hash function for noise
      fn hash2(p: vec2f) -> f32 {
          let h = dot(p, vec2f(127.1, 311.7));
          return fract(sin(h) * 43758.5453);
      }

      // Value noise
      fn noise2(p: vec2f) -> f32 {
          let i = floor(p);
          let f = fract(p);
          let u = f * f * (3.0 - 2.0 * f); // Smoothstep

          let a = hash2(i);
          let b = hash2(i + vec2f(1.0, 0.0));
          let c = hash2(i + vec2f(0.0, 1.0));
          let d = hash2(i + vec2f(1.0, 1.0));

          return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
      }

      // FBM (Fractal Brownian Motion) for cloud shadows
      fn fbmCloudShadow(pos: vec2f) -> f32 {
          var p = pos;
          var value = 0.0;
          var amplitude = 0.5;
          var frequency = 1.0;

          for (var i = 0; i < 5; i++) {
              value += amplitude * noise2(p * frequency);
              amplitude *= 0.5;
              frequency *= 2.0;
          }

          return value;
      }

      // Calculate cloud shadow factor based on world position
      fn getCloudShadow(worldPos: vec3f) -> f32 {
          let enabled = scene.cloudShadowParams.x;
          if (enabled < 0.5) {
              return 1.0; // No shadow when disabled
          }

          let intensity = scene.cloudShadowParams.y;
          let scale = scene.cloudShadowParams.z;
          let speed = scene.cloudShadowParams.w;
          let coverage = scene.cloudShadowParams2.x;
          let softness = scene.cloudShadowParams2.y;
          let windDirX = scene.cloudShadowParams2.z;
          let windDirZ = scene.cloudShadowParams2.w;

          // Calculate UV from world XZ position with wind animation
          let windOffset = vec2f(windDirX, windDirZ) * scene.time * speed;
          let uv = worldPos.xz * scale + windOffset;

          // Sample FBM noise
          let noise = fbmCloudShadow(uv);

          // Apply coverage threshold - higher coverage = more shadow
          // noise is typically 0-1, coverage shifts the threshold
          let threshold = 1.0 - coverage;
          let cloudAmount = smoothstep(threshold - softness * 0.5, threshold + softness * 0.5, noise);

          // Return shadow factor: 1 = no shadow, (1-intensity) = max shadow
          return 1.0 - cloudAmount * intensity;
      }

      fn inverse(m: mat4x4f) -> mat4x4f {
        let a00 = m[0][0]; let a01 = m[0][1]; let a02 = m[0][2]; let a03 = m[0][3];
        let a10 = m[1][0]; let a11 = m[1][1]; let a12 = m[1][2]; let a13 = m[1][3];
        let a20 = m[2][0]; let a21 = m[2][1]; let a22 = m[2][2]; let a23 = m[2][3];
        let a30 = m[3][0]; let a31 = m[3][1]; let a32 = m[3][2]; let a33 = m[3][3];

        let b00 = a00 * a11 - a01 * a10;
        let b01 = a00 * a12 - a02 * a10;
        let b02 = a00 * a13 - a03 * a10;
        let b03 = a01 * a12 - a02 * a11;
        let b04 = a01 * a13 - a03 * a11;
        let b05 = a02 * a13 - a03 * a12;
        let b06 = a20 * a31 - a21 * a30;
        let b07 = a20 * a32 - a22 * a30;
        let b08 = a20 * a33 - a23 * a30;
        let b09 = a21 * a32 - a22 * a31;
        let b10 = a21 * a33 - a23 * a31;
        let b11 = a22 * a33 - a23 * a32;

        let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        let invDet = 1.0 / det;

        return mat4x4f(
            a11 * b11 - a12 * b10 + a13 * b09,
            a02 * b10 - a01 * b11 - a03 * b09,
            a31 * b05 - a32 * b04 + a33 * b03,
            a22 * b04 - a21 * b05 - a23 * b03,
            a12 * b08 - a10 * b11 - a13 * b07,
            a00 * b11 - a02 * b08 + a03 * b07,
            a32 * b02 - a30 * b05 - a33 * b00,
            a20 * b05 - a22 * b02 + a23 * b00,
            a10 * b10 - a11 * b08 + a13 * b06,
            a01 * b08 - a00 * b10 - a03 * b06,
            a30 * b04 - a31 * b02 + a33 * b01,
            a21 * b02 - a20 * b04 - a23 * b01,
            a11 * b07 - a10 * b09 - a12 * b06,
            a00 * b09 - a01 * b07 + a02 * b06,
            a31 * b01 - a30 * b03 - a32 * b00,
            a20 * b03 - a21 * b01 + a22 * b00
        ) * invDet;
      }

      fn applyFog(color: vec3f, worldPos: vec3f, cameraPos: vec3f) -> vec3f {
        let fogEnabled = scene.fogSettings.y;
        if (fogEnabled == 0u) {
            return color;
        }

        let dist = length(worldPos - cameraPos);
        var fogFactor = 0.0;
        let fogType = scene.fogSettings.x;
        let density = scene.fogDensity;

        if (fogType == 1u) { // LINEAR
            let start = scene.fogParams.x;
            let end = scene.fogParams.y;
            fogFactor = clamp((dist - start) / (end - start), 0.0, 1.0);
        } else if (fogType == 2u) { // EXPONENTIAL (like Three.js FogExp2)
            // Simple exponential: fog increases with distance
            // Using density directly (not squared) for more intuitive control
            fogFactor = 1.0 - exp(-density * dist);
            fogFactor = clamp(fogFactor, 0.0, 1.0);
        } else if (fogType == 3u) { // EXPONENTIAL HEIGHT (Unreal Engine style)
            // Fog that is denser at lower altitudes, fades with height
            // But ALWAYS has some distance-based fog to hide the horizon
            //
            // Parameters:
            // - density: base fog density
            // - fogParams.x: start distance (fog begins here, not at camera)
            // - fogParams.z: fog base height (fog is densest below this)
            // - fogParams.w: height falloff (how quickly fog fades with altitude)

            let startDist = scene.fogParams.x;
            let fogBaseHeight = scene.fogParams.z;
            let heightFalloff = scene.fogParams.w;

            // Effective distance (accounting for start distance)
            let effectiveDist = max(dist - startDist, 0.0);

            // Base exponential fog from distance - this always applies
            // This ensures distant objects (horizon) always get fogged
            let baseFog = 1.0 - exp(-density * effectiveDist);

            // Height-based density modifier
            // Fog is full strength below fogBaseHeight, decreases above
            // Both the camera and the object height affect the fog
            let avgHeight = (worldPos.y + cameraPos.y) * 0.5;
            let heightAboveBase = max(avgHeight - fogBaseHeight, 0.0);
            let heightMultiplier = exp(-heightFalloff * heightAboveBase);

            // Combine: base distance fog scaled by height factor
            // Always keep at least 30% of base fog to ensure horizon hiding
            let minFogMultiplier = 0.3;
            fogFactor = baseFog * max(heightMultiplier, minFogMultiplier);
            fogFactor = clamp(fogFactor, 0.0, 1.0);
        }

        return mix(color, scene.fogColor, fogFactor);
      }

      // ==========================================
      // Fog2: Three.js-style fog (exact port)
      // ==========================================
      // Three.js uses view-space Z depth: vFogDepth = -mvPosition.z
      // This is the distance along the camera's view direction, NOT euclidean distance
      fn applyFog2(color: vec3f, worldPos: vec3f) -> vec3f {
        // Check if fog2 is enabled (fog2Params.w)
        let fog2Enabled = scene.fog2Params.w;
        if (fog2Enabled < 0.5) {
            return color;
        }

        // Calculate view-space Z depth (exactly like Three.js)
        // Three.js: vFogDepth = -mvPosition.z where mvPosition = modelViewMatrix * position
        // We transform world position to view space and take -z
        let viewPos = scene.viewMatrix * vec4f(worldPos, 1.0);
        let fogDepth = -viewPos.z;  // Negate because camera looks down -Z in view space

        var fogFactor = 0.0;
        let fog2Type = scene.fog2Params.z; // 0 = LINEAR, 1 = EXP2

        if (fog2Type < 0.5) {
            // LINEAR fog (Three.js Fog class)
            // Formula: smoothstep(fogNear, fogFar, vFogDepth)
            let fogNear = scene.fog2Params.x;
            let fogFar = scene.fog2Params.y;
            fogFactor = smoothstep(fogNear, fogFar, fogDepth);
        } else {
            // EXPONENTIAL SQUARED fog (Three.js FogExp2 class)
            // Formula: 1.0 - exp(-fogDensity * fogDensity * vFogDepth * vFogDepth)
            let fogDensity = scene.fog2Density;
            fogFactor = 1.0 - exp(-fogDensity * fogDensity * fogDepth * fogDepth);
        }

        fogFactor = clamp(fogFactor, 0.0, 1.0);
        return mix(color, scene.fog2Color, fogFactor);
      }

      fn distributionGGX(N: vec3f, H: vec3f, roughness: f32) -> f32 {
        let a = roughness * roughness;
        let a2 = a * a;
        let NdotH = max(dot(N, H), 0.0);
        let NdotH2 = NdotH * NdotH;
        let num = a2;
        let denom = (NdotH2 * (a2 - 1.0) + 1.0);
        return num / (PI * denom * denom);
      }

      fn geometrySchlickGGX(NdotV: f32, roughness: f32) -> f32 {
        let r = (roughness + 1.0);
        let k = (r * r) / 8.0;
        let num = NdotV;
        let denom = NdotV * (1.0 - k) + k;
        return num / denom;
      }

      fn geometrySmith(N: vec3f, V: vec3f, L: vec3f, roughness: f32) -> f32 {
        let NdotV = max(dot(N, V), 0.0);
        let NdotL = max(dot(N, L), 0.0);
        let ggx2 = geometrySchlickGGX(NdotV, roughness);
        let ggx1 = geometrySchlickGGX(NdotL, roughness);
        return ggx1 * ggx2;
      }

      fn fresnelSchlick(cosTheta: f32, F0: vec3f) -> vec3f {
        return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
      }

      // Frostbite 3 physically-based distance attenuation
      // Based on: https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
      fn getDistanceAttenuation(lightDistance: f32, cutoffDistance: f32, decayExponent: f32) -> f32 {
          // Clamp minimum distance to prevent extreme brightness very close to light source
          // This creates a "core" radius where brightness is constant, matching real light behavior
          let minDistance = 0.5; // Half meter minimum distance
          let clampedDistance = max(lightDistance, minDistance);

          // Base inverse power falloff with clamped distance
          var distanceFalloff = 1.0 / max(pow(clampedDistance, decayExponent), 0.01);

          // Smooth windowing function when cutoff is specified
          if (cutoffDistance > 0.0) {
              let ratio = lightDistance / cutoffDistance;
              let ratio2 = ratio * ratio;
              let ratio4 = ratio2 * ratio2;
              // Smooth falloff to zero at cutoff distance
              distanceFalloff *= pow(saturate(1.0 - ratio4), 2.0);
          }

          return distanceFalloff;
      }

      // Get hemisphere light irradiance based on surface normal
      // Interpolates between ground and sky color based on how much the surface faces up
      fn getHemisphereLightIrradiance(skyColor: vec3f, groundColor: vec3f, normal: vec3f, direction: vec3f) -> vec3f {
          let dotNL = dot(normal, direction);
          let hemiDiffuseWeight = dotNL * 0.5 + 0.5;  // Remap [-1,1] to [0,1]
          return mix(groundColor, skyColor, hemiDiffuseWeight);
      }

      struct VertexOutput {
        @builtin(position) position : vec4f,
        @location(0) uv : vec2f,
        @location(1) @interpolate(flat) invViewProj0 : vec4f,
        @location(2) @interpolate(flat) invViewProj1 : vec4f,
        @location(3) @interpolate(flat) invViewProj2 : vec4f,
        @location(4) @interpolate(flat) invViewProj3 : vec4f,
      }

      @vertex
      fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
        var output : VertexOutput;
        let pos = array(
          vec2f(-1.0, -1.0),
          vec2f( 3.0, -1.0),
          vec2f(-1.0,  3.0)
        );
        let p = pos[vertexIndex];
        output.position = vec4f(p, 0.0, 1.0);
        output.uv = p * 0.5 + 0.5;
        output.uv.y = 1.0 - output.uv.y;
        
        let viewProj = scene.projectionMatrix * scene.viewMatrix;
        let invViewProj = inverse(viewProj);
        output.invViewProj0 = invViewProj[0];
        output.invViewProj1 = invViewProj[1];
        output.invViewProj2 = invViewProj[2];
        output.invViewProj3 = invViewProj[3];
        
        return output;
      }

      fn worldFromDepth(depth: f32, uv: vec2f, invViewProj: mat4x4f) -> vec3f {
        let clipXY = vec2f(uv.x * 2.0 - 1.0, (1.0 - uv.y) * 2.0 - 1.0);
        let clipPos = vec4f(clipXY, depth, 1.0);
        let worldPos = invViewProj * clipPos;
        return worldPos.xyz / worldPos.w;
      }

      // Sample shadow for a specific light using its shadow atlas layer
      fn sampleShadowForLight(shadowLightIdx: u32, worldPos: vec3f, N: vec3f, L: vec3f) -> f32 {
        if ((scene.flags & 1u) == 0u) {
            return 1.0;
        }
        if (shadowLightIdx >= shadowUniforms.shadowLightCount) {
            return 1.0;
        }

        let shadowLight = shadowUniforms.lights[shadowLightIdx];

        // Apply normal bias to prevent shadow acne on surfaces facing away from light
        let biasedWorldPos = worldPos + N * shadowLight.normalBias;

        // Project to light space
        let lightSpacePos = shadowLight.viewProj * vec4f(biasedWorldPos, 1.0);
        let projCoords = lightSpacePos.xyz / lightSpacePos.w;
        let uv = vec2f(projCoords.x, -projCoords.y) * 0.5 + 0.5;

        // Check bounds
        if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0 || projCoords.z < 0.0 || projCoords.z > 1.0) {
            return 1.0;
        }

        // Dynamic bias based on surface angle
        let angleBias = max(shadowLight.bias * (1.0 - dot(N, L)), shadowLight.bias * 0.1);
        let currentDepth = projCoords.z - angleBias;

        // PCF (Percentage Closer Filtering) with 3x3 kernel
        var visibility = 0.0;
        let oneOverSize = 1.0 / shadowUniforms.atlasResolution;
        let layer = i32(shadowLight.atlasLayer);

        for (var y = -1; y <= 1; y++) {
            for (var x = -1; x <= 1; x++) {
                let offset = vec2f(f32(x), f32(y)) * oneOverSize;
                visibility += textureSampleCompareLevel(
                    shadowTex, shadowSamp,
                    uv + offset, layer, currentDepth
                );
            }
        }
        return visibility / 9.0;
      }

      // Legacy function for backward compatibility (uses first shadow light)
      fn sampleShadow(worldPos: vec3f, N: vec3f, L: vec3f) -> f32 {
        return sampleShadowForLight(0u, worldPos, N, L);
      }

      // Sample a single cascade at specified index with randomized PCF
      fn sampleCascadeWithNoise(cascade: u32, worldPos: vec3f, N: vec3f, fragCoord: vec2f) -> f32 {
        let viewProj = cascadeUniforms.viewProj[cascade];
        let bias = cascadeUniforms.biases[cascade];

        // Minimal normal bias - just enough to prevent acne
        let normalBias = 0.01;
        let biasedWorldPos = worldPos + N * normalBias;

        // Project to light space
        let lightSpacePos = viewProj * vec4f(biasedWorldPos, 1.0);
        let projCoords = lightSpacePos.xyz / lightSpacePos.w;
        let uv = vec2f(projCoords.x, -projCoords.y) * 0.5 + 0.5;

        // Check bounds
        if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0 || projCoords.z < 0.0 || projCoords.z > 1.0) {
            return 1.0;
        }

        let currentDepth = projCoords.z - bias;

        // PCF with Vogel disk and per-pixel rotation to break up moire patterns
        var visibility = 0.0;
        let oneOverSize = 1.0 / 2048.0; // Shadow map size
        let layer = i32(cascade); // Cascades use layers 0-3

        // Scale filter size by cascade - larger cascades get larger filter
        let filterScale = 1.0 + f32(cascade) * 0.5;
        let filterRadius = oneOverSize * filterScale * 1.5;

        // Use IGN to rotate sampling pattern per pixel - eliminates moire/banding
        let phi = interleavedGradientNoise(fragCoord) * 6.283185307;

        // 12 Vogel disk samples for smooth, noise-free shadows
        let NUM_SAMPLES = 12;
        for (var i = 0; i < NUM_SAMPLES; i++) {
            let offset2D = vogelDiskSample(i, NUM_SAMPLES, phi) * filterRadius;
            visibility += textureSampleCompareLevel(
                shadowTex, shadowSamp,
                uv + offset2D, layer, currentDepth
            );
        }
        return visibility / f32(NUM_SAMPLES);
      }

      // Legacy function for compatibility (without noise)
      fn sampleCascade(cascade: u32, worldPos: vec3f, N: vec3f) -> f32 {
        let viewProj = cascadeUniforms.viewProj[cascade];
        let bias = cascadeUniforms.biases[cascade];
        let normalBias = 0.01;
        let biasedWorldPos = worldPos + N * normalBias;
        let lightSpacePos = viewProj * vec4f(biasedWorldPos, 1.0);
        let projCoords = lightSpacePos.xyz / lightSpacePos.w;
        let uv = vec2f(projCoords.x, -projCoords.y) * 0.5 + 0.5;
        if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0 || projCoords.z < 0.0 || projCoords.z > 1.0) {
            return 1.0;
        }
        let currentDepth = projCoords.z - bias;
        var visibility = 0.0;
        let oneOverSize = 1.0 / 2048.0;
        let layer = i32(cascade);
        for (var y = -1; y <= 1; y++) {
            for (var x = -1; x <= 1; x++) {
                let offset = vec2f(f32(x), f32(y)) * oneOverSize;
                visibility += textureSampleCompareLevel(shadowTex, shadowSamp, uv + offset, layer, currentDepth);
            }
        }
        return visibility / 9.0;
      }

      // Cascaded Shadow Map sampling for directional lights with blending
      fn sampleCascadedShadowWithNoise(worldPos: vec3f, N: vec3f, viewMatrix: mat4x4<f32>, fragCoord: vec2f) -> f32 {
        if ((scene.flags & 1u) == 0u) {
            return 1.0; // Shadows disabled
        }

        // Get view-space depth (negative Z in view space)
        let viewPos = viewMatrix * vec4f(worldPos, 1.0);
        let depth = -viewPos.z;

        // Select cascade based on depth
        var cascade = 3u;
        if (depth < cascadeUniforms.splits.x) {
            cascade = 0u;
        } else if (depth < cascadeUniforms.splits.y) {
            cascade = 1u;
        } else if (depth < cascadeUniforms.splits.z) {
            cascade = 2u;
        }

        // Sample primary cascade with noise-based PCF
        let shadow1 = sampleCascadeWithNoise(cascade, worldPos, N, fragCoord);

        // Cascade blending at boundaries (last 25% of each cascade)
        // Larger blend region reduces visible seams on flat surfaces
        if (cascade < 3u) {
            let splits = array<f32, 4>(
                cascadeUniforms.splits.x,
                cascadeUniforms.splits.y,
                cascadeUniforms.splits.z,
                cascadeUniforms.splits.w
            );
            let cascadeEnd = splits[cascade];
            let blendStart = cascadeEnd * 0.75; // Blend in last 25%

            if (depth > blendStart) {
                // Use smoothstep for a more gradual transition
                let t = (depth - blendStart) / (cascadeEnd - blendStart);
                let blendFactor = t * t * (3.0 - 2.0 * t); // smoothstep
                let shadow2 = sampleCascadeWithNoise(cascade + 1u, worldPos, N, fragCoord);
                return mix(shadow1, shadow2, blendFactor);
            }
        }

        return shadow1;
      }

      // Legacy version without noise (for compatibility)
      fn sampleCascadedShadow(worldPos: vec3f, N: vec3f, viewMatrix: mat4x4<f32>) -> f32 {
        if ((scene.flags & 1u) == 0u) { return 1.0; }
        let viewPos = viewMatrix * vec4f(worldPos, 1.0);
        let depth = -viewPos.z;
        var cascade = 3u;
        if (depth < cascadeUniforms.splits.x) { cascade = 0u; }
        else if (depth < cascadeUniforms.splits.y) { cascade = 1u; }
        else if (depth < cascadeUniforms.splits.z) { cascade = 2u; }
        let shadow1 = sampleCascade(cascade, worldPos, N);
        if (cascade < 3u) {
            let splits = array<f32, 4>(cascadeUniforms.splits.x, cascadeUniforms.splits.y, cascadeUniforms.splits.z, cascadeUniforms.splits.w);
            let cascadeEnd = splits[cascade];
            let blendStart = cascadeEnd * 0.75;
            if (depth > blendStart) {
                let t = (depth - blendStart) / (cascadeEnd - blendStart);
                let blendFactor = t * t * (3.0 - 2.0 * t);
                let shadow2 = sampleCascade(cascade + 1u, worldPos, N);
                return mix(shadow1, shadow2, blendFactor);
            }
        }
        return shadow1;
      }

      // PCF Shadow Sampling Utilities (matching Three.js approach)

      // Interleaved Gradient Noise for randomizing sampling patterns per pixel
      fn interleavedGradientNoise(position: vec2f) -> f32 {
          return fract(52.9829189 * fract(dot(position, vec2f(0.06711056, 0.00583715))));
      }

      // Vogel disk sampling for uniform circular distribution
      fn vogelDiskSample(sampleIndex: i32, samplesCount: i32, phi: f32) -> vec2f {
          let goldenAngle = 2.399963229728653;
          let r = sqrt((f32(sampleIndex) + 0.5) / f32(samplesCount));
          let theta = f32(sampleIndex) * goldenAngle + phi;
          return vec2f(cos(theta), sin(theta)) * r;
      }

      // Convert direction to cube face index and UV coordinates
      // Face order: 0=+X, 1=-X, 2=+Y, 3=-Y, 4=+Z, 5=-Z
      // Derived from lookAt view matrices: ze=eye-target, xe=up×ze, ye=ze×xe
      // UV.x = dot(dir, xe), UV.y = dot(dir, ye) but Y is flipped for texture coords
      fn dirToCubeFaceUV(dir: vec3f) -> vec3f {
          let absDir = abs(dir);
          var faceIndex: f32;
          var uv: vec2f;

          if (absDir.x >= absDir.y && absDir.x >= absDir.z) {
              // X face
              if (dir.x > 0.0) {
                  faceIndex = 0.0; // +X: xe=(0,0,-1), ye=(0,-1,0)
                  uv = vec2f(-dir.z, dir.y) / absDir.x;
              } else {
                  faceIndex = 1.0; // -X: xe=(0,0,1), ye=(0,-1,0)
                  uv = vec2f(dir.z, dir.y) / absDir.x;
              }
          } else if (absDir.y >= absDir.x && absDir.y >= absDir.z) {
              // Y face
              if (dir.y > 0.0) {
                  faceIndex = 2.0; // +Y: xe=(1,0,0), ye=(0,0,1)
                  uv = vec2f(dir.x, -dir.z) / absDir.y;
              } else {
                  faceIndex = 3.0; // -Y: xe=(1,0,0), ye=(0,0,-1)
                  uv = vec2f(dir.x, dir.z) / absDir.y;
              }
          } else {
              // Z face
              if (dir.z > 0.0) {
                  faceIndex = 4.0; // +Z: xe=(1,0,0), ye=(0,-1,0)
                  uv = vec2f(dir.x, dir.y) / absDir.z;
              } else {
                  faceIndex = 5.0; // -Z: xe=(-1,0,0), ye=(0,-1,0)
                  uv = vec2f(-dir.x, dir.y) / absDir.z;
              }
          }

          // Convert from [-1,1] to [0,1]
          uv = uv * 0.5 + 0.5;
          return vec3f(uv, faceIndex);
      }

      fn samplePointShadow(shadowIndex: i32, worldPos: vec3f, lightPos: vec3f, fragCoord: vec2f, shadowRadius: f32, shadowIntensity: f32) -> f32 {
          // Early return handled with select to avoid non-uniform control flow issues
          let shadowsEnabled = (scene.flags & 1u) != 0u;

          let lightToFrag = worldPos - lightPos;
          let dist = length(lightToFrag);
          let dir = lightToFrag / dist;

          // Calculate linear distance from light, normalized by far plane
          let far = 100.0;
          let currentDepth = dist / far;

          // Shadow softness from light.shadow.radius (adjustable via JS)
          // Higher values = softer shadows. 0.05 is default, try 0.1-0.2 for very soft
          let shadowSoftness = shadowRadius;

          // Scale offset based on distance - shadows get softer further from light
          // This simulates realistic penumbra behavior
          let diskRadius = shadowSoftness * dist;

          // Build tangent-space coordinate system for sampling offsets
          // This ensures offsets are perpendicular to the light direction
          let absDir = abs(dir);
          var tangent: vec3f;
          if (absDir.x > absDir.z) {
              tangent = vec3f(0.0, 1.0, 0.0);
          } else {
              tangent = vec3f(1.0, 0.0, 0.0);
          }
          tangent = normalize(cross(dir, tangent));
          let bitangent = cross(dir, tangent);

          // Use IGN to rotate sampling pattern per pixel - eliminates banding artifacts
          let phi = interleavedGradientNoise(fragCoord) * 6.283185307;

          // PCF with 9 Vogel disk samples for smoother shadows
          let bias = 0.003;
          var shadow = 0.0;
          let NUM_SAMPLES = 9;

          for (var i = 0; i < NUM_SAMPLES; i++) {
              let offset2D = vogelDiskSample(i, NUM_SAMPLES, phi);
              // Apply offset in world space perpendicular to light direction
              let samplePos = worldPos + (tangent * offset2D.x + bitangent * offset2D.y) * diskRadius;
              let sampleVec = samplePos - lightPos;
              let sampleDist = length(sampleVec);
              let sampleDir = sampleVec / sampleDist;
              let sampleDepth = sampleDist / far;

              let faceUV = dirToCubeFaceUV(sampleDir);
              let layerIndex = shadowIndex * 6 + i32(faceUV.z);

              let shadowMapDepth = textureSampleLevel(pointShadowTex, pointShadowSamp, faceUV.xy, layerIndex, 0.0).r;
              shadow += select(0.0, 1.0, sampleDepth - bias <= shadowMapDepth);
          }

          shadow = shadow / f32(NUM_SAMPLES);

          // Apply shadow intensity - allows ambient light to "leak through" shadows
          // shadowIntensity=1.0 means fully dark shadows, 0.7 means 30% light leaks through
          let finalShadow = mix(1.0, shadow, shadowIntensity);

          // Return 1.0 if shadows disabled, otherwise the shadow value
          return select(1.0, finalShadow, shadowsEnabled);
      }

      @fragment
      fn fs_main(
        @builtin(position) fragCoord: vec4f,
        @location(0) uv: vec2f,
        @location(1) @interpolate(flat) invViewProj0: vec4f,
        @location(2) @interpolate(flat) invViewProj1: vec4f,
        @location(3) @interpolate(flat) invViewProj2: vec4f,
        @location(4) @interpolate(flat) invViewProj3: vec4f
      ) -> @location(0) vec4f {
        let invViewProj = mat4x4f(invViewProj0, invViewProj1, invViewProj2, invViewProj3);

        let albedo = textureSample(albedoTex, samp, uv);
        let normalRough = textureSample(normalTex, samp, uv);
        let positionOccl = textureSample(positionTex, samp, uv);
        let emissiveData = textureSample(emissiveTex, samp, uv);
        let emissive = emissiveData.rgb;
        let ambientIntensity = emissiveData.a;  // Per-material ambient multiplier (0-1)
        let depth = textureLoad(depthTex, vec2i(floor(fragCoord.xy)), 0);
        let ssao = textureSample(ssaoTex, samp, uv).r;
        let ssgi = textureSample(ssgiTex, samp, uv).rgb;

        // Safe normalize to prevent NaN from degenerate/missing normals
        let rawN = normalRough.xyz * 2.0 - 1.0;
        let nLen = length(rawN);
        let N = select(vec3f(0.0, 1.0, 0.0), rawN / nLen, nLen > 0.0001);
        let worldPos = positionOccl.xyz;
        let occlusion = positionOccl.w * ssao; // Combine Material AO and SSAO

        // Debug: Show depth value
        if (scene.debugMode == 10u) {
            return vec4f(vec3f(depth), 1.0);
        }
        
        // ... Debug Modes ...
        if (scene.debugMode == 1u) { return vec4f(albedo.rgb, 1.0); }
        if (scene.debugMode == 2u) { return vec4f(N * 0.5 + 0.5, 1.0); }
        if (scene.debugMode == 3u) { return vec4f(vec3f(pow(depth, 50.0)), 1.0); }
        if (scene.debugMode == 4u) { return vec4f(worldPos, 1.0); }
        if (scene.debugMode == 7u) { return vec4f(vec3f(occlusion), 1.0); } // Debug AO (Combined)
        if (scene.debugMode == 8u) { return vec4f(emissive, 1.0); } // Debug Emissive
        if (scene.debugMode == 9u) { return vec4f(vec3f(ssao), 1.0); } // Debug SSAO Only
        if (scene.debugMode == 11u) { return vec4f(ssgi, 1.0); } // Debug SSGI (Denoised)
        if (scene.debugMode == 12u) { return vec4f(textureSample(ssgiRawTex, samp, uv).rgb, 1.0); } // Debug SSGI Raw

        // Pixels with no geometry (depth = 1.0) are at infinite distance
        // If fog is enabled, render them as fully fogged (fog color)
        // Otherwise discard to show sky behind
        if (depth >= 1.0) {
            // Check Fog2 first (Three.js-style fog)
            let fog2Enabled = scene.fog2Params.w;
            if (fog2Enabled >= 0.5) {
                return vec4f(scene.fog2Color, 1.0);
            }
            // Check old fog system
            let fogEnabled = scene.fogSettings.y;
            if (fogEnabled != 0u) {
                return vec4f(scene.fogColor, 1.0);
            }
            discard;
        }

        let roughness = albedo.a;
        let metallic = normalRough.a;
        let V = normalize(scene.cameraPosition - worldPos);

        var F0 = vec3f(0.04);
        F0 = mix(F0, albedo.rgb, metallic);
        var Lo = vec3f(0.0);

        // ===========================================
        // PHASE 1: Accumulate Ambient Irradiance
        // Ambient/Hemisphere lights are NOT affected by shadows
        // ===========================================
        var ambientIrradiance = vec3f(0.0);
        for (var i = 0u; i < lightStorage.lightCount; i++) {
          let light = lightStorage.lights[i];

          if (light.lightType == 3u) { // Ambient Light
              // Flat ambient - same everywhere regardless of normal
              ambientIrradiance += light.color * light.intensity;
          } else if (light.lightType == 4u) { // Hemisphere Light
              // Sky/ground interpolation based on surface normal
              // light.color = skyColor, light.attenuation = groundColor
              let hemiIrradiance = getHemisphereLightIrradiance(
                  light.color,
                  light.attenuation,  // groundColor stored in attenuation field
                  N,
                  light.direction     // up direction (usually 0,1,0)
              );
              ambientIrradiance += hemiIrradiance * light.intensity;
          }
        }

        // ===========================================
        // PHASE 2: Direct Lighting with Shadows
        // Only Directional, Point, and Spot lights
        // ===========================================

        // Debug: track shadow values per light (up to 4)
        var debugShadows = array<f32, 4>(1.0, 1.0, 1.0, 1.0);
        var debugShadowIndices = array<i32, 4>(-1, -1, -1, -1);
        var shadowLightCount = 0u;

        for (var i = 0u; i < lightStorage.lightCount; i++) {
          let light = lightStorage.lights[i];

          // Skip ambient and hemisphere lights (already processed above)
          if (light.lightType == 3u || light.lightType == 4u) {
              continue;
          }

          var L = vec3f(0.0);
          var attenuation = 1.0;
          var shadow = 1.0;

          if (light.lightType == 0u) { // Directional
            L = normalize(-light.direction);
          } else {
             let lightVec = light.position - worldPos;
             let dist = length(lightVec);
             L = normalize(lightVec);

             // Frostbite 3 physically-based attenuation
             // light.attenuation.x = distance (cutoff), light.attenuation.y = decay exponent
             let cutoffDistance = light.attenuation.x;
             let decayExponent = select(2.0, light.attenuation.y, light.attenuation.y > 0.0);
             attenuation = getDistanceAttenuation(dist, cutoffDistance, decayExponent);

             if (light.lightType == 2u) { // Spot
               let spotDir = normalize(-light.direction);
               let angle = acos(dot(L, spotDir));
               let inner = light.coneAngles.x;
               let outer = light.coneAngles.y;
               let spotEffect = 1.0 - smoothstep(inner, outer, angle);
               attenuation *= spotEffect;
            }
          }

          // Sample shadow if this light has a valid shadow index
          // (deferred objects always receive shadows; use forward rendering for no-shadow materials)
          if (light.shadowIndex >= 0) {
            if (light.lightType == 0u) { // Directional - use Cascaded Shadow Maps with noise-based PCF
                shadow = sampleCascadedShadowWithNoise(worldPos, N, scene.viewMatrix, fragCoord.xy);
                // Apply shadow intensity - allows ambient light to "leak through" shadows
                shadow = mix(1.0, shadow, light.shadowIntensity);
            } else if (light.lightType == 1u) { // Point
                shadow = samplePointShadow(light.shadowIndex, worldPos, light.position, fragCoord.xy, light.shadowRadius, light.shadowIntensity);
            } else { // Spot
                shadow = sampleShadowForLight(u32(light.shadowIndex), worldPos, N, L);
                // Apply shadow intensity for spot lights too
                shadow = mix(1.0, shadow, light.shadowIntensity);
            }
          }

          // Apply cloud shadow cookies to directional lights
          if (light.lightType == 0u) {
            shadow *= getCloudShadow(worldPos);
          }

          // Track for debug (for any light that casts shadows)
          if (light.shadowIndex >= 0 && shadowLightCount < 4u) {
            debugShadows[shadowLightCount] = shadow;
            debugShadowIndices[shadowLightCount] = light.shadowIndex;
            shadowLightCount++;
          }

          let H = normalize(V + L);
          let radiance = light.color * light.intensity * attenuation * shadow;

          let NDF = distributionGGX(N, H, roughness);
          let G = geometrySmith(N, V, L, roughness);
          let F = fresnelSchlick(max(dot(H, V), 0.0), F0);

          let numerator = NDF * G * F;
          let denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.0001;
          let specular = numerator / denominator;

          let kS = F;
          var kD = vec3f(1.0) - kS;
          kD *= 1.0 - metallic;

          let NdotL = max(dot(N, L), 0.0);
          // Apply SSAO to direct diffuse as well (optional but helps visibility)
          Lo += (kD * albedo.rgb * occlusion / PI + specular) * radiance * NdotL;
        }
        
        // IBL Calculations
        let R = reflect(-V, N);
        
        let numLevels = f32(textureNumLevels(envMap));
        let lod = roughness * (numLevels - 1.0);
        
        let iblSpecular = textureSampleLevel(envMap, envSamp, R, lod).rgb;
        
        let diffuseLOD = numLevels - 2.0; 
        let skyColor = textureSampleLevel(envMap, envSamp, vec3f(0.0, 1.0, 0.0), diffuseLOD).rgb;
        let groundColor = textureSampleLevel(envMap, envSamp, vec3f(0.0, -1.0, 0.0), diffuseLOD).rgb;
        let hemiMix = N.y * 0.5 + 0.5;
        var iblDiffuse = mix(groundColor, skyColor, hemiMix);
        
        // Add SSGI to IBL Diffuse
        // SSGI replaces or adds to the IBL? usually adds (indirect bounces)
        // If we use SSGI, we should probably reduce simple ambient IBL or mix them based on sky visibility?
        // For now, let's just add it.
        iblDiffuse += ssgi;

        let F_IBL = fresnelSchlick(max(dot(N, V), 0.0), F0);
        let kS_IBL = F_IBL;
        var kD_IBL = vec3f(1.0) - kS_IBL;
        kD_IBL *= 1.0 - metallic;

        // Apply AO to IBL/Ambient only
        let ambientIBL = (kD_IBL * albedo.rgb * iblDiffuse + iblSpecular * F_IBL) * scene.environmentIntensity * occlusion;

        // ===========================================
        // PHASE 3: Final Composition
        // Combine IBL, explicit ambient lights, direct lighting, and emissive
        // ===========================================

        // Explicit ambient light contribution (AmbientLight + HemisphereLight)
        // Apply as Lambertian diffuse with AO, scaled by per-material ambient intensity
        let explicitAmbient = kD_IBL * albedo.rgb * ambientIrradiance * occlusion * ambientIntensity / PI;

        // Total ambient = IBL ambient + explicit ambient lights
        let totalAmbient = ambientIBL + explicitAmbient;

        var finalColor = totalAmbient + Lo + emissive;

        // Debug mode 22: Visualize fog factor (white = full fog, black = no fog)
        if (scene.debugMode == 22u) {
            let dist = length(worldPos - scene.cameraPosition);
            var fogFactor = 0.0;
            let fogType = scene.fogSettings.x;
            let density = scene.fogDensity;

            if (fogType == 2u) { // EXPONENTIAL
                let fogExp = density * density * dist * dist;
                fogFactor = 1.0 - exp(-fogExp);
            } else if (fogType == 3u) { // EXPONENTIAL_HEIGHT
                let fogHeight = scene.fogParams.z;
                let heightBelowFog = max(fogHeight - worldPos.y, 0.0);
                let m = heightBelowFog * dist;
                let fogExp = density * density * m * m;
                fogFactor = 1.0 - exp(-fogExp);
            }
            return vec4f(vec3f(fogFactor), 1.0);
        }

        // Debug mode 23: Visualize distance from camera (normalized to 0-100 range)
        if (scene.debugMode == 23u) {
            let dist = length(worldPos - scene.cameraPosition);
            return vec4f(vec3f(dist / 100.0), 1.0);
        }

        finalColor = applyFog(finalColor, worldPos, scene.cameraPosition);

        // Apply Fog2 (Three.js-style fog) if enabled
        finalColor = applyFog2(finalColor, worldPos);

        // Debug mode 20: Raw shadow values as grayscale bands
        // Left third = shadow0, Middle third = shadow1, Right third = shadowLightCount indicator
        if (scene.debugMode == 20u) {
          if (uv.x < 0.33) {
            return vec4f(vec3f(debugShadows[0]), 1.0); // Left: shadow 0
          } else if (uv.x < 0.66) {
            return vec4f(vec3f(debugShadows[1]), 1.0); // Middle: shadow 1
          } else {
            // Right: color based on shadowLightCount
            if (shadowLightCount == 0u) { return vec4f(1.0, 0.0, 0.0, 1.0); } // RED = 0 lights
            if (shadowLightCount == 1u) { return vec4f(1.0, 1.0, 0.0, 1.0); } // YELLOW = 1 light
            if (shadowLightCount == 2u) { return vec4f(0.0, 1.0, 0.0, 1.0); } // GREEN = 2 lights
            return vec4f(0.0, 1.0, 1.0, 1.0); // CYAN = 3+ lights
          }
        }
        // Debug mode 21: Show raw shadowIndex values as bands
        // Left = light[0].shadowIndex, Right = light[1].shadowIndex
        if (scene.debugMode == 21u) {
          if (uv.x < 0.5) {
            // Left half: light[0].shadowIndex
            if (lightStorage.lightCount == 0u) { return vec4f(0.5, 0.0, 0.5, 1.0); } // PURPLE = no lights
            let idx = lightStorage.lights[0].shadowIndex;
            if (idx == -1) { return vec4f(1.0, 0.0, 0.0, 1.0); } // RED = -1
            if (idx == 0) { return vec4f(0.0, 1.0, 0.0, 1.0); } // GREEN = 0
            if (idx == 1) { return vec4f(0.0, 0.0, 1.0, 1.0); } // BLUE = 1
            return vec4f(1.0, 1.0, 0.0, 1.0); // YELLOW = other
          } else {
            // Right half: light[1].shadowIndex
            if (lightStorage.lightCount < 2u) { return vec4f(0.5, 0.0, 0.5, 1.0); } // PURPLE = < 2 lights
            let idx = lightStorage.lights[1].shadowIndex;
            if (idx == -1) { return vec4f(1.0, 0.0, 0.0, 1.0); } // RED = -1
            if (idx == 0) { return vec4f(0.0, 1.0, 0.0, 1.0); } // GREEN = 0
            if (idx == 1) { return vec4f(0.0, 0.0, 1.0, 1.0); } // BLUE = 1
            return vec4f(1.0, 1.0, 0.0, 1.0); // YELLOW = other
          }
        }
        // Debug mode 22: Show only shadow 0 (grayscale)
        if (scene.debugMode == 22u) {
          return vec4f(vec3f(debugShadows[0]), 1.0);
        }
        // Debug mode 23: Show only shadow 1 (grayscale)
        if (scene.debugMode == 23u) {
          return vec4f(vec3f(debugShadows[1]), 1.0);
        }
        // Debug mode 24: Light counts - very clear
        // GREEN = has lights, BLUE = has shadow uniforms, RED = missing something
        if (scene.debugMode == 24u) {
          var col = vec3f(0.0);
          if (lightStorage.lightCount > 0u) { col.g = 1.0; } // GREEN = has lights
          if (shadowUniforms.shadowLightCount > 0u) { col.b = 1.0; } // BLUE = has shadow uniforms
          if (lightStorage.lightCount == 0u || shadowUniforms.shadowLightCount == 0u) { col.r = 1.0; } // RED = problem
          // CYAN = both good, RED = problem
          return vec4f(col, 1.0);
        }
        // Debug mode 25: Shadow atlas direct sample
        // GREEN = layer 0 has data, BLUE = layer 1 has data
        if (scene.debugMode == 25u) {
          let layer0 = textureSampleCompareLevel(shadowTex, shadowSamp, vec2f(0.5, 0.5), 0, 0.5);
          let layer1 = textureSampleCompareLevel(shadowTex, shadowSamp, vec2f(0.5, 0.5), 1, 0.5);
          var col = vec3f(0.0);
          if (layer0 > 0.1) { col.g = 1.0; } // GREEN = layer 0 has depth
          if (layer1 > 0.1) { col.b = 1.0; } // BLUE = layer 1 has depth
          if (layer0 < 0.1 && layer1 < 0.1) { col.r = 1.0; } // RED = no data
          return vec4f(col, 1.0);
        }
        // Debug mode 26: Show atlas layer being sampled for each shadow light
        // Left = shadowUniforms.lights[0].atlasLayer, Right = shadowUniforms.lights[1].atlasLayer
        if (scene.debugMode == 26u) {
          if (uv.x < 0.5) {
            let layer = shadowUniforms.lights[0].atlasLayer;
            if (layer == 0u) { return vec4f(0.0, 1.0, 0.0, 1.0); } // GREEN = layer 0
            if (layer == 1u) { return vec4f(0.0, 0.0, 1.0, 1.0); } // BLUE = layer 1
            return vec4f(1.0, 0.0, 0.0, 1.0); // RED = other
          } else {
            let layer = shadowUniforms.lights[1].atlasLayer;
            if (layer == 0u) { return vec4f(0.0, 1.0, 0.0, 1.0); } // GREEN = layer 0
            if (layer == 1u) { return vec4f(0.0, 0.0, 1.0, 1.0); } // BLUE = layer 1
            return vec4f(1.0, 0.0, 0.0, 1.0); } // RED = other
        }
        // Debug mode 27: Sample shadow using shadowUniforms.lights[0] viewProj - shows if dirLight shadow works
        if (scene.debugMode == 27u) {
          let shadowLight = shadowUniforms.lights[0];
          let biasedWorldPos = worldPos + N * shadowLight.normalBias;
          let lightSpacePos = shadowLight.viewProj * vec4f(biasedWorldPos, 1.0);
          let projCoords = lightSpacePos.xyz / lightSpacePos.w;
          let shadowUV = vec2f(projCoords.x, -projCoords.y) * 0.5 + 0.5;
          // Show UV coords: R = U, G = V, B = depth
          return vec4f(shadowUV.x, shadowUV.y, projCoords.z, 1.0);
        }
        // Debug mode 28: Sample shadow using shadowUniforms.lights[1] viewProj - shows if spotlight shadow works
        if (scene.debugMode == 28u) {
          let shadowLight = shadowUniforms.lights[1];
          let biasedWorldPos = worldPos + N * shadowLight.normalBias;
          let lightSpacePos = shadowLight.viewProj * vec4f(biasedWorldPos, 1.0);
          let projCoords = lightSpacePos.xyz / lightSpacePos.w;
          let shadowUV = vec2f(projCoords.x, -projCoords.y) * 0.5 + 0.5;
          // Show UV coords: R = U, G = V, B = depth
          return vec4f(shadowUV.x, shadowUV.y, projCoords.z, 1.0);
        }
        // Debug mode 29: Show raw matrix diagonal elements for shadowUniforms.lights[0]
        // If all zeros, the matrix wasn't written correctly
        if (scene.debugMode == 29u) {
          let m = shadowUniforms.lights[0].viewProj;
          // Show diagonal elements: m[0][0], m[1][1], m[2][2], m[3][3]
          // Scaled to 0-1 range (assuming values roughly -1 to 1)
          let d0 = m[0][0] * 0.5 + 0.5;
          let d1 = m[1][1] * 0.5 + 0.5;
          let d2 = m[2][2] * 0.5 + 0.5;
          // Display as RGB
          return vec4f(d0, d1, d2, 1.0);
        }
        // Debug mode 30: Show raw matrix translation elements for shadowUniforms.lights[0]
        // m[3][0], m[3][1], m[3][2] are translation components
        if (scene.debugMode == 30u) {
          let m = shadowUniforms.lights[0].viewProj;
          // Show translation elements scaled to visible range
          let t0 = m[3][0] * 0.01 + 0.5; // Scale down large values
          let t1 = m[3][1] * 0.01 + 0.5;
          let t2 = m[3][2] * 0.01 + 0.5;
          return vec4f(t0, t1, t2, 1.0);
        }
        // Debug mode 31: Check if shadowUniforms.lights[0] vs lights[1] have different matrices
        // Shows lights[0] on left, lights[1] on right - diagonal sum
        if (scene.debugMode == 31u) {
          if (uv.x < 0.5) {
            let m = shadowUniforms.lights[0].viewProj;
            let sum = abs(m[0][0]) + abs(m[1][1]) + abs(m[2][2]) + abs(m[3][3]);
            return vec4f(vec3f(sum * 0.1), 1.0); // Scale to visible
          } else {
            let m = shadowUniforms.lights[1].viewProj;
            let sum = abs(m[0][0]) + abs(m[1][1]) + abs(m[2][2]) + abs(m[3][3]);
            return vec4f(vec3f(sum * 0.1), 1.0);
          }
        }
        // Debug mode 32: Sample shadow atlas layer 0 at light[0]'s projected UV
        // Shows actual shadow map depth vs current depth
        if (scene.debugMode == 32u) {
          let shadowLight = shadowUniforms.lights[0];
          let lightSpacePos = shadowLight.viewProj * vec4f(worldPos, 1.0);
          let projCoords = lightSpacePos.xyz / lightSpacePos.w;
          let shadowUV = vec2f(projCoords.x, -projCoords.y) * 0.5 + 0.5;

          // Use textureLoad instead to avoid sampler issues with depth textures
          let texSize = textureDimensions(shadowTex);
          let texCoord = vec2i(shadowUV * vec2f(texSize));
          let shadowDepth = textureLoad(shadowTex, texCoord, 0, 0);
          let currentDepth = projCoords.z;

          // R = shadow map depth, G = current depth, B = difference
          return vec4f(shadowDepth, currentDepth, abs(shadowDepth - currentDepth) * 10.0, 1.0);
        }
        // Debug mode 33: Show if point is inside light frustum for light[0]
        if (scene.debugMode == 33u) {
          let shadowLight = shadowUniforms.lights[0];
          let lightSpacePos = shadowLight.viewProj * vec4f(worldPos, 1.0);
          let projCoords = lightSpacePos.xyz / lightSpacePos.w;
          let shadowUV = vec2f(projCoords.x, -projCoords.y) * 0.5 + 0.5;

          // Check bounds
          var col = vec3f(0.0, 1.0, 0.0); // GREEN = inside
          if (shadowUV.x < 0.0 || shadowUV.x > 1.0) { col = vec3f(1.0, 0.0, 0.0); } // RED = outside X
          if (shadowUV.y < 0.0 || shadowUV.y > 1.0) { col = vec3f(1.0, 0.5, 0.0); } // ORANGE = outside Y
          if (projCoords.z < 0.0) { col = vec3f(0.0, 0.0, 1.0); } // BLUE = behind light
          if (projCoords.z > 1.0) { col = vec3f(1.0, 0.0, 1.0); } // MAGENTA = too far
          return vec4f(col, 1.0);
        }
        // Debug mode 34: Compare scene.lightViewProj vs shadowUniforms.lights[0].viewProj
        // These SHOULD be identical. If different, buffer write is wrong.
        if (scene.debugMode == 34u) {
          // Project using scene.lightViewProj (from SceneUniforms)
          let sceneLightSpace = scene.lightViewProj * vec4f(worldPos, 1.0);
          let sceneProj = sceneLightSpace.xyz / sceneLightSpace.w;
          let sceneUV = vec2f(sceneProj.x, -sceneProj.y) * 0.5 + 0.5;

          // Project using shadowUniforms.lights[0].viewProj
          let shadowLightSpace = shadowUniforms.lights[0].viewProj * vec4f(worldPos, 1.0);
          let shadowProj = shadowLightSpace.xyz / shadowLightSpace.w;
          let shadowUV = vec2f(shadowProj.x, -shadowProj.y) * 0.5 + 0.5;

          // Show difference: should be BLACK if matrices match
          let diff = abs(sceneUV - shadowUV);
          return vec4f(diff.x * 10.0, diff.y * 10.0, 0.0, 1.0);
        }
        // Debug mode 35: Show UV from scene.lightViewProj (legacy matrix)
        if (scene.debugMode == 35u) {
          let lightSpacePos = scene.lightViewProj * vec4f(worldPos, 1.0);
          let projCoords = lightSpacePos.xyz / lightSpacePos.w;
          let shadowUV = vec2f(projCoords.x, -projCoords.y) * 0.5 + 0.5;
          return vec4f(shadowUV.x, shadowUV.y, projCoords.z, 1.0);
        }

        // Debug mode 40: Point Shadow Raw Depth (using 2D array with manual face selection)
        if (scene.debugMode == 40u) {
            let lightPos = vec3f(2.0, 2.5, 2.0); // Hardcoded from atmosphere.ts
            let L = worldPos - lightPos;
            let dir = normalize(L);

            // Convert direction to face index and UV
            let faceUV = dirToCubeFaceUV(dir);
            let layerIndex = i32(faceUV.z); // shadowIndex 0 * 6 + face

            // Sample raw depth from shadow map
            let shadowDepth = textureSampleLevel(pointShadowTex, pointShadowSamp, faceUV.xy, layerIndex, 0.0).r;

            // Show: R=shadowDepth, G=currentDepth, B=comparison result
            let far = 100.0;
            let currentDepth = length(L) / far;
            let inLight = select(0.0, 1.0, currentDepth - 0.005 <= shadowDepth);
            return vec4f(shadowDepth, currentDepth, inLight, 1.0);
        }

        // Debug mode 41: Visualize cube map direction
        if (scene.debugMode == 41u) {
            let lightPos = vec3f(2.0, 2.5, 2.0);
            let L = worldPos - lightPos;
            let dir = normalize(L);
            // Show direction as color (RGB = XYZ mapped to 0-1)
            return vec4f(dir * 0.5 + 0.5, 1.0);
        }

        // Debug mode 42: Sample each face directly from 2D array (layers 0-5)
        if (scene.debugMode == 42u) {
            // Sample center of each face (layer 0-5 for light index 0)
            let depthPX = textureSampleLevel(pointShadowTex, pointShadowSamp, vec2f(0.5, 0.5), 0, 0.0).r; // +X
            let depthNX = textureSampleLevel(pointShadowTex, pointShadowSamp, vec2f(0.5, 0.5), 1, 0.0).r; // -X
            let depthPY = textureSampleLevel(pointShadowTex, pointShadowSamp, vec2f(0.5, 0.5), 2, 0.0).r; // +Y
            let depthNY = textureSampleLevel(pointShadowTex, pointShadowSamp, vec2f(0.5, 0.5), 3, 0.0).r; // -Y
            let depthPZ = textureSampleLevel(pointShadowTex, pointShadowSamp, vec2f(0.5, 0.5), 4, 0.0).r; // +Z
            let depthNZ = textureSampleLevel(pointShadowTex, pointShadowSamp, vec2f(0.5, 0.5), 5, 0.0).r; // -Z
            return vec4f(depthPX, depthNY, depthPZ, 1.0); // Show +X, -Y, +Z as RGB
        }

        // Debug mode 43: Sample center of -Y face (layer 3) - ground should be visible
        if (scene.debugMode == 43u) {
            let depth = textureSampleLevel(pointShadowTex, pointShadowSamp, vec2f(0.5, 0.5), 3, 0.0).r;
            return vec4f(vec3f(depth), 1.0); // Should be < 1.0 if ground is rendered
        }

        // Debug mode 44: Use textureLoad (no sampler) to rule out sampler issues
        if (scene.debugMode == 44u) {
            let texSize = textureDimensions(pointShadowTex);
            let coord = vec2i(i32(texSize.x) / 2, i32(texSize.y) / 2); // Center pixel
            let depth0 = textureLoad(pointShadowTex, coord, 0, 0).r; // Layer 0 (+X)
            let depth3 = textureLoad(pointShadowTex, coord, 3, 0).r; // Layer 3 (-Y)
            let depth5 = textureLoad(pointShadowTex, coord, 5, 0).r; // Layer 5 (-Z)
            return vec4f(depth0, depth3, depth5, 1.0); // RGB = layers 0, 3, 5
        }

        // Debug mode 45: Show texture dimensions
        if (scene.debugMode == 45u) {
            let texSize = textureDimensions(pointShadowTex);
            let layers = textureNumLayers(pointShadowTex);
            // Encode dimensions as colors (scaled)
            return vec4f(f32(texSize.x) / 2048.0, f32(texSize.y) / 2048.0, f32(layers) / 24.0, 1.0);
        }

        // Debug mode 46: Show which cube face is being sampled (colored by face)
        // +X=Red, -X=Cyan, +Y=Green, -Y=Magenta, +Z=Blue, -Z=Yellow
        if (scene.debugMode == 46u) {
            let lightPos = vec3f(2.0, 2.5, 2.0);
            let L = worldPos - lightPos;
            let dir = normalize(L);
            let faceUV = dirToCubeFaceUV(dir);
            let face = i32(faceUV.z);
            var col = vec3f(0.0);
            if (face == 0) { col = vec3f(1.0, 0.0, 0.0); } // +X = Red
            if (face == 1) { col = vec3f(0.0, 1.0, 1.0); } // -X = Cyan
            if (face == 2) { col = vec3f(0.0, 1.0, 0.0); } // +Y = Green
            if (face == 3) { col = vec3f(1.0, 0.0, 1.0); } // -Y = Magenta
            if (face == 4) { col = vec3f(0.0, 0.0, 1.0); } // +Z = Blue
            if (face == 5) { col = vec3f(1.0, 1.0, 0.0); } // -Z = Yellow
            return vec4f(col, 1.0);
        }

        // Debug mode 47: Show UV coordinates being used for shadow sampling
        if (scene.debugMode == 47u) {
            let lightPos = vec3f(2.0, 2.5, 2.0);
            let L = worldPos - lightPos;
            let dir = normalize(L);
            let faceUV = dirToCubeFaceUV(dir);
            return vec4f(faceUV.xy, 0.0, 1.0); // R=U, G=V
        }

        return vec4f(finalColor, 1.0);
      }`;
    this.gBufferLayout = device.createBindGroupLayout({
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 3, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "depth" } },
        { binding: 4, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 5, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "non-filtering" } },
        { binding: 6, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 7, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 8, visibility: GPUShaderStage.FRAGMENT, texture: {} }
      ]
    });
    const pipelineLayout = device.createPipelineLayout({
      bindGroupLayouts: [globalResources.renderBindGroupLayout, this.gBufferLayout]
    });
    this.pipeline = device.createRenderPipeline({
      label: "Deferred Lighting Pipeline",
      layout: pipelineLayout,
      vertex: {
        module: createShaderModuleSafe(device, { code }),
        entryPoint: "vs_main"
      },
      fragment: {
        module: createShaderModuleSafe(device, { code }),
        entryPoint: "fs_main",
        targets: [{ format }]
      },
      primitive: { topology: "triangle-list" }
    });
  }
  createBindGroup(device) {
    if (!this.gBufferLayout || !this.gBuffer.albedoTexture || !this.gBuffer.normalTexture || !this.gBuffer.positionTexture || !this.gBuffer.depthTexture || !this.gBuffer.emissiveTexture || !this.gBuffer.ssaoTexture || !this.gBuffer.ssgiTexture)
      return;
    const depthView = this.gBuffer.depthTexture.createView({
      aspect: "depth-only"
    });
    console.log("DeferredLightingPass: Creating bind group with position texture", {
      hasPosition: !!this.gBuffer.positionTexture,
      depthFormat: this.gBuffer.depthTexture.format
    });
    this.bindGroup = device.createBindGroup({
      label: "Deferred Lighting GBuffer Bind Group",
      layout: this.gBufferLayout,
      entries: [
        { binding: 0, resource: this.gBuffer.albedoTexture.createView() },
        { binding: 1, resource: this.gBuffer.normalTexture.createView() },
        { binding: 2, resource: this.gBuffer.positionTexture.createView() },
        { binding: 3, resource: depthView },
        { binding: 4, resource: this.gBuffer.emissiveTexture.createView() },
        { binding: 5, resource: device.createSampler({
          minFilter: "nearest",
          magFilter: "nearest"
        }) },
        { binding: 6, resource: this.gBuffer.ssaoTexture.createView() },
        { binding: 7, resource: this.gBuffer.ssgiTexture.createView() },
        { binding: 8, resource: this.gBuffer.ssgiRawTexture.createView() }
      ]
    });
  }
}

// ../../src/core/renderer/GBuffer.ts
class GBuffer {
  width = 0;
  height = 0;
  albedoTexture = null;
  normalTexture = null;
  positionTexture = null;
  emissiveTexture = null;
  depthTexture = null;
  ssaoTexture = null;
  ssgiTexture = null;
  ssgiRawTexture = null;
  ssgiHistoryA = null;
  ssgiHistoryB = null;
  velocityTexture = null;
  accumulationTexture = null;
  device = null;
  _emissiveFormat = "rgba8unorm";
  _useComputedVelocity = false;
  constructor(device, width, height) {
    this.device = device;
    const limit = device.limits.maxColorAttachmentBytesPerSample;
    if (limit >= 40) {
      this._emissiveFormat = "rgba16float";
      this._useComputedVelocity = false;
    } else {
      this._emissiveFormat = "rgba16float";
      this._useComputedVelocity = true;
    }
    console.log(`GBuffer: maxColorAttachmentBytesPerSample=${limit}, emissiveFormat=${this._emissiveFormat}, useComputedVelocity=${this._useComputedVelocity}`);
    this.resize(width, height);
  }
  get emissiveFormat() {
    return this._emissiveFormat;
  }
  get useComputedVelocity() {
    return this._useComputedVelocity;
  }
  resize(width, height) {
    if (width <= 0 || height <= 0)
      return;
    if (this.width === width && this.height === height)
      return;
    console.log(`GBuffer: Resizing textures to ${width}x${height}`);
    this.width = width;
    this.height = height;
    this.destroy();
    this.createTextures();
  }
  destroy() {
    if (this.albedoTexture)
      this.albedoTexture.destroy();
    if (this.normalTexture)
      this.normalTexture.destroy();
    if (this.positionTexture)
      this.positionTexture.destroy();
    if (this.emissiveTexture)
      this.emissiveTexture.destroy();
    if (this.depthTexture)
      this.depthTexture.destroy();
    if (this.ssaoTexture)
      this.ssaoTexture.destroy();
    if (this.ssgiTexture)
      this.ssgiTexture.destroy();
    if (this.ssgiRawTexture)
      this.ssgiRawTexture.destroy();
    if (this.ssgiHistoryA)
      this.ssgiHistoryA.destroy();
    if (this.ssgiHistoryB)
      this.ssgiHistoryB.destroy();
    if (this.velocityTexture)
      this.velocityTexture.destroy();
    if (this.accumulationTexture)
      this.accumulationTexture.destroy();
  }
  async readDepthValues(commandEncoder, numSamples = 100) {
    if (!this.device || !this.depthTexture)
      return;
    const bytesPerPixel = 4;
    const bytesPerRow = this.width * bytesPerPixel;
    const alignedBytesPerRow = Math.ceil(bytesPerRow / 256) * 256;
    const bufferSize = alignedBytesPerRow * this.height;
    const readbackBuffer = this.device.createBuffer({
      label: "Depth Readback Buffer",
      size: bufferSize,
      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
    });
    commandEncoder.copyTextureToBuffer({
      texture: this.depthTexture,
      aspect: "depth-only"
    }, {
      buffer: readbackBuffer,
      bytesPerRow: alignedBytesPerRow
    }, { width: this.width, height: this.height, depthOrArrayLayers: 1 });
    await readbackBuffer.mapAsync(GPUMapMode.READ);
    const rawData = new Uint8Array(readbackBuffer.getMappedRange());
    const totalPixels = this.width * this.height;
    const sampleStep = Math.floor(totalPixels / numSamples);
    const samples = [];
    let min = Infinity;
    let max = -Infinity;
    let sum = 0;
    const uniqueValues = new Set;
    let pixelIndex = 0;
    for (let y = 0;y < this.height; y++) {
      const rowOffset = y * alignedBytesPerRow;
      const rowData = new Float32Array(rawData.buffer, rawData.byteOffset + rowOffset, this.width);
      for (let x = 0;x < this.width; x++) {
        const value = rowData[x];
        min = Math.min(min, value);
        max = Math.max(max, value);
        sum += value;
        if (pixelIndex % sampleStep === 0 && samples.length < numSamples) {
          samples.push(value);
        }
        if (uniqueValues.size < 1000) {
          uniqueValues.add(value);
        }
        pixelIndex++;
      }
    }
    console.log("Depth texture samples:", {
      textureSize: `${this.width}x${this.height}`,
      totalPixels,
      samples: samples.slice(0, 20),
      min,
      max,
      avg: sum / totalPixels,
      uniqueValues: uniqueValues.size >= 1000 ? ">1000" : uniqueValues.size
    });
    readbackBuffer.unmap();
    readbackBuffer.destroy();
  }
  createTextures() {
    if (!this.device)
      return;
    this.albedoTexture = this.device.createTexture({
      label: "G-Buffer Albedo",
      size: [this.width, this.height],
      format: "rgba16float",
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
    });
    this.normalTexture = this.device.createTexture({
      label: "G-Buffer Normal",
      size: [this.width, this.height],
      format: "rgba16float",
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
    });
    this.positionTexture = this.device.createTexture({
      label: "G-Buffer Position",
      size: [this.width, this.height],
      format: "rgba16float",
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
    });
    this.emissiveTexture = this.device.createTexture({
      label: "G-Buffer Emissive",
      size: [this.width, this.height],
      format: this._emissiveFormat,
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
    });
    this.depthTexture = this.device.createTexture({
      label: "G-Buffer Depth",
      size: [this.width, this.height],
      format: "depth24plus",
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC
    });
    this.ssaoTexture = this.device.createTexture({
      label: "G-Buffer SSAO",
      size: [this.width, this.height],
      format: "r8unorm",
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
    });
    this.ssgiTexture = this.device.createTexture({
      label: "G-Buffer SSGI",
      size: [this.width, this.height],
      format: "rgba16float",
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
    });
    this.ssgiRawTexture = this.device.createTexture({
      label: "SSGI Raw (Noisy)",
      size: [this.width, this.height],
      format: "rgba16float",
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC
    });
    this.ssgiHistoryA = this.device.createTexture({
      label: "SSGI History A",
      size: [this.width, this.height],
      format: "rgba16float",
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC
    });
    this.ssgiHistoryB = this.device.createTexture({
      label: "SSGI History B",
      size: [this.width, this.height],
      format: "rgba16float",
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC
    });
    this.velocityTexture = this.device.createTexture({
      label: "G-Buffer Velocity",
      size: [this.width, this.height],
      format: "rg16float",
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
    });
    this.accumulationTexture = this.device.createTexture({
      label: "Accumulation Buffer (HDR)",
      size: [this.width, this.height],
      format: "rgba16float",
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC
    });
  }
}

// ../../src/debug/GPUProfiler.ts
class GPUProfiler {
  device = null;
  querySet = null;
  resolveBuffer = null;
  readBuffer = null;
  timestampSupported = false;
  maxPasses = 16;
  passNames = [];
  lastResults = new Map;
  pendingRead = false;
  enabled = true;
  frameCount = 0;
  sampleInterval = 60;
  constructor() {}
  init(device, adapter) {
    this.device = device;
    this.timestampSupported = adapter.features.has("timestamp-query");
    if (!this.timestampSupported) {
      console.warn("GPUProfiler: timestamp-query feature not available. GPU timing will not be available.");
      return;
    }
    console.log("GPUProfiler: timestamp-query feature available, initializing GPU profiling");
    this.querySet = device.createQuerySet({
      type: "timestamp",
      count: this.maxPasses * 2
    });
    this.resolveBuffer = device.createBuffer({
      size: this.maxPasses * 2 * 8,
      usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC
    });
    this.readBuffer = device.createBuffer({
      size: this.maxPasses * 2 * 8,
      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
    });
  }
  beginFrame() {
    this.passNames = [];
  }
  shouldProfile() {
    return this.timestampSupported && this.enabled && this.frameCount % this.sampleInterval === 0;
  }
  getTimestampWrites(passName) {
    if (!this.shouldProfile() || !this.querySet)
      return;
    const passIndex = this.passNames.length;
    if (passIndex >= this.maxPasses)
      return;
    this.passNames.push(passName);
    const beginIndex = passIndex * 2;
    const endIndex = passIndex * 2 + 1;
    return {
      querySet: this.querySet,
      beginningOfPassWriteIndex: beginIndex,
      endOfPassWriteIndex: endIndex
    };
  }
  getComputeTimestampWrites(passName) {
    return this.getTimestampWrites(passName);
  }
  endFrame(encoder) {
    this.frameCount++;
    if (!this.shouldProfile() || !this.querySet || !this.resolveBuffer || !this.readBuffer || !this.device)
      return;
    if ((this.frameCount - 1) % this.sampleInterval !== 0)
      return;
    if (this.passNames.length === 0)
      return;
    if (this.pendingRead)
      return;
    const queryCount = this.passNames.length * 2;
    encoder.resolveQuerySet(this.querySet, 0, queryCount, this.resolveBuffer, 0);
    encoder.copyBufferToBuffer(this.resolveBuffer, 0, this.readBuffer, 0, queryCount * 8);
    this.pendingRead = true;
    const passNamesCopy = [...this.passNames];
    this.readBuffer.mapAsync(GPUMapMode.READ).then(() => {
      if (!this.readBuffer)
        return;
      const data = new BigUint64Array(this.readBuffer.getMappedRange());
      for (let i = 0;i < passNamesCopy.length; i++) {
        const start = data[i * 2];
        const end = data[i * 2 + 1];
        const durationNs = Number(end - start);
        const durationMs = durationNs / 1e6;
        this.lastResults.set(passNamesCopy[i], durationMs);
      }
      this.readBuffer.unmap();
      this.pendingRead = false;
    }).catch(() => {
      this.pendingRead = false;
    });
  }
  getPassTime(passName) {
    return this.lastResults.get(passName);
  }
  getAllPassTimes() {
    return new Map(this.lastResults);
  }
  getTotalTime() {
    let total = 0;
    for (const time of this.lastResults.values()) {
      total += time;
    }
    return total;
  }
  logTimes() {
    if (this.lastResults.size === 0) {
      console.log("GPUProfiler: No timing data available" + (this.timestampSupported ? "" : " (timestamp-query not supported)"));
      return;
    }
    console.group("GPU Pass Times:");
    let total = 0;
    const sorted = [...this.lastResults.entries()].sort((a, b) => b[1] - a[1]);
    for (const [name12, time] of sorted) {
      console.log(`  ${name12}: ${time.toFixed(3)} ms`);
      total += time;
    }
    console.log(`  TOTAL: ${total.toFixed(3)} ms`);
    console.groupEnd();
  }
  getFormattedTimes() {
    if (this.lastResults.size === 0) {
      return this.timestampSupported ? "No data" : "timestamp-query not supported";
    }
    let result = "";
    let total = 0;
    const sorted = [...this.lastResults.entries()].sort((a, b) => b[1] - a[1]);
    for (const [name12, time] of sorted) {
      result += `${name12}: ${time.toFixed(2)}ms
`;
      total += time;
    }
    result += `TOTAL: ${total.toFixed(2)}ms`;
    return result;
  }
  setEnabled(enabled) {
    this.enabled = enabled;
  }
  setSampleInterval(frames) {
    this.sampleInterval = Math.max(1, frames);
  }
  isTimestampSupported() {
    return this.timestampSupported;
  }
}
var profilerInstance = null;
function getGPUProfiler() {
  if (!profilerInstance) {
    profilerInstance = new GPUProfiler;
  }
  return profilerInstance;
}

// ../../src/core/renderer/HiZGenerationPass.ts
class HiZGenerationPass {
  gBuffer;
  pipeline = null;
  copyPipeline = null;
  constructor(gBuffer) {
    this.gBuffer = gBuffer;
  }
  init(device, context, presentationFormat) {
    const copyCode = `
      @group(0) @binding(0) var depthTex : texture_depth_2d;
      @group(0) @binding(1) var outTex : texture_storage_2d<r32float, write>;

      @compute @workgroup_size(8, 8)
      fn main(@builtin(global_invocation_id) id : vec3u) {
        let dim = textureDimensions(outTex);
        if (id.x >= dim.x || id.y >= dim.y) { return; }
        
        let depth = textureLoad(depthTex, id.xy, 0);
        textureStore(outTex, id.xy, vec4f(depth, 0.0, 0.0, 0.0));
      }
    `;
    this.copyPipeline = device.createComputePipeline({
      label: "Hi-Z Copy Pipeline",
      layout: "auto",
      compute: { module: createShaderModuleSafe(device, { code: copyCode }), entryPoint: "main" }
    });
    const mipCode = `
      @group(0) @binding(0) var srcTex : texture_2d<f32>;
      @group(0) @binding(1) var outTex : texture_storage_2d<r32float, write>;

      @compute @workgroup_size(8, 8)
      fn main(@builtin(global_invocation_id) id : vec3u) {
        let dim = textureDimensions(outTex);
        if (id.x >= dim.x || id.y >= dim.y) { return; }
        
        let srcDim = textureDimensions(srcTex);
        let srcCoord = id.xy * 2;
        
        // Sample 4 texels from src (previous mip)
        // Clamp to ensure we don't read OOB on odd-sized textures
        let d0 = textureLoad(srcTex, min(srcCoord + vec2u(0, 0), srcDim - vec2u(1)), 0).r;
        let d1 = textureLoad(srcTex, min(srcCoord + vec2u(1, 0), srcDim - vec2u(1)), 0).r;
        let d2 = textureLoad(srcTex, min(srcCoord + vec2u(0, 1), srcDim - vec2u(1)), 0).r;
        let d3 = textureLoad(srcTex, min(srcCoord + vec2u(1, 1), srcDim - vec2u(1)), 0).r;
        
        // Standard Depth: 0.0 (near) to 1.0 (far).
        // Use MAX for conservative occlusion culling with temporal reprojection.
        // MAX only culls when object is definitely behind everything - prevents false culls.

        let maxDepth = max(max(d0, d1), max(d2, d3));
        textureStore(outTex, id.xy, vec4f(maxDepth, 0.0, 0.0, 0.0));
      }
    `;
    this.pipeline = device.createComputePipeline({
      label: "Hi-Z Mip Pipeline",
      layout: "auto",
      compute: { module: createShaderModuleSafe(device, { code: mipCode }), entryPoint: "main" }
    });
  }
  resize(width, height) {}
  execute(commandEncoder, context, globalResources) {
    if (!this.copyPipeline || !this.pipeline || !this.gBuffer.depthTexture || !globalResources.hiZBuffer.texture)
      return;
    const device = this.gBuffer.device;
    if (!device)
      return;
    const copyBindGroup = device.createBindGroup({
      layout: this.copyPipeline.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: this.gBuffer.depthTexture.createView({ aspect: "depth-only" }) },
        { binding: 1, resource: globalResources.hiZBuffer.texture.createView({ baseMipLevel: 0, mipLevelCount: 1 }) }
      ]
    });
    const pass = commandEncoder.beginComputePass({ label: "Hi-Z Gen Pass" });
    pass.setPipeline(this.copyPipeline);
    pass.setBindGroup(0, copyBindGroup);
    pass.dispatchWorkgroups(Math.ceil(globalResources.hiZBuffer.width / 8), Math.ceil(globalResources.hiZBuffer.height / 8));
    pass.setPipeline(this.pipeline);
    let w = globalResources.hiZBuffer.width;
    let h = globalResources.hiZBuffer.height;
    for (let i = 0;i < globalResources.hiZBuffer.mipLevels - 1; i++) {
      const srcMip = i;
      const dstMip = i + 1;
      const dstW = Math.max(1, Math.floor(w / 2));
      const dstH = Math.max(1, Math.floor(h / 2));
      const bindGroup = device.createBindGroup({
        layout: this.pipeline.getBindGroupLayout(0),
        entries: [
          { binding: 0, resource: globalResources.hiZBuffer.texture.createView({ baseMipLevel: srcMip, mipLevelCount: 1 }) },
          { binding: 1, resource: globalResources.hiZBuffer.texture.createView({ baseMipLevel: dstMip, mipLevelCount: 1 }) }
        ]
      });
      pass.setBindGroup(0, bindGroup);
      pass.dispatchWorkgroups(Math.ceil(dstW / 8), Math.ceil(dstH / 8));
      w = dstW;
      h = dstH;
    }
    pass.end();
  }
}

// ../../src/core/renderer/GPUCullingPass.ts
class GPUCullingPass {
  gBuffer;
  pipeline = null;
  bindGroup = null;
  indirectBuffer = null;
  objectBuffer = null;
  constructor(gBuffer) {
    this.gBuffer = gBuffer;
  }
  init(device, _context, _presentationFormat) {
    const code = `
      struct SceneUniforms {
        viewMatrix: mat4x4<f32>,
        projectionMatrix: mat4x4<f32>,
        lightViewProj: mat4x4<f32>,
        prevViewProj: mat4x4<f32>,
        inverseProjectionMatrix: mat4x4<f32>,
        cameraPositionAndTime: vec4<f32>,
        lightCount: u32,
        debugMode: u32,
        flags: u32,
        envIntensity: f32,
      };

      struct ObjectData {
        modelMatrix: mat4x4<f32>,
        normalMatrix: mat4x4<f32>,
        aabbMin: vec3<f32>,
        triangleCount: u32,
        aabbMax: vec3<f32>,
        pad2: f32,
        prevModelMatrix: mat4x4<f32>,
        pad3: vec4<f32>,
        pad4: vec4<f32>,
      };

      struct IndirectCommand {
         indexCount: u32,
         instanceCount: u32,
         firstIndex: u32,
         baseVertex: u32,
         firstInstance: u32,
      };
      
      struct RenderStats {
          drawCount: atomic<u32>,
          triangleCount: atomic<u32>,
          pad1: u32,
          pad2: u32,
      };

      @group(0) @binding(0) var<uniform> scene : SceneUniforms;
      @group(0) @binding(1) var<storage, read> objects : array<ObjectData>;
      @group(0) @binding(2) var<storage, read_write> indirectDraws : array<IndirectCommand>;
      @group(0) @binding(3) var hiZTexture : texture_2d<f32>;
      @group(0) @binding(4) var<storage, read_write> stats : RenderStats;
      @group(0) @binding(5) var<storage, read_write> debugData : array<f32>;

      @compute @workgroup_size(64)
      fn main(@builtin(global_invocation_id) id : vec3u) {
        let index = id.x;
        if (index >= arrayLength(&objects)) { return; }
        
        let obj = objects[index];
        var visible = true;
        
        let frustumEnabled = (scene.flags & 2u) != 0u;
        let occlusionEnabled = (scene.flags & 4u) != 0u;

        let aabbMin = obj.aabbMin;
        let aabbMax = obj.aabbMax;
        
        // --- Frustum Culling ---
        if (frustumEnabled) {
            let worldCenter = (aabbMin + aabbMax) * 0.5;
            let worldExtent = (aabbMax - aabbMin) * 0.5;
            
            // Extract Frustum Planes from ViewProjection Matrix
            let viewProjectionMatrix = scene.projectionMatrix * scene.viewMatrix;
            // Transpose to get rows (since WGSL mat4x4 is column-major)
            let m = transpose(viewProjectionMatrix);
            
            let row0 = m[0];
            let row1 = m[1];
            let row2 = m[2];
            let row3 = m[3];
            
            let left   = row3 + row0;
            let right  = row3 - row0;
            let bottom = row3 + row1;
            let top    = row3 - row1;
            let near   = row2;
            let far    = row3 - row2;
            
            var planes = array<vec4<f32>, 6>(left, right, bottom, top, near, far);
            
            for (var i = 0; i < 6; i++) {
                let plane = planes[i];
                let r = dot(abs(plane.xyz), worldExtent);
                let d = dot(plane.xyz, worldCenter) + plane.w;
                
                if (d + r < 0.0) {
                    visible = false;
                }
            }
        }

        var debugMinZ = -1.0;
        var debugHiZDepth = -1.0;
        var debugLod = -1.0;
        
        var minUV = vec2(0.0, 0.0);
        var maxUV = vec2(0.0, 0.0);
        var texDim = vec2(0.0, 0.0);

        // --- Occlusion Culling (Hi-Z) ---
        if (visible && occlusionEnabled) {
             let minP = aabbMin;
             let maxP = aabbMax;
             let corners = array<vec3<f32>, 8>(
                vec3(minP.x, minP.y, minP.z),
                vec3(maxP.x, minP.y, minP.z),
                vec3(minP.x, maxP.y, minP.z),
                vec3(maxP.x, maxP.y, minP.z),
                vec3(minP.x, minP.y, maxP.z),
                vec3(maxP.x, minP.y, maxP.z),
                vec3(minP.x, maxP.y, maxP.z),
                vec3(maxP.x, maxP.y, maxP.z)
             );
             
             minUV = vec2(1.0, 1.0);
             maxUV = vec2(0.0, 0.0);
             var minZ = 1.0;
             
             // Use Previous View Projection Matrix for Hi-Z test (History Buffer)
             let projMatrix = scene.prevViewProj;
             
             for (var k = 0; k < 8; k++) {
                let clip = projMatrix * vec4(corners[k], 1.0);
                
                // If behind camera, skip occlusion culling
                if (clip.w <= 0.0) {
                   minZ = 0.0;
                   minUV = vec2(0.0, 0.0);
                   maxUV = vec2(1.0, 1.0);
                   break;
                }

                let ndc = clip.xyz / clip.w;
                
                let uv = vec2(ndc.x * 0.5 + 0.5, 1.0 - (ndc.y * 0.5 + 0.5));
                
                minUV = min(minUV, uv);
                maxUV = max(maxUV, uv);
                minZ = min(minZ, ndc.z);
             }
             
             minUV = clamp(minUV, vec2(0.0), vec2(1.0));
             maxUV = clamp(maxUV, vec2(0.0), vec2(1.0));
             
             texDim = vec2<f32>(textureDimensions(hiZTexture));
             let boxSize = (maxUV - minUV) * texDim;
             let dim = max(boxSize.x, boxSize.y);
             
             if (dim > 0.0) {
                 // Calculate LOD such that the box fits within a 1x1 texel block (conservative).
                 // Using a coarser LOD (log2(dim) instead of log2(dim)-1) ensures we don't undersample.
                 // This prevents "flickering" where we miss a hole in the depth buffer by sampling too fine.
                 let lodRaw = ceil(log2(dim));
                 
                 // Clamp LOD to available levels
                 let maxLod = f32(textureNumLevels(hiZTexture) - 1u);
                 let lod = min(maxLod, max(0.0, lodRaw));
                 let lodLevel = i32(lod);

                 let mipSize = vec2<i32>(i32(texDim.x) >> u32(lodLevel), i32(texDim.y) >> u32(lodLevel));

                 // Sample at the 4 CORNERS of the bounding box projection (not a 2x2 at one corner).
                 // This ensures we test the full extent of the object's screen coverage.
                 let minCoord = vec2<i32>(minUV * vec2<f32>(mipSize));
                 let maxCoord = vec2<i32>(maxUV * vec2<f32>(mipSize));

                 // Sample all 4 corners of the projected bounding box
                 let d0 = textureLoad(hiZTexture, clamp(minCoord, vec2(0), mipSize - vec2(1)), lodLevel).r;
                 let d1 = textureLoad(hiZTexture, clamp(vec2(maxCoord.x, minCoord.y), vec2(0), mipSize - vec2(1)), lodLevel).r;
                 let d2 = textureLoad(hiZTexture, clamp(vec2(minCoord.x, maxCoord.y), vec2(0), mipSize - vec2(1)), lodLevel).r;
                 let d3 = textureLoad(hiZTexture, clamp(maxCoord, vec2(0), mipSize - vec2(1)), lodLevel).r;
                 
                 // Take MAX of the 4 sampled texels (conservative - furthest in coverage area)
                 let hiZDepth = max(max(d0, d1), max(d2, d3));

                 debugMinZ = minZ;
                 debugHiZDepth = hiZDepth;
                 debugLod = lod;

                 // Standard Z: 0=Near, 1=Far.
                 // Hi-Z stores MAX depth (conservative).
                 // If object minZ (closest point) > hiZDepth, object is behind everything → OCCLUDED.
                 //
                 // Use a tiny epsilon (0.0001) to handle floating point precision.
                 // Larger epsilons (0.005) cause false negatives at far distances where
                 // depth values are compressed (e.g., wall at depth 0.994 vs spheres at 0.996).

                 if (minZ > hiZDepth + 0.0001) {
                    visible = false;
                 }
             }
        }
        
        if (visible) {
            indirectDraws[index].instanceCount = 1;
            atomicAdd(&stats.drawCount, 1u);
            atomicAdd(&stats.triangleCount, obj.triangleCount);
        } else {
            indirectDraws[index].instanceCount = 0;
        }

        // --- Debug Output for Mesh 2 (first red sphere in occlusion test scene) ---
        if (index == 2u) {
            debugData[0] = f32(visible);      // 0: Visibility (1.0 = true)
            debugData[1] = debugMinZ;         // 1: Object Min Z
            debugData[2] = debugHiZDepth;     // 2: Hi-Z Sampled Depth
            debugData[3] = debugLod;          // 3: LOD Level
            debugData[4] = aabbMin.x;         // 4: AABB Min X
            debugData[5] = aabbMin.y;         // 5: AABB Min Y
            debugData[6] = aabbMin.z;         // 6: AABB Min Z
            debugData[7] = f32(occlusionEnabled); // 7: Occlusion Enabled Flag
            debugData[8] = minUV.x;           // 8: Min UV X
            debugData[9] = minUV.y;           // 9: Min UV Y
            debugData[10] = maxUV.x;          // 10: Max UV X
            debugData[11] = maxUV.y;          // 11: Max UV Y
            debugData[12] = texDim.x;         // 12: Texture Width
            debugData[13] = texDim.y;         // 13: Texture Height
            
            // Debug: Sample Center Mip 0
            let centerUV = (minUV + maxUV) * 0.5;
            let centerCoord = vec2<i32>(centerUV * texDim);
            // Clamp to avoid OOB on edge
            let safeCoord = clamp(centerCoord, vec2(0), vec2<i32>(texDim) - vec2(1));
            debugData[14] = textureLoad(hiZTexture, safeCoord, 0).r;

            // Debug: Sample Center at LOD
            let lodMipSize = vec2<i32>(i32(texDim.x) >> u32(debugLod), i32(texDim.y) >> u32(debugLod));
            let lodCenterCoord = vec2<i32>(centerUV * vec2<f32>(lodMipSize));
            let safeLodCoord = clamp(lodCenterCoord, vec2(0), lodMipSize - vec2(1));
            debugData[15] = textureLoad(hiZTexture, safeLodCoord, i32(debugLod)).r;
        }
      }
    `;
    this.pipeline = device.createComputePipeline({
      label: "GPU Culling Pipeline",
      layout: "auto",
      compute: { module: createShaderModuleSafe(device, { code }), entryPoint: "main" }
    });
  }
  resize(_width, _height) {
    this.bindGroup = null;
  }
  execute(commandEncoder, _context, globalResources) {
    if (!this.pipeline)
      return;
    const device = this.gBuffer.device;
    if (!device)
      return;
    if (this.indirectBuffer !== globalResources.indirectDrawBuffer.buffer || this.objectBuffer !== globalResources.objectBuffer.buffer) {
      console.log("[GPUCullingPass] Buffer changed, recreating bind group");
      this.bindGroup = null;
      this.indirectBuffer = globalResources.indirectDrawBuffer.buffer;
      this.objectBuffer = globalResources.objectBuffer.buffer;
    }
    if (!this.bindGroup) {
      if (!globalResources.hiZBuffer.texture)
        return;
      this.bindGroup = device.createBindGroup({
        layout: this.pipeline.getBindGroupLayout(0),
        entries: [
          { binding: 0, resource: { buffer: globalResources.sceneUniforms.buffer } },
          { binding: 1, resource: { buffer: globalResources.objectBuffer.buffer } },
          { binding: 2, resource: { buffer: globalResources.indirectDrawBuffer.buffer } },
          { binding: 3, resource: globalResources.hiZBuffer.texture.createView() },
          { binding: 4, resource: { buffer: globalResources.statsBuffer } },
          { binding: 5, resource: { buffer: globalResources.cullingDebugBuffer } }
        ]
      });
    }
    const pass = commandEncoder.beginComputePass({ label: "GPU Culling Pass" });
    pass.setPipeline(this.pipeline);
    pass.setBindGroup(0, this.bindGroup);
    const objectCount = globalResources.objectBuffer.objectCount;
    if (objectCount > 0) {
      pass.dispatchWorkgroups(Math.ceil(objectCount / 64));
    }
    pass.end();
  }
}

// ../../src/core/renderer/ShadowPass.ts
class ShadowPass {
  depthStencilState;
  pipeline = null;
  alphaPipeline = null;
  bindGroups = [];
  shadowUniformBuffers = [];
  device = null;
  frameCount = 0;
  lastLoggedLightCount = -1;
  lastObjectBuffer = null;
  alphaSampler = null;
  alphaUniformBuffer = null;
  dummyTexture = null;
  dummyTextureView = null;
  lambda = 0.5;
  shadowMapSize = 2048;
  cascadeBiases = new Float32Array([0.0005, 0.001, 0.002, 0.003]);
  defaultMaxShadowDistance = 500;
  cascadeSplits = [];
  cascadeViewProjs = [];
  hasLoggedCascade = false;
  cascadeViewProjArrays = [];
  cascadeSplitsArray = new Float32Array(CASCADE_COUNT);
  spotLightViewProjArrays = [];
  simpleInstancedShadowPipeline = null;
  simpleInstancedAlphaShadowPipeline = null;
  simpleInstancedBindGroups = [];
  simpleInstancedAlphaBindGroupCache = new Map;
  static hasLoggedInstancedShadow = false;
  constructor() {
    this.depthStencilState = {
      depthWriteEnabled: true,
      depthCompare: "less",
      format: "depth32float"
    };
    for (let i = 0;i < CASCADE_COUNT; i++) {
      this.cascadeViewProjs.push(new Matrix4);
      this.cascadeViewProjArrays.push(new Float32Array(16));
    }
    for (let i = 0;i < MAX_SHADOW_LIGHTS; i++) {
      this.spotLightViewProjArrays.push(new Float32Array(16));
    }
  }
  init(device, context, presentationFormat) {
    this.device = device;
    const shaderCode = `
      struct Uniforms {
        lightViewProj : mat4x4<f32>,
      }
      @binding(0) @group(0) var<uniform> uniforms : Uniforms;

      struct ObjectData {
        modelMatrix : mat4x4<f32>,
        normalMatrix : mat4x4<f32>,
        aabbMin : vec3f,
        _pad1 : f32,
        aabbMax : vec3f,
        _pad2 : f32,
        prevModelMatrix : mat4x4<f32>,
        _pad3 : vec4<f32>,
        _pad4 : vec4<f32>,
      }
      @binding(1) @group(0) var<storage, read> objects : array<ObjectData>;

      struct VertexInput {
        @location(0) position : vec3<f32>,
      }

      @vertex
      fn main(input : VertexInput, @builtin(instance_index) instanceIndex : u32) -> @builtin(position) vec4<f32> {
        let model = objects[instanceIndex].modelMatrix;
        return uniforms.lightViewProj * model * vec4<f32>(input.position, 1.0);
      }
    `;
    this.pipeline = device.createRenderPipeline({
      label: "Shadow Pipeline",
      layout: "auto",
      vertex: {
        module: createShaderModuleSafe(device, { code: shaderCode }),
        entryPoint: "main",
        buffers: [
          {
            arrayStride: 12,
            attributes: [{ shaderLocation: 0, offset: 0, format: "float32x3" }]
          }
        ]
      },
      primitive: {
        topology: "triangle-list",
        cullMode: "none"
      },
      depthStencil: this.depthStencilState
    });
    const alphaShaderCode = `
      struct Uniforms {
        lightViewProj : mat4x4<f32>,
      }
      @binding(0) @group(0) var<uniform> uniforms : Uniforms;

      struct ObjectData {
        modelMatrix : mat4x4<f32>,
        normalMatrix : mat4x4<f32>,
        aabbMin : vec3f,
        _pad1 : f32,
        aabbMax : vec3f,
        _pad2 : f32,
        prevModelMatrix : mat4x4<f32>,
        _pad3 : vec4<f32>,
        _pad4 : vec4<f32>,
      }
      @binding(1) @group(0) var<storage, read> objects : array<ObjectData>;

      // Alpha testing uniforms (32 bytes minimum for WebGPU uniform buffers)
      struct AlphaUniforms {
        alphaCutoff : f32,
        _pad1 : f32,
        _pad2 : f32,
        _pad3 : f32,
        _pad4 : vec4<f32>,
      }
      @binding(2) @group(0) var<uniform> alphaUniforms : AlphaUniforms;
      @binding(3) @group(0) var albedoTexture : texture_2d<f32>;
      @binding(4) @group(0) var albedoSampler : sampler;

      struct VertexInput {
        @location(0) position : vec3<f32>,
        @location(1) uv : vec2<f32>,
      }

      struct VertexOutput {
        @builtin(position) position : vec4<f32>,
        @location(0) uv : vec2<f32>,
      }

      @vertex
      fn vs_main(input : VertexInput, @builtin(instance_index) instanceIndex : u32) -> VertexOutput {
        let model = objects[instanceIndex].modelMatrix;
        var output : VertexOutput;
        output.position = uniforms.lightViewProj * model * vec4<f32>(input.position, 1.0);
        output.uv = input.uv;
        return output;
      }

      @fragment
      fn fs_main(input : VertexOutput) {
        let alpha = textureSample(albedoTexture, albedoSampler, input.uv).a;
        if (alpha < alphaUniforms.alphaCutoff) {
          discard;
        }
      }
    `;
    this.alphaPipeline = device.createRenderPipeline({
      label: "Alpha Shadow Pipeline",
      layout: "auto",
      vertex: {
        module: createShaderModuleSafe(device, { code: alphaShaderCode }),
        entryPoint: "vs_main",
        buffers: [
          {
            arrayStride: 12,
            attributes: [{ shaderLocation: 0, offset: 0, format: "float32x3" }]
          },
          {
            arrayStride: 8,
            attributes: [{ shaderLocation: 1, offset: 0, format: "float32x2" }]
          }
        ]
      },
      fragment: {
        module: createShaderModuleSafe(device, { code: alphaShaderCode }),
        entryPoint: "fs_main",
        targets: []
      },
      primitive: {
        topology: "triangle-list",
        cullMode: "none"
      },
      depthStencil: this.depthStencilState
    });
    this.alphaSampler = device.createSampler({
      label: "Alpha Shadow Sampler",
      magFilter: "linear",
      minFilter: "linear",
      addressModeU: "repeat",
      addressModeV: "repeat"
    });
    this.alphaUniformBuffer = device.createBuffer({
      label: "Alpha Shadow Uniform Buffer",
      size: 32,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.dummyTexture = device.createTexture({
      label: "Dummy Alpha Texture",
      size: { width: 1, height: 1 },
      format: "rgba8unorm",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
    });
    device.queue.writeTexture({ texture: this.dummyTexture }, new Uint8Array([255, 255, 255, 255]), { bytesPerRow: 4 }, { width: 1, height: 1 });
    this.dummyTextureView = this.dummyTexture.createView();
    const totalBuffers = CASCADE_COUNT + MAX_SHADOW_LIGHTS;
    for (let i = 0;i < totalBuffers; i++) {
      this.shadowUniformBuffers.push(device.createBuffer({
        label: `Shadow Uniform Buffer ${i}`,
        size: 64,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
      }));
    }
    this.simpleInstancedShadowPipeline = this.createSimpleInstancedShadowPipeline(device, false);
    this.simpleInstancedAlphaShadowPipeline = this.createSimpleInstancedShadowPipeline(device, true);
  }
  createSimpleInstancedShadowPipeline(device, alphaTest) {
    const shaderCode = `
      struct Uniforms {
        lightViewProj: mat4x4<f32>,
      }

      @group(0) @binding(0) var<uniform> uniforms: Uniforms;
      ${alphaTest ? `
      @group(0) @binding(1) var albedoTexture: texture_2d<f32>;
      @group(0) @binding(2) var albedoSampler: sampler;
      ` : ""}

      struct VertexInput {
        @location(0) position: vec3f,
        ${alphaTest ? "@location(1) uv: vec2f," : ""}
        // Instance data
        @location(${alphaTest ? "2" : "1"}) instancePosRot: vec4f,  // position.xyz, rotation
        @location(${alphaTest ? "3" : "2"}) instanceScale: vec4f,   // scale.xyz, unused
        @location(${alphaTest ? "4" : "3"}) instanceColor: vec4f,   // color.rgb, unused
      }

      struct VertexOutput {
        @builtin(position) position: vec4f,
        ${alphaTest ? "@location(0) uv: vec2f," : ""}
      }

      @vertex
      fn vs_main(input: VertexInput) -> VertexOutput {
        var output: VertexOutput;

        // Instance transform
        let instancePos = input.instancePosRot.xyz;
        let rotationY = input.instancePosRot.w;
        let scale = input.instanceScale.xyz;

        // Build Y-axis rotation matrix
        let cosR = cos(rotationY);
        let sinR = sin(rotationY);
        let rotMat = mat3x3f(
          vec3f(cosR, 0.0, sinR),
          vec3f(0.0, 1.0, 0.0),
          vec3f(-sinR, 0.0, cosR)
        );

        var localPos = input.position * scale;
        var worldPos = rotMat * localPos + instancePos;

        output.position = uniforms.lightViewProj * vec4f(worldPos, 1.0);
        ${alphaTest ? "output.uv = input.uv;" : ""}
        return output;
      }

      ${alphaTest ? `
      @fragment
      fn fs_main(input: VertexOutput) {
        let alpha = textureSample(albedoTexture, albedoSampler, input.uv).a;
        if (alpha < 0.5) {
          discard;
        }
      }
      ` : ""}
    `;
    const shaderModule = createShaderModuleSafe(device, {
      label: alphaTest ? "Simple Instanced Alpha Shadow Shader" : "Simple Instanced Shadow Shader",
      code: shaderCode
    });
    const buffers = alphaTest ? [
      {
        arrayStride: 12,
        attributes: [{ shaderLocation: 0, offset: 0, format: "float32x3" }]
      },
      {
        arrayStride: 8,
        attributes: [{ shaderLocation: 1, offset: 0, format: "float32x2" }]
      },
      {
        arrayStride: 48,
        stepMode: "instance",
        attributes: [
          { shaderLocation: 2, offset: 0, format: "float32x4" },
          { shaderLocation: 3, offset: 16, format: "float32x4" },
          { shaderLocation: 4, offset: 32, format: "float32x4" }
        ]
      }
    ] : [
      {
        arrayStride: 12,
        attributes: [{ shaderLocation: 0, offset: 0, format: "float32x3" }]
      },
      {
        arrayStride: 48,
        stepMode: "instance",
        attributes: [
          { shaderLocation: 1, offset: 0, format: "float32x4" },
          { shaderLocation: 2, offset: 16, format: "float32x4" },
          { shaderLocation: 3, offset: 32, format: "float32x4" }
        ]
      }
    ];
    return device.createRenderPipeline({
      label: alphaTest ? "Simple Instanced Alpha Shadow Pipeline" : "Simple Instanced Shadow Pipeline",
      layout: "auto",
      vertex: {
        module: shaderModule,
        entryPoint: "vs_main",
        buffers
      },
      ...alphaTest ? {
        fragment: {
          module: shaderModule,
          entryPoint: "fs_main",
          targets: []
        }
      } : {},
      primitive: {
        topology: "triangle-list",
        cullMode: "none"
      },
      depthStencil: this.depthStencilState
    });
  }
  resize(width, height) {}
  isAlphaMaskedMaterial(material) {
    if (material instanceof StandardMaterial) {
      return material.alphaMode === "MASK" && material.albedoMap !== null;
    }
    return false;
  }
  drawMeshesToShadowMap(passEncoder, context, globalResources, cascadeOrLayerIndex, lightViewProj) {
    if (!this.pipeline || !this.alphaPipeline || !this.device)
      return;
    const opaqueMeshes = [];
    const alphaMeshes = [];
    const instancedGLBMeshes = [];
    const instancedMeshes = [];
    context.scene.traverse((node) => {
      if (!node.visible)
        return false;
      if (node instanceof InstancedMesh) {
        if (node.instanceCount > 0 && node.instanceBuffer) {
          instancedMeshes.push(node);
        }
      } else if (node instanceof InstancedGLBMesh) {
        instancedGLBMeshes.push(node);
      } else if (node instanceof Mesh && node.material instanceof Material) {
        if (node.geometry.buffersDirty)
          return;
        if (!node.geometry.vertexBuffers["position"])
          return;
        if (this.isAlphaMaskedMaterial(node.material)) {
          alphaMeshes.push(node);
        } else {
          opaqueMeshes.push(node);
        }
      }
    });
    if (opaqueMeshes.length > 0) {
      passEncoder.setPipeline(this.pipeline);
      passEncoder.setBindGroup(0, this.bindGroups[cascadeOrLayerIndex]);
      for (const mesh of opaqueMeshes) {
        passEncoder.setVertexBuffer(0, mesh.geometry.vertexBuffers["position"]);
        const instanceIndex = mesh.renderIndex;
        if (mesh.geometry.indexBuffer) {
          const indexFormat = mesh.geometry.indices instanceof Uint32Array ? "uint32" : "uint16";
          passEncoder.setIndexBuffer(mesh.geometry.indexBuffer, indexFormat);
          passEncoder.drawIndexed(mesh.geometry.indexCount, 1, 0, 0, instanceIndex);
        } else {
          passEncoder.draw(mesh.geometry.vertexCount, 1, 0, instanceIndex);
        }
      }
    }
    if (alphaMeshes.length > 0 && this.alphaUniformBuffer && this.alphaSampler) {
      passEncoder.setPipeline(this.alphaPipeline);
      for (const mesh of alphaMeshes) {
        const material = mesh.material;
        if (!mesh.geometry.vertexBuffers["uv"])
          continue;
        const alphaCutoff = material.alphaCutoff;
        this.device.queue.writeBuffer(this.alphaUniformBuffer, 0, new Float32Array([alphaCutoff, 0, 0, 0, 0, 0, 0, 0]));
        const textureView = material.albedoMap?.view ?? this.dummyTextureView;
        if (!textureView)
          continue;
        const alphaBindGroup = this.device.createBindGroup({
          label: `Alpha Shadow Bind Group - ${mesh.name}`,
          layout: this.alphaPipeline.getBindGroupLayout(0),
          entries: [
            { binding: 0, resource: { buffer: this.shadowUniformBuffers[cascadeOrLayerIndex] } },
            { binding: 1, resource: { buffer: globalResources.objectBuffer.buffer } },
            { binding: 2, resource: { buffer: this.alphaUniformBuffer } },
            { binding: 3, resource: textureView },
            { binding: 4, resource: this.alphaSampler }
          ]
        });
        passEncoder.setBindGroup(0, alphaBindGroup);
        passEncoder.setVertexBuffer(0, mesh.geometry.vertexBuffers["position"]);
        passEncoder.setVertexBuffer(1, mesh.geometry.vertexBuffers["uv"]);
        const instanceIndex = mesh.renderIndex;
        if (mesh.geometry.indexBuffer) {
          const indexFormat = mesh.geometry.indices instanceof Uint32Array ? "uint32" : "uint16";
          passEncoder.setIndexBuffer(mesh.geometry.indexBuffer, indexFormat);
          passEncoder.drawIndexed(mesh.geometry.indexCount, 1, 0, 0, instanceIndex);
        } else {
          passEncoder.draw(mesh.geometry.vertexCount, 1, 0, instanceIndex);
        }
      }
    }
    if (instancedMeshes.length > 0) {
      this.renderInstancedMeshShadowsSimple(passEncoder, instancedMeshes, cascadeOrLayerIndex, context.time ?? 0);
    }
  }
  renderInstancedMeshShadowsSimple(passEncoder, instancedMeshes, cascadeOrLayerIndex, time) {
    if (!this.device)
      return;
    if (!this.simpleInstancedShadowPipeline || !this.simpleInstancedAlphaShadowPipeline)
      return;
    const uniformBuffer = this.shadowUniformBuffers[cascadeOrLayerIndex];
    if (!uniformBuffer)
      return;
    if (this.simpleInstancedBindGroups.length === 0) {
      const totalBuffers = CASCADE_COUNT + MAX_SHADOW_LIGHTS;
      for (let i = 0;i < totalBuffers; i++) {
        this.simpleInstancedBindGroups.push(this.device.createBindGroup({
          label: `Simple Instanced Shadow Bind Group ${i}`,
          layout: this.simpleInstancedShadowPipeline.getBindGroupLayout(0),
          entries: [
            { binding: 0, resource: { buffer: this.shadowUniformBuffers[i] } }
          ]
        }));
      }
    }
    for (const instancedMesh of instancedMeshes) {
      const { geometry, material } = instancedMesh;
      if (!geometry.vertexBuffers["position"])
        continue;
      if (!instancedMesh.instanceBuffer)
        continue;
      instancedMesh._writeToGPU(this.device);
      const needsAlphaTest = material.alphaMode === "MASK" && material.albedoMap !== null;
      if (!ShadowPass.hasLoggedInstancedShadow) {
        const debugData = instancedMesh.getDebugInstanceData();
        console.log("[ShadowPass SIMPLE] ==================== INSTANCED SHADOW DEBUG ====================");
        console.log("[ShadowPass SIMPLE] Using SAME uniform buffer as non-instanced shadows");
        console.log(`[ShadowPass SIMPLE] cascadeOrLayerIndex: ${cascadeOrLayerIndex}`);
        console.log(`[ShadowPass SIMPLE] uniformBuffer size: ${uniformBuffer.size} bytes`);
        if (debugData) {
          console.log("[ShadowPass SIMPLE] Instance positions (first 3):");
          debugData.forEach((d, i) => {
            console.log(`  Instance ${i}: pos=(${d.position[0].toFixed(2)}, ${d.position[1].toFixed(2)}, ${d.position[2].toFixed(2)}), rot=${d.rotation.toFixed(2)}, scale=(${d.scale[0].toFixed(2)}, ${d.scale[1].toFixed(2)}, ${d.scale[2].toFixed(2)})`);
          });
        }
        console.log(`[ShadowPass SIMPLE] needsAlphaTest: ${needsAlphaTest}`);
        console.log(`[ShadowPass SIMPLE] instanceCount: ${instancedMesh.instanceCount}`);
        console.log("[ShadowPass SIMPLE] ================================================================");
      }
      if (needsAlphaTest && geometry.vertexBuffers["uv"]) {
        const textureView = material.albedoMap?.view ?? this.dummyTextureView;
        if (!textureView)
          continue;
        const cacheKey = `${cascadeOrLayerIndex}-${material.albedoMap?.label ?? "dummy"}`;
        let alphaBindGroup = this.simpleInstancedAlphaBindGroupCache.get(cacheKey);
        if (!alphaBindGroup) {
          alphaBindGroup = this.device.createBindGroup({
            label: `Simple Instanced Alpha Shadow Bind Group - cascade ${cascadeOrLayerIndex}`,
            layout: this.simpleInstancedAlphaShadowPipeline.getBindGroupLayout(0),
            entries: [
              { binding: 0, resource: { buffer: uniformBuffer } },
              { binding: 1, resource: textureView },
              { binding: 2, resource: this.alphaSampler }
            ]
          });
          this.simpleInstancedAlphaBindGroupCache.set(cacheKey, alphaBindGroup);
        }
        passEncoder.setPipeline(this.simpleInstancedAlphaShadowPipeline);
        passEncoder.setBindGroup(0, alphaBindGroup);
        passEncoder.setVertexBuffer(0, geometry.vertexBuffers["position"]);
        passEncoder.setVertexBuffer(1, geometry.vertexBuffers["uv"]);
        passEncoder.setVertexBuffer(2, instancedMesh.instanceBuffer);
      } else {
        passEncoder.setPipeline(this.simpleInstancedShadowPipeline);
        passEncoder.setBindGroup(0, this.simpleInstancedBindGroups[cascadeOrLayerIndex]);
        passEncoder.setVertexBuffer(0, geometry.vertexBuffers["position"]);
        passEncoder.setVertexBuffer(1, instancedMesh.instanceBuffer);
      }
      if (geometry.indexBuffer) {
        const indexFormat = geometry.indices instanceof Uint32Array ? "uint32" : "uint16";
        passEncoder.setIndexBuffer(geometry.indexBuffer, indexFormat);
        passEncoder.drawIndexed(geometry.indexCount, instancedMesh.instanceCount);
      } else {
        passEncoder.draw(geometry.vertexCount, instancedMesh.instanceCount);
      }
    }
    if (!ShadowPass.hasLoggedInstancedShadow && instancedMeshes.length > 0) {
      console.log(`[ShadowPass SIMPLE] Rendered ${instancedMeshes.length} InstancedMesh shadows using simple pipeline`);
      ShadowPass.hasLoggedInstancedShadow = true;
    }
  }
  getShadowCastingLights(context) {
    const activeLights = context.scene.getClosestLights(context.camera.transform.position, 8);
    const maxLights = Math.min(context.scene.shadows.maxLights ?? 1, MAX_SHADOW_LIGHTS);
    return activeLights.filter((l) => (l.type === 0 /* Directional */ || l.type === 2 /* Spot */) && l.shadow.castShadow).slice(0, maxLights);
  }
  execute(commandEncoder, context, globalResources) {
    if (!this.pipeline || this.shadowUniformBuffers.length === 0 || !this.device || !globalResources.shadowAtlas)
      return;
    if (!context.scene.shadows.enabled)
      return;
    let shadowLights = this.getShadowCastingLights(context);
    if (shadowLights.length === 0) {
      const activeLights = context.scene.getClosestLights(context.camera.transform.position, 8);
      const fallbackLight = activeLights.find((l) => l.type === 0 /* Directional */);
      if (fallbackLight) {
        shadowLights = [fallbackLight];
      }
    }
    if (shadowLights.length === 0)
      return;
    this.frameCount++;
    const directionalLight = shadowLights.find((l) => l.type === 0 /* Directional */);
    const spotLights = shadowLights.filter((l) => l.type === 2 /* Spot */);
    let layerIndex = 0;
    const totalBuffers = CASCADE_COUNT + MAX_SHADOW_LIGHTS;
    if (this.lastObjectBuffer !== globalResources.objectBuffer.buffer) {
      console.log("[ShadowPass] Object buffer changed, recreating bind groups");
      this.bindGroups = [];
      this.lastObjectBuffer = globalResources.objectBuffer.buffer;
    }
    if (this.bindGroups.length === 0) {
      for (let i = 0;i < totalBuffers; i++) {
        this.bindGroups.push(this.device.createBindGroup({
          label: `Shadow Bind Group ${i}`,
          layout: this.pipeline.getBindGroupLayout(0),
          entries: [
            { binding: 0, resource: { buffer: this.shadowUniformBuffers[i] } },
            { binding: 1, resource: { buffer: globalResources.objectBuffer.buffer } }
          ]
        }));
      }
    }
    if (directionalLight) {
      const maxShadowDistance = context.scene.shadows.cascadeMaxDistance ?? this.defaultMaxShadowDistance;
      this.updateCascades(context.camera, directionalLight, maxShadowDistance);
      if (!this.hasLoggedCascade) {
        this.hasLoggedCascade = true;
      }
      for (let cascade = 0;cascade < CASCADE_COUNT; cascade++) {
        const viewProj = this.cascadeViewProjs[cascade];
        const viewProjArray = this.cascadeViewProjArrays[cascade];
        viewProjArray.set(viewProj.elements);
        this.device.queue.writeBuffer(this.shadowUniformBuffers[cascade], 0, viewProjArray.buffer);
        const layerView = globalResources.shadowAtlas.createView({
          dimension: "2d",
          baseArrayLayer: cascade,
          arrayLayerCount: 1
        });
        const passEncoder = commandEncoder.beginRenderPass({
          label: `Shadow Pass - Cascade ${cascade}`,
          colorAttachments: [],
          depthStencilAttachment: {
            view: layerView,
            depthClearValue: 1,
            depthLoadOp: "clear",
            depthStoreOp: "store"
          }
        });
        this.drawMeshesToShadowMap(passEncoder, context, globalResources, cascade, viewProjArray);
        passEncoder.end();
      }
      directionalLight.shadowAtlasIndex = 0;
      layerIndex = CASCADE_COUNT;
      for (let i = 0;i < this.cascadeSplits.length; i++) {
        this.cascadeSplitsArray[i] = this.cascadeSplits[i];
      }
      globalResources.updateCascadeUniforms(this.device, this.cascadeViewProjArrays, this.cascadeSplitsArray, this.cascadeBiases);
    }
    const spotLightData = [];
    for (let i = 0;i < spotLights.length && layerIndex < globalResources.shadowAtlas.depthOrArrayLayers; i++) {
      const light = spotLights[i];
      light.shadowAtlasIndex = i;
      const lightViewProj = ShadowUtils.getLightShadowViewProj(light, context.camera);
      const viewProjArray = this.spotLightViewProjArrays[i];
      viewProjArray.set(lightViewProj.elements);
      this.device.queue.writeBuffer(this.shadowUniformBuffers[layerIndex], 0, viewProjArray.buffer);
      spotLightData.push({
        viewProj: viewProjArray,
        atlasLayer: layerIndex,
        bias: light.shadow.bias,
        normalBias: light.shadow.normalBias
      });
      const layerView = globalResources.shadowAtlas.createView({
        dimension: "2d",
        baseArrayLayer: layerIndex,
        arrayLayerCount: 1
      });
      const passEncoder = commandEncoder.beginRenderPass({
        label: `Shadow Pass - Spot Light ${i}`,
        colorAttachments: [],
        depthStencilAttachment: {
          view: layerView,
          depthClearValue: 1,
          depthLoadOp: "clear",
          depthStoreOp: "store"
        }
      });
      this.drawMeshesToShadowMap(passEncoder, context, globalResources, layerIndex, viewProjArray);
      passEncoder.end();
      layerIndex++;
    }
    for (const light of context.scene.lights) {
      if (!shadowLights.includes(light) && light.type !== 1 /* Point */) {
        light.shadowAtlasIndex = -1;
      }
    }
    globalResources.updateShadowUniforms(this.device, spotLightData, globalResources.shadowAtlas.width);
    const shouldLog = this.frameCount === 1 || shadowLights.length !== this.lastLoggedLightCount || this.frameCount % 300 === 0;
    if (shouldLog) {
      this.lastLoggedLightCount = shadowLights.length;
    }
  }
  updateCascades(camera, light, maxShadowDistance) {
    this.cascadeSplits = this.calculateSplitDepths(camera, maxShadowDistance);
    const lightDir = light.transform.getForwardVector().normalize();
    let prevSplit = camera.near;
    for (let i = 0;i < CASCADE_COUNT; i++) {
      const split = this.cascadeSplits[i];
      this.cascadeViewProjs[i] = this.calculateLightMatrix(camera, lightDir, prevSplit, split);
      prevSplit = split;
    }
  }
  calculateSplitDepths(camera, maxShadowDistance) {
    const splits = [];
    const near = camera.near;
    const far = Math.min(camera.far, maxShadowDistance);
    const range = far - near;
    const ratio = far / near;
    for (let i = 0;i < CASCADE_COUNT; i++) {
      const p = (i + 1) / CASCADE_COUNT;
      const log2 = near * Math.pow(ratio, p);
      const uniform = near + range * p;
      const d = this.lambda * log2 + (1 - this.lambda) * uniform;
      splits.push(d);
    }
    return splits;
  }
  calculateLightMatrix(camera, lightDir, near, far) {
    const corners = this.getFrustumCorners(camera, near, far);
    let center = new Vector3(0, 0, 0);
    for (const c of corners)
      center = center.add(c);
    center = center.divide(corners.length);
    let radius = 0;
    for (const c of corners) {
      const dist = c.distanceTo(center);
      radius = Math.max(radius, dist);
    }
    radius *= 1.5;
    const minRadius = 100;
    radius = Math.max(radius, minRadius);
    const up = Math.abs(lightDir.y) > 0.9 ? new Vector3(0, 0, 1) : Vector3.up;
    const lightZ = lightDir.clone().normalize();
    let lightX = up.clone().cross(lightZ).normalize();
    if (lightX.magnitude() < 0.001) {
      const altUp = new Vector3(1, 0, 0);
      lightX = altUp.clone().cross(lightZ).normalize();
    }
    const lightY = lightZ.clone().cross(lightX).normalize();
    const worldUnitsPerTexel = 2 * radius / this.shadowMapSize;
    const centerDotX = center.dot(lightX);
    const centerDotY = center.dot(lightY);
    const centerDotZ = center.dot(lightZ);
    const snappedX = Math.floor(centerDotX / worldUnitsPerTexel) * worldUnitsPerTexel;
    const snappedY = Math.floor(centerDotY / worldUnitsPerTexel) * worldUnitsPerTexel;
    const snappedCenter = lightX.clone().multiply(snappedX).add(lightY.clone().multiply(snappedY)).add(lightZ.clone().multiply(centerDotZ));
    const lightDistance = radius + 200;
    const lightPos = snappedCenter.clone().subtract(lightDir.clone().multiply(lightDistance));
    const lightView = new Matrix4().lookAt(lightPos, snappedCenter, up);
    const minX = -radius;
    const maxX = radius;
    const minY = -radius;
    const maxY = radius;
    const orthoNear = 0.1;
    const orthoFar = lightDistance + radius + 200;
    const lightProj = new Matrix4().makeOrthographic(minX, maxX, maxY, minY, orthoNear, orthoFar);
    return lightProj.multiply(lightView);
  }
  getFrustumCorners(camera, near, far) {
    const aspect = camera.aspect;
    const fov = camera.fov;
    const tanHalfFov = Math.tan(fov * Math.PI / 180 * 0.5);
    const nearH = 2 * tanHalfFov * near;
    const nearW = nearH * aspect;
    const farH = 2 * tanHalfFov * far;
    const farW = farH * aspect;
    const viewInv = camera.viewMatrix.clone().invert();
    const cornersCam = [
      new Vector3(-nearW / 2, nearH / 2, -near),
      new Vector3(nearW / 2, nearH / 2, -near),
      new Vector3(-nearW / 2, -nearH / 2, -near),
      new Vector3(nearW / 2, -nearH / 2, -near),
      new Vector3(-farW / 2, farH / 2, -far),
      new Vector3(farW / 2, farH / 2, -far),
      new Vector3(-farW / 2, -farH / 2, -far),
      new Vector3(farW / 2, -farH / 2, -far)
    ];
    return cornersCam.map((c) => viewInv.transformVector(c));
  }
}

// ../../src/core/renderer/PointShadowPass.ts
class PointShadowPass {
  depthStencilState;
  pipeline = null;
  shadowUniformBuffer = null;
  device = null;
  depthTexture = null;
  faceDirections = [
    new Vector3(1, 0, 0),
    new Vector3(-1, 0, 0),
    new Vector3(0, 1, 0),
    new Vector3(0, -1, 0),
    new Vector3(0, 0, 1),
    new Vector3(0, 0, -1)
  ];
  faceUps = [
    new Vector3(0, -1, 0),
    new Vector3(0, -1, 0),
    new Vector3(0, 0, 1),
    new Vector3(0, 0, -1),
    new Vector3(0, -1, 0),
    new Vector3(0, -1, 0)
  ];
  constructor() {
    this.depthStencilState = {
      depthWriteEnabled: true,
      depthCompare: "less",
      format: "depth32float"
    };
  }
  init(device, context, presentationFormat) {
    this.device = device;
    const shaderCode = `
      struct ObjectData {
        modelMatrix : mat4x4<f32>,
        normalMatrix : mat4x4<f32>,
        aabbMin : vec3f,
        _pad1 : f32,
        aabbMax : vec3f,
        _pad2 : f32,
        prevModelMatrix : mat4x4<f32>,
        _pad3 : vec4<f32>,
        _pad4 : vec4<f32>,
      }
      @binding(1) @group(0) var<storage, read> objects : array<ObjectData>;

      struct VertexInput {
        @location(0) position : vec3<f32>,
      }

      struct VertexOutput {
        @builtin(position) position : vec4<f32>,
        @location(0) worldPos : vec3<f32>,
      }

      struct LightUniforms {
        lightViewProj : mat4x4<f32>,
        lightPos : vec3<f32>,
        far : f32,
      }
      @binding(0) @group(0) var<uniform> lightUniforms : LightUniforms;

      @vertex
      fn vs_main(input : VertexInput, @builtin(instance_index) instanceIndex : u32) -> VertexOutput {
        let model = objects[instanceIndex].modelMatrix;
        var output : VertexOutput;
        let worldPos4 = model * vec4<f32>(input.position, 1.0);
        output.position = lightUniforms.lightViewProj * worldPos4;
        output.worldPos = worldPos4.xyz;
        return output;
      }

      @fragment
      fn fs_main(input : VertexOutput) -> @location(0) f32 {
        // Calculate linear distance from light and normalize to [0,1]
        let lightToFrag = input.worldPos - lightUniforms.lightPos;
        let dist = length(lightToFrag);
        return dist / lightUniforms.far;
      }
    `;
    this.pipeline = device.createRenderPipeline({
      label: "Point Shadow Pipeline",
      layout: "auto",
      vertex: {
        module: createShaderModuleSafe(device, { code: shaderCode }),
        entryPoint: "vs_main",
        buffers: [
          {
            arrayStride: 12,
            attributes: [{ shaderLocation: 0, offset: 0, format: "float32x3" }]
          }
        ]
      },
      fragment: {
        module: createShaderModuleSafe(device, { code: shaderCode }),
        entryPoint: "fs_main",
        targets: [{ format: "r32float" }]
      },
      primitive: {
        topology: "triangle-list",
        cullMode: "none"
      },
      depthStencil: this.depthStencilState
    });
    this.shadowUniformBuffer = device.createBuffer({
      label: "Point Shadow Uniform Buffer",
      size: 256 * 6 * MAX_SHADOW_LIGHTS,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.depthTexture = device.createTexture({
      label: "Point Shadow Depth Buffer",
      size: [1024, 1024],
      format: "depth32float",
      usage: GPUTextureUsage.RENDER_ATTACHMENT
    });
  }
  resize(width, height) {}
  execute(commandEncoder, context, globalResources) {
    if (!this.pipeline || !this.shadowUniformBuffer || !this.device || !globalResources.pointShadowAtlas || !this.depthTexture)
      return;
    if (!context.scene.shadows.enabled)
      return;
    const activeLights = context.scene.getClosestLights(context.camera.transform.position, 256);
    const pointLights = activeLights.filter((l) => l.type === 1 /* Point */ && l.shadow.castShadow);
    if (pointLights.length === 0)
      return;
    const depthView = this.depthTexture.createView();
    for (const light of pointLights) {
      if (light.shadowAtlasIndex < 0 || light.shadowAtlasIndex >= MAX_SHADOW_LIGHTS)
        continue;
      const lightIndex = light.shadowAtlasIndex;
      const near = 0.1;
      const far = 100;
      const fovRadians = 90 * Math.PI / 180;
      const projection = new Matrix4().makePerspective(fovRadians, 1, near, far);
      const lightPos = light.transform.position;
      for (let face = 0;face < 6; face++) {
        const lookTarget = lightPos.clone().add(this.faceDirections[face]);
        const view = new Matrix4().lookAt(lightPos, lookTarget, this.faceUps[face]);
        const viewProj = projection.clone().multiply(view);
        const offset = (lightIndex * 6 + face) * 256;
        const uniformData = new Float32Array(20);
        uniformData.set(viewProj.elements, 0);
        uniformData[16] = lightPos.x;
        uniformData[17] = lightPos.y;
        uniformData[18] = lightPos.z;
        uniformData[19] = far;
        this.device.queue.writeBuffer(this.shadowUniformBuffer, offset, uniformData);
        const layer = lightIndex * 6 + face;
        const colorView = globalResources.pointShadowAtlas.createView({
          dimension: "2d",
          baseArrayLayer: layer,
          arrayLayerCount: 1
        });
        const bindGroup = this.device.createBindGroup({
          label: `Point Shadow BindGroup L${lightIndex} F${face}`,
          layout: this.pipeline.getBindGroupLayout(0),
          entries: [
            { binding: 0, resource: { buffer: this.shadowUniformBuffer, offset, size: 80 } },
            { binding: 1, resource: { buffer: globalResources.objectBuffer.buffer } }
          ]
        });
        const passEncoder = commandEncoder.beginRenderPass({
          label: `Point Shadow L${lightIndex} F${face}`,
          colorAttachments: [{
            view: colorView,
            clearValue: { r: 1, g: 0, b: 0, a: 1 },
            loadOp: "clear",
            storeOp: "store"
          }],
          depthStencilAttachment: {
            view: depthView,
            depthClearValue: 1,
            depthLoadOp: "clear",
            depthStoreOp: "discard"
          }
        });
        passEncoder.setPipeline(this.pipeline);
        passEncoder.setBindGroup(0, bindGroup);
        context.scene.traverse((node) => {
          if (!node.visible)
            return false;
          if (node instanceof Mesh && node.material instanceof Material) {
            if (node.geometry.buffersDirty) {
              return;
            }
            if (node.geometry.vertexBuffers["position"]) {
              passEncoder.setVertexBuffer(0, node.geometry.vertexBuffers["position"]);
              const instanceIndex = node.renderIndex;
              if (node.geometry.indexBuffer) {
                const indexFormat = node.geometry.indices instanceof Uint32Array ? "uint32" : "uint16";
                passEncoder.setIndexBuffer(node.geometry.indexBuffer, indexFormat);
                passEncoder.drawIndexed(node.geometry.indexCount, 1, 0, 0, instanceIndex);
              } else {
                passEncoder.draw(node.geometry.vertexCount, 1, 0, instanceIndex);
              }
            }
          }
        });
        passEncoder.end();
      }
    }
  }
}

// ../../src/core/renderer/shaders/AtmosphereCommon.ts
var AtmosphereCommonWGSL = `
// Constants
const PI: f32 = 3.14159265358979323846;
const rad: f32 = 1.0;
const m: f32 = 1.0;
const km: f32 = 1000.0 * m;
const m2: f32 = m * m;
const m3: f32 = m * m * m;
const pi: f32 = PI * rad;
const deg: f32 = pi / 180.0;
const watt: f32 = 1.0;
const lm: f32 = 1.0;
const sr: f32 = 1.0;
const nm: f32 = 1.0;

// Units
const watt_per_square_meter: f32 = watt / m2;
const watt_per_square_meter_per_sr: f32 = watt / (m2 * sr);
const watt_per_square_meter_per_nm: f32 = watt / (m2 * nm);
const watt_per_square_meter_per_sr_per_nm: f32 = watt / (m2 * sr * nm);
const watt_per_cubic_meter_per_sr_per_nm: f32 = watt / (m3 * sr * nm);
const cd: f32 = lm / sr;
const kcd: f32 = 1000.0 * cd;
const cd_per_square_meter: f32 = cd / m2;
const kcd_per_square_meter: f32 = kcd / m2;

struct DensityProfileLayer {
    width: f32,
    exp_term: f32,
    exp_scale: f32,
    linear_term: f32,
    constant_term: f32,
}

struct DensityProfile {
    layers: array<DensityProfileLayer, 2>,
}

struct AtmosphereParameters {
    solar_irradiance: vec3f,
    sun_angular_radius: f32,
    absorption_extinction: vec3f,
    mu_s_min: f32,
    rayleigh_scattering: vec3f,
    mie_phase_function_g: f32,
    mie_scattering: vec3f,
    bottom_radius: f32,
    mie_extinction: vec3f,
    top_radius: f32,
    mie_absorption: vec3f,
    pad00: f32,
    ground_albedo: vec3f,
    pad0: f32,
    // Densities are flattened in Uniform Buffer, but we reconstruct them or access via array
    // We will use a helper to unpack or access directly from the uniform buffer structure 
    // defined in the main shader. 
    // For now, let's assume we pass the struct or use global access.
}

// Uniform Buffer Definition (Must match AtmospherePass.ts)
struct AtmosphereUniforms {
    solar_irradiance: vec3f,
    sun_angular_radius: f32,
    absorption_extinction: vec3f,
    mu_s_min: f32,
    rayleigh_scattering: vec3f,
    mie_phase_function_g: f32,
    mie_scattering: vec3f,
    bottom_radius: f32,
    mie_extinction: vec3f,
    top_radius: f32,
    mie_absorption: vec3f,
    pad00: f32,
    ground_albedo: vec3f,
    pad0: f32,

    // Arrays flattened as vec4s
    rayleigh_density: array<vec4f, 3>,
    mie_density: array<vec4f, 3>,
    absorption_density: array<vec4f, 3>,

    // Dynamic Params
    sun_direction: vec3f,
    pad1: f32,
    camera_position: vec3f,
    pad2: f32,

    // === Celestial Configuration ===
    // Sun disk: enabled, scale, pad, pad
    sun_disk_enabled: f32,
    sun_disk_scale: f32,
    pad3: f32,
    pad4: f32,

    // Moon: direction + enabled
    moon_direction: vec3f,
    moon_enabled: f32,

    // Moon: phase, scale, angular_radius, pad
    moon_phase: f32,
    moon_scale: f32,
    moon_angular_radius: f32,
    pad5: f32,

    // Moon color + pad
    moon_color: vec3f,
    pad6: f32,

    // Stars: enabled, intensity, twinkle, time
    stars_enabled: f32,
    stars_intensity: f32,
    stars_twinkle: f32,
    stars_time: f32,

    // Custom skybox: enabled, blend, pad, pad
    custom_skybox_enabled: f32,
    custom_skybox_blend: f32,
    pad7: f32,
    pad8: f32,

    // Clouds
    cloud_color: vec3f,
    cloud_enabled: f32,
    
    cloud_wind_direction: vec3f,
    cloud_coverage: f32,

    cloud_altitude: f32,
    cloud_height: f32,
    cloud_density: f32,
    cloud_speed: f32,

    cloud_quality: u32,  // 0=low (2D plane), 1=medium (12 steps), 2=high (32 steps)
    pad9: u32,
    pad10: u32,
    pad11: u32,
}

// @group(0) @binding(0) var<uniform> atmosphere : AtmosphereUniforms; // Removed, must be declared by user

// Helper to unpack DensityProfile from Uniforms
fn GetRayleighDensityProfile() -> DensityProfile {
    var p: DensityProfile;
    // Layer 0
    p.layers[0].width = atmosphere.rayleigh_density[0].x;
    p.layers[0].exp_term = atmosphere.rayleigh_density[0].y;
    p.layers[0].exp_scale = atmosphere.rayleigh_density[0].z;
    p.layers[0].linear_term = atmosphere.rayleigh_density[0].w;
    p.layers[0].constant_term = atmosphere.rayleigh_density[1].x;
    // Layer 1
    p.layers[1].width = atmosphere.rayleigh_density[1].y;
    p.layers[1].exp_term = atmosphere.rayleigh_density[1].z;
    p.layers[1].exp_scale = atmosphere.rayleigh_density[1].w;
    p.layers[1].linear_term = atmosphere.rayleigh_density[2].x;
    p.layers[1].constant_term = atmosphere.rayleigh_density[2].y;
    return p;
}

fn GetMieDensityProfile() -> DensityProfile {
    var p: DensityProfile;
    p.layers[0].width = atmosphere.mie_density[0].x;
    p.layers[0].exp_term = atmosphere.mie_density[0].y;
    p.layers[0].exp_scale = atmosphere.mie_density[0].z;
    p.layers[0].linear_term = atmosphere.mie_density[0].w;
    p.layers[0].constant_term = atmosphere.mie_density[1].x;
    p.layers[1].width = atmosphere.mie_density[1].y;
    p.layers[1].exp_term = atmosphere.mie_density[1].z;
    p.layers[1].exp_scale = atmosphere.mie_density[1].w;
    p.layers[1].linear_term = atmosphere.mie_density[2].x;
    p.layers[1].constant_term = atmosphere.mie_density[2].y;
    return p;
}

fn GetAbsorptionDensityProfile() -> DensityProfile {
    var p: DensityProfile;
    p.layers[0].width = atmosphere.absorption_density[0].x;
    p.layers[0].exp_term = atmosphere.absorption_density[0].y;
    p.layers[0].exp_scale = atmosphere.absorption_density[0].z;
    p.layers[0].linear_term = atmosphere.absorption_density[0].w;
    p.layers[0].constant_term = atmosphere.absorption_density[1].x;
    p.layers[1].width = atmosphere.absorption_density[1].y;
    p.layers[1].exp_term = atmosphere.absorption_density[1].z;
    p.layers[1].exp_scale = atmosphere.absorption_density[1].w;
    p.layers[1].linear_term = atmosphere.absorption_density[2].x;
    p.layers[1].constant_term = atmosphere.absorption_density[2].y;
    return p;
}

// Math Functions
fn ClampCosine(mu: f32) -> f32 {
    return clamp(mu, -1.0, 1.0);
}

fn ClampDistance(d: f32) -> f32 {
    return max(d, 0.0 * m);
}

fn ClampRadius(r: f32) -> f32 {
    return clamp(r, atmosphere.bottom_radius, atmosphere.top_radius);
}

fn SafeSqrt(a: f32) -> f32 {
    return sqrt(max(a, 0.0));
}

fn DistanceToTopAtmosphereBoundary(r: f32, mu: f32) -> f32 {
    let discriminant = r * r * (mu * mu - 1.0) + atmosphere.top_radius * atmosphere.top_radius;
    return ClampDistance(-r * mu + SafeSqrt(discriminant));
}

fn DistanceToBottomAtmosphereBoundary(r: f32, mu: f32) -> f32 {
    let discriminant = r * r * (mu * mu - 1.0) + atmosphere.bottom_radius * atmosphere.bottom_radius;
    return ClampDistance(-r * mu - SafeSqrt(discriminant));
}

fn RayIntersectsGround(r: f32, mu: f32) -> bool {
    // Check if ray starts inside ground? (r < bottom) -> assume not possible or handled
    // Check if line intersects sphere
    return mu < 0.0 && (r * r * (mu * mu - 1.0) + atmosphere.bottom_radius * atmosphere.bottom_radius) >= 0.0;
}

fn GetLayerDensity(layer: DensityProfileLayer, altitude: f32) -> f32 {
    let density = layer.exp_term * exp(layer.exp_scale * altitude) + layer.linear_term * altitude + layer.constant_term;
    return clamp(density, 0.0, 1.0);
}

fn GetProfileDensity(profile: DensityProfile, altitude: f32) -> f32 {
    // Layer 0 is [bottom, bottom + width]
    // Layer 1 is [bottom + width, top] (width ignored/infinite)
    if (altitude < profile.layers[0].width) {
        return GetLayerDensity(profile.layers[0], altitude);
    }
    return GetLayerDensity(profile.layers[1], altitude);
}

fn ComputeOpticalLengthToTopAtmosphereBoundary(profile: DensityProfile, r: f32, mu: f32) -> f32 {
    let SAMPLE_COUNT = 500u;
    let dx = DistanceToTopAtmosphereBoundary(r, mu) / f32(SAMPLE_COUNT);
    var result = 0.0;
    for (var i = 0u; i <= SAMPLE_COUNT; i++) {
        let d_i = f32(i) * dx;
        let r_i = sqrt(d_i * d_i + 2.0 * r * mu * d_i + r * r);
        let y_i = GetProfileDensity(profile, r_i - atmosphere.bottom_radius);
        let weight_i = select(1.0, 0.5, i == 0u || i == SAMPLE_COUNT);
        result += y_i * weight_i * dx;
    }
    return result;
}

fn ComputeTransmittanceToTopAtmosphereBoundary(r: f32, mu: f32) -> vec3f {
    let rayleigh = GetRayleighDensityProfile();
    let mie = GetMieDensityProfile();
    let absorption = GetAbsorptionDensityProfile();

    let rayleigh_length = ComputeOpticalLengthToTopAtmosphereBoundary(rayleigh, r, mu);
    let mie_length = ComputeOpticalLengthToTopAtmosphereBoundary(mie, r, mu);
    let absorption_length = ComputeOpticalLengthToTopAtmosphereBoundary(absorption, r, mu);
    
    return exp(-(
        atmosphere.rayleigh_scattering * rayleigh_length +
        atmosphere.mie_extinction * mie_length +
        atmosphere.absorption_extinction * absorption_length
    ));
}

// LUT Mapping Constants
const TRANSMITTANCE_TEXTURE_WIDTH: f32 = 256.0;
const TRANSMITTANCE_TEXTURE_HEIGHT: f32 = 64.0;

fn GetTextureCoordFromUnitRange(x: f32, texture_size: f32) -> f32 {
    return 0.5 / texture_size + x * (1.0 - 1.0 / texture_size);
}

fn GetUnitRangeFromTextureCoord(u: f32, texture_size: f32) -> f32 {
    return (u - 0.5 / texture_size) / (1.0 - 1.0 / texture_size);
}

fn GetTransmittanceTextureUvFromRMu(r: f32, mu: f32) -> vec2f {
    // r in [bottom, top]
    // mu in [-1, 1]
    
    let H = sqrt(atmosphere.top_radius * atmosphere.top_radius - atmosphere.bottom_radius * atmosphere.bottom_radius);
    let rho = SafeSqrt(r * r - atmosphere.bottom_radius * atmosphere.bottom_radius);
    
    let d = DistanceToTopAtmosphereBoundary(r, mu);
    let d_min = atmosphere.top_radius - r;
    let d_max = rho + H;
    
    let x_mu = (d - d_min) / (d_max - d_min);
    let x_r = rho / H;
    
    return vec2f(
        GetTextureCoordFromUnitRange(x_mu, TRANSMITTANCE_TEXTURE_WIDTH),
        GetTextureCoordFromUnitRange(x_r, TRANSMITTANCE_TEXTURE_HEIGHT)
    );
}

fn GetRMuFromTransmittanceTextureUv(uv: vec2f) -> vec2f {
    let x_mu = GetUnitRangeFromTextureCoord(uv.x, TRANSMITTANCE_TEXTURE_WIDTH);
    let x_r = GetUnitRangeFromTextureCoord(uv.y, TRANSMITTANCE_TEXTURE_HEIGHT);
    
    let H = sqrt(atmosphere.top_radius * atmosphere.top_radius - atmosphere.bottom_radius * atmosphere.bottom_radius);
    let rho = x_r * H;
    
    let r = sqrt(rho * rho + atmosphere.bottom_radius * atmosphere.bottom_radius);
    
    let d_min = atmosphere.top_radius - r;
    let d_max = rho + H;
    let d = d_min + x_mu * (d_max - d_min);
    
    let mu = select((H * H - rho * rho - d * d) / (2.0 * r * d), 1.0, d == 0.0);
    
    return vec2f(ClampRadius(r), ClampCosine(mu));
}

// Compute Shader Entry Logic Wrapper
fn ComputeTransmittanceToTopAtmosphereBoundaryTexture(global_id: vec3u) -> vec3f {
    let uv = vec2f(f32(global_id.x) + 0.5, f32(global_id.y) + 0.5) / vec2f(TRANSMITTANCE_TEXTURE_WIDTH, TRANSMITTANCE_TEXTURE_HEIGHT);
    
    let r_mu = GetRMuFromTransmittanceTextureUv(uv);
    let r = r_mu.x;
    let mu = r_mu.y;
    
    return ComputeTransmittanceToTopAtmosphereBoundary(r, mu);
}

// Phase Functions
fn RayleighPhaseFunction(nu: f32) -> f32 {
    let k = 3.0 / (16.0 * PI);
    return k * (1.0 + nu * nu);
}

// Original Henyey-Greenstein phase function
fn MiePhaseFunction(g: f32, nu: f32) -> f32 {
    let k = 3.0 / (8.0 * PI) * (1.0 - g * g) / (2.0 + g * g);
    return k * (1.0 + nu * nu) / pow(1.0 + g * g - 2.0 * g * nu, 1.5);
}

// Cornette-Shanks phase function - more physically accurate for Mie scattering
// Better handles the forward scattering peak and rainbow angles
fn CornetteShanksPhaseFunction(g: f32, nu: f32) -> f32 {
    let k = 3.0 / (8.0 * PI) * (1.0 - g * g) / (2.0 + g * g);
    let denom = pow(1.0 + g * g - 2.0 * g * nu, 1.5);
    return k * (1.0 + nu * nu) / denom;
}

// Schlick approximation - faster than HG but similar result
fn SchlickPhaseFunction(g: f32, nu: f32) -> f32 {
    let k = (1.0 - g * g) / (4.0 * PI * pow(1.0 + g * (g - 2.0 * nu), 2.0));
    return k;
}

// Compute ground irradiance contribution (light scattered from atmosphere to ground)
fn ComputeGroundIrradiance(
    transmittance_texture: texture_2d<f32>,
    transmittance_sampler: sampler,
    r: f32,
    mu_s: f32
) -> vec3f {
    // Direct irradiance from sun
    let transmittanceToSun = GetTransmittance(transmittance_texture, transmittance_sampler, r, mu_s);
    let directIrradiance = atmosphere.solar_irradiance * transmittanceToSun * max(0.0, mu_s);

    return directIrradiance;
}

// Compute ground-reflected contribution to sky radiance
// This adds the "bounce light" from the ground back into the atmosphere
fn ComputeGroundReflectedRadiance(
    groundAlbedo: vec3f,
    groundIrradiance: vec3f,
    transmittanceToGround: vec3f
) -> vec3f {
    // Ground reflects irradiance isotropically (Lambertian)
    // The factor 1/PI comes from Lambertian BRDF normalization
    return groundAlbedo * groundIrradiance * transmittanceToGround / PI;
}

// Improved horizon blending factor
// Creates smooth transition at horizon with proper atmospheric darkening
fn ComputeHorizonBlendFactor(viewZenithCos: f32, r: f32) -> f32 {
    // Compute horizon angle based on altitude
    let horizonCos = -SafeSqrt(1.0 - (atmosphere.bottom_radius * atmosphere.bottom_radius) / (r * r));

    // Smooth transition zone around horizon
    let transitionWidth = 0.05;
    let aboveHorizon = smoothstep(horizonCos - transitionWidth, horizonCos + transitionWidth, viewZenithCos);

    // Additional darkening at exact horizon (limb darkening effect)
    let horizonDarkening = 1.0 - exp(-abs(viewZenithCos - horizonCos) * 30.0) * 0.3;

    return aboveHorizon * horizonDarkening;
}

// Aerial perspective contribution - adds atmospheric haze based on path length
fn ComputeAerialPerspective(
    transmittance: vec3f,
    inscatter: vec3f,
    pathLength: f32
) -> vec3f {
    // Blend between object color and atmosphere based on transmittance
    // Longer paths = more atmospheric contribution
    let atmosphericBlend = 1.0 - (transmittance.r + transmittance.g + transmittance.b) / 3.0;
    return inscatter * atmosphericBlend;
}

// Texture Lookups
fn GetTransmittance(tex: texture_2d<f32>, sam: sampler, r: f32, mu: f32) -> vec3f {
    let uv = GetTransmittanceTextureUvFromRMu(r, mu);
    return textureSampleLevel(tex, sam, uv, 0.0).rgb;
}

fn GetTransmittanceToSun(tex: texture_2d<f32>, sam: sampler, r: f32, mu_s: f32) -> vec3f {
    let sin_theta_h = atmosphere.bottom_radius / r;
    let cos_theta_h = -sqrt(max(1.0 - sin_theta_h * sin_theta_h, 0.0));
    
    // If ray intersects ground, return 0 (shadow) - handled by horizon check mostly?
    // But for transmittance to sun, we just check mu_s vs horizon?
    // The reference uses GetTransmittanceToTopAtmosphereBoundary logic.
    return GetTransmittance(tex, sam, r, mu_s);
}

fn DistanceToNearestAtmosphereBoundary(r: f32, mu: f32, ray_r_mu_intersects_ground: bool) -> f32 {
    if (ray_r_mu_intersects_ground) {
        return DistanceToBottomAtmosphereBoundary(r, mu);
    }
    return DistanceToTopAtmosphereBoundary(r, mu);
}

fn GetTransmittanceToBoundary(tex: texture_2d<f32>, sam: sampler, r: f32, mu: f32) -> vec3f {
    // Helper to call GetTransmittance (Top)
    // Note: The original GetTransmittance assumes Top Boundary.
    return GetTransmittance(tex, sam, r, mu);
}

fn GetTransmittanceBetween(tex: texture_2d<f32>, sam: sampler, r: f32, mu: f32, d: f32, ray_r_mu_intersects_ground: bool) -> vec3f {
    let r_d = ClampRadius(sqrt(d * d + 2.0 * r * mu * d + r * r));
    let mu_d = ClampCosine((r * mu + d) / r_d);

    if (ray_r_mu_intersects_ground) {
        return min(
            GetTransmittanceToBoundary(tex, sam, r_d, -mu_d) /
            GetTransmittanceToBoundary(tex, sam, r, -mu),
            vec3f(1.0)
        );
    } else {
        return min(
            GetTransmittanceToBoundary(tex, sam, r, mu) /
            GetTransmittanceToBoundary(tex, sam, r_d, mu_d),
            vec3f(1.0)
        );
    }
}

// 3D LUT Constants
const SCATTERING_TEXTURE_R_SIZE: f32 = 32.0;
const SCATTERING_TEXTURE_MU_SIZE: f32 = 128.0;
const SCATTERING_TEXTURE_MU_S_SIZE: f32 = 32.0;
const SCATTERING_TEXTURE_NU_SIZE: f32 = 8.0;

fn GetScatteringTextureUvwzFromRMuMuSNu(r: f32, mu: f32, mu_s: f32, nu: f32, ray_r_mu_intersects_ground: bool) -> vec4f {
    let H = sqrt(atmosphere.top_radius * atmosphere.top_radius - atmosphere.bottom_radius * atmosphere.bottom_radius);
    let rho = SafeSqrt(r * r - atmosphere.bottom_radius * atmosphere.bottom_radius);
    let u_r = GetTextureCoordFromUnitRange(rho / H, SCATTERING_TEXTURE_R_SIZE);
    
    let r_mu = r * mu;
    let discriminant = r_mu * r_mu - r * r + atmosphere.bottom_radius * atmosphere.bottom_radius;
    var u_mu = 0.0;
    
    if (ray_r_mu_intersects_ground) {
        let d = -r_mu - SafeSqrt(discriminant);
        let d_min = r - atmosphere.bottom_radius;
        let d_max = rho;
        u_mu = 0.5 - 0.5 * GetTextureCoordFromUnitRange(
             select((d - d_min) / (d_max - d_min), 0.0, d_max == d_min), 
             SCATTERING_TEXTURE_MU_SIZE / 2.0
        );
    } else {
        let d = -r_mu + SafeSqrt(discriminant + H * H);
        let d_min = atmosphere.top_radius - r;
        let d_max = rho + H;
        u_mu = 0.5 + 0.5 * GetTextureCoordFromUnitRange(
            (d - d_min) / (d_max - d_min), 
            SCATTERING_TEXTURE_MU_SIZE / 2.0
        );
    }
    
    let d = DistanceToTopAtmosphereBoundary(atmosphere.bottom_radius, mu_s);
    let d_min = atmosphere.top_radius - atmosphere.bottom_radius;
    let d_max = H;
    let a = (d - d_min) / (d_max - d_min);
    let A = -2.0 * atmosphere.mu_s_min * atmosphere.bottom_radius / (d_max - d_min);
    let u_mu_s = GetTextureCoordFromUnitRange(
        max(1.0 - a / A, 0.0) / (1.0 + a), SCATTERING_TEXTURE_MU_S_SIZE
    );
    
    let u_nu = (nu + 1.0) / 2.0;
    return vec4f(u_nu, u_mu_s, u_mu, u_r);
}

fn GetRMuMuSNuFromScatteringTextureFragCoord(frag_coord: vec3f) -> vec4f {
    // Returns vec4(r, mu, mu_s, nu)
    // We also need ray_r_mu_intersects_ground, but return generic vector for now.
    // Wait, the logic is complex and returns multiple values.
    // I'll implement a specific struct or update usage.
    // For now, let's implement the internal logic to extract U, V, W, Z.
    
    let SCATTERING_TEXTURE_SIZE = vec4f(
        SCATTERING_TEXTURE_NU_SIZE - 1.0,
        SCATTERING_TEXTURE_MU_S_SIZE,
        SCATTERING_TEXTURE_MU_SIZE,
        SCATTERING_TEXTURE_R_SIZE
    );
    
    let frag_coord_nu = floor(frag_coord.x / SCATTERING_TEXTURE_MU_S_SIZE);
    let frag_coord_mu_s = frag_coord.x - frag_coord_nu * SCATTERING_TEXTURE_MU_S_SIZE; // mod
    
    let uvwz = vec4f(frag_coord_nu, frag_coord_mu_s, frag_coord.y, frag_coord.z) / SCATTERING_TEXTURE_SIZE;
    
    var r = 0.0;
    var mu = 0.0;
    var mu_s = 0.0;
    var nu = 0.0;
    
    // Inverse Mapping
    let H = sqrt(atmosphere.top_radius * atmosphere.top_radius - atmosphere.bottom_radius * atmosphere.bottom_radius);
    let rho = H * GetUnitRangeFromTextureCoord(uvwz.w, SCATTERING_TEXTURE_R_SIZE);
    r = sqrt(rho * rho + atmosphere.bottom_radius * atmosphere.bottom_radius);
    
    if (uvwz.z < 0.5) {
        let d_min = r - atmosphere.bottom_radius;
        let d_max = rho;
        let d = d_min + (d_max - d_min) * GetUnitRangeFromTextureCoord(1.0 - 2.0 * uvwz.z, SCATTERING_TEXTURE_MU_SIZE / 2.0);
        mu = select(ClampCosine(-(rho * rho + d * d) / (2.0 * r * d)), -1.0, d == 0.0);
    } else {
        let d_min = atmosphere.top_radius - r;
        let d_max = rho + H;
        let d = d_min + (d_max - d_min) * GetUnitRangeFromTextureCoord(2.0 * uvwz.z - 1.0, SCATTERING_TEXTURE_MU_SIZE / 2.0);
        mu = select(ClampCosine((H * H - rho * rho - d * d) / (2.0 * r * d)), 1.0, d == 0.0);
    }
    
    let x_mu_s = GetUnitRangeFromTextureCoord(uvwz.y, SCATTERING_TEXTURE_MU_S_SIZE);
    let d_min = atmosphere.top_radius - atmosphere.bottom_radius;
    let d_max = H;
    let A = -2.0 * atmosphere.mu_s_min * atmosphere.bottom_radius / (d_max - d_min);
    let a = (A - x_mu_s * A) / (1.0 + x_mu_s * A);
    let d = d_min + min(a, A) * (d_max - d_min);
    mu_s = select(ClampCosine((H * H - d * d) / (2.0 * atmosphere.bottom_radius * d)), 1.0, d == 0.0);
    
    nu = ClampCosine(uvwz.x * 2.0 - 1.0);
    
    // Clamp nu
    nu = clamp(nu, mu * mu_s - sqrt((1.0 - mu * mu) * (1.0 - mu_s * mu_s)), mu * mu_s + sqrt((1.0 - mu * mu) * (1.0 - mu_s * mu_s)));
    
    return vec4f(r, mu, mu_s, nu);
}

// Single Scattering Integrator
fn ComputeSingleScatteringTexture(
    transmittance_texture: texture_2d<f32>, 
    transmittance_sampler: sampler, 
    frag_coord: vec3f
) -> vec4f { // Returns Rayleigh (rgb) + Mie (r in alpha?)
    let params = GetRMuMuSNuFromScatteringTextureFragCoord(frag_coord);
    let r = params.x;
    let mu = params.y;
    let mu_s = params.z;
    let nu = params.w;
    
    let ray_r_mu_intersects_ground = RayIntersectsGround(r, mu);
    
    let SAMPLE_COUNT = 50u;
    let dx = DistanceToNearestAtmosphereBoundary(r, mu, ray_r_mu_intersects_ground) / f32(SAMPLE_COUNT);
    
    var rayleigh_sum = vec3f(0.0);
    var mie_sum = vec3f(0.0);
    
    for (var i = 0u; i <= SAMPLE_COUNT; i++) {
        let d_i = f32(i) * dx;
        let r_d = ClampRadius(sqrt(d_i * d_i + 2.0 * r * mu * d_i + r * r));
        let mu_s_d = ClampCosine((r * mu_s + d_i * nu) / r_d);
        
        let transmittance = GetTransmittanceBetween(transmittance_texture, transmittance_sampler, r, mu, d_i, ray_r_mu_intersects_ground) *
            GetTransmittanceToSun(transmittance_texture, transmittance_sampler, r_d, mu_s_d);
            
        let rayleigh_density = GetProfileDensity(GetRayleighDensityProfile(), r_d - atmosphere.bottom_radius);
        let mie_density = GetProfileDensity(GetMieDensityProfile(), r_d - atmosphere.bottom_radius);
        
        let rayleigh_i = transmittance * rayleigh_density;
        let mie_i = transmittance * mie_density;
        
        let weight_i = select(1.0, 0.5, i == 0u || i == SAMPLE_COUNT);
        rayleigh_sum += rayleigh_i * weight_i;
        mie_sum += mie_i * weight_i;
    }
    
    let rayleigh = rayleigh_sum * dx * atmosphere.solar_irradiance * atmosphere.rayleigh_scattering;
    let mie = mie_sum * dx * atmosphere.solar_irradiance * atmosphere.mie_scattering;
    
    // Store Rayleigh in RGB, Mie Red in Alpha (Standard Bruneton packing)
    return vec4f(rayleigh, mie.r); 
}

// SkyViewLUT Mapping
const SKY_VIEW_W = 192.0;
const SKY_VIEW_H = 108.0;

fn raySphereIntersectNearest(r0: vec3f, rd: vec3f, s0: vec3f, sR: f32) -> f32 {
    let a = dot(rd, rd);
    let s0_r0 = r0 - s0;
    let b = 2.0 * dot(rd, s0_r0);
    let c = dot(s0_r0, s0_r0) - (sR * sR);
    let delta = b * b - 4.0 * a * c;
    if (delta < 0.0 || a == 0.0) {
        return -1.0;
    }
    let sol0 = (-b - sqrt(delta)) / (2.0 * a);
    let sol1 = (-b + sqrt(delta)) / (2.0 * a);
    if (sol0 < 0.0 && sol1 < 0.0) {
        return -1.0;
    }
    if (sol0 < 0.0) { return max(0.0, sol1); }
    else if (sol1 < 0.0) { return max(0.0, sol0); }
    return max(0.0, min(sol0, sol1));
}

fn UvToSkyViewLutParams(uv: vec2f, viewHeight: f32) -> vec2f {
    // Returns vec2(viewZenithCosAngle, lightViewCosAngle)
    // Constrain UVs
    let uv_sub = vec2f(fromSubUvsToUnit(uv.x, SKY_VIEW_W), fromSubUvsToUnit(uv.y, SKY_VIEW_H));
    
    let Vhorizon = SafeSqrt(viewHeight * viewHeight - atmosphere.bottom_radius * atmosphere.bottom_radius);
    let CosBeta = Vhorizon / viewHeight;
    let Beta = acos(CosBeta);
    let ZenithHorizonAngle = PI - Beta;
    
    var viewZenithCosAngle = 0.0;
    if (uv_sub.y < 0.5) {
        var coord = 2.0 * uv_sub.y;
        coord = 1.0 - coord;
        coord *= coord; // Non-linear
        coord = 1.0 - coord;
        viewZenithCosAngle = cos(ZenithHorizonAngle * coord);
    } else {
        var coord = uv_sub.y * 2.0 - 1.0;
        coord *= coord; // Non-linear
        viewZenithCosAngle = cos(ZenithHorizonAngle + Beta * coord);
    }
    
    var coord = uv_sub.x;
    coord *= coord;
    let lightViewCosAngle = -(coord * 2.0 - 1.0);
    
    return vec2f(viewZenithCosAngle, lightViewCosAngle);
}

fn SkyViewLutParamsToUv(viewZenithCosAngle: f32, lightViewCosAngle: f32, viewHeight: f32) -> vec2f {
    let Vhorizon = SafeSqrt(viewHeight * viewHeight - atmosphere.bottom_radius * atmosphere.bottom_radius);
    let CosBeta = Vhorizon / viewHeight;
    let Beta = acos(CosBeta);
    let ZenithHorizonAngle = PI - Beta;
    
    var v = 0.0;
    let IntersectGround = raySphereIntersectNearest(vec3f(0.0, viewHeight, 0.0), vec3f(sqrt(max(0.0, 1.0 - viewZenithCosAngle*viewZenithCosAngle)), viewZenithCosAngle, 0.0), vec3f(0.0), atmosphere.bottom_radius) >= 0.0;
    // Or simpler check: viewZenithCosAngle < CosBeta? No, CosBeta is positive.
    // If angle > ZenithHorizonAngle?
    
    if (!IntersectGround) {
        var coord = acos(viewZenithCosAngle) / ZenithHorizonAngle;
        coord = 1.0 - coord;
        coord = SafeSqrt(coord);
        coord = 1.0 - coord;
        v = coord * 0.5;
    } else {
        var coord = (acos(viewZenithCosAngle) - ZenithHorizonAngle) / Beta;
        coord = SafeSqrt(coord);
        v = coord * 0.5 + 0.5;
    }
    
    var coord = -lightViewCosAngle * 0.5 + 0.5;
    coord = SafeSqrt(coord);
    let u = coord;
    
    return vec2f(fromUnitToSubUvs(u, SKY_VIEW_W), fromUnitToSubUvs(v, SKY_VIEW_H));
}

fn fromSubUvsToUnit(u: f32, resolution: f32) -> f32 {
    return (u - 0.5 / resolution) * (resolution / (resolution - 1.0));
}

fn fromUnitToSubUvs(u: f32, resolution: f32) -> f32 {
    return (u + 0.5 / resolution) * (resolution / (resolution + 1.0));
}
`;

// ../../src/core/renderer/SkyboxPass.ts
class SkyboxPass {
  pipeline = null;
  atmospherePipeline = null;
  gBuffer = null;
  context = null;
  presentationFormat = null;
  constructor(gBuffer = null) {
    this.gBuffer = gBuffer;
  }
  init(device, context, presentationFormat) {
    this.context = context;
    this.presentationFormat = presentationFormat;
    const format = this.gBuffer ? "rgba16float" : presentationFormat;
    this.createCubemapPipeline(device, format);
  }
  initAtmosphere(device, renderBindGroupLayout, atmosphereBindGroupLayout) {
    if (this.atmospherePipeline)
      return;
    const format = this.gBuffer ? "rgba16float" : this.presentationFormat || "bgra8unorm";
    this.createAtmospherePipeline(device, format, renderBindGroupLayout, atmosphereBindGroupLayout);
  }
  resize(width, height) {}
  execute(commandEncoder, context, globalResources) {
    if (!this.pipeline || !this.context || !this.presentationFormat)
      return;
    let textureView;
    if (this.gBuffer && this.gBuffer.accumulationTexture) {
      textureView = this.gBuffer.accumulationTexture.createView();
    } else {
      textureView = this.context.getCurrentTexture().createView();
    }
    const depthTexture = this.gBuffer ? this.gBuffer.depthTexture : null;
    if (!depthTexture)
      return;
    const renderPassDescriptor = {
      colorAttachments: [
        {
          view: textureView,
          loadOp: "load",
          storeOp: "store"
        }
      ],
      depthStencilAttachment: {
        view: depthTexture.createView({ aspect: "depth-only" }),
        depthLoadOp: "load",
        depthStoreOp: "store"
      }
    };
    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
    if (context.scene.atmosphere.enabled && this.atmospherePipeline && globalResources.atmosphereBindGroup) {
      passEncoder.setPipeline(this.atmospherePipeline);
      passEncoder.setBindGroup(0, globalResources.renderBindGroup);
      passEncoder.setBindGroup(1, globalResources.atmosphereBindGroup);
    } else if (globalResources.environmentMap) {
      passEncoder.setPipeline(this.pipeline);
      passEncoder.setBindGroup(0, globalResources.renderBindGroup);
    } else {
      passEncoder.end();
      return;
    }
    passEncoder.draw(36);
    passEncoder.end();
  }
  createCubemapPipeline(device, format) {
    const code = `
      struct SceneUniforms {
        viewMatrix : mat4x4<f32>,
        projectionMatrix : mat4x4<f32>,
        lightViewProj : mat4x4<f32>,
        prevViewProj : mat4x4<f32>,
        inverseProjectionMatrix : mat4x4<f32>,
        cameraPosition : vec3f,
        time : f32,
        lightCount : u32,
        debugMode : u32,
        shadowsEnabled : u32,
        environmentIntensity : f32,
        fogColor: vec3f,
        fogDensity: f32,
        fogParams: vec4f,     // x=start, y=end, z=height, w=heightFalloff
        fogSettings: vec4u,   // x=type, y=enabled, z=pad, w=pad
        cloudShadowParams: vec4f,  // x=enabled, y=intensity, z=scale, w=speed
        cloudShadowParams2: vec4f, // x=coverage, y=softness, z=windDirX, w=windDirZ
        // Fog2 (Three.js-style fog)
        fog2Color: vec3f,     // Fog color
        fog2Density: f32,     // FogExp2 density for objects
        fog2Params: vec4f,    // x=near, y=far, z=type (0=LINEAR, 1=EXP2), w=enabled
        fog2SkyFalloff: f32,  // How high fog extends into sky (0=none, 1=zenith)
        _fog2Pad1: f32,       // padding
        _fog2Pad2: f32,       // padding
        _fog2Pad3: f32,       // padding
      }

      @group(0) @binding(0) var<uniform> scene : SceneUniforms;
      @group(0) @binding(6) var envMap: texture_cube<f32>;
      @group(0) @binding(7) var envSamp: sampler;

      struct VertexOutput {
        @builtin(position) position : vec4f,
        @location(0) uv : vec3f,
      }

      @vertex
      fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
        var output : VertexOutput;
        let pos = array<vec3f, 36>(
            vec3f(-1,  1, -1), vec3f(-1, -1, -1), vec3f( 1, -1, -1),
            vec3f( 1, -1, -1), vec3f( 1,  1, -1), vec3f(-1,  1, -1),
            vec3f(-1, -1,  1), vec3f(-1, -1, -1), vec3f(-1,  1, -1),
            vec3f(-1,  1, -1), vec3f(-1,  1,  1), vec3f(-1, -1,  1),
            vec3f( 1, -1, -1), vec3f( 1, -1,  1), vec3f( 1,  1,  1),
            vec3f( 1,  1,  1), vec3f( 1,  1, -1), vec3f( 1, -1, -1),
            vec3f(-1, -1,  1), vec3f(-1,  1,  1), vec3f( 1,  1,  1),
            vec3f( 1,  1,  1), vec3f( 1, -1,  1), vec3f(-1, -1,  1),
            vec3f(-1,  1, -1), vec3f( 1,  1, -1), vec3f( 1,  1,  1),
            vec3f( 1,  1,  1), vec3f(-1,  1,  1), vec3f(-1,  1, -1),
            vec3f(-1, -1, -1), vec3f(-1, -1,  1), vec3f( 1, -1, -1),
            vec3f( 1, -1, -1), vec3f(-1, -1,  1), vec3f( 1, -1,  1)
        );

        let p = pos[vertexIndex];
        output.uv = p;

        var view = scene.viewMatrix;
        view[3] = vec4f(0.0, 0.0, 0.0, 1.0);

        let clipPos = scene.projectionMatrix * view * vec4f(p, 1.0);
        output.position = clipPos.xyww;
        return output;
      }

      @fragment
      fn fs_main(@location(0) uv : vec3f) -> @location(0) vec4f {
        var color = textureSample(envMap, envSamp, normalize(uv));
        let viewDir = normalize(uv);

        // Fog for cubemap skybox - uses uniform fog color
        let fog2Enabled = scene.fog2Params.w;
        if (fog2Enabled >= 0.5) {
            let fog2Type = scene.fog2Params.z;
            let upFactor = abs(viewDir.y);

            var fogFactor = 0.0;
            if (fog2Type < 0.5) {
                let fogNear = scene.fog2Params.x;
                let fogFar = scene.fog2Params.y;
                let skyDistance = mix(fogFar, fogNear, upFactor);
                fogFactor = smoothstep(fogNear, fogFar, skyDistance);
            } else {
                let fogDensity = scene.fog2Density;
                let horizonDistance = 500.0;
                if (viewDir.y <= 0.0) {
                    fogFactor = 1.0 - exp(-fogDensity * fogDensity * horizonDistance * horizonDistance);
                } else {
                    let skyDistance = mix(horizonDistance, 10.0, viewDir.y);
                    let baseFogFactor = 1.0 - exp(-fogDensity * fogDensity * skyDistance * skyDistance);
                    let heightFade = 1.0 - smoothstep(0.0, max(scene.fog2SkyFalloff, 0.001), viewDir.y);
                    fogFactor = baseFogFactor * heightFade;
                }
            }
            fogFactor = clamp(fogFactor, 0.0, 1.0);
            color = vec4f(mix(color.rgb, scene.fog2Color, fogFactor), color.a);
        }

        return color;
      }
      `;
    const bindGroupLayout = device.createBindGroupLayout({
      label: "Global Render Bind Group Layout (Skybox Copy)",
      entries: [
        { binding: 0, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
        { binding: 1, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: "read-only-storage" } },
        { binding: 3, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: "read-only-storage" } },
        { binding: 4, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "depth", viewDimension: "2d-array" } },
        { binding: 5, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "comparison" } },
        { binding: 6, visibility: GPUShaderStage.FRAGMENT, texture: { viewDimension: "cube" } },
        { binding: 7, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "filtering" } },
        { binding: 8, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
        { binding: 9, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "unfilterable-float", viewDimension: "2d-array" } },
        { binding: 10, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "non-filtering" } },
        { binding: 11, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } }
      ]
    });
    const pipelineLayout = device.createPipelineLayout({
      bindGroupLayouts: [bindGroupLayout]
    });
    this.pipeline = device.createRenderPipeline({
      label: "Skybox Pipeline",
      layout: pipelineLayout,
      vertex: {
        module: createShaderModuleSafe(device, { code }),
        entryPoint: "vs_main"
      },
      fragment: {
        module: createShaderModuleSafe(device, { code }),
        entryPoint: "fs_main",
        targets: [{ format }]
      },
      primitive: {
        topology: "triangle-list",
        cullMode: "none"
      },
      depthStencil: {
        depthWriteEnabled: false,
        depthCompare: "less-equal",
        format: this.gBuffer?.depthTexture?.format || "depth24plus"
      }
    });
  }
  createAtmospherePipeline(device, format, renderBindGroupLayout, atmosphereBindGroupLayout) {
    const code = `
      ${AtmosphereCommonWGSL}

      // Group 0: Core scene resources
      struct SceneUniforms {
        viewMatrix : mat4x4<f32>,
        projectionMatrix : mat4x4<f32>,
        lightViewProj : mat4x4<f32>,
        prevViewProj : mat4x4<f32>,
        inverseProjectionMatrix : mat4x4<f32>,
        cameraPosition : vec3f,
        time : f32,
        lightCount : u32,
        debugMode : u32,
        shadowsEnabled : u32,
        environmentIntensity : f32,
        fogColor: vec3f,
        fogDensity: f32,
        fogParams: vec4f,     // x=start, y=end, z=height, w=heightFalloff
        fogSettings: vec4u,   // x=type, y=enabled, z=pad, w=pad
        cloudShadowParams: vec4f,  // x=enabled, y=intensity, z=scale, w=speed
        cloudShadowParams2: vec4f, // x=coverage, y=softness, z=windDirX, w=windDirZ
        // Fog2 (Three.js-style fog)
        fog2Color: vec3f,     // Fog color
        fog2Density: f32,     // FogExp2 density for objects
        fog2Params: vec4f,    // x=near, y=far, z=type (0=LINEAR, 1=EXP2), w=enabled
        fog2SkyFalloff: f32,  // How high fog extends into sky (0=none, 1=zenith)
        _fog2Pad1: f32,       // padding
        _fog2Pad2: f32,       // padding
        _fog2Pad3: f32,       // padding
      }
      @group(0) @binding(0) var<uniform> scene : SceneUniforms;

      // Group 1: Atmosphere resources (simplified for Safari - consecutive bindings 0-5)
      @group(1) @binding(0) var transmittanceLUT : texture_2d<f32>;
      @group(1) @binding(1) var skyViewLUT : texture_2d<f32>;
      @group(1) @binding(2) var<uniform> atmosphere : AtmosphereUniforms;
      @group(1) @binding(3) var samp : sampler;
      @group(1) @binding(4) var cloudNoiseLUT : texture_3d<f32>;
      @group(1) @binding(5) var linearSamp : sampler;

      struct VertexOutput {
        @builtin(position) position : vec4f,
        @location(0) uv : vec3f,
      }

      @vertex
      fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
        var output : VertexOutput;
        let pos = array<vec3f, 36>(
            vec3f(-1,  1, -1), vec3f(-1, -1, -1), vec3f( 1, -1, -1),
            vec3f( 1, -1, -1), vec3f( 1,  1, -1), vec3f(-1,  1, -1),
            vec3f(-1, -1,  1), vec3f(-1, -1, -1), vec3f(-1,  1, -1),
            vec3f(-1,  1, -1), vec3f(-1,  1,  1), vec3f(-1, -1,  1),
            vec3f( 1, -1, -1), vec3f( 1, -1,  1), vec3f( 1,  1,  1),
            vec3f( 1,  1,  1), vec3f( 1,  1, -1), vec3f( 1, -1, -1),
            vec3f(-1, -1,  1), vec3f(-1,  1,  1), vec3f( 1,  1,  1),
            vec3f( 1,  1,  1), vec3f( 1, -1,  1), vec3f(-1, -1,  1),
            vec3f(-1,  1, -1), vec3f( 1,  1, -1), vec3f( 1,  1,  1),
            vec3f( 1,  1,  1), vec3f(-1,  1,  1), vec3f(-1,  1, -1),
            vec3f(-1, -1, -1), vec3f(-1, -1,  1), vec3f( 1, -1, -1),
            vec3f( 1, -1, -1), vec3f(-1, -1,  1), vec3f( 1, -1,  1)
        );

        let p = pos[vertexIndex];
        output.uv = p;

        var view = scene.viewMatrix;
        view[3] = vec4f(0.0, 0.0, 0.0, 1.0);

        let clipPos = scene.projectionMatrix * view * vec4f(p, 1.0);
        output.position = clipPos.xyww;
        return output;
      }

      // Sky View LUT UV mapping with improved horizon handling
      fn directionToSkyViewUV(dir: vec3f, cameraAltitude: f32) -> vec2f {
          let up = vec3f(0.0, 1.0, 0.0);
          let viewZenithCos = dot(dir, up);
          let lightDir = normalize(atmosphere.sun_direction.xyz);
          let lightViewCos = dot(lightDir, dir);

          // Compute horizon angle (angle from zenith where ground becomes visible)
          let horizonCos = sqrt(max(0.0, cameraAltitude * cameraAltitude - atmosphere.bottom_radius * atmosphere.bottom_radius)) / cameraAltitude;
          let horizonAngle = acos(horizonCos);
          let viewZenith = acos(clamp(viewZenithCos, -1.0, 1.0));

          var u: f32;
          var v: f32;

          // Improved non-linear UV mapping for better resolution near horizon
          // This gives more texel precision where we need it most
          if viewZenith < horizonAngle {
              // Above horizon - use quadratic mapping for smooth gradients
              let normalizedAngle = viewZenith / horizonAngle;
              // Use power curve for more resolution near horizon
              let horizonBias = pow(normalizedAngle, 0.7);
              v = 0.5 - 0.5 * (1.0 - horizonBias);
          } else {
              // Below horizon (looking at ground)
              let belowHorizonAngle = viewZenith - horizonAngle;
              let maxBelowAngle = 3.14159265 - horizonAngle;
              let t = belowHorizonAngle / maxBelowAngle;
              // Square root for more resolution near horizon
              v = 0.5 + 0.5 * sqrt(t);
          }

          // Light view cosine mapping with slight non-linearity for sun/anti-sun
          // This improves color accuracy around sun and opposite direction
          let lightViewNorm = (lightViewCos + 1.0) * 0.5;
          u = sqrt(lightViewNorm); // More resolution toward sun

          return vec2f(u, v);
      }

      // Compute horizon glow contribution for golden hour
      fn computeHorizonGlow(dir: vec3f, sunDir: vec3f, cameraAltitude: f32) -> vec3f {
          let viewZenithCos = dir.y;
          let horizonCos = sqrt(max(0.0, cameraAltitude * cameraAltitude - atmosphere.bottom_radius * atmosphere.bottom_radius)) / cameraAltitude;

          // Distance from horizon (0 = at horizon, 1 = far from horizon)
          let horizonDist = abs(viewZenithCos - (-horizonCos));

          // Sharp falloff from horizon
          let horizonFactor = exp(-horizonDist * 8.0);

          // Sun contribution - glow depends on sun being near horizon
          let sunNearHorizon = 1.0 - smoothstep(-0.1, 0.3, sunDir.y);

          // Color gradient from deep red to orange at horizon during sunset
          var glowColor = vec3f(0.0);
          if sunNearHorizon > 0.0 {
              let sunSide = dot(normalize(vec3f(dir.x, 0.0, dir.z)), normalize(vec3f(sunDir.x, 0.0, sunDir.z)));
              let sunInfluence = smoothstep(-0.3, 0.8, sunSide);

              // Deep orange-red glow near horizon at sunset
              let warmGlow = vec3f(1.0, 0.3, 0.05) * sunInfluence;
              // Purple-blue anti-sun glow
              let coolGlow = vec3f(0.2, 0.1, 0.4) * (1.0 - sunInfluence);

              glowColor = (warmGlow + coolGlow) * horizonFactor * sunNearHorizon * 0.3;
          }

          return glowColor;
      }

      // Compute ground reflection ambient contribution
      fn computeGroundAmbient(dir: vec3f, sunDir: vec3f, groundAlbedo: vec3f) -> vec3f {
          // Only applies when looking toward ground
          if dir.y > 0.0 { return vec3f(0.0); }

          // Ground ambient is stronger when sun is up
          let sunUp = max(0.0, sunDir.y);

          // Ground reflects sky light back up - this creates the subtle
          // brightening of the lower sky from ground bounce
          let groundBrightness = groundAlbedo * sunUp * 0.15;

          // Fade based on how far below horizon we're looking
          // Note: smoothstep requires low < high per WGSL spec (Dawn is strict about this)
          let belowHorizonFactor = 1.0 - smoothstep(-0.5, 0.0, dir.y);

          return groundBrightness * belowHorizonFactor;
      }

      fn getTransmittanceToSun(altitude: f32, sunZenithCos: f32) -> vec3f {
          let H = sqrt(max(0.0, atmosphere.top_radius * atmosphere.top_radius - atmosphere.bottom_radius * atmosphere.bottom_radius));
          let rho = sqrt(max(0.0, altitude * altitude - atmosphere.bottom_radius * atmosphere.bottom_radius));
          let d = max(0.0, altitude * altitude - atmosphere.bottom_radius * atmosphere.bottom_radius);

          let u_mu = 0.5 + 0.5 * sunZenithCos;
          let u_r = rho / H;

          return textureLoad(transmittanceLUT, vec2i(vec2f(u_mu, u_r) * vec2f(256.0, 64.0)), 0).rgb;
      }

      fn renderSunDisk(dir: vec3f, sunDir: vec3f, transmittanceToSun: vec3f) -> vec3f {
          // Hide if below horizon (with small buffer for grazing angles)
          if (sunDir.y < -0.05) { return vec3f(0.0); }

          // Use atmosphere uniform for sun size, with scale multiplier
          let baseSunAngularRadius = atmosphere.sun_angular_radius;
          let sunAngularRadius = baseSunAngularRadius * atmosphere.sun_disk_scale;
          let cosAngle = dot(dir, sunDir);
          let sunCosAngle = cos(sunAngularRadius);

          if cosAngle >= sunCosAngle {
              let sunIntensity = atmosphere.solar_irradiance.xyz;
              let limbDarkening = sqrt(1.0 - pow((1.0 - cosAngle) / (1.0 - sunCosAngle), 2.0));
              return sunIntensity * transmittanceToSun * limbDarkening * 10.0;
          }
          return vec3f(0.0);
      }

      fn renderMoonDisk(dir: vec3f, moonDir: vec3f, transmittanceToMoon: vec3f, moonPhase: f32) -> vec3f {
          // Hide if below horizon
          if (moonDir.y < -0.05) { return vec3f(0.0); }

          // Use atmosphere uniform for moon size, with scale multiplier
          let baseMoonAngularRadius = atmosphere.moon_angular_radius;
          let moonAngularRadius = baseMoonAngularRadius * atmosphere.moon_scale;
          let cosAngle = dot(dir, moonDir);
          let moonCosAngle = cos(moonAngularRadius);

          if cosAngle >= moonCosAngle {
              // Moon color: pure white (no atmospheric tinting)
              let moonColor = vec3f(1.0, 1.0, 1.0);
              let moonIntensity = 3.0;  // Lower intensity to reduce bloom

              // Calculate position on moon disk in local 2D coordinates
              let toCenter = normalize(dir - moonDir * dot(dir, moonDir));
              let upDir = normalize(cross(cross(moonDir, vec3f(0.0, 1.0, 0.0)), moonDir));
              let rightDir = normalize(cross(moonDir, upDir));

              let distFromCenter = acos(clamp(cosAngle, -1.0, 1.0)) / moonAngularRadius;

              // Get x,y coordinates on the moon disk (-1 to 1)
              let localX = dot(toCenter, rightDir) * distFromCenter;
              let localY = dot(toCenter, upDir) * distFromCenter;

              // Moon phase creates a CURVED terminator (ellipse on sphere)
              // moonPhase: 0 = new moon, 0.5 = full moon, 1 = new moon
              // The terminator curves: at height y, the edge is at x = t * sqrt(1 - y²)

              // Calculate terminator position (t) that moves continuously
              // For waxing (0 to 0.5): t goes from 1 (right edge) to -1 (left edge)
              // For waning (0.5 to 1): t goes from 1 (right edge) to -1 (left edge)
              // The key insight: at phase 0.5, BOTH formulas should give a fully lit moon
              var t: f32;
              if moonPhase <= 0.5 {
                  // Waxing: shadow recedes from right to left
                  t = 1.0 - 4.0 * moonPhase;  // 1 at phase 0, -1 at phase 0.5
              } else {
                  // Waning: shadow advances from right to left
                  t = 1.0 - 4.0 * (moonPhase - 0.5);  // 1 at phase 0.5, -1 at phase 1
              }

              // The terminator is an ellipse: at this y position, the terminator x is:
              let ellipseFactor = sqrt(max(0.0, 1.0 - localY * localY));
              let terminatorAtY = t * ellipseFactor;

              // Determine illumination based on which side of curved terminator we're on
              var illumination = 0.0;
              if moonPhase <= 0.5 {
                  // Waxing: right side is lit (x > terminatorAtY means lit)
                  illumination = smoothstep(terminatorAtY - 0.05, terminatorAtY + 0.05, localX);
              } else {
                  // Waning: left side is lit (x < terminatorAtY means lit)
                  // Note: smoothstep requires low < high per WGSL spec
                  illumination = 1.0 - smoothstep(terminatorAtY - 0.05, terminatorAtY + 0.05, localX);
              }

              // Subtle limb darkening
              let limbDarkening = 0.7 + 0.3 * sqrt(max(0.0, 1.0 - distFromCenter * distFromCenter));

              // Return pure moon color without atmospheric tinting
              return moonColor * moonIntensity * illumination * limbDarkening;
          }
          return vec3f(0.0);
      }

      // --- Cloud Sampling ---

      // Optimized: Two-sample noise blending to hide tiling
      fn sampleCloudNoiseMultiScale(pos: vec3f, lod: f32) -> vec4f {
          // First sample - base
          let n1 = textureSampleLevel(cloudNoiseLUT, linearSamp, pos, lod);

          // Second sample - rotated 60° and offset to break patterns
          let c = 0.5; let s = 0.866; // cos/sin(60°) - larger angle for more separation
          let rotated = vec3f(pos.x * c - pos.z * s, pos.y, pos.x * s + pos.z * c);
          let n2 = textureSampleLevel(cloudNoiseLUT, linearSamp, rotated * 2.1 + 0.33, lod);

          // Blend samples
          return n1 * 0.65 + n2 * 0.35;
      }

      // Screen-space jitter to break up horizontal banding (called once per pixel)
      fn getScreenJitter(fragCoord: vec2f, time: f32) -> f32 {
          // Interleaved gradient noise with temporal variation
          let t = fract(time * 5.0);
          return fract(52.9829189 * fract(0.06711056 * fragCoord.x + 0.00583715 * fragCoord.y + t * 0.1));
      }

      // Sample cloud noise with detail erosion
      // Returns vec2f: x=density, y=detail for lighting
      fn sampleCloudNoise(pos: vec3f, heightFraction: f32, lod: f32) -> vec2f {
          // Animate clouds with wind
          let wind = atmosphere.cloud_wind_direction * atmosphere.cloud_speed * scene.time * 0.1;

          // Base scale for large cloud shapes
          let baseScale = 0.00002;
          let baseUvw = (pos + wind) * baseScale;

          // Sample with multi-scale blending to hide tiling
          let noise = sampleCloudNoiseMultiScale(baseUvw, lod);
          let baseShape = noise.r;
          let detailNoise = noise.g;
          let wispyNoise = noise.b;
          let coverageVar = noise.a;

          // Use noise to perturb height thresholds - this breaks up horizontal banding
          // The variation is small but enough to blur the hard edges
          let heightVar = (detailNoise - 0.5) * 0.15 + (wispyNoise - 0.5) * 0.1;
          let perturbedHeight = clamp(heightFraction + heightVar, 0.0, 1.0);

          // Height gradient with perturbed thresholds and wider transitions
          // Note: smoothstep requires low < high per WGSL spec
          let heightGradient = smoothstep(0.0, 0.25, perturbedHeight) *
                               (1.0 - smoothstep(0.5, 1.0, perturbedHeight));

          // Round bottom, flat top profile with noise variation
          let roundBottom = smoothstep(0.0, 0.3, perturbedHeight);
          let flatTop = 1.0 - smoothstep(0.6, 1.0, perturbedHeight) * 0.5;
          let anvilShape = roundBottom * flatTop;

          // Apply coverage variation and base threshold
          let cov = atmosphere.cloud_coverage;
          var density = baseShape * coverageVar;

          // Coverage remapping with smooth falloff
          density = smoothstep(1.0 - cov, 1.0 - cov * 0.5, density);

          // Apply height shaping
          density *= anvilShape * heightGradient;

          // Erode edges with detail noise (more erosion at edges)
          let erosion = detailNoise * 0.35 * (1.0 - density * 0.5);
          density = max(0.0, density - erosion);

          // Add wispy tendrils at top of clouds
          let wispyContrib = wispyNoise * smoothstep(0.4, 0.85, perturbedHeight) * 0.2;
          density = max(density, wispyContrib * cov);

          return vec2f(density, detailNoise);
      }

      fn getCloudDensity(pos: vec3f) -> f32 {
          // Legacy function for compatibility
          let wind = atmosphere.cloud_wind_direction * atmosphere.cloud_speed * scene.time * 0.1;
          let scale = 0.00002;
          let baseUvw = (pos + wind) * scale;
          let noise = sampleCloudNoiseMultiScale(baseUvw, 0.0);
          return noise.r;
      }

      fn intersectSphere(ro: vec3f, rd: vec3f, r: f32) -> vec2f {
          let b = dot(ro, rd);
          let c = dot(ro, ro) - r * r;
          let h = b * b - c;
          if (h < 0.0) { return vec2f(-1.0); }
          let h_sqrt = sqrt(h);
          return vec2f(-b - h_sqrt, -b + h_sqrt);
      }

      // Height gradient function: 0 at bottom/top, 1 in middle
      fn getCloudHeightGradient(heightFraction: f32) -> f32 {
          // Note: smoothstep requires low < high per WGSL spec
          return smoothstep(0.0, 0.2, heightFraction) * (1.0 - smoothstep(0.8, 1.0, heightFraction));
      }
      
      // Interleaved Gradient Noise for dithering
      fn ign(pixel: vec2f) -> f32 {
          return fract(52.9829189 * fract(0.06711056 * pixel.x + 0.00583715 * pixel.y));
      }

      // ============================================
      // LOW QUALITY: 2D Plane Clouds (very fast)
      // Multi-sample at plane intersection with parallax
      // ============================================
      fn renderCloudsLow(rayOrigin: vec3f, rayDir: vec3f, skyColor: vec3f, sunDir: vec3f, lightColor: vec3f, fragCoord: vec2f) -> vec3f {
          if (atmosphere.cloud_enabled == 0.0) { return skyColor; }

          // Skip if looking down
          if (rayDir.y < 0.01) { return skyColor; }

          let earthRadius = atmosphere.bottom_radius;
          let cloudPlaneHeight = earthRadius + atmosphere.cloud_altitude + atmosphere.cloud_height * 0.5;

          // Simple plane intersection (camera relative to earth center)
          let camHeight = earthRadius + rayOrigin.y;
          let t = (cloudPlaneHeight - camHeight) / rayDir.y;

          if (t < 0.0 || t > 500000.0) { return skyColor; }

          // World position at intersection
          let hitPos = vec3f(rayOrigin.x, camHeight, rayOrigin.z) + rayDir * t;

          // Sample noise at hit point with wind animation
          let wind = atmosphere.cloud_wind_direction * atmosphere.cloud_speed * scene.time * 0.1;
          let scale = 0.00002;
          let baseUvw = (hitPos + wind) * scale;

          // Add parallax offset based on view angle for fake depth
          let parallax = (rayDir.xz / max(rayDir.y, 0.1)) * atmosphere.cloud_height * 0.0001;
          let uvwParallax = baseUvw + vec3f(parallax.x, 0.0, parallax.y);

          // Sample with multi-scale blending to hide tiling
          let noise = sampleCloudNoiseMultiScale(uvwParallax, 0.0);
          var density = noise.r * noise.a; // Base shape * coverage variation
          let detail = noise.g;

          // Coverage threshold with smooth falloff
          let cov = atmosphere.cloud_coverage;
          density = smoothstep(1.0 - cov, 1.0 - cov * 0.4, density);

          // Add slight detail erosion
          density = max(0.0, density - detail * 0.15);

          if (density < 0.01) { return skyColor; }

          // Improved lighting with smooth color transitions
          let sunElevation = sunDir.y;
          let sunFade = smoothstep(-0.1, 0.15, sunElevation);

          // Smooth sun color gradient
          var sunTint = vec3f(1.0);
          {
              let redOrangeT = smoothstep(-0.05, 0.05, sunElevation);
              let orangeGoldenT = smoothstep(0.05, 0.2, sunElevation);
              let goldenWhiteT = smoothstep(0.2, 0.5, sunElevation);

              sunTint = mix(vec3f(1.0, 0.15, 0.03), vec3f(1.0, 0.5, 0.15), redOrangeT);
              sunTint = mix(sunTint, vec3f(1.0, 0.9, 0.7), orangeGoldenT);
              sunTint = mix(sunTint, vec3f(1.0, 1.0, 1.0), goldenWhiteT);
          }

          // Simple phase approximation for silver lining
          let cosThetaSun = dot(rayDir, sunDir);
          let silverLining = pow(max(0.0, cosThetaSun), 3.0) * detail * sunFade * 0.3;

          // Ambient based on time of day
          var ambient = vec3f(0.3, 0.4, 0.5);
          {
              let nightSunsetT = smoothstep(-0.1, 0.05, sunElevation);
              let sunsetDayT = smoothstep(0.05, 0.3, sunElevation);
              ambient = mix(vec3f(0.02, 0.03, 0.06), vec3f(0.2, 0.1, 0.12), nightSunsetT);
              ambient = mix(ambient, vec3f(0.3, 0.4, 0.5), sunsetDayT);
          }

          let cloudLit = lightColor * sunTint * sunFade * 0.9 + ambient;
          var cloudColor = cloudLit * atmosphere.cloud_color;

          // Add silver lining
          cloudColor += lightColor * sunTint * silverLining;

          // Soft edges with horizon fade
          let horizonFade = smoothstep(0.0, 0.15, rayDir.y);
          let alpha = density * horizonFade * 0.9;

          // Enhanced dithering
          let frameOffset = fract(scene.time * 5.17);
          let ditherR = (ign(fragCoord + vec2f(frameOffset * 50.0, 0.0)) - 0.5) * 0.025;
          let ditherG = (ign(fragCoord + vec2f(37.0 + frameOffset * 30.0, 17.0)) - 0.5) * 0.025;
          let ditherB = (ign(fragCoord + vec2f(59.0, 83.0 + frameOffset * 40.0)) - 0.5) * 0.025;
          cloudColor += vec3f(ditherR, ditherG, ditherB);

          return mix(skyColor, cloudColor, alpha);
      }

      // ============================================
      // VOLUMETRIC CLOUDS (medium/high quality)
      // ============================================
      fn renderClouds(rayOrigin: vec3f, rayDir: vec3f, skyColor: vec3f, sunDir: vec3f, lightColor: vec3f, fragCoord: vec2f) -> vec3f {
          if (atmosphere.cloud_enabled == 0.0) { return skyColor; }

          let earthRadius = atmosphere.bottom_radius;
          let cloudBottom = earthRadius + atmosphere.cloud_altitude;
          let cloudTop = cloudBottom + atmosphere.cloud_height;

          // Camera relative to Earth Center
          let camPosFromCenter = vec3f(0.0, earthRadius + scene.cameraPosition.y, 0.0);

          // Intersect Cloud Layer
          let tBottom = intersectSphere(camPosFromCenter, rayDir, cloudBottom);
          let tTop = intersectSphere(camPosFromCenter, rayDir, cloudTop);

          var tStart = 0.0;
          var tEnd = 0.0;

          // Assuming camera is below clouds (Ground)
          if (length(camPosFromCenter) < cloudBottom) {
               if (tBottom.y < 0.0) { return skyColor; } // Looking down/horizon miss
               tStart = tBottom.y;
               tEnd = tTop.y;
          } else if (length(camPosFromCenter) > cloudTop) {
               // Space/Above
               if (tTop.x < 0.0) { return skyColor; }
               tStart = tTop.x;
               tEnd = tBottom.x;
          } else {
               // Inside
               tStart = 0.0;
               tEnd = tTop.y; // Simplified
          }

          if (tEnd <= tStart) { return skyColor; }

          // Horizon Culling / Fade
          if (tStart > 400000.0) { return skyColor; }

          let thickness = tEnd - tStart;

          // Step count based on quality setting
          // High (2): 32 base steps with distance adaptation
          // Medium (1): 12 fixed steps
          var numSteps = 12u;
          if (atmosphere.cloud_quality == 2u) {
              // High quality with distance-based reduction
              numSteps = 32u;
              if (tStart > 120000.0) {
                  numSteps = 16u;
              } else if (tStart > 60000.0) {
                  numSteps = 24u;
              }
          }

          let stepSize = thickness / f32(numSteps);

          // Enhanced dithering with temporal offset to reduce banding
          // Use interleaved gradient noise with frame-based offset
          let frameOffset = fract(scene.time * 7.23); // Temporal variation
          let dither = ign(fragCoord + vec2f(frameOffset * 100.0, frameOffset * 57.0));
          let tOffset = stepSize * dither;

          var totalDensity = 0.0;
          var cloudScatter = vec3f(0.0);
          var transmittance = 1.0;

          // Phase functions (Henyey-Greenstein)
          // Use two-lobe phase function for more realistic scattering
          let gForward = 0.8;  // Strong forward scattering
          let gBack = -0.3;    // Weak back scattering for silver lining

          // --- Lighting Setup ---

          // 1. Sun
          let sunElevation = sunDir.y;
          // Smooth fade with extended range for better sunset/sunrise transitions
          let sunFade = smoothstep(-0.15, 0.15, sunElevation);

          // Continuous sun color gradient using smooth interpolation
          // This eliminates hard thresholds that cause banding
          var sunTint = vec3f(1.0);
          {
              // Elevation-based color: Deep Red -> Orange -> Golden -> White
              let redOrangeT = smoothstep(-0.05, 0.05, sunElevation);
              let orangeGoldenT = smoothstep(0.05, 0.2, sunElevation);
              let goldenWhiteT = smoothstep(0.2, 0.5, sunElevation);

              let sunColorRed = vec3f(1.0, 0.1, 0.02);
              let sunColorOrange = vec3f(1.0, 0.45, 0.12);
              let sunColorGolden = vec3f(1.0, 0.85, 0.6);
              let sunColorWhite = vec3f(1.0, 0.98, 0.95);

              // Smooth multi-stage blend
              sunTint = mix(sunColorRed, sunColorOrange, redOrangeT);
              sunTint = mix(sunTint, sunColorGolden, orangeGoldenT);
              sunTint = mix(sunTint, sunColorWhite, goldenWhiteT);
          }

          // Sunset intensity boost (more gradual)
          // Note: smoothstep requires low < high per WGSL spec
          let sunsetBoost = 1.0 + 1.5 * (1.0 - smoothstep(0.0, 0.3, abs(sunElevation)));
          let sunLightColor = lightColor * sunTint * sunFade * sunsetBoost;

          // Phase function calculation
          let cosThetaSun = dot(rayDir, sunDir);
          // Two-lobe phase: forward + back scattering (silver lining)
          let phaseForward = (1.0 - gForward*gForward) / pow(1.0 + gForward*gForward - 2.0*gForward*cosThetaSun, 1.5);
          let phaseBack = (1.0 - gBack*gBack) / pow(1.0 + gBack*gBack - 2.0*gBack*cosThetaSun, 1.5);
          let phaseSun = (phaseForward * 0.7 + phaseBack * 0.3) / (4.0 * 3.14159);

          // Silver lining factor (bright edges when backlit)
          let silverLining = pow(max(0.0, cosThetaSun), 4.0) * 2.0;

          // 2. Moon
          let moonDir = normalize(atmosphere.moon_direction.xyz);
          let moonElevation = moonDir.y;
          let moonFade = smoothstep(-0.05, 0.15, moonElevation);
          let moonTint = vec3f(0.65, 0.75, 1.0);
          let moonLightColor = atmosphere.moon_color * moonTint * 2.5 * moonFade;
          let cosThetaMoon = dot(rayDir, moonDir);
          let phaseMoon = (1.0 - gForward*gForward) / pow(1.0 + gForward*gForward - 2.0*gForward*cosThetaMoon, 1.5) / (4.0 * 3.14159);

          // 3. Ambient (smooth gradient based on sun elevation)
          var ambientColor = vec3f(0.0);
          {
              let ambientNight = vec3f(0.015, 0.02, 0.04);
              let ambientSunset = vec3f(0.25, 0.12, 0.15);
              let ambientDay = vec3f(0.25, 0.35, 0.55);

              let nightSunsetT = smoothstep(-0.15, 0.05, sunElevation);
              let sunsetDayT = smoothstep(0.05, 0.35, sunElevation);

              ambientColor = mix(ambientNight, ambientSunset, nightSunsetT);
              ambientColor = mix(ambientColor, ambientDay, sunsetDayT);
          }

          // Horizon Fade Factor (smoother)
          let horizonFade = smoothstep(0.0, 0.15, rayDir.y);

          // LOD for distant clouds (reduces aliasing)
          let distanceLOD = smoothstep(0.0, 200000.0, tStart) * 2.0;

          // Screen-space jitter to break horizontal banding (computed once per pixel)
          let screenJitter = getScreenJitter(fragCoord, scene.time);
          let jitterOffset = (screenJitter - 0.5) * 500.0; // Small world-space offset

          // Empty space skipping state
          var emptyStepCount = 0u;
          var currentStep = 0.0;

          for (var i = 0u; i < numSteps; i++) {
              // Adaptive step size: larger steps when in empty space
              var adaptiveStep = stepSize;
              if (emptyStepCount > 2u) {
                  adaptiveStep = stepSize * 2.0; // Double step in empty regions
              }

              let t = tStart + tOffset + currentStep;
              currentStep += adaptiveStep;

              if (t > tEnd) { break; }

              let pos = camPosFromCenter + rayDir * t;
              // Add jitter to break horizontal banding
              let jitteredPos = pos + vec3f(jitterOffset * 0.3, jitterOffset, jitterOffset * 0.3);
              let height = length(pos) - cloudBottom;
              let heightFraction = clamp(height / atmosphere.cloud_height, 0.0, 1.0);

              // Soft bounds falloff (smoothstep requires low < high per WGSL spec)
              let boundsFalloff = smoothstep(-0.05, 0.05, heightFraction) *
                                  (1.0 - smoothstep(0.95, 1.05, heightFraction));
              if (boundsFalloff < 0.001) {
                  emptyStepCount += 1u;
                  continue;
              }

              // Sample cloud density using enhanced multi-channel noise
              let noiseSample = sampleCloudNoise(jitteredPos, heightFraction, distanceLOD);
              var d = noiseSample.x * horizonFade * boundsFalloff;

              // Track empty space for adaptive stepping
              if (d < 0.01) {
                  emptyStepCount += 1u;
              } else {
                  emptyStepCount = 0u;
              }

              if (d > 0.005) {
                  let stepDensity = d * atmosphere.cloud_density;
                  let extinction = stepDensity * stepSize * 0.0008;
                  let stepTransmittance = exp(-extinction);

                  // Beer-Powder approximation for realistic light transport
                  // Beer's law (absorption) + Powder effect (multiple scattering)
                  let beerLaw = exp(-extinction * 2.0);
                  let powder = 1.0 - exp(-extinction * 4.0);
                  let beerPowder = beerLaw * powder * 2.0;

                  // Self-shadowing based on accumulated density
                  let shadow = exp(-totalDensity * 0.3);

                  // Height-based ambient variation (brighter at top)
                  let heightAmbient = 0.4 + 0.6 * heightFraction;

                  // Silver lining at cloud edges (based on detail noise = edges)
                  let edgeFactor = noiseSample.y;
                  let silverContrib = silverLining * edgeFactor * sunFade * 0.5;

                  // Compute scattering
                  let sunScatter = sunLightColor * phaseSun * shadow * beerPowder;
                  let moonScatter = moonLightColor * phaseMoon * shadow * beerPowder * 0.5;
                  let ambientScatter = ambientColor * heightAmbient * (0.6 + 0.4 * shadow);

                  // Add silver lining contribution
                  let silverColor = sunLightColor * silverContrib * transmittance;

                  let scattering = (sunScatter + moonScatter + ambientScatter + silverColor) * atmosphere.cloud_color;

                  // Energy-conserving integration
                  let absorbed = transmittance * (1.0 - stepTransmittance);
                  cloudScatter += scattering * absorbed;

                  transmittance *= stepTransmittance;
                  totalDensity += stepDensity * stepSize;

                  // Early termination
                  if (transmittance < 0.01) { break; }
              }
          }

          // Atmospheric perspective (distant clouds fade to sky)
          let atmosphericFade = 1.0 - exp(-tStart * 0.000003);
          transmittance = max(transmittance, atmosphericFade * 0.5);

          var finalCloudColor = mix(cloudScatter, skyColor, transmittance);

          // Enhanced dithering to combat banding
          // Use different offset for RGB to break up color banding
          let ditherR = (ign(fragCoord) - 0.5) * 0.025;
          let ditherG = (ign(fragCoord + vec2f(37.0, 17.0)) - 0.5) * 0.025;
          let ditherB = (ign(fragCoord + vec2f(59.0, 83.0)) - 0.5) * 0.025;
          let cloudAlpha = 1.0 - transmittance;
          finalCloudColor += vec3f(ditherR, ditherG, ditherB) * cloudAlpha;

          return finalCloudColor;
      }

      // Bilinear sample from SkyView LUT (textureLoad doesn't filter, causing banding)
      fn sampleSkyViewBilinear(uv: vec2f) -> vec3f {
          let texSize = vec2f(192.0, 108.0);
          let texCoord = uv * texSize - 0.5;
          let baseCoord = floor(texCoord);
          let f = texCoord - baseCoord;

          let c00 = textureLoad(skyViewLUT, vec2i(clamp(baseCoord, vec2f(0.0), texSize - 1.0)), 0).rgb;
          let c10 = textureLoad(skyViewLUT, vec2i(clamp(baseCoord + vec2f(1.0, 0.0), vec2f(0.0), texSize - 1.0)), 0).rgb;
          let c01 = textureLoad(skyViewLUT, vec2i(clamp(baseCoord + vec2f(0.0, 1.0), vec2f(0.0), texSize - 1.0)), 0).rgb;
          let c11 = textureLoad(skyViewLUT, vec2i(clamp(baseCoord + vec2f(1.0, 1.0), vec2f(0.0), texSize - 1.0)), 0).rgb;

          let c0 = mix(c00, c10, f.x);
          let c1 = mix(c01, c11, f.x);
          return mix(c0, c1, f.y);
      }

      @fragment
      fn fs_main(@location(0) uv : vec3f, @builtin(position) fragCoord : vec4f) -> @location(0) vec4f {
          let dir = normalize(uv);

          let cameraAltitude = atmosphere.bottom_radius + max(scene.cameraPosition.y * 0.001, 0.001);
          let skyUV = directionToSkyViewUV(dir, cameraAltitude);

          // Use bilinear filtering to reduce banding in sky gradients
          var skyColor = sampleSkyViewBilinear(skyUV);

          let sunDir = normalize(atmosphere.sun_direction.xyz);

          // Add horizon glow for golden hour/sunset
          let horizonGlow = computeHorizonGlow(dir, sunDir, cameraAltitude);
          skyColor += horizonGlow;

          // Add ground ambient contribution (bounce light from ground to sky)
          let groundAmbient = computeGroundAmbient(dir, sunDir, atmosphere.ground_albedo);
          skyColor += groundAmbient;

          // Enhanced dithering for sky gradients with per-channel offset
          // Use temporal variation to further break up banding
          let frameOffset = fract(scene.time * 3.71);
          let skyDitherR = (ign(fragCoord.xy + vec2f(frameOffset * 50.0, 0.0)) - 0.5) * 0.02;
          let skyDitherG = (ign(fragCoord.xy + vec2f(23.0 + frameOffset * 30.0, 41.0)) - 0.5) * 0.02;
          let skyDitherB = (ign(fragCoord.xy + vec2f(67.0, 89.0 + frameOffset * 40.0)) - 0.5) * 0.02;
          skyColor += vec3f(skyDitherR, skyDitherG, skyDitherB);

          let sunZenithCos = sunDir.y;
          let transmittanceToSun = getTransmittanceToSun(cameraAltitude, sunZenithCos);
          let sunDisk = renderSunDisk(dir, sunDir, transmittanceToSun);

          let moonDir = normalize(atmosphere.moon_direction.xyz);
          let moonZenithCos = moonDir.y;
          let transmittanceToMoon = getTransmittanceToSun(cameraAltitude, moonZenithCos);
          let moonDisk = renderMoonDisk(dir, moonDir, transmittanceToMoon, atmosphere.moon_phase);

          // Render order: Sky -> Stars -> Sun/Moon -> Clouds -> Fog
          var finalColor = skyColor;

          // Add Stars (only at night when sky is dark AND looking UP)
          // Don't render stars below the horizon (dir.y < 0)
          if (length(skyColor) < 0.1 && dir.y > 0.0) {
              let starIntensity = 1.0 - smoothstep(-0.1, 0.3, sunDir.y);
              if (starIntensity > 0.0) {
                  let starDir = dir * 1000.0;
                  let starHash = fract(sin(dot(floor(starDir), vec3f(12.9898, 78.233, 45.164))) * 43758.5453);
                  if (starHash > 0.997) {
                      let starBrightness = (starHash - 0.997) / 0.003;
                      let twinkle = 0.7 + 0.3 * sin(scene.time * 3.0 + starHash * 100.0);
                      finalColor += vec3f(starBrightness * starIntensity * twinkle * 2.0);
                  }
              }
          }

          // Add Celestial Bodies
          finalColor += sunDisk + moonDisk;

          // Clouds (rendered once, on top of sky+stars+bodies)
          // Quality: 0=low (2D plane), 1=medium (12 steps), 2=high (32 steps)
          if (atmosphere.cloud_quality == 0u) {
              finalColor = renderCloudsLow(scene.cameraPosition, dir, finalColor, sunDir, atmosphere.solar_irradiance.xyz, fragCoord.xy);
          } else {
              finalColor = renderClouds(scene.cameraPosition, dir, finalColor, sunDir, atmosphere.solar_irradiance.xyz, fragCoord.xy);
          }

          // Fog on skybox: sample the ACTUAL horizon color from the sky
          // This ensures the sky's fog matches what objects fade toward
          let fog2Enabled = scene.fog2Params.w;
          if (fog2Enabled >= 0.5) {
              let fog2Type = scene.fog2Params.z; // 0 = LINEAR, 1 = EXP2

              let upFactor = abs(dir.y);

              var fogFactor = 0.0;
              if (fog2Type < 0.5) {
                  // LINEAR fog
                  let fogNear = scene.fog2Params.x;
                  let fogFar = scene.fog2Params.y;
                  let skyDistance = mix(fogFar, fogNear, upFactor);
                  fogFactor = smoothstep(fogNear, fogFar, skyDistance);
              } else {
                  // EXP2 fog with height falloff
                  let fogDensity = scene.fog2Density;
                  let horizonDistance = 500.0;

                  if (dir.y <= 0.0) {
                      // Looking DOWN - full fog
                      let skyDistance = horizonDistance;
                      fogFactor = 1.0 - exp(-fogDensity * fogDensity * skyDistance * skyDistance);
                  } else {
                      // Looking UP - apply height falloff
                      let skyDistance = mix(horizonDistance, 10.0, dir.y);
                      let baseFogFactor = 1.0 - exp(-fogDensity * fogDensity * skyDistance * skyDistance);
                      let heightFade = 1.0 - smoothstep(0.0, max(scene.fog2SkyFalloff, 0.001), dir.y);
                      fogFactor = baseFogFactor * heightFade;
                  }
              }

              fogFactor = clamp(fogFactor, 0.0, 1.0);

              // Use the SAME fog color as objects (uniform)
              // This guarantees sky horizon matches what objects fade toward
              // Just like Three.js where fog.color === sky.bottomColor
              finalColor = mix(finalColor, scene.fog2Color, fogFactor);
          }

          return vec4f(finalColor, 1.0);
      }
      `;
    const pipelineLayout = device.createPipelineLayout({
      bindGroupLayouts: [renderBindGroupLayout, atmosphereBindGroupLayout]
    });
    this.atmospherePipeline = device.createRenderPipeline({
      label: "Atmosphere Skybox Pipeline",
      layout: pipelineLayout,
      vertex: {
        module: createShaderModuleSafe(device, { code }),
        entryPoint: "vs_main"
      },
      fragment: {
        module: createShaderModuleSafe(device, { code }),
        entryPoint: "fs_main",
        targets: [{ format }]
      },
      primitive: {
        topology: "triangle-list",
        cullMode: "none"
      },
      depthStencil: {
        depthWriteEnabled: false,
        depthCompare: "less-equal",
        format: this.gBuffer?.depthTexture?.format || "depth24plus"
      }
    });
  }
}

// ../../src/core/renderer/SSAOPass.ts
class SSAOPass {
  gBuffer;
  pipeline = null;
  bindGroup = null;
  ssaoKernelBuffer = null;
  ssaoParamsBuffer = null;
  noiseTexture = null;
  sampler = null;
  noiseSampler = null;
  kernelSize = 32;
  kernel;
  enabled = true;
  constructor(gBuffer) {
    this.gBuffer = gBuffer;
    this.kernel = this.generateKernel();
  }
  init(device, context, presentationFormat) {
    this.generateNoiseTexture(device);
    this.createKernelBuffer(device);
    this.ssaoParamsBuffer = device.createBuffer({
      label: "SSAO Params Buffer",
      size: 16,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.sampler = device.createSampler({
      magFilter: "linear",
      minFilter: "linear",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    });
    this.noiseSampler = device.createSampler({
      magFilter: "nearest",
      minFilter: "nearest",
      addressModeU: "repeat",
      addressModeV: "repeat"
    });
  }
  resize(width, height) {
    this.bindGroup = null;
  }
  execute(commandEncoder, context, globalResources) {
    const device = this.gBuffer.device;
    if (!device || !this.gBuffer.ssaoTexture)
      return;
    if (!this.enabled) {
      const renderPassDescriptor2 = {
        label: "SSAO Clear Pass",
        colorAttachments: [{
          view: this.gBuffer.ssaoTexture.createView(),
          clearValue: { r: 1, g: 1, b: 1, a: 1 },
          loadOp: "clear",
          storeOp: "store"
        }]
      };
      const pass = commandEncoder.beginRenderPass(renderPassDescriptor2);
      pass.end();
      return;
    }
    if (this.ssaoParamsBuffer) {
      const params = new Float32Array([
        context.scene.postProcessing.ssao.radius,
        context.scene.postProcessing.ssao.bias
      ]);
      device.queue.writeBuffer(this.ssaoParamsBuffer, 0, params);
    }
    if (!this.pipeline) {
      this.createPipeline(device, globalResources);
    }
    if (!this.bindGroup) {
      this.createBindGroup(device, globalResources);
    }
    const renderPassDescriptor = {
      label: "SSAO Pass",
      colorAttachments: [{
        view: this.gBuffer.ssaoTexture.createView(),
        clearValue: { r: 1, g: 1, b: 1, a: 1 },
        loadOp: "clear",
        storeOp: "store"
      }]
    };
    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
    passEncoder.setPipeline(this.pipeline);
    passEncoder.setBindGroup(0, globalResources.renderBindGroup);
    passEncoder.setBindGroup(1, this.bindGroup);
    passEncoder.draw(3);
    passEncoder.end();
  }
  generateKernel() {
    const kernel = new Float32Array(this.kernelSize * 4);
    for (let i = 0;i < this.kernelSize; i++) {
      let sample = new Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random());
      sample = sample.normalize();
      let scale2 = i / this.kernelSize;
      scale2 = 0.1 + 0.9 * (scale2 * scale2);
      sample = sample.multiply(scale2);
      kernel[i * 4] = sample.x;
      kernel[i * 4 + 1] = sample.y;
      kernel[i * 4 + 2] = sample.z;
      kernel[i * 4 + 3] = 0;
    }
    return kernel;
  }
  createKernelBuffer(device) {
    this.ssaoKernelBuffer = device.createBuffer({
      label: "SSAO Kernel Buffer",
      size: this.kernel.byteLength,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
      mappedAtCreation: true
    });
    new Float32Array(this.ssaoKernelBuffer.getMappedRange()).set(this.kernel);
    this.ssaoKernelBuffer.unmap();
  }
  generateNoiseTexture(device) {
    const size = 4;
    const data = new Uint8Array(size * size * 4);
    for (let i = 0;i < size * size; i++) {
      data[i * 4] = Math.floor((Math.random() * 2 - 1) * 0.5 + 0.5 * 255);
      data[i * 4 + 1] = Math.floor((Math.random() * 2 - 1) * 0.5 + 0.5 * 255);
      data[i * 4 + 2] = 0;
      data[i * 4 + 3] = 0;
    }
    this.noiseTexture = device.createTexture({
      label: "SSAO Noise Texture",
      size: [size, size],
      format: "rgba8unorm",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
    });
    device.queue.writeTexture({ texture: this.noiseTexture }, data, { bytesPerRow: size * 4 }, { width: size, height: size });
  }
  createPipeline(device, globalResources) {
    const code = `
        struct SceneUniforms {
            viewMatrix : mat4x4<f32>,
            projectionMatrix : mat4x4<f32>,
            lightViewProj : mat4x4<f32>,
            prevViewProj : mat4x4<f32>,
            inverseProjectionMatrix : mat4x4<f32>,
            cameraPosition : vec3f,
            time : f32,
            _pad : vec3f,
        }

        struct SSAOUniforms {
             kernel : array<vec4f, ${this.kernelSize}>,
        }

        struct SSAOParams {
            radius: f32,
            bias: f32,
        }

        @group(0) @binding(0) var<uniform> scene : SceneUniforms;

        @group(1) @binding(0) var positionTex : texture_2d<f32>;
        @group(1) @binding(1) var normalTex : texture_2d<f32>;
        @group(1) @binding(2) var noiseTex : texture_2d<f32>;
        @group(1) @binding(3) var<uniform> ssaoConfig : SSAOUniforms;
        @group(1) @binding(4) var samp : sampler;
        @group(1) @binding(5) var noiseSamp : sampler;
        @group(1) @binding(6) var<uniform> params : SSAOParams;

        @vertex
        fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> @builtin(position) vec4f {
            let pos = array(
              vec2f(-1.0, -1.0),
              vec2f( 3.0, -1.0),
              vec2f(-1.0,  3.0)
            );
            return vec4f(pos[vertexIndex], 0.0, 1.0);
        }

        @fragment
        fn fs_main(@builtin(position) fragCoord : vec4f) -> @location(0) f32 {
            let uv = fragCoord.xy / vec2f(textureDimensions(positionTex));
            let noiseScale = vec2f(textureDimensions(positionTex)) / 4.0;
            
            // Get World Space Position and Normal
            let worldPos = textureSample(positionTex, samp, uv).xyz;
            let worldNormal = normalize(textureSample(normalTex, samp, uv).xyz * 2.0 - 1.0);
            
            // Convert to View Space
            let viewPos = (scene.viewMatrix * vec4f(worldPos, 1.0)).xyz;
            let viewNormal = (scene.viewMatrix * vec4f(worldNormal, 0.0)).xyz;

            let randomVec = textureSample(noiseTex, noiseSamp, uv * noiseScale).xyz * 2.0 - 1.0;
            let tangent = normalize(randomVec - viewNormal * dot(randomVec, viewNormal));
            let bitangent = cross(viewNormal, tangent);
            let TBN = mat3x3f(tangent, bitangent, viewNormal);

            var occlusion : f32 = 0.0;
            
            for (var i = 0u; i < ${this.kernelSize}u; i++) {
                // Kernel samples are in Tangent Space
                let sampleDir = TBN * ssaoConfig.kernel[i].xyz;
                let samplePos = viewPos + sampleDir * params.radius; // View Space Sample Position

                // Project sample position to Clip Space -> UV
                let offset = scene.projectionMatrix * vec4f(samplePos, 1.0);
                let offsetPos = offset.xyz / offset.w; // NDC
                let offsetUV = vec2f(offsetPos.x, -offsetPos.y) * 0.5 + 0.5;

                // Sample geometry at the kernel sample's screen location
                let geomWorldPos = textureSample(positionTex, samp, offsetUV).xyz;
                let geomViewPos = (scene.viewMatrix * vec4f(geomWorldPos, 1.0)).xyz;
                
                // Depth Check
                let rangeCheck = smoothstep(0.0, 1.0, params.radius / abs(viewPos.z - geomViewPos.z));
                
                // Bias check:
                if (geomViewPos.z >= samplePos.z + params.bias) {
                    occlusion += 1.0 * rangeCheck;
                }
            }
            
            occlusion = 1.0 - (occlusion / f32(${this.kernelSize}));
            return occlusion;
        }
      `;
    this.pipeline = device.createRenderPipeline({
      label: "SSAO Pipeline",
      layout: device.createPipelineLayout({
        bindGroupLayouts: [
          globalResources.renderBindGroupLayout,
          device.createBindGroupLayout({
            entries: [
              { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: {} },
              { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: {} },
              { binding: 2, visibility: GPUShaderStage.FRAGMENT, texture: {} },
              { binding: 3, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
              { binding: 4, visibility: GPUShaderStage.FRAGMENT, sampler: {} },
              { binding: 5, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "non-filtering" } },
              { binding: 6, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } }
            ]
          })
        ]
      }),
      vertex: {
        module: createShaderModuleSafe(device, { code }),
        entryPoint: "vs_main"
      },
      fragment: {
        module: createShaderModuleSafe(device, { code }),
        entryPoint: "fs_main",
        targets: [{ format: "r8unorm" }]
      },
      primitive: { topology: "triangle-list" }
    });
  }
  createBindGroup(device, globalResources) {
    if (!this.pipeline)
      return;
    this.bindGroup = device.createBindGroup({
      label: "SSAO Bind Group",
      layout: this.pipeline.getBindGroupLayout(1),
      entries: [
        { binding: 0, resource: this.gBuffer.positionTexture.createView() },
        { binding: 1, resource: this.gBuffer.normalTexture.createView() },
        { binding: 2, resource: this.noiseTexture.createView() },
        { binding: 3, resource: { buffer: this.ssaoKernelBuffer } },
        { binding: 4, resource: this.sampler },
        { binding: 5, resource: this.noiseSampler },
        { binding: 6, resource: { buffer: this.ssaoParamsBuffer } }
      ]
    });
  }
}

// ../../src/core/renderer/denoise/SSGIDenoisePass.ts
class SSGIDenoisePass {
  device = null;
  denoisePipeline = null;
  denoiseLayout = null;
  sampler = null;
  linearSampler = null;
  gBuffer;
  constructor(gBuffer) {
    this.gBuffer = gBuffer;
  }
  init(device, context, presentationFormat) {
    this.device = device;
    this.sampler = device.createSampler({
      minFilter: "nearest",
      magFilter: "nearest",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    });
    this.linearSampler = device.createSampler({
      minFilter: "linear",
      magFilter: "linear",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    });
    this.createLayouts(device);
    this.createPipelines(device);
  }
  resize(width, height) {}
  execute(commandEncoder, context, globalResources) {
    if (!this.device || !this.denoisePipeline || !this.denoiseLayout)
      return;
    if (!this.gBuffer.ssgiRawTexture || !this.gBuffer.ssgiTexture)
      return;
    const bindGroup = this.device.createBindGroup({
      layout: this.denoiseLayout,
      entries: [
        { binding: 0, resource: this.gBuffer.ssgiRawTexture.createView() },
        { binding: 1, resource: this.linearSampler },
        { binding: 2, resource: this.gBuffer.normalTexture.createView() },
        { binding: 3, resource: this.gBuffer.depthTexture.createView({ aspect: "depth-only" }) },
        { binding: 4, resource: { buffer: globalResources.sceneUniforms.buffer } },
        { binding: 5, resource: this.sampler }
      ]
    });
    const pass = commandEncoder.beginRenderPass({
      label: "SSGI Spatial Denoise",
      colorAttachments: [{
        view: this.gBuffer.ssgiTexture.createView(),
        loadOp: "clear",
        storeOp: "store",
        clearValue: { r: 0, g: 0, b: 0, a: 0 }
      }]
    });
    pass.setPipeline(this.denoisePipeline);
    pass.setBindGroup(0, bindGroup);
    pass.draw(3);
    pass.end();
  }
  createLayouts(device) {
    this.denoiseLayout = device.createBindGroupLayout({
      label: "SSGI Denoise Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, sampler: {} },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 3, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "depth" } },
        { binding: 4, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
        { binding: 5, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "non-filtering" } }
      ]
    });
  }
  createPipelines(device) {
    const fullVS = `
            struct VertexOutput {
                @builtin(position) position : vec4f,
                @location(0) uv : vec2f,
            }
            @vertex
            fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                var output : VertexOutput;
                let pos = array(vec2f(-1.0, -1.0), vec2f(3.0, -1.0), vec2f(-1.0, 3.0));
                let p = pos[vertexIndex];
                output.position = vec4f(p, 0.0, 1.0);
                output.uv = p * 0.5 + 0.5;
                output.uv.y = 1.0 - output.uv.y;
                return output;
            }
        `;
    const denoiseFS = `
            @group(0) @binding(0) var srcTex : texture_2d<f32>;
            @group(0) @binding(1) var samp : sampler;
            @group(0) @binding(2) var normalTex : texture_2d<f32>;
            @group(0) @binding(3) var depthTex : texture_depth_2d;
            
            struct SceneUniforms {
                viewMatrix : mat4x4<f32>,
                projectionMatrix : mat4x4<f32>,
                lightViewProj : mat4x4<f32>,
                prevViewProj : mat4x4<f32>,
                inverseProjectionMatrix : mat4x4<f32>,
            }
            @group(0) @binding(4) var<uniform> scene : SceneUniforms;
            @group(0) @binding(5) var depthSamp : sampler;

            fn linearizeDepth(depth: f32, uv: vec2f) -> f32 {
                let clipXY = vec2f(uv.x * 2.0 - 1.0, (1.0 - uv.y) * 2.0 - 1.0);
                let clipPos = vec4f(clipXY, depth, 1.0);
                let viewPos = scene.inverseProjectionMatrix * clipPos;
                return abs(viewPos.z / viewPos.w);
            }

            @fragment
            fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {
                let centerDepthNDC = textureSampleLevel(depthTex, depthSamp, uv, 0);
                if (centerDepthNDC >= 1.0) { return vec4f(0.0); } 
                
                let centerDepth = linearizeDepth(centerDepthNDC, uv);
                let centerNormal = normalize(textureSampleLevel(normalTex, depthSamp, uv, 0.0).xyz * 2.0 - 1.0);
                
                let texSize = vec2f(textureDimensions(srcTex));
                let onePixel = 1.0 / texSize;
                
                var totalColor = vec3f(0.0);
                var totalWeight = 0.0;
                
                // 5x5 Kernel with Stride 2 = Effective Area 9x9 pixels
                let radius = 2; 
                let stride = 2.0;

                for (var y = -radius; y <= radius; y++) {
                    for (var x = -radius; x <= radius; x++) {
                        let offset = vec2f(f32(x), f32(y)) * onePixel * stride;
                        let sampleUV = uv + offset;
                        
                        let rawSampleColor = textureSampleLevel(srcTex, samp, sampleUV, 0.0).rgb;
                        let sampleColor = clamp(rawSampleColor, vec3f(0.0), vec3f(100.0));

                        let sampleDepthNDC = textureSampleLevel(depthTex, depthSamp, sampleUV, 0);
                        let sampleDepth = linearizeDepth(sampleDepthNDC, sampleUV);
                        let sampleNormal = normalize(textureSampleLevel(normalTex, depthSamp, sampleUV, 0.0).xyz * 2.0 - 1.0);
                        
                        // 1. Spatial Weight
                        let dist = length(vec2f(f32(x), f32(y)));
                        let wSpatial = exp(-dist * dist / (2.0 * f32(radius) * f32(radius))); 
                        
                        // 2. Depth Weight (Relative)
                        // Relaxed tolerance to fill holes in IGN pattern
                        // Was 10.0, now 1.0 to allow blending across slight depth changes
                        let diffDepth = abs(centerDepth - sampleDepth) / max(centerDepth, 0.001);
                        let wDepth = exp(-diffDepth * 1.0); 
                        
                        // 3. Normal Weight
                        // Relaxed to 1.0 (was 4.0) to handle normal maps/curvature better
                        let dotNormal = max(0.0, dot(centerNormal, sampleNormal));
                        let wNormal = pow(dotNormal, 1.0);
                        
                        let weight = wSpatial * wDepth * wNormal;
                        
                        totalColor += sampleColor * weight;
                        totalWeight += weight;
                    }
                }
                
                if (totalWeight > 0.001) {
                    return vec4f(clamp(totalColor / totalWeight, vec3f(0.0), vec3f(100.0)), 1.0);
                }
                
                return textureSampleLevel(srcTex, samp, uv, 0.0);
            }
        `;
    this.denoisePipeline = device.createRenderPipeline({
      label: "SSGI Denoise Pipeline",
      layout: device.createPipelineLayout({ bindGroupLayouts: [this.denoiseLayout] }),
      vertex: { module: createShaderModuleSafe(device, { code: fullVS }), entryPoint: "vs_main" },
      fragment: { module: createShaderModuleSafe(device, { code: denoiseFS }), entryPoint: "fs_main", targets: [{ format: "rgba16float" }] },
      primitive: { topology: "triangle-list" }
    });
  }
}

// ../../src/core/renderer/SSGIPass.ts
class SSGIPass {
  device = null;
  enabled = true;
  stepSize = 1;
  maxSteps = 24;
  thickness = 2;
  intensity = 1;
  fallbackAmbient = [0.03, 0.03, 0.05];
  spatialRadius = 4;
  temporalAlpha = 0.1;
  enableSpatialDenoise = true;
  enableTemporalDenoise = true;
  tracePipeline = null;
  temporalAccumPipeline = null;
  traceBindGroupLayout = null;
  temporalBindGroupLayout = null;
  sampler = null;
  depthSampler = null;
  gBuffer;
  denoisePass;
  historyIndex = 0;
  constructor(gBuffer) {
    this.gBuffer = gBuffer;
    this.denoisePass = new SSGIDenoisePass(gBuffer);
  }
  init(device, context, presentationFormat) {
    this.device = device;
    this.sampler = device.createSampler({
      minFilter: "linear",
      magFilter: "linear",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    });
    this.depthSampler = device.createSampler({
      minFilter: "nearest",
      magFilter: "nearest",
      mipmapFilter: "nearest",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    });
    this.createBindGroupLayouts(device);
    this.denoisePass.init(device, context, presentationFormat);
  }
  resize(width, height) {
    this.historyIndex = 0;
    this.denoisePass.resize(width, height);
  }
  getOutputTexture() {
    return this.gBuffer.ssgiTexture;
  }
  previousFrameTexture = null;
  setPreviousFrameTexture(tex) {
    this.previousFrameTexture = tex;
  }
  execute(commandEncoder, context, globalResources) {
    if (!this.gBuffer.ssgiTexture || !this.gBuffer.ssgiRawTexture || !this.device)
      return;
    if (!this.enabled) {
      const pass = commandEncoder.beginRenderPass({
        label: "SSGI Clear",
        colorAttachments: [{
          view: this.gBuffer.ssgiTexture.createView(),
          loadOp: "clear",
          storeOp: "store",
          clearValue: { r: 0, g: 0, b: 0, a: 0 }
        }]
      });
      pass.end();
      return;
    }
    if (!globalResources.sceneUniforms?.buffer)
      return;
    this.ensurePipelines(this.device, globalResources);
    this.executeTracePass(commandEncoder, globalResources);
    if (this.enableSpatialDenoise) {
      this.denoisePass.execute(commandEncoder, context, globalResources);
    } else {
      commandEncoder.copyTextureToTexture({ texture: this.gBuffer.ssgiRawTexture }, { texture: this.gBuffer.ssgiTexture }, [this.gBuffer.width, this.gBuffer.height]);
    }
    if (this.enableTemporalDenoise) {
      this.executeTemporalAccumPass(commandEncoder, globalResources);
    }
  }
  executeTracePass(commandEncoder, globalResources) {
    if (!this.device || !this.traceBindGroupLayout || !this.sampler || !this.depthSampler)
      return;
    const sceneUniformBuffer = globalResources.sceneUniforms.buffer;
    const paramsData = new Float32Array([
      this.maxSteps,
      this.stepSize,
      this.thickness,
      this.intensity,
      this.fallbackAmbient[0],
      this.fallbackAmbient[1],
      this.fallbackAmbient[2],
      0
    ]);
    const paramsBuffer = this.device.createBuffer({
      size: 32,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
      mappedAtCreation: true
    });
    new Float32Array(paramsBuffer.getMappedRange()).set(paramsData);
    paramsBuffer.unmap();
    const sourceView = this.previousFrameTexture ? this.previousFrameTexture.createView() : this.gBuffer.albedoTexture.createView();
    const defaultEnv = CubeTexture.getDefault(this.device);
    const envMap = globalResources.environmentMap || defaultEnv;
    const hiZView = globalResources.hiZBuffer.texture ? globalResources.hiZBuffer.texture.createView() : this.gBuffer.depthTexture.createView({ aspect: "depth-only" });
    const bindGroup = this.device.createBindGroup({
      layout: this.traceBindGroupLayout,
      entries: [
        { binding: 0, resource: this.gBuffer.normalTexture.createView() },
        { binding: 1, resource: this.gBuffer.depthTexture.createView({ aspect: "depth-only" }) },
        { binding: 2, resource: sourceView },
        { binding: 3, resource: this.sampler },
        { binding: 4, resource: { buffer: sceneUniformBuffer } },
        { binding: 5, resource: { buffer: paramsBuffer } },
        { binding: 6, resource: this.gBuffer.albedoTexture.createView() },
        { binding: 7, resource: this.depthSampler },
        { binding: 8, resource: envMap.view },
        { binding: 9, resource: envMap.sampler },
        { binding: 10, resource: hiZView }
      ]
    });
    const pass = commandEncoder.beginRenderPass({
      label: "SSGI Trace",
      colorAttachments: [{
        view: this.gBuffer.ssgiRawTexture.createView(),
        loadOp: "clear",
        storeOp: "store",
        clearValue: { r: 0, g: 0, b: 0, a: 0 }
      }]
    });
    pass.setPipeline(this.tracePipeline);
    pass.setBindGroup(0, bindGroup);
    pass.draw(3);
    pass.end();
  }
  executeTemporalAccumPass(commandEncoder, globalResources) {
    if (!this.device || !this.temporalBindGroupLayout || !this.sampler)
      return;
    if (!this.gBuffer.ssgiHistoryA || !this.gBuffer.ssgiHistoryB || !this.gBuffer.velocityTexture)
      return;
    const historyRead = this.historyIndex === 0 ? this.gBuffer.ssgiHistoryA : this.gBuffer.ssgiHistoryB;
    const historyWrite = this.historyIndex === 0 ? this.gBuffer.ssgiHistoryB : this.gBuffer.ssgiHistoryA;
    const paramsData = new Float32Array([
      this.temporalAlpha,
      0,
      0,
      0
    ]);
    const paramsBuffer = this.device.createBuffer({
      size: 16,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
      mappedAtCreation: true
    });
    new Float32Array(paramsBuffer.getMappedRange()).set(paramsData);
    paramsBuffer.unmap();
    const bindGroup = this.device.createBindGroup({
      layout: this.temporalBindGroupLayout,
      entries: [
        { binding: 0, resource: this.gBuffer.ssgiTexture.createView() },
        { binding: 1, resource: historyRead.createView() },
        { binding: 2, resource: this.gBuffer.velocityTexture.createView() },
        { binding: 3, resource: this.gBuffer.normalTexture.createView() },
        { binding: 4, resource: this.sampler },
        { binding: 5, resource: { buffer: paramsBuffer } }
      ]
    });
    const pass = commandEncoder.beginRenderPass({
      label: "SSGI Temporal Accumulation",
      colorAttachments: [{
        view: historyWrite.createView(),
        loadOp: "clear",
        storeOp: "store",
        clearValue: { r: 0, g: 0, b: 0, a: 0 }
      }]
    });
    pass.setPipeline(this.temporalAccumPipeline);
    pass.setBindGroup(0, bindGroup);
    pass.draw(3);
    pass.end();
    commandEncoder.copyTextureToTexture({ texture: historyWrite }, { texture: this.gBuffer.ssgiTexture }, [this.gBuffer.width, this.gBuffer.height]);
    this.historyIndex = 1 - this.historyIndex;
  }
  createBindGroupLayouts(device) {
    this.traceBindGroupLayout = device.createBindGroupLayout({
      label: "SSGI Trace Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "depth" } },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 3, visibility: GPUShaderStage.FRAGMENT, sampler: {} },
        { binding: 4, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
        { binding: 5, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
        { binding: 6, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 7, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "non-filtering" } },
        { binding: 8, visibility: GPUShaderStage.FRAGMENT, texture: { viewDimension: "cube" } },
        { binding: 9, visibility: GPUShaderStage.FRAGMENT, sampler: {} },
        { binding: 10, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "unfilterable-float" } }
      ]
    });
    this.temporalBindGroupLayout = device.createBindGroupLayout({
      label: "SSGI Temporal Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 3, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 4, visibility: GPUShaderStage.FRAGMENT, sampler: {} },
        { binding: 5, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } }
      ]
    });
  }
  ensurePipelines(device, globalResources) {
    if (!this.tracePipeline) {
      this.createTracePipeline(device);
    }
    if (!this.temporalAccumPipeline) {
      this.createTemporalAccumPipeline(device);
    }
  }
  createTracePipeline(device) {
    const fullscreenVS = `
        struct VertexOutput {
            @builtin(position) position : vec4f,
            @location(0) uv : vec2f,
        }
        @vertex
        fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
            var output : VertexOutput;
            let pos = array(vec2f(-1.0, -1.0), vec2f(3.0, -1.0), vec2f(-1.0, 3.0));
            let p = pos[vertexIndex];
            output.position = vec4f(p, 0.0, 1.0);
            output.uv = p * 0.5 + 0.5;
            output.uv.y = 1.0 - output.uv.y;
            return output;
        }
      `;
    const traceFS = `
        @group(0) @binding(0) var normalTex : texture_2d<f32>;
        @group(0) @binding(1) var depthTex : texture_depth_2d;
        @group(0) @binding(2) var sceneColorTex : texture_2d<f32>;
        @group(0) @binding(3) var samp : sampler;

        struct SceneUniforms {
            viewMatrix : mat4x4<f32>,
            projectionMatrix : mat4x4<f32>,
            lightViewProj : mat4x4<f32>,
            prevViewProj : mat4x4<f32>,
            inverseProjectionMatrix : mat4x4<f32>,
            cameraPosition : vec3f,
            time : f32,
        }
        @group(0) @binding(4) var<uniform> scene : SceneUniforms;

        struct SSGIParams {
            maxSteps: f32,
            stepSize: f32,
            thickness: f32,
            intensity: f32,
            fallbackR: f32,
            fallbackG: f32,
            fallbackB: f32,
            pad: f32,
        }
        @group(0) @binding(5) var<uniform> params : SSGIParams;
        @group(0) @binding(6) var albedoTex : texture_2d<f32>;
        @group(0) @binding(7) var depthSamp : sampler;
        @group(0) @binding(8) var envMap : texture_cube<f32>;
        @group(0) @binding(9) var envSamp : sampler;
        @group(0) @binding(10) var hiZTex : texture_2d<f32>;

        const PI = 3.14159265359;
        const HIZ_MAX_LEVEL = 6;  // Maximum mip level to use for Hi-Z

        // Convert view-space direction to world-space for environment sampling
        fn viewToWorldDir(viewDir: vec3f) -> vec3f {
            // View matrix is world-to-view, so we need to transpose the 3x3 rotation part
            // to get view-to-world (transpose of rotation = inverse for orthonormal matrices)
            let invView = transpose(mat3x3f(
                scene.viewMatrix[0].xyz,
                scene.viewMatrix[1].xyz,
                scene.viewMatrix[2].xyz
            ));
            return normalize(invView * viewDir);
        }

        fn getViewPosition(uv: vec2f, depth: f32) -> vec3f {
            let clipXY = vec2f(uv.x * 2.0 - 1.0, (1.0 - uv.y) * 2.0 - 1.0);
            let clipPos = vec4f(clipXY, depth, 1.0);
            let viewPos = scene.inverseProjectionMatrix * clipPos;
            return viewPos.xyz / viewPos.w;
        }

        // Interleaved Gradient Noise (IGN)
        // Generates a specific high-frequency pattern that TAA handles well
        fn ign(pixel: vec2f, frame: f32) -> f32 {
            // frame is needed to rotate the noise over time for integration
            // But for TAA-compatible stable noise, we might want static or periodic?
            // Usually we want it to jitter with TAA?
            // Let's use standard IGN formula:
            let magic = vec3f(0.06711056, 0.00583715, 52.9829189);
            // Add frame offset to x/y to animate noise? 
            // Or just add frame to result?
            // "Animated IGN" usually just adds a golden ratio offset per frame
            let val = dot(pixel, magic.xy) + frame * 0.61803398;
            return fract(magic.z * fract(val));
        }

        fn hash2(p: vec2f) -> vec2f {
             // Fallback/Variation
             return vec2f(fract(sin(dot(p, vec2f(12.9898, 78.233))) * 43758.5453),
                          fract(sin(dot(p, vec2f(39.7867, 12.345))) * 43758.5453));
        }

        @fragment
        fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {
             let depth = textureSampleLevel(depthTex, depthSamp, uv, 0);
             if (depth >= 1.0) { return vec4f(0.0); } // Sky - no GI contribution

             let rawNormal = textureSampleLevel(normalTex, samp, uv, 0.0);
             let N = normalize(rawNormal.xyz * 2.0 - 1.0);

             let viewNormal = normalize((scene.viewMatrix * vec4f(N, 0.0)).xyz);
             let viewPos = getViewPosition(uv, depth);

             // Use IGN for stable noise pattern
             // Pixel coordinates
             let dim = vec2f(textureDimensions(depthTex));
             let pixel = uv * dim;
             
             // 2D Noise from IGN
             // We need 2 numbers for Hemisphere sampling (phi, theta)
             // We can use IGN for one, and a hash or offset IGN for second?
             // Or just use IGN for both (offset pixel)?
             
             let noise0 = ign(pixel, scene.time);
             let noise1 = ign(pixel + vec2f(5.2, 1.3), scene.time);
             
             let noise = vec2f(noise0, noise1);

             let phi = 2.0 * PI * noise.x;
             let cosTheta = sqrt(1.0 - noise.y);
             let sinTheta = sqrt(noise.y);

             let tangentSample = vec3f(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);

             let up = select(vec3f(1.0, 0.0, 0.0), vec3f(0.0, 0.0, 1.0), abs(viewNormal.z) < 0.999);
             let tangent = normalize(cross(up, viewNormal));
             let bitangent = cross(viewNormal, tangent);

             let sampleDir = normalize(tangent * tangentSample.x + bitangent * tangentSample.y + viewNormal * tangentSample.z);

             // Adaptive parameters based on depth
             let linearDepth = abs(viewPos.z);
             let stepSize = params.stepSize * max(1.0, linearDepth * 0.01);
             let thickness = params.thickness * max(1.0, linearDepth * 0.01);

             var currentPos = viewPos + viewNormal * 0.01; // Small offset to avoid self-hit
             let maxSteps = i32(params.maxSteps);

             var hit = false;
             var hitUV = vec2f(0.0);

             for (var i = 0; i < maxSteps; i++) {
                 currentPos += sampleDir * stepSize;

                 let projected = scene.projectionMatrix * vec4f(currentPos, 1.0);
                 let ndc = projected.xyz / projected.w;
                 let screenUV = vec2f(ndc.x, -ndc.y) * 0.5 + 0.5;

                 if (screenUV.x < 0.0 || screenUV.x > 1.0 || screenUV.y < 0.0 || screenUV.y > 1.0) {
                     break;
                 }

                 let sampleDepth = textureSampleLevel(depthTex, depthSamp, screenUV, 0);
                 if (sampleDepth >= 1.0) { break; }

                 let sampleViewPos = getViewPosition(screenUV, sampleDepth);
                 let delta = currentPos.z - sampleViewPos.z;

                 if (delta < 0.0 && delta > -thickness) {
                     hit = true;
                     hitUV = screenUV;
                     break;
                 }
             }

             var result = vec3f(params.fallbackR, params.fallbackG, params.fallbackB);

             if (hit) {
                 let rawHitColor = textureSampleLevel(sceneColorTex, samp, hitUV, 0.0).rgb;
                 // Clamp to prevent NaNs/Infs from propagating
                 let hitColor = clamp(rawHitColor, vec3f(0.0), vec3f(100.0));
                 let edgeFade = 1.0 - max(abs(hitUV.x - 0.5), abs(hitUV.y - 0.5)) * 2.0;
                 result = hitColor * clamp(edgeFade, 0.0, 1.0) * params.intensity;
             }
             // Miss returns black - denoising will handle it

             return vec4f(result, 1.0);
        }
      `;
    this.tracePipeline = device.createRenderPipeline({
      label: "SSGI Trace Pipeline",
      layout: device.createPipelineLayout({ bindGroupLayouts: [this.traceBindGroupLayout] }),
      vertex: { module: createShaderModuleSafe(device, { code: fullscreenVS }), entryPoint: "vs_main" },
      fragment: { module: createShaderModuleSafe(device, { code: traceFS }), entryPoint: "fs_main", targets: [{ format: "rgba16float" }] },
      primitive: { topology: "triangle-list" }
    });
  }
  createTemporalAccumPipeline(device) {
    const fullscreenVS = `
        struct VertexOutput {
            @builtin(position) position : vec4f,
            @location(0) uv : vec2f,
        }
        @vertex
        fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
            var output : VertexOutput;
            let pos = array(vec2f(-1.0, -1.0), vec2f(3.0, -1.0), vec2f(-1.0, 3.0));
            let p = pos[vertexIndex];
            output.position = vec4f(p, 0.0, 1.0);
            output.uv = p * 0.5 + 0.5;
            output.uv.y = 1.0 - output.uv.y;
            return output;
        }
      `;
    const temporalFS = `
        @group(0) @binding(0) var currentTex : texture_2d<f32>;
        @group(0) @binding(1) var historyTex : texture_2d<f32>;
        @group(0) @binding(2) var velocityTex : texture_2d<f32>;
        @group(0) @binding(3) var normalTex : texture_2d<f32>;
        @group(0) @binding(4) var samp : sampler;

        struct TemporalParams {
            alpha: f32,
            pad1: f32,
            pad2: f32,
            pad3: f32,
        }
        @group(0) @binding(5) var<uniform> params : TemporalParams;

        fn luminance(c: vec3f) -> f32 {
            return dot(c, vec3f(0.299, 0.587, 0.114));
        }

        @fragment
        fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {
            let current = textureSampleLevel(currentTex, samp, uv, 0.0);
            let velocity = textureSampleLevel(velocityTex, samp, uv, 0.0).xy;

            // Reproject to previous frame
            let prevUV = uv - velocity;

            // Out of bounds - use current frame only
            if (prevUV.x < 0.0 || prevUV.x > 1.0 || prevUV.y < 0.0 || prevUV.y > 1.0) {
                return current;
            }

            let history = textureSampleLevel(historyTex, samp, prevUV, 0.0);

            // Variance-based neighborhood clamping
            // Compute mean and variance of neighborhood
            let texSize = vec2f(textureDimensions(currentTex));
            let onePixel = 1.0 / texSize;

            var mean = vec3f(0.0);
            var meanSq = vec3f(0.0);
            var minColor = current.rgb;
            var maxColor = current.rgb;

            // 3x3 neighborhood
            for (var y = -1; y <= 1; y++) {
                for (var x = -1; x <= 1; x++) {
                    let offset = vec2f(f32(x), f32(y)) * onePixel;
                    let neighborColor = textureSampleLevel(currentTex, samp, uv + offset, 0.0).rgb;
                    mean += neighborColor;
                    meanSq += neighborColor * neighborColor;
                    minColor = min(minColor, neighborColor);
                    maxColor = max(maxColor, neighborColor);
                }
            }

            mean /= 9.0;
            meanSq /= 9.0;
            let variance = max(meanSq - mean * mean, vec3f(0.0));
            let stdDev = sqrt(variance);

            // Variance-based clamping: expand bounds when variance is low (sparse/dark areas)
            // This prevents aggressive rejection of valid history in dark regions
            let gamma = 1.5;  // How many std devs to allow
            let varianceMin = mean - stdDev * gamma;
            let varianceMax = mean + stdDev * gamma;

            // Use the more permissive of min/max clamping and variance clamping
            // When neighborhood is dark/sparse, variance clamping allows more history through
            let expandedMin = min(minColor, varianceMin);
            let expandedMax = max(maxColor, varianceMax);

            // Add small tolerance to prevent completely black clamping
            let tolerance = 0.02;
            let finalMin = expandedMin - tolerance;
            let finalMax = expandedMax + tolerance;

            // Clamp history with expanded bounds
            let clampedHistory = clamp(history.rgb, finalMin, finalMax);

            // Velocity-based blend factor - fast motion = trust current more
            let velMag = length(velocity * texSize);
            let velocityFactor = clamp(velMag * 0.1, 0.0, 1.0);

            // Luminance-based rejection REMOVED:
            // High noise looks like high luminance change, which caused the history to be rejected.
            // We rely on Variance Clipping (above) to handle ghosting.
            
            // Final blend: more weight to history for stable result
            // Alpha is usually 0.1 (10% new, 90% old)
            // If moving fast, we blend more new.
            let alpha = mix(params.alpha, 1.0, velocityFactor);
            let result = mix(clampedHistory, current.rgb, alpha);

            return vec4f(result, 1.0);
        }
      `;
    this.temporalAccumPipeline = device.createRenderPipeline({
      label: "SSGI Temporal Accumulation Pipeline",
      layout: device.createPipelineLayout({ bindGroupLayouts: [this.temporalBindGroupLayout] }),
      vertex: { module: createShaderModuleSafe(device, { code: fullscreenVS }), entryPoint: "vs_main" },
      fragment: { module: createShaderModuleSafe(device, { code: temporalFS }), entryPoint: "fs_main", targets: [{ format: "rgba16float" }] },
      primitive: { topology: "triangle-list" }
    });
  }
}

// ../../src/core/renderer/TAAPass.ts
class TAAPass {
  gBuffer;
  historyTextureA = null;
  historyTextureB = null;
  historyIndex = 0;
  pipeline = null;
  bindGroupLayout = null;
  width = 0;
  height = 0;
  device = null;
  alpha = 0.1;
  enabled = true;
  constructor(gBuffer) {
    this.gBuffer = gBuffer;
  }
  init(device, context, presentationFormat) {
    this.device = device;
    this.resize(this.gBuffer.width, this.gBuffer.height);
  }
  resize(width, height) {
    if (width <= 0 || height <= 0)
      return;
    this.width = width;
    this.height = height;
    if (this.device) {
      this.destroyTextures();
      this.createTextures(this.device);
    }
  }
  destroyTextures() {
    if (this.historyTextureA)
      this.historyTextureA.destroy();
    if (this.historyTextureB)
      this.historyTextureB.destroy();
  }
  createTextures(device) {
    const desc = {
      label: "TAA History",
      size: [this.width, this.height],
      format: "rgba16float",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT
    };
    this.historyTextureA = device.createTexture(desc);
    this.historyTextureB = device.createTexture(desc);
  }
  execute(commandEncoder, context, globalResources) {
    if (!this.enabled)
      return;
    if (!this.device || !this.gBuffer.accumulationTexture || !this.gBuffer.velocityTexture || !this.historyTextureA || !this.historyTextureB)
      return;
    if (!this.pipeline) {
      this.createPipeline(this.device, globalResources);
    }
    const source = this.gBuffer.accumulationTexture;
    const historyRead = this.historyIndex === 0 ? this.historyTextureA : this.historyTextureB;
    const historyWrite = this.historyIndex === 0 ? this.historyTextureB : this.historyTextureA;
    const bindGroup = this.device.createBindGroup({
      label: "TAA Bind Group",
      layout: this.bindGroupLayout,
      entries: [
        { binding: 0, resource: source.createView() },
        { binding: 1, resource: historyRead.createView() },
        { binding: 2, resource: this.gBuffer.velocityTexture.createView() },
        { binding: 3, resource: this.device.createSampler({ magFilter: "linear", minFilter: "linear", addressModeU: "clamp-to-edge", addressModeV: "clamp-to-edge" }) }
      ]
    });
    const passDescriptor = {
      colorAttachments: [
        {
          view: historyWrite.createView(),
          loadOp: "clear",
          storeOp: "store"
        }
      ]
    };
    const pass = commandEncoder.beginRenderPass(passDescriptor);
    pass.setPipeline(this.pipeline);
    pass.setBindGroup(0, bindGroup);
    pass.draw(3);
    pass.end();
    this.historyIndex = 1 - this.historyIndex;
  }
  getHistoryTexture() {
    return 1 - this.historyIndex === 0 ? this.historyTextureA : this.historyTextureB;
  }
  getPreviousFrameTexture() {
    return this.historyIndex === 0 ? this.historyTextureA : this.historyTextureB;
  }
  createPipeline(device, globalResources) {
    const code = `
        @group(0) @binding(0) var currentTex : texture_2d<f32>;
        @group(0) @binding(1) var historyTex : texture_2d<f32>;
        @group(0) @binding(2) var velocityTex : texture_2d<f32>;
        @group(0) @binding(3) var samp : sampler;

        struct VertexOutput {
            @builtin(position) position : vec4f,
            @location(0) uv : vec2f,
        }

        @vertex
        fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
            var output : VertexOutput;
            let pos = array(
            vec2f(-1.0, -1.0),
            vec2f( 3.0, -1.0),
            vec2f(-1.0,  3.0)
            );
            let p = pos[vertexIndex];
            output.position = vec4f(p, 0.0, 1.0);
            output.uv = p * 0.5 + 0.5;
            output.uv.y = 1.0 - output.uv.y; 
            return output;
        }

        fn RGBToYCoCg(rgb: vec3f) -> vec3f {
            let Y  = dot(rgb, vec3f(0.25, 0.5, 0.25));
            let Co = dot(rgb, vec3f(0.5, 0.0, -0.5));
            let Cg = dot(rgb, vec3f(-0.25, 0.5, -0.25));
            return vec3f(Y, Co, Cg);
        }

        fn YCoCgToRGB(ycocg: vec3f) -> vec3f {
            let Y  = ycocg.x;
            let Co = ycocg.y;
            let Cg = ycocg.z;
            let R = Y + Co - Cg;
            let G = Y + Cg;
            let B = Y - Co - Cg;
            return vec3f(R, G, B);
        }

        @fragment
        fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {
            let velocity = textureSample(velocityTex, samp, uv).xy;
            let currentRGB = textureSample(currentTex, samp, uv).rgb;
            let current = RGBToYCoCg(currentRGB);
            
            // Reproject
            let prevUV = uv - velocity;
            
            // Bounds check
            if (prevUV.x < 0.0 || prevUV.x > 1.0 || prevUV.y < 0.0 || prevUV.y > 1.0) {
                return vec4f(currentRGB, 1.0); // No history
            }
            
            // Safe sample history with explicit LOD
            let historyRGB = textureSampleLevel(historyTex, samp, prevUV, 0.0).rgb;
            let history = RGBToYCoCg(historyRGB);
            
            // Neighborhood Statistics (Variance Clipping in YCoCg)
            let texSize = vec2f(textureDimensions(currentTex));
            let onePixel = 1.0 / texSize;
            
            var m1 = vec3f(0.0);
            var m2 = vec3f(0.0);
            
            for(var y = -1; y <= 1; y++) {
                for(var x = -1; x <= 1; x++) {
                    let offset = vec2f(f32(x), f32(y)) * onePixel;
                    let cRGB = textureSampleLevel(currentTex, samp, uv + offset, 0.0).rgb;
                    let c = RGBToYCoCg(cRGB);
                    m1 += c;
                    m2 += c * c;
                }
            }
            
            m1 /= 9.0;
            m2 /= 9.0;
            
            let sigma = sqrt(abs(m2 - m1 * m1));
            let gamma = 1.25; // Wider clipping to preserve detail (was 0.75)

            // Prevent zero-width box in perfectly uniform areas
            let minSpread = vec3f(0.01);

            let minColor = m1 - gamma * sigma - minSpread;
            let maxColor = m1 + gamma * sigma + minSpread;
            
            // Clip history to neighborhood Variance AABB (in YCoCg)
            let clampedHistory = clamp(history, minColor, maxColor);
            
            // Dynamic Feedback Factor
            // 1. Velocity Factor: If moving fast, trust history less to avoid ghosting
            let velMag = length(velocity * texSize); // Velocity in pixels
            let velWeight = clamp(velMag * 0.1, 0.0, 1.0); // Adjust scale as needed
            
            let baseAlpha = 0.15; // 15% new, 85% old (was 0.1 - increased to reduce blur)
            let targetAlpha = mix(baseAlpha, 1.0, velWeight);
            
            let resultYCoCg = mix(clampedHistory, current, targetAlpha);
            let resultRGB = YCoCgToRGB(resultYCoCg);
            
            // Clamp final result to prevent NaNs
            return vec4f(clamp(resultRGB, vec3f(0.0), vec3f(100.0)), 1.0);
        }
      `;
    this.bindGroupLayout = device.createBindGroupLayout({
      label: "TAA Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 3, visibility: GPUShaderStage.FRAGMENT, sampler: {} }
      ]
    });
    const layout = device.createPipelineLayout({
      bindGroupLayouts: [this.bindGroupLayout]
    });
    this.pipeline = device.createRenderPipeline({
      label: "TAA Pipeline",
      layout,
      vertex: {
        module: createShaderModuleSafe(device, { code }),
        entryPoint: "vs_main"
      },
      fragment: {
        module: createShaderModuleSafe(device, { code }),
        entryPoint: "fs_main",
        targets: [{ format: "rgba16float" }]
      },
      primitive: { topology: "triangle-list" }
    });
  }
}

// ../../src/core/renderer/FXAAPass.ts
class FXAAPass {
  gBuffer;
  outputTexture = null;
  inputTexture = null;
  pipeline = null;
  bindGroupLayout = null;
  sampler = null;
  width = 0;
  height = 0;
  device = null;
  contrastThreshold = 0.0312;
  relativeThreshold = 0.063;
  subpixelBlending = 0.75;
  enabled = true;
  constructor(gBuffer) {
    this.gBuffer = gBuffer;
  }
  setInputTexture(texture) {
    this.inputTexture = texture;
  }
  init(device, _context, _presentationFormat) {
    this.device = device;
    this.sampler = device.createSampler({
      minFilter: "linear",
      magFilter: "linear",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    });
    this.resize(this.gBuffer.width, this.gBuffer.height);
  }
  resize(width, height) {
    if (width <= 0 || height <= 0)
      return;
    this.width = width;
    this.height = height;
    if (this.device) {
      this.destroyTextures();
      this.createTextures(this.device);
    }
  }
  destroyTextures() {
    if (this.outputTexture)
      this.outputTexture.destroy();
  }
  createTextures(device) {
    this.outputTexture = device.createTexture({
      label: "FXAA Output",
      size: [this.width, this.height],
      format: "rgba16float",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT
    });
  }
  execute(commandEncoder, _context, _globalResources) {
    if (!this.enabled)
      return;
    const source = this.inputTexture || this.gBuffer.accumulationTexture;
    if (!this.device || !source || !this.outputTexture)
      return;
    if (!this.pipeline) {
      this.createPipeline(this.device);
    }
    const bindGroup = this.device.createBindGroup({
      label: "FXAA Bind Group",
      layout: this.bindGroupLayout,
      entries: [
        { binding: 0, resource: source.createView() },
        { binding: 1, resource: this.sampler }
      ]
    });
    const passDescriptor = {
      colorAttachments: [
        {
          view: this.outputTexture.createView(),
          loadOp: "clear",
          storeOp: "store"
        }
      ]
    };
    const pass = commandEncoder.beginRenderPass(passDescriptor);
    pass.setPipeline(this.pipeline);
    pass.setBindGroup(0, bindGroup);
    pass.draw(3);
    pass.end();
  }
  getOutputTexture() {
    return this.outputTexture;
  }
  createPipeline(device) {
    const code = `
      @group(0) @binding(0) var inputTex : texture_2d<f32>;
      @group(0) @binding(1) var samp : sampler;

      struct VertexOutput {
        @builtin(position) position : vec4f,
        @location(0) uv : vec2f,
      }

      // Fullscreen triangle vertex shader
      @vertex
      fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
        var output : VertexOutput;
        let pos = array(
          vec2f(-1.0, -1.0),
          vec2f( 3.0, -1.0),
          vec2f(-1.0,  3.0)
        );
        let p = pos[vertexIndex];
        output.position = vec4f(p, 0.0, 1.0);
        output.uv = p * 0.5 + 0.5;
        output.uv.y = 1.0 - output.uv.y;
        return output;
      }

      // Constants - hardcoded for now, could be made uniforms
      const CONTRAST_THRESHOLD: f32 = ${this.contrastThreshold};
      const RELATIVE_THRESHOLD: f32 = ${this.relativeThreshold};
      const SUBPIXEL_BLENDING: f32 = ${this.subpixelBlending};

      // Edge search steps - balance between quality and performance
      const EDGE_STEP_COUNT: i32 = 10;
      const EDGE_STEPS: array<f32, 10> = array<f32, 10>(
        1.0, 1.5, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 4.0
      );
      const EDGE_GUESS: f32 = 8.0;

      // Convert RGB to luminance using perceptual weights
      fn luminance(rgb: vec3f) -> f32 {
        return dot(rgb, vec3f(0.299, 0.587, 0.114));
      }

      // Sample luminance at offset from UV
      fn sampleLuma(uv: vec2f) -> f32 {
        return luminance(textureSampleLevel(inputTex, samp, uv, 0.0).rgb);
      }

      @fragment
      fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {
        let texSize = vec2f(textureDimensions(inputTex));
        let invSize = 1.0 / texSize;

        // Sample center and 4 neighbors
        let rgbM = textureSampleLevel(inputTex, samp, uv, 0.0).rgb;
        let lumaM = luminance(rgbM);

        let lumaN = sampleLuma(uv + vec2f(0.0, -invSize.y));
        let lumaS = sampleLuma(uv + vec2f(0.0, invSize.y));
        let lumaE = sampleLuma(uv + vec2f(invSize.x, 0.0));
        let lumaW = sampleLuma(uv + vec2f(-invSize.x, 0.0));

        // Find min/max luminance in the neighborhood
        let lumaMin = min(lumaM, min(min(lumaN, lumaS), min(lumaE, lumaW)));
        let lumaMax = max(lumaM, max(max(lumaN, lumaS), max(lumaE, lumaW)));
        let lumaRange = lumaMax - lumaMin;

        // Early exit if contrast is too low (not an edge)
        if (lumaRange < max(CONTRAST_THRESHOLD, lumaMax * RELATIVE_THRESHOLD)) {
          return vec4f(rgbM, 1.0);
        }

        // Sample diagonal neighbors for subpixel aliasing detection
        let lumaNW = sampleLuma(uv + vec2f(-invSize.x, -invSize.y));
        let lumaNE = sampleLuma(uv + vec2f(invSize.x, -invSize.y));
        let lumaSW = sampleLuma(uv + vec2f(-invSize.x, invSize.y));
        let lumaSE = sampleLuma(uv + vec2f(invSize.x, invSize.y));

        // Compute subpixel blend factor
        let lumaL = (lumaN + lumaS + lumaE + lumaW) * 0.25;
        let rangeL = abs(lumaL - lumaM);
        var blendL = max(0.0, (rangeL / lumaRange) - 0.25);
        blendL = min(SUBPIXEL_BLENDING, blendL * 1.3333333);

        // Detect edge direction (horizontal vs vertical)
        let edgeH = abs(-2.0 * lumaW + lumaNW + lumaSW) +
                    abs(-2.0 * lumaM + lumaN + lumaS) * 2.0 +
                    abs(-2.0 * lumaE + lumaNE + lumaSE);
        let edgeV = abs(-2.0 * lumaN + lumaNW + lumaNE) +
                    abs(-2.0 * lumaM + lumaW + lumaE) * 2.0 +
                    abs(-2.0 * lumaS + lumaSW + lumaSE);

        let isHorizontal = edgeH >= edgeV;

        // Choose edge direction
        var stepLength: f32;
        var luma1: f32;
        var luma2: f32;

        if (isHorizontal) {
          stepLength = invSize.y;
          luma1 = lumaN;
          luma2 = lumaS;
        } else {
          stepLength = invSize.x;
          luma1 = lumaW;
          luma2 = lumaE;
        }

        // Determine which side of the edge we're on
        let gradient1 = luma1 - lumaM;
        let gradient2 = luma2 - lumaM;
        let is1Steepest = abs(gradient1) >= abs(gradient2);
        let gradientScaled = 0.25 * max(abs(gradient1), abs(gradient2));

        // Choose step direction
        var edgeStep: f32;
        var lumaLocalAvg: f32;

        if (is1Steepest) {
          edgeStep = -stepLength;
          lumaLocalAvg = 0.5 * (luma1 + lumaM);
        } else {
          edgeStep = stepLength;
          lumaLocalAvg = 0.5 * (luma2 + lumaM);
        }

        // Compute edge UV
        var edgeUV = uv;
        if (isHorizontal) {
          edgeUV.y += edgeStep * 0.5;
        } else {
          edgeUV.x += edgeStep * 0.5;
        }

        // Step along the edge in both directions
        var uvStep: vec2f;
        if (isHorizontal) {
          uvStep = vec2f(invSize.x, 0.0);
        } else {
          uvStep = vec2f(0.0, invSize.y);
        }

        var uv1 = edgeUV - uvStep;
        var uv2 = edgeUV + uvStep;

        var lumaEnd1 = sampleLuma(uv1) - lumaLocalAvg;
        var lumaEnd2 = sampleLuma(uv2) - lumaLocalAvg;

        var reached1 = abs(lumaEnd1) >= gradientScaled;
        var reached2 = abs(lumaEnd2) >= gradientScaled;
        var reachedBoth = reached1 && reached2;

        if (!reached1) { uv1 -= uvStep; }
        if (!reached2) { uv2 += uvStep; }

        // Continue searching for edge endpoints
        if (!reachedBoth) {
          for (var i = 2; i < EDGE_STEP_COUNT; i++) {
            if (!reached1) {
              lumaEnd1 = sampleLuma(uv1) - lumaLocalAvg;
              reached1 = abs(lumaEnd1) >= gradientScaled;
            }
            if (!reached2) {
              lumaEnd2 = sampleLuma(uv2) - lumaLocalAvg;
              reached2 = abs(lumaEnd2) >= gradientScaled;
            }
            reachedBoth = reached1 && reached2;
            if (!reached1) { uv1 -= uvStep * EDGE_STEPS[i]; }
            if (!reached2) { uv2 += uvStep * EDGE_STEPS[i]; }
            if (reachedBoth) { break; }
          }
        }

        // Compute distances to edge endpoints
        var distance1: f32;
        var distance2: f32;
        if (isHorizontal) {
          distance1 = uv.x - uv1.x;
          distance2 = uv2.x - uv.x;
        } else {
          distance1 = uv.y - uv1.y;
          distance2 = uv2.y - uv.y;
        }

        let distanceToEnd = min(distance1, distance2);
        let edgeLength = distance1 + distance2;
        let pixelOffset = -distanceToEnd / edgeLength + 0.5;

        // Check if we should apply AA based on edge direction
        let isLumaCenterSmaller = lumaM < lumaLocalAvg;
        let correctVariation1 = (lumaEnd1 < 0.0) != isLumaCenterSmaller;
        let correctVariation2 = (lumaEnd2 < 0.0) != isLumaCenterSmaller;
        let correctVariation = select(correctVariation2, correctVariation1, distance1 < distance2);

        var finalPixelOffset = select(0.0, pixelOffset, correctVariation);
        finalPixelOffset = max(finalPixelOffset, blendL);

        // Apply the offset and sample the final color
        var finalUV = uv;
        if (isHorizontal) {
          finalUV.y += finalPixelOffset * edgeStep;
        } else {
          finalUV.x += finalPixelOffset * edgeStep;
        }

        let finalColor = textureSampleLevel(inputTex, samp, finalUV, 0.0).rgb;
        return vec4f(finalColor, 1.0);
      }
    `;
    this.bindGroupLayout = device.createBindGroupLayout({
      label: "FXAA Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, sampler: {} }
      ]
    });
    const layout = device.createPipelineLayout({
      bindGroupLayouts: [this.bindGroupLayout]
    });
    this.pipeline = device.createRenderPipeline({
      label: "FXAA Pipeline",
      layout,
      vertex: {
        module: createShaderModuleSafe(device, { code }),
        entryPoint: "vs_main"
      },
      fragment: {
        module: createShaderModuleSafe(device, { code }),
        entryPoint: "fs_main",
        targets: [{ format: "rgba16float" }]
      },
      primitive: { topology: "triangle-list" }
    });
  }
}

// ../../src/core/renderer/ToneMappingPass.ts
class ToneMappingPass {
  pipeline = null;
  inputTexture = null;
  bloomTexture = null;
  godRaysTexture = null;
  context = null;
  defaultTexture = null;
  bloomIntensity = 0.5;
  godRaysIntensity = 1;
  constructor() {}
  setInputTexture(texture) {
    this.inputTexture = texture;
  }
  setBloomTexture(texture) {
    this.bloomTexture = texture;
  }
  setGodRaysTexture(texture) {
    this.godRaysTexture = texture;
  }
  init(device, context, presentationFormat) {
    this.context = context;
    this.gDevice = device;
    this.defaultTexture = device.createTexture({
      size: [1, 1],
      format: "rgba16float",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
    });
    device.queue.writeTexture({ texture: this.defaultTexture }, new Float32Array([0, 0, 0, 0]), { bytesPerRow: 16 }, { width: 1, height: 1 });
    this.createPipeline(device, presentationFormat);
  }
  resize(width, height) {}
  execute(commandEncoder, context, globalResources) {
    if (!this.inputTexture || !this.pipeline || !this.context || !this.gDevice)
      return;
    if (this.inputTexture.width === 0 || this.inputTexture.height === 0)
      return;
    let currentTexture;
    try {
      currentTexture = this.context.getCurrentTexture();
    } catch (e) {
      return;
    }
    const textureView = currentTexture.createView();
    let bloomView;
    if (this.bloomTexture && this.bloomTexture.width > 0 && this.bloomTexture.height > 0) {
      bloomView = this.bloomTexture.createView();
    } else {
      bloomView = this.defaultTexture.createView();
    }
    let godRaysView;
    if (this.godRaysTexture && this.godRaysTexture.width > 0 && this.godRaysTexture.height > 0) {
      godRaysView = this.godRaysTexture.createView();
    } else {
      godRaysView = this.defaultTexture.createView();
    }
    const uniformData = new Float32Array([this.bloomIntensity, this.godRaysIntensity, 0, 0]);
    const uniformBuffer = createBufferWithData(this.gDevice, uniformData, GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST, "ToneMapping Uniform Buffer");
    const bg = this.gDevice.createBindGroup({
      label: "ToneMapping Bind Group",
      layout: this.pipeline.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: this.inputTexture.createView() },
        { binding: 1, resource: this.gDevice.createSampler({ minFilter: "linear", magFilter: "linear" }) },
        { binding: 2, resource: bloomView },
        { binding: 3, resource: { buffer: uniformBuffer } },
        { binding: 4, resource: godRaysView }
      ]
    });
    const passDescriptor = {
      colorAttachments: [
        {
          view: textureView,
          loadOp: "clear",
          storeOp: "store"
        }
      ]
    };
    const pass = commandEncoder.beginRenderPass(passDescriptor);
    pass.setPipeline(this.pipeline);
    pass.setBindGroup(0, bg);
    pass.draw(3);
    pass.end();
  }
  gDevice = null;
  createPipeline(device, format) {
    this.gDevice = device;
    const code = `
        @group(0) @binding(0) var inputTex : texture_2d<f32>;
        @group(0) @binding(1) var samp : sampler;
        @group(0) @binding(2) var bloomTex : texture_2d<f32>;
        struct Params {
            bloomIntensity: f32,
            godRaysIntensity: f32,
            pad1: f32,
            pad2: f32,
        }
        @group(0) @binding(3) var<uniform> params : Params;
        @group(0) @binding(4) var godRaysTex : texture_2d<f32>;

        struct VertexOutput {
            @builtin(position) position : vec4f,
            @location(0) uv : vec2f,
        }

        @vertex
        fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
            var output : VertexOutput;
            let pos = array(
            vec2f(-1.0, -1.0),
            vec2f( 3.0, -1.0),
            vec2f(-1.0,  3.0)
            );
            let p = pos[vertexIndex];
            output.position = vec4f(p, 0.0, 1.0);
            output.uv = p * 0.5 + 0.5;
            output.uv.y = 1.0 - output.uv.y;
            return output;
        }

        // Interleaved Gradient Noise for dithering (reduces banding in gradients)
        fn ign(pixel: vec2f) -> f32 {
            return fract(52.9829189 * fract(0.06711056 * pixel.x + 0.00583715 * pixel.y));
        }

        @fragment
        fn fs_main(@location(0) uv : vec2f, @builtin(position) fragCoord : vec4f) -> @location(0) vec4f {
            var color = textureSample(inputTex, samp, uv).rgb;

            // God Rays Composite (additive, before bloom)
            let godRays = textureSample(godRaysTex, samp, uv).rgb;
            color += godRays * params.godRaysIntensity;

            // Bloom Composite
            let bloom = textureSample(bloomTex, samp, uv).rgb;
            color += bloom * params.bloomIntensity;

            // ACES Tone Mapping
            let a = 2.51;
            let b = 0.03;
            let c = 2.43;
            let d = 0.59;
            let e = 0.14;
            let mapped = clamp((color * (a * color + b)) / (color * (c * color + d) + e), vec3f(0.0), vec3f(1.0));

            let gamma = 2.2;
            var finalColor = pow(mapped, vec3f(1.0 / gamma));

            // Dithering to reduce banding in gradients (especially atmosphere sunrise/sunset)
            // Apply noise in the range [-0.5/255, 0.5/255] to break up quantization bands
            let dither = (ign(fragCoord.xy) - 0.5) / 255.0;
            finalColor += vec3f(dither);

            return vec4f(finalColor, 1.0);
        }
      `;
    this.pipeline = device.createRenderPipeline({
      label: "ToneMapping Pipeline",
      layout: "auto",
      vertex: {
        module: createShaderModuleSafe(device, { code }),
        entryPoint: "vs_main"
      },
      fragment: {
        module: createShaderModuleSafe(device, { code }),
        entryPoint: "fs_main",
        targets: [{ format }]
      },
      primitive: { topology: "triangle-list" }
    });
  }
}

// ../../src/core/renderer/BloomPass.ts
class BloomPass {
  device = null;
  width = 0;
  height = 0;
  bloomTexture = null;
  enabled = true;
  threshold = 1;
  knee = 0.1;
  intensity = 1;
  prefilterPipeline = null;
  downsamplePipeline = null;
  upsamplePipeline = null;
  bindGroupLayout = null;
  sampler = null;
  targetMipLevels = 5;
  actualMipLevels = 5;
  constructor() {}
  init(device, context, presentationFormat) {
    this.device = device;
    this.sampler = device.createSampler({
      minFilter: "linear",
      magFilter: "linear",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    });
    this.bindGroupLayout = device.createBindGroupLayout({
      label: "Bloom Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, sampler: {} },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } }
      ]
    });
  }
  resize(width, height) {
    if (width <= 0 || height <= 0) {
      if (this.bloomTexture) {
        this.bloomTexture.destroy();
        this.bloomTexture = null;
      }
      return;
    }
    this.width = Math.max(1, Math.floor(width / 2));
    this.height = Math.max(1, Math.floor(height / 2));
    if (this.device) {
      if (this.bloomTexture)
        this.bloomTexture.destroy();
      const maxDim = Math.max(this.width, this.height);
      const maxMipLevels = Math.floor(Math.log2(maxDim)) + 1;
      this.actualMipLevels = Math.min(this.targetMipLevels, maxMipLevels);
      this.bloomTexture = this.device.createTexture({
        label: "Bloom Texture Chain",
        size: { width: this.width, height: this.height, depthOrArrayLayers: 1 },
        format: "rgba16float",
        mipLevelCount: this.actualMipLevels,
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT
      });
    }
  }
  getOutputTexture() {
    return this.bloomTexture;
  }
  execute(commandEncoder, context, globalResources) {
    if (!this.enabled || !this.bloomTexture || !this.device || !this.bindGroupLayout || !this.sampler)
      return;
    this.executeInternal(commandEncoder);
  }
  inputTexture = null;
  setInputTexture(tex) {
    this.inputTexture = tex;
  }
  executeInternal(commandEncoder) {
    if (!this.inputTexture || !this.bloomTexture || !this.device || !this.bindGroupLayout || !this.sampler)
      return;
    this.ensurePipelines(this.device);
    const uniformData = new Float32Array([this.threshold, this.knee, this.intensity, 0]);
    const uniformBuffer = createBufferWithData(this.device, uniformData, GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST, "Bloom Uniform Buffer");
    const prefilterBG = this.device.createBindGroup({
      layout: this.bindGroupLayout,
      entries: [
        { binding: 0, resource: this.inputTexture.createView() },
        { binding: 1, resource: this.sampler },
        { binding: 2, resource: { buffer: uniformBuffer } }
      ]
    });
    const pass0 = commandEncoder.beginRenderPass({
      colorAttachments: [{
        view: this.bloomTexture.createView({ baseMipLevel: 0, mipLevelCount: 1 }),
        loadOp: "clear",
        storeOp: "store"
      }]
    });
    pass0.setPipeline(this.prefilterPipeline);
    pass0.setBindGroup(0, prefilterBG);
    pass0.draw(3);
    pass0.end();
    for (let i = 0;i < this.actualMipLevels - 1; i++) {
      const inputView = this.bloomTexture.createView({ baseMipLevel: i, mipLevelCount: 1 });
      const outputView = this.bloomTexture.createView({ baseMipLevel: i + 1, mipLevelCount: 1 });
      const bg = this.device.createBindGroup({
        layout: this.bindGroupLayout,
        entries: [
          { binding: 0, resource: inputView },
          { binding: 1, resource: this.sampler },
          { binding: 2, resource: { buffer: uniformBuffer } }
        ]
      });
      const pass = commandEncoder.beginRenderPass({
        colorAttachments: [{
          view: outputView,
          loadOp: "clear",
          storeOp: "store"
        }]
      });
      pass.setPipeline(this.downsamplePipeline);
      pass.setBindGroup(0, bg);
      pass.draw(3);
      pass.end();
    }
    for (let i = this.actualMipLevels - 1;i > 0; i--) {
      const inputView = this.bloomTexture.createView({ baseMipLevel: i, mipLevelCount: 1 });
      const outputView = this.bloomTexture.createView({ baseMipLevel: i - 1, mipLevelCount: 1 });
      const bg = this.device.createBindGroup({
        layout: this.bindGroupLayout,
        entries: [
          { binding: 0, resource: inputView },
          { binding: 1, resource: this.sampler },
          { binding: 2, resource: { buffer: uniformBuffer } }
        ]
      });
      const pass = commandEncoder.beginRenderPass({
        colorAttachments: [{
          view: outputView,
          loadOp: "load",
          storeOp: "store"
        }]
      });
      pass.setPipeline(this.upsamplePipeline);
      pass.setBindGroup(0, bg);
      pass.draw(3);
      pass.end();
    }
  }
  ensurePipelines(device) {
    if (this.prefilterPipeline)
      return;
    const fullscreenVS = `
        struct VertexOutput {
            @builtin(position) position : vec4f,
            @location(0) uv : vec2f,
        }
        @vertex
        fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
            var output : VertexOutput;
            let pos = array(vec2f(-1.0, -1.0), vec2f(3.0, -1.0), vec2f(-1.0, 3.0));
            let p = pos[vertexIndex];
            output.position = vec4f(p, 0.0, 1.0);
            output.uv = p * 0.5 + 0.5;
            output.uv.y = 1.0 - output.uv.y;
            return output;
        }
      `;
    const prefilterFS = `
        @group(0) @binding(0) var inputTex : texture_2d<f32>;
        @group(0) @binding(1) var samp : sampler;
        struct Params {
            threshold: f32,
            knee: f32,
            intensity: f32,
            pad: f32,
        }
        @group(0) @binding(2) var<uniform> params : Params;
        
        @fragment
        fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {
            let color = textureSample(inputTex, samp, uv).rgb;
            
            // Thresholding (Quadratic Knee)
            let brightness = max(color.r, max(color.g, color.b));
            
            var soft = brightness - params.threshold + params.knee;
            soft = clamp(soft, 0.0, 2.0 * params.knee);
            soft = soft * soft / (4.0 * params.knee + 0.00001);
            
            var contribution = max(soft, brightness - params.threshold);
            contribution /= max(brightness, 0.00001);
            
            return vec4f(color * contribution, 1.0);
        }
      `;
    const downsampleFS = `
        @group(0) @binding(0) var inputTex : texture_2d<f32>;
        @group(0) @binding(1) var samp : sampler;
        @group(0) @binding(2) var<uniform> params : array<vec4f, 1>; // Dummy
        
        @fragment
        fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {
            // 13-tap filter (approximate) or just simple bilinear
            // Efficient chain: 4 bilinear samples
            let texSize = vec2f(textureDimensions(inputTex));
            let halfPixel = 0.5 / texSize;
            
            let c0 = textureSample(inputTex, samp, uv + vec2f(-halfPixel.x * 2.0, -halfPixel.y * 2.0)).rgb;
            let c1 = textureSample(inputTex, samp, uv + vec2f( halfPixel.x * 2.0, -halfPixel.y * 2.0)).rgb;
            let c2 = textureSample(inputTex, samp, uv + vec2f(-halfPixel.x * 2.0,  halfPixel.y * 2.0)).rgb;
            let c3 = textureSample(inputTex, samp, uv + vec2f( halfPixel.x * 2.0,  halfPixel.y * 2.0)).rgb;
            
            let c4 = textureSample(inputTex, samp, uv).rgb;
            
            let color = (c0 + c1 + c2 + c3 + c4) * 0.2;
            return vec4f(color, 1.0);
        }
      `;
    const upsampleFS = `
        @group(0) @binding(0) var inputTex : texture_2d<f32>;
        @group(0) @binding(1) var samp : sampler;
        @group(0) @binding(2) var<uniform> params : array<vec4f, 1>; // Dummy
        
        @fragment
        fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {
            // 3x3 Tent Filter
            let texSize = vec2f(textureDimensions(inputTex));
            let d = 1.0 / texSize; // Radius
            
            let c0 = textureSample(inputTex, samp, uv + vec2f(-d.x, -d.y));
            let c1 = textureSample(inputTex, samp, uv + vec2f( 0.0, -d.y));
            let c2 = textureSample(inputTex, samp, uv + vec2f( d.x, -d.y));
            
            let c3 = textureSample(inputTex, samp, uv + vec2f(-d.x, 0.0));
            let c4 = textureSample(inputTex, samp, uv + vec2f( 0.0, 0.0));
            let c5 = textureSample(inputTex, samp, uv + vec2f( d.x, 0.0));
            
            let c6 = textureSample(inputTex, samp, uv + vec2f(-d.x, d.y));
            let c7 = textureSample(inputTex, samp, uv + vec2f( 0.0, d.y));
            let c8 = textureSample(inputTex, samp, uv + vec2f( d.x, d.y));
            
            let color = (
                c0 * 1.0 + c1 * 2.0 + c2 * 1.0 +
                c3 * 2.0 + c4 * 4.0 + c5 * 2.0 +
                c6 * 1.0 + c7 * 2.0 + c8 * 1.0
            ) * (1.0 / 16.0);
            
            return color;
        }
      `;
    const primitive = { topology: "triangle-list" };
    const targets = [{ format: "rgba16float" }];
    this.prefilterPipeline = device.createRenderPipeline({
      label: "Bloom Prefilter",
      layout: device.createPipelineLayout({ bindGroupLayouts: [this.bindGroupLayout] }),
      vertex: { module: createShaderModuleSafe(device, { code: fullscreenVS }), entryPoint: "vs_main" },
      fragment: { module: createShaderModuleSafe(device, { code: prefilterFS }), entryPoint: "fs_main", targets },
      primitive
    });
    this.downsamplePipeline = device.createRenderPipeline({
      label: "Bloom Downsample",
      layout: device.createPipelineLayout({ bindGroupLayouts: [this.bindGroupLayout] }),
      vertex: { module: createShaderModuleSafe(device, { code: fullscreenVS }), entryPoint: "vs_main" },
      fragment: { module: createShaderModuleSafe(device, { code: downsampleFS }), entryPoint: "fs_main", targets },
      primitive
    });
    this.upsamplePipeline = device.createRenderPipeline({
      label: "Bloom Upsample",
      layout: device.createPipelineLayout({ bindGroupLayouts: [this.bindGroupLayout] }),
      vertex: { module: createShaderModuleSafe(device, { code: fullscreenVS }), entryPoint: "vs_main" },
      fragment: {
        module: createShaderModuleSafe(device, { code: upsampleFS }),
        entryPoint: "fs_main",
        targets: [{
          format: "rgba16float",
          blend: {
            color: { srcFactor: "one", dstFactor: "one", operation: "add" },
            alpha: { srcFactor: "one", dstFactor: "one", operation: "add" }
          }
        }]
      },
      primitive
    });
  }
}

// ../../src/core/renderer/SSRPass.ts
class SSRPass {
  device = null;
  ssrTexture = null;
  enabled = false;
  stepSize = 0.5;
  maxSteps = 64;
  binarySearchSteps = 8;
  thickness = 0.5;
  tracePipeline = null;
  compositePipeline = null;
  bindGroupLayout = null;
  compositeLayout = null;
  sampler = null;
  depthSampler = null;
  gBuffer;
  constructor(gBuffer) {
    this.gBuffer = gBuffer;
  }
  init(device, context, presentationFormat) {
    this.device = device;
    this.sampler = device.createSampler({
      minFilter: "linear",
      magFilter: "linear",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    });
    this.depthSampler = device.createSampler({
      minFilter: "nearest",
      magFilter: "nearest",
      mipmapFilter: "nearest",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    });
    this.bindGroupLayout = device.createBindGroupLayout({
      label: "SSR Trace Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "depth" } },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 3, visibility: GPUShaderStage.FRAGMENT, sampler: {} },
        { binding: 4, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
        { binding: 5, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
        { binding: 6, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 7, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "non-filtering" } }
      ]
    });
    this.compositeLayout = device.createBindGroupLayout({
      label: "SSR Composite Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, sampler: {} }
      ]
    });
  }
  resize(width, height) {
    if (width <= 0 || height <= 0)
      return;
    if (this.device) {
      if (this.ssrTexture)
        this.ssrTexture.destroy();
      this.ssrTexture = this.device.createTexture({
        label: "SSR Result",
        size: { width, height, depthOrArrayLayers: 1 },
        format: "rgba16float",
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT
      });
    }
  }
  getOutputTexture() {
    return this.ssrTexture;
  }
  inputTexture = null;
  setInputTexture(tex) {
    this.inputTexture = tex;
  }
  execute(commandEncoder, context, globalResources) {
    if (!this.enabled || !this.inputTexture || !this.ssrTexture || !this.device || !this.bindGroupLayout || !this.sampler)
      return;
    if (!globalResources.sceneUniforms?.buffer)
      return;
    const sceneUniformBuffer = globalResources.sceneUniforms.buffer;
    this.ensurePipelines(this.device);
    const paramsData = new Float32Array([
      this.maxSteps,
      this.stepSize,
      this.thickness,
      0
    ]);
    const paramsBuffer = this.device.createBuffer({
      size: 16,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
      mappedAtCreation: true
    });
    new Float32Array(paramsBuffer.getMappedRange()).set(paramsData);
    paramsBuffer.unmap();
    const traceBG = this.device.createBindGroup({
      layout: this.bindGroupLayout,
      entries: [
        { binding: 0, resource: this.gBuffer.normalTexture.createView() },
        { binding: 1, resource: this.gBuffer.depthTexture.createView({ aspect: "depth-only" }) },
        { binding: 2, resource: this.inputTexture.createView() },
        { binding: 3, resource: this.sampler },
        { binding: 4, resource: { buffer: sceneUniformBuffer } },
        { binding: 5, resource: { buffer: paramsBuffer } },
        { binding: 6, resource: this.gBuffer.albedoTexture.createView() },
        { binding: 7, resource: this.depthSampler }
      ]
    });
    const pass = commandEncoder.beginRenderPass({
      label: "SSR Trace",
      colorAttachments: [{
        view: this.ssrTexture.createView(),
        loadOp: "clear",
        storeOp: "store",
        clearValue: { r: 0, g: 0, b: 0, a: 0 }
      }]
    });
    pass.setPipeline(this.tracePipeline);
    pass.setBindGroup(0, traceBG);
    pass.draw(3);
    pass.end();
    const compBG = this.device.createBindGroup({
      layout: this.compositeLayout,
      entries: [
        { binding: 0, resource: this.ssrTexture.createView() },
        { binding: 1, resource: this.sampler }
      ]
    });
    const compPass = commandEncoder.beginRenderPass({
      label: "SSR Composite",
      colorAttachments: [{
        view: this.inputTexture.createView(),
        loadOp: "load",
        storeOp: "store"
      }]
    });
    compPass.setPipeline(this.compositePipeline);
    compPass.setBindGroup(0, compBG);
    compPass.draw(3);
    compPass.end();
  }
  ensurePipelines(device) {
    if (this.tracePipeline)
      return;
    const fullscreenVS = `
        struct VertexOutput {
            @builtin(position) position : vec4f,
            @location(0) uv : vec2f,
        }
        @vertex
        fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
            var output : VertexOutput;
            let pos = array(vec2f(-1.0, -1.0), vec2f(3.0, -1.0), vec2f(-1.0, 3.0));
            let p = pos[vertexIndex];
            output.position = vec4f(p, 0.0, 1.0);
            output.uv = p * 0.5 + 0.5;
            output.uv.y = 1.0 - output.uv.y;
            return output;
        }
      `;
    const traceFS = `
        @group(0) @binding(0) var normalTex : texture_2d<f32>;
        @group(0) @binding(1) var depthTex : texture_depth_2d;
        @group(0) @binding(2) var sceneColorTex : texture_2d<f32>;
        @group(0) @binding(3) var samp : sampler;
        
        struct SceneUniforms {
            viewMatrix : mat4x4<f32>,
            projectionMatrix : mat4x4<f32>,
            lightViewProj : mat4x4<f32>,
            prevViewProj : mat4x4<f32>,
            inverseProjectionMatrix : mat4x4<f32>,
            cameraPosition : vec3f, 
            time : f32,
            // ...
        }
        @group(0) @binding(4) var<uniform> scene : SceneUniforms;
        
        struct SSRParams {
            maxSteps: f32,
            stepSize: f32,
            thickness: f32,
            pad: f32,
        }
        @group(0) @binding(5) var<uniform> params : SSRParams;
        @group(0) @binding(6) var albedoTex : texture_2d<f32>;
        @group(0) @binding(7) var depthSamp : sampler;

        fn getViewPosition(uv: vec2f, depth: f32) -> vec3f {
            let clipXY = vec2f(uv.x * 2.0 - 1.0, (1.0 - uv.y) * 2.0 - 1.0);
            let clipPos = vec4f(clipXY, depth, 1.0);
            let viewPos = scene.inverseProjectionMatrix * clipPos;
            return viewPos.xyz / viewPos.w;
        }
        
        @fragment
        fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {
             let depth = textureSampleLevel(depthTex, depthSamp, uv, 0);
             if (depth >= 1.0) { return vec4f(0.0); } // Sky
             
             let rawNormal = textureSampleLevel(normalTex, samp, uv, 0.0);
             let N = normalize(rawNormal.xyz * 2.0 - 1.0);
             let metallic = rawNormal.a;
             
             let albedoSample = textureSampleLevel(albedoTex, samp, uv, 0.0);
             let roughness = albedoSample.a;

             if (roughness > 0.8) { return vec4f(0.0); }
             
             let viewNormal = normalize((scene.viewMatrix * vec4f(N, 0.0)).xyz);
             let viewPos = getViewPosition(uv, depth);
             let viewDir = normalize(viewPos); 
             
             let reflectionDir = normalize(reflect(viewDir, viewNormal));
             
             var currentPos = viewPos;
             let stepSize = params.stepSize;
             let maxSteps = i32(params.maxSteps);
             
             var hit = false;
             var hitUV = vec2f(0.0);
             
             // Simple jitter
             let jitter = fract(sin(dot(uv, vec2f(12.9898, 78.233))) * 43758.5453);
             currentPos += reflectionDir * stepSize * jitter;
             
             for (var i = 0; i < maxSteps; i++) {
                 currentPos += reflectionDir * stepSize;
                 
                 let projected = scene.projectionMatrix * vec4f(currentPos, 1.0);
                 let projectedPos = projected.xyz / projected.w;
                 let screenUV = vec2f(projectedPos.x, -projectedPos.y) * 0.5 + 0.5;
                 
                 if (screenUV.x < 0.0 || screenUV.x > 1.0 || screenUV.y < 0.0 || screenUV.y > 1.0) {
                     break;
                 }
                 
                 // Fixed: textureSampleLevel with 0 (integer) and depthSamp
                 let sampleDepth = textureSampleLevel(depthTex, depthSamp, screenUV, 0);
                 let sampleViewPos = getViewPosition(screenUV, sampleDepth);
                 let sampleZ = sampleViewPos.z;
                 
                 let delta = currentPos.z - sampleZ; 
                 if (delta < 0.0 && delta > -params.thickness) {
                     hit = true;
                     hitUV = screenUV;
                     
                     // Binary Search
                     currentPos -= reflectionDir * stepSize;
                     let halfStep = stepSize * 0.5;
                     
                     for (var j = 0; j < 4; j++) {
                         currentPos += reflectionDir * halfStep;
                         
                         let p = scene.projectionMatrix * vec4f(currentPos, 1.0);
                         let pPos = p.xyz / p.w;
                         let sUV = vec2f(pPos.x, -pPos.y) * 0.5 + 0.5;
                         
                         let sDepth = textureSampleLevel(depthTex, depthSamp, sUV, 0);
                         let sViewPos = getViewPosition(sUV, sDepth);
                         
                         if (currentPos.z < sViewPos.z) {
                             // Still behind surface, move back
                             currentPos -= reflectionDir * halfStep;
                         }
                         // Else in front, move forward (implicit in loop start)
                     }
                     
                     // Final UV
                     let finalP = scene.projectionMatrix * vec4f(currentPos, 1.0);
                     let finalPos = finalP.xyz / finalP.w;
                     hitUV = vec2f(finalPos.x, -finalPos.y) * 0.5 + 0.5;
                     
                     break; 
                 }
             }
             
             if (hit) {
                 // Edge Fade
                 let x = 2.0 * abs(hitUV.x - 0.5);
                 let y = 2.0 * abs(hitUV.y - 0.5);
                 var screenFade = 1.0 - max(x, y);
                 screenFade = clamp(screenFade * 10.0, 0.0, 1.0);
                 
                 // Roughness Fade
                 let roughnessFade = 1.0 - roughness;
                 
                 let color = textureSampleLevel(sceneColorTex, samp, hitUV, 0.0).rgb;
                 
                 // Mix with Metallic/Fresnel approximation
                 let reflectionIntensity = 0.5 * screenFade * roughnessFade; 
                 
                 return vec4f(color * reflectionIntensity, 1.0);
             }
             
             return vec4f(0.0);
        }
      `;
    const compositeFS = `
        @group(0) @binding(0) var ssrTex : texture_2d<f32>;
        @group(0) @binding(1) var samp : sampler;
        
        @fragment
        fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {
            let ssr = textureSample(ssrTex, samp, uv);
            return ssr; // Additive blend will add this to target
        }
      `;
    const primitive = { topology: "triangle-list" };
    const targets = [{ format: "rgba16float" }];
    const compositeTargets = [{
      format: "rgba16float",
      blend: {
        color: { srcFactor: "one", dstFactor: "one", operation: "add" },
        alpha: { srcFactor: "one", dstFactor: "one", operation: "add" }
      }
    }];
    this.tracePipeline = device.createRenderPipeline({
      label: "SSR Trace Pipeline",
      layout: device.createPipelineLayout({ bindGroupLayouts: [this.bindGroupLayout] }),
      vertex: { module: createShaderModuleSafe(device, { code: fullscreenVS }), entryPoint: "vs_main" },
      fragment: { module: createShaderModuleSafe(device, { code: traceFS }), entryPoint: "fs_main", targets },
      primitive
    });
    this.compositePipeline = device.createRenderPipeline({
      label: "SSR Composite Pipeline",
      layout: device.createPipelineLayout({ bindGroupLayouts: [this.compositeLayout] }),
      vertex: { module: createShaderModuleSafe(device, { code: fullscreenVS }), entryPoint: "vs_main" },
      fragment: { module: createShaderModuleSafe(device, { code: compositeFS }), entryPoint: "fs_main", targets: compositeTargets },
      primitive
    });
  }
}

// ../../src/core/renderer/shaders/AtmosphereCompute.ts
var Uniforms = `
@group(0) @binding(0) var<uniform> atmosphere : AtmosphereUniforms;
`;
var AtmosphereTransmittanceCompute = `
${AtmosphereCommonWGSL}
${Uniforms}

@group(0) @binding(1) var transmittance_write : texture_storage_2d<rgba32float, write>;

@compute @workgroup_size(8, 8, 1)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    if (global_id.x >= u32(TRANSMITTANCE_TEXTURE_WIDTH) || global_id.y >= u32(TRANSMITTANCE_TEXTURE_HEIGHT)) {
        return;
    }
    
    let result = ComputeTransmittanceToTopAtmosphereBoundaryTexture(global_id);
    textureStore(transmittance_write, vec2<i32>(global_id.xy), vec4f(result, 1.0));
}
`;
var AtmosphereSingleScatteringCompute = `
${AtmosphereCommonWGSL}
${Uniforms}

@group(0) @binding(1) var transmittance_read : texture_2d<f32>;
@group(0) @binding(2) var transmittance_sampler : sampler;
@group(0) @binding(3) var scattering_write : texture_storage_3d<rgba32float, write>;

@compute @workgroup_size(8, 8, 1)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    // Dimensions: 256 x 128 x 32
    if (global_id.x >= 256u || global_id.y >= 128u || global_id.z >= 32u) {
        return;
    }
    
    let result = ComputeSingleScatteringTexture(transmittance_read, transmittance_sampler, vec3f(f32(global_id.x) + 0.5, f32(global_id.y) + 0.5, f32(global_id.z) + 0.5));
    textureStore(scattering_write, vec3<i32>(global_id.xyz), result);
}
`;

// ../../src/core/renderer/shaders/AtmosphereRaymarch.ts
var AtmosphereRaymarch = `
${AtmosphereCommonWGSL}

@group(0) @binding(0) var<uniform> atmosphere : AtmosphereUniforms;

// Bindings
// Group 0: Uniforms (Atmosphere)
// Group 1: Textures
@group(1) @binding(0) var transmittance_tex : texture_2d<f32>;
@group(1) @binding(1) var transmittance_samp : sampler;
@group(1) @binding(2) var multiscattering_tex : texture_2d<f32>;
@group(1) @binding(3) var multiscattering_samp : sampler;

// Output
@group(2) @binding(0) var output_tex : texture_storage_2d<rgba32float, write>;

// --- Raymarching Constants ---
const MULTISCAT_STEPS = 20.0;
const SKYVIEW_STEPS = 30.0;

struct MediumSampleRGB {
    scattering: vec3f,
    absorption: vec3f,
    extinction: vec3f,
    scatteringMie: vec3f,
    absorptionMie: vec3f,
    extinctionMie: vec3f,
    scatteringRay: vec3f,
    absorptionRay: f32, 
    extinctionRay: vec3f,
    scatteringOzo: f32,
    absorptionOzo: vec3f,
    extinctionOzo: vec3f,
    albedo: vec3f,
}

fn sampleMediumRGB(WorldPos: vec3f) -> MediumSampleRGB {
    let viewHeight = length(WorldPos) - atmosphere.bottom_radius;
    let densityMie = GetProfileDensity(GetMieDensityProfile(), viewHeight);
    let densityRay = GetProfileDensity(GetRayleighDensityProfile(), viewHeight);
    let densityOzo = GetProfileDensity(GetAbsorptionDensityProfile(), viewHeight); // Absorption profile handles ozone layers

    var s: MediumSampleRGB;
    s.scatteringMie = densityMie * atmosphere.mie_scattering;
    s.absorptionMie = densityMie * atmosphere.mie_absorption;
    s.extinctionMie = densityMie * atmosphere.mie_extinction;
    
    s.scatteringRay = densityRay * atmosphere.rayleigh_scattering;
    s.absorptionRay = 0.0;
    s.extinctionRay = s.scatteringRay; 
    
    s.scatteringOzo = 0.0;
    s.absorptionOzo = densityOzo * atmosphere.absorption_extinction;
    s.extinctionOzo = s.absorptionOzo;
    
    s.scattering = s.scatteringMie + s.scatteringRay;
    s.absorption = s.absorptionMie + s.absorptionOzo;
    s.extinction = s.extinctionMie + s.extinctionRay + s.extinctionOzo;
    
    // Albedo
    s.albedo = s.scattering / max(vec3f(0.001), s.extinction);
    
    return s;
}

// Raymarching for both MultiScattering and SkyView
// Modes:
// 0: SkyView (Full)
// 1: MultiScattering (Isotropic Phase, 2nd Order)
fn IntegrateScatteredLuminance(
    pixPos: vec2f,
    WorldPos: vec3f,
    WorldDir: vec3f,
    SunDir: vec3f,
    sampleCount: f32,
    variableSampleCount: bool,
    useMiePhase: bool,
    mode: u32
) -> vec3f {
    var L = vec3f(0.0);
    var throughput = vec3f(1.0);
    var opticalDepth = vec3f(0.0);
    var t = 0.0;
    var tPrev = 0.0;

    // Intersections
    let tBottom = raySphereIntersectNearest(WorldPos, WorldDir, vec3f(0.0), atmosphere.bottom_radius);
    let tTop = raySphereIntersectNearest(WorldPos, WorldDir, vec3f(0.0), atmosphere.top_radius);

    var tMax = 0.0;
    var hitsGround = false;
    if (tBottom < 0.0) {
        if (tTop < 0.0) { return vec3f(0.0); }
        tMax = tTop;
    } else {
        if (tTop > 0.0) {
            tMax = min(tTop, tBottom);
            hitsGround = tBottom < tTop;
        }
    }

    let dt = tMax / sampleCount;

    let cosTheta = dot(WorldDir, SunDir);

    // Use Cornette-Shanks for more accurate Mie phase (better sunset colors)
    let miePhaseValue = CornetteShanksPhaseFunction(atmosphere.mie_phase_function_g, -cosTheta);
    let rayleighPhaseValue = RayleighPhaseFunction(cosTheta);
    let uniformPhase = 1.0 / (4.0 * PI);

    // Global illuminance factor
    let globalL = vec3f(1.0);

    // Track accumulated optical depth for ground contribution
    var accumulatedOpticalDepth = vec3f(0.0);

    for (var s = 0.0; s < sampleCount; s += 1.0) {
        let newT = tMax * (s + 0.3) / sampleCount; // SampleSegmentT = 0.3
        let dt_step = newT - t;
        t = newT;

        let P = WorldPos + t * WorldDir;
        let medium = sampleMediumRGB(P);
        let sampleOpticalDepth = medium.extinction * dt_step;
        let sampleTransmittance = exp(-sampleOpticalDepth);
        accumulatedOpticalDepth += sampleOpticalDepth;

        let pHeight = length(P);
        let upVector = P / pHeight;
        let sunZenithCosAngle = dot(SunDir, upVector);
        let uv = GetTransmittanceTextureUvFromRMu(pHeight, sunZenithCosAngle);
        let transmittanceToSun = textureSampleLevel(transmittance_tex, transmittance_samp, uv, 0.0).rgb;

        var phaseTimesScattering = vec3f(0.0);
        if (useMiePhase) {
            phaseTimesScattering = medium.scatteringMie * miePhaseValue + medium.scatteringRay * rayleighPhaseValue;
        } else {
            phaseTimesScattering = medium.scattering * uniformPhase;
        }

        // Multi-scattering (Approximation from LUT)
        // If mode == 1, we are computing the LUT, so we don't sample it (2nd order only).
        // If mode == 0, we sample it.
        var multiScatteredLuminance = vec3f(0.0);
        if (mode == 0u) {
             let ms_uv = vec2f(fromUnitToSubUvs(sunZenithCosAngle * 0.5 + 0.5, 32.0),
                               fromUnitToSubUvs((pHeight - atmosphere.bottom_radius) / (atmosphere.top_radius - atmosphere.bottom_radius), 32.0));
             multiScatteredLuminance = textureSampleLevel(multiscattering_tex, multiscattering_samp, ms_uv, 0.0).rgb;
        }

        // Earth Shadow (Simple check)
        let tEarth = raySphereIntersectNearest(P, SunDir, vec3f(0.0), atmosphere.bottom_radius);
        let earthShadow = select(1.0, 0.0, tEarth >= 0.0);

        let S = globalL * (earthShadow * transmittanceToSun * phaseTimesScattering + multiScatteredLuminance * medium.scattering);

        // Integrate using improved numerical integration
        // This handles the case when extinction approaches zero more stably
        let extinctionMag = max(0.0001, (medium.extinction.r + medium.extinction.g + medium.extinction.b) / 3.0);
        let Sint = (S - S * sampleTransmittance) / max(medium.extinction, vec3f(0.0001));
        L += throughput * Sint;
        throughput *= sampleTransmittance;

        tPrev = t;
    }

    // If ground hit, add ground reflection with improved lighting
    if (mode == 0u && hitsGround && tBottom > 0.0) {
        let P = WorldPos + tBottom * WorldDir;
        let pHeight = length(P);
        let upVector = P / pHeight;
        let sunZenithCosAngle = dot(SunDir, upVector);
        let uv = GetTransmittanceTextureUvFromRMu(pHeight, sunZenithCosAngle);
        let transmittanceToSun = textureSampleLevel(transmittance_tex, transmittance_samp, uv, 0.0).rgb;

        // Direct sun contribution
        let NdotL = max(0.0, dot(upVector, SunDir));
        let directGroundLight = transmittanceToSun * NdotL;

        // Multi-scattering contribution to ground (ambient sky light on ground)
        let ms_uv = vec2f(fromUnitToSubUvs(sunZenithCosAngle * 0.5 + 0.5, 32.0),
                          fromUnitToSubUvs(0.0, 32.0)); // At ground level
        let groundMultiScatter = textureSampleLevel(multiscattering_tex, multiscattering_samp, ms_uv, 0.0).rgb;

        // Combine direct and ambient ground lighting
        let groundIrradiance = directGroundLight + groundMultiScatter * 0.5;

        // Lambertian reflection with proper normalization
        L += globalL * groundIrradiance * throughput * atmosphere.ground_albedo / PI;
    }

    // For multi-scattering LUT, include ground contribution
    if (mode == 1u) {
        // Add ground-reflected contribution to multi-scattering
        // This creates realistic sky brightening from ground bounce
        let groundNormal = vec3f(0.0, 1.0, 0.0);
        let groundSunCos = max(0.0, dot(groundNormal, SunDir));
        let groundUv = GetTransmittanceTextureUvFromRMu(atmosphere.bottom_radius, dot(groundNormal, SunDir));
        let groundTransmittance = textureSampleLevel(transmittance_tex, transmittance_samp, groundUv, 0.0).rgb;

        // Ground contribution (isotropic reflection weighted by ground albedo)
        let groundContrib = atmosphere.ground_albedo * groundTransmittance * groundSunCos * throughput * 0.5;
        L += groundContrib;

        return L * 4.0 * PI; // Normalize for isotropic phase integration
    }

    return L;
}

// Compute Shaders

// MultiScattering LUT (32x32)
// Dispatch (32, 32, 1)
@compute @workgroup_size(1, 1, 1)
fn computeMultiScattering(@builtin(global_invocation_id) id: vec3u) {
    let size = vec2f(32.0, 32.0);
    let uv = (vec2f(id.xy) + 0.5) / size;
    
    let cosSunZenithAngle = uv.x * 2.0 - 1.0;
    let sunDir = vec3f(0.0, sqrt(clamp(1.0 - cosSunZenithAngle * cosSunZenithAngle, 0.0, 1.0)), cosSunZenithAngle);
    
    let viewHeight = atmosphere.bottom_radius + uv.y * (atmosphere.top_radius - atmosphere.bottom_radius);
    
    let worldPos = vec3f(0.0, 0.0, viewHeight);
    let worldDir = vec3f(0.0, 0.0, 1.0); // Zenital view for 2nd order integration
    
    // We actually need to integrate over the sphere. The reference uses 64 threads (Z) to integrate.
    // Simplifying: Just raymarch Up? No, 2nd order is isotropic approximation.
    // For simplicity in Phase 3, I'll assume we can skip complex integration and just sample Up?
    // Reference NewMultiScattCS integrates 64 directions.
    // Let's implement a simplified version: sample 20 directions? Or just use Isotropic assumption?
    // If we assume isotropic, gathering from all directions = integrating uniform phase.
    
    // Let's stick to simple raymarch Up for now, scaling by geometric factor?
    // Actually, MultiScat LUT is about transfer factor.
    // Let's leave MultiScat basic implementation: Raymarch Up.
    
    let L = IntegrateScatteredLuminance(uv, worldPos, worldDir, sunDir, 20.0, false, false, 1u);
    
    // Store
    textureStore(output_tex, vec2i(id.xy), vec4f(L, 1.0));
}

    // SkyView LUT (192x108)

// Dispatch (192, 108, 1)

@compute @workgroup_size(8, 8, 1)

fn computeSkyView(@builtin(global_invocation_id) id: vec3u) {

    if (id.x >= 192u || id.y >= 108u) { return; }

    

    let size = vec2f(192.0, 108.0);

    let pixPos = vec2f(id.xy) + 0.5;

    let uv = pixPos / size;



    // We assume the LUT is generated for a camera at (0, viewHeight, 0) relative to planet center

    // But we need to handle the actual relative orientation of Sun vs Camera.

    // The LUT parameterizes the sky relative to Zenith and Sun.

    // So we can simulate a canonical camera frame where Up is Z (or Y), and Sun is in XZ plane?



    // Compute view height (distance from planet center)
    // Clamp to minimum of bottomRadius + 10m to prevent math issues when camera is underground
    let rawViewHeight = length(atmosphere.camera_position + vec3f(0.0, atmosphere.bottom_radius, 0.0));
    let viewHeight = max(rawViewHeight, atmosphere.bottom_radius + 10.0);

    

    let worldPos = vec3f(0.0, viewHeight, 0.0); // Canonical Up = Y

    

    let params = UvToSkyViewLutParams(uv, viewHeight);

    let viewZenithCosAngle = params.x;

    let lightViewCosAngle = params.y;

    

    // Construct SunDir in this canonical frame
    // Up is (0, 1, 0).
    let upVector = vec3f(0.0, 1.0, 0.0);
    
    // Actual Sun Zenith (from Uniforms)
    let actualSunDir = normalize(atmosphere.sun_direction);
    
    let sunZenithCosAngle = dot(upVector, actualSunDir);
    let sunDirLocal = normalize(vec3f(sqrt(max(0.0, 1.0 - sunZenithCosAngle * sunZenithCosAngle)), sunZenithCosAngle, 0.0));
    
    let viewZenithSinAngle = sqrt(max(0.0, 1.0 - viewZenithCosAngle * viewZenithCosAngle));
    
    let worldDir = normalize(vec3f(
        viewZenithSinAngle * lightViewCosAngle,
        viewZenithCosAngle,
        viewZenithSinAngle * sqrt(max(0.0, 1.0 - lightViewCosAngle * lightViewCosAngle))
    ));
    
    let L = IntegrateScatteredLuminance(pixPos, worldPos, worldDir, sunDirLocal, SKYVIEW_STEPS, true, true, 0u);
    
    textureStore(output_tex, vec2i(id.xy), vec4f(L, 1.0));
}



`;

// ../../src/core/renderer/shaders/CloudNoiseCompute.ts
var CloudNoiseCompute = `
// Enhanced Tiling 3D Cloud Noise Generator
// Stores: R=base shape, G=detail erosion, B=curl/wispy, A=coverage variation

@group(0) @binding(0) var noiseTexture : texture_storage_3d<rgba8unorm, write>;

// High quality hash function
fn hash31(p: vec3f) -> f32 {
    var p3 = fract(p * 0.1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

fn hash33(p: vec3f) -> vec3f {
    var p3 = fract(p * vec3f(0.1031, 0.1030, 0.0973));
    p3 += dot(p3, p3.yxz + 33.33);
    return fract((p3.xxy + p3.yxx) * p3.zyx);
}

// Value Noise with quintic interpolation (smoother than cubic)
fn noise(x: vec3f, period: f32) -> f32 {
    let i = floor(x);
    let f = fract(x);
    // Quintic interpolation for smoother gradients (reduces banding)
    let u = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);

    // Wrap grid coordinates for tiling
    let p000 = (i + vec3f(0,0,0)) % period;
    let p100 = (i + vec3f(1,0,0)) % period;
    let p010 = (i + vec3f(0,1,0)) % period;
    let p110 = (i + vec3f(1,1,0)) % period;
    let p001 = (i + vec3f(0,0,1)) % period;
    let p101 = (i + vec3f(1,0,1)) % period;
    let p011 = (i + vec3f(0,1,1)) % period;
    let p111 = (i + vec3f(1,1,1)) % period;

    return mix(mix(mix( hash31(p000), hash31(p100), u.x),
                   mix( hash31(p010), hash31(p110), u.x), u.y),
               mix(mix( hash31(p001), hash31(p101), u.x),
                   mix( hash31(p011), hash31(p111), u.x), u.y), u.z);
}

// Worley/Cellular noise for cloud edges
fn worley(x: vec3f, period: f32) -> f32 {
    let i = floor(x);
    let f = fract(x);

    var minDist = 1.0;

    for (var z = -1; z <= 1; z++) {
        for (var y = -1; y <= 1; y++) {
            for (var xx = -1; xx <= 1; xx++) {
                let neighbor = vec3f(f32(xx), f32(y), f32(z));
                let cellPos = (i + neighbor) % period;
                let point = hash33(cellPos);
                let diff = neighbor + point - f;
                let dist = dot(diff, diff);
                minDist = min(minDist, dist);
            }
        }
    }

    return sqrt(minDist);
}

// FBM (Fractal Brownian Motion) with persistence
fn fbm(p: vec3f, period: f32, octaves: i32) -> f32 {
    var value = 0.0;
    var amplitude = 0.5;
    var frequency = 1.0;
    var maxValue = 0.0;

    for (var i = 0; i < octaves; i++) {
        value += amplitude * noise(p * frequency, period * frequency);
        maxValue += amplitude;
        amplitude *= 0.5;
        frequency *= 2.0;
    }

    return value / maxValue;
}

// "Billowy" Noise for puffy cloud shapes
fn billowyNoise(x: vec3f, period: f32) -> f32 {
    let n = noise(x, period);
    return abs(n * 2.0 - 1.0);
}

// Ridged noise for wispy details
fn ridgedNoise(x: vec3f, period: f32) -> f32 {
    let n = noise(x, period);
    return 1.0 - abs(n * 2.0 - 1.0);
}

// Curl-like noise for wispy tendrils
fn curlNoise(p: vec3f, period: f32) -> f32 {
    let eps = 0.01;

    let n1 = noise(p + vec3f(eps, 0.0, 0.0), period);
    let n2 = noise(p - vec3f(eps, 0.0, 0.0), period);
    let n3 = noise(p + vec3f(0.0, eps, 0.0), period);
    let n4 = noise(p - vec3f(0.0, eps, 0.0), period);
    let n5 = noise(p + vec3f(0.0, 0.0, eps), period);
    let n6 = noise(p - vec3f(0.0, 0.0, eps), period);

    // Pseudo curl magnitude
    let dx = n1 - n2;
    let dy = n3 - n4;
    let dz = n5 - n6;

    return length(vec3f(dx, dy, dz)) * 10.0;
}

@compute @workgroup_size(8, 8, 4)
fn main(@builtin(global_invocation_id) global_id : vec3u) {
    let dims = vec3u(128, 128, 128);
    if (any(global_id >= dims)) { return; }

    // Normalized coordinates 0-1
    let uvw = vec3f(global_id) / vec3f(dims);

    // ============================================
    // R Channel: Base Cloud Shape (Low Frequency)
    // ============================================
    // Use Perlin-Worley combination for better cloud shapes
    let perlin = fbm(uvw * 4.0, 4.0, 4);
    let worleyVal = 1.0 - worley(uvw * 4.0, 4.0);

    // Remap Perlin-Worley: clouds have sharp edges from Worley, soft interiors from Perlin
    var baseShape = perlin * 0.625 + worleyVal * 0.375;

    // Add medium frequency detail
    baseShape = baseShape * 0.8 + fbm(uvw * 8.0, 8.0, 3) * 0.2;

    // Apply subtle shaping curve
    baseShape = smoothstep(0.25, 0.75, baseShape);

    // ============================================
    // G Channel: Detail/Erosion (High Frequency)
    // ============================================
    // High frequency billowy noise to erode cloud edges
    var detail = billowyNoise(uvw * 16.0, 16.0) * 0.5;
    detail += billowyNoise(uvw * 32.0, 32.0) * 0.35;
    detail += billowyNoise(uvw * 64.0, 64.0) * 0.15;

    // Add some Worley for edge definition
    let worleyDetail = 1.0 - worley(uvw * 16.0, 16.0);
    detail = detail * 0.7 + worleyDetail * 0.3;

    // ============================================
    // B Channel: Curl/Wispy Tendrils
    // ============================================
    var wispy = curlNoise(uvw * 8.0, 8.0);
    wispy += ridgedNoise(uvw * 24.0, 24.0) * 0.5;
    wispy = clamp(wispy, 0.0, 1.0);

    // ============================================
    // A Channel: Coverage Variation
    // ============================================
    // Large scale variation for cloud clusters
    var coverage = fbm(uvw * 2.0, 2.0, 3);
    coverage = smoothstep(0.3, 0.7, coverage);

    textureStore(noiseTexture, global_id, vec4f(baseShape, detail, wispy, coverage));
}
`;

// ../../src/core/renderer/AtmospherePass.ts
class AtmospherePass {
  transmittancePipeline = null;
  scatteringPipeline = null;
  multiScatteringPipeline = null;
  skyViewPipeline = null;
  cloudNoisePipeline = null;
  sampler = null;
  transmittanceTexture = null;
  scatteringTexture = null;
  multiScatteringTexture = null;
  irradianceTexture = null;
  skyViewTexture = null;
  cloudNoiseTexture = null;
  transmittanceBindGroup = null;
  scatteringBindGroup = null;
  cloudNoiseBindGroup = null;
  dirty = true;
  noiseDirty = true;
  TRANSMITTANCE_W = 256;
  TRANSMITTANCE_H = 64;
  SCATTERING_R = 32;
  SCATTERING_MU = 128;
  SCATTERING_MU_S = 32;
  SCATTERING_NU = 8;
  get SCATTERING_W() {
    return this.SCATTERING_NU * this.SCATTERING_MU_S;
  }
  get SCATTERING_H() {
    return this.SCATTERING_MU;
  }
  get SCATTERING_D() {
    return this.SCATTERING_R;
  }
  IRRADIANCE_W = 64;
  IRRADIANCE_H = 16;
  MULTISCAT_W = 32;
  MULTISCAT_H = 32;
  SKYVIEW_W = 192;
  SKYVIEW_H = 108;
  constructor() {}
  init(device, context, presentationFormat) {
    this.device = device;
    this.sampler = device.createSampler({
      minFilter: "nearest",
      magFilter: "nearest",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge",
      addressModeW: "clamp-to-edge"
    });
    this.transmittanceTexture = device.createTexture({
      label: "Transmittance LUT",
      size: [this.TRANSMITTANCE_W, this.TRANSMITTANCE_H, 1],
      format: "rgba32float",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING
    });
    this.scatteringTexture = device.createTexture({
      label: "Scattering LUT",
      size: [this.SCATTERING_W, this.SCATTERING_H, this.SCATTERING_D],
      dimension: "3d",
      format: "rgba32float",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING
    });
    this.multiScatteringTexture = device.createTexture({
      label: "MultiScattering LUT",
      size: [this.MULTISCAT_W, this.MULTISCAT_H, 1],
      format: "rgba32float",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING
    });
    this.irradianceTexture = device.createTexture({
      label: "Irradiance LUT",
      size: [this.IRRADIANCE_W, this.IRRADIANCE_H, 1],
      format: "rgba32float",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING
    });
    this.skyViewTexture = device.createTexture({
      label: "SkyView LUT",
      size: [this.SKYVIEW_W, this.SKYVIEW_H, 1],
      format: "rgba32float",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING
    });
    this.cloudNoiseTexture = device.createTexture({
      label: "Cloud Noise 3D",
      size: [128, 128, 128],
      dimension: "3d",
      format: "rgba8unorm",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING
    });
    this.placeholderTexture = device.createTexture({
      label: "Atmosphere Placeholder",
      size: [1, 1, 1],
      format: "rgba32float",
      usage: GPUTextureUsage.TEXTURE_BINDING
    });
    const transmittanceLayout = device.createBindGroupLayout({
      label: "Transmittance BG Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: "uniform" } },
        { binding: 1, visibility: GPUShaderStage.COMPUTE, storageTexture: { access: "write-only", format: "rgba32float", viewDimension: "2d" } }
      ]
    });
    const transmittancePipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [transmittanceLayout] });
    this.transmittancePipeline = device.createComputePipeline({
      label: "Atmosphere Transmittance Pipeline",
      layout: transmittancePipelineLayout,
      compute: { module: createShaderModuleSafe(device, { code: AtmosphereTransmittanceCompute }), entryPoint: "main" }
    });
    const scatteringLayout = device.createBindGroupLayout({
      label: "Atmosphere Scattering Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: "uniform" } },
        { binding: 1, visibility: GPUShaderStage.COMPUTE, texture: { sampleType: "unfilterable-float", viewDimension: "2d" } },
        { binding: 2, visibility: GPUShaderStage.COMPUTE, sampler: { type: "non-filtering" } },
        { binding: 3, visibility: GPUShaderStage.COMPUTE, storageTexture: { access: "write-only", format: "rgba32float", viewDimension: "3d" } }
      ]
    });
    const scatteringPipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [scatteringLayout] });
    this.scatteringPipeline = device.createComputePipeline({
      label: "Atmosphere Scattering Pipeline",
      layout: scatteringPipelineLayout,
      compute: { module: createShaderModuleSafe(device, { code: AtmosphereSingleScatteringCompute }), entryPoint: "main" }
    });
    const raymarchModule = createShaderModuleSafe(device, { code: AtmosphereRaymarch });
    const raymarchUniformsLayout = device.createBindGroupLayout({
      entries: [{ binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: "uniform" } }]
    });
    const raymarchTexturesLayout = device.createBindGroupLayout({
      entries: [
        { binding: 0, visibility: GPUShaderStage.COMPUTE, texture: { sampleType: "unfilterable-float", viewDimension: "2d" } },
        { binding: 1, visibility: GPUShaderStage.COMPUTE, sampler: { type: "non-filtering" } },
        { binding: 2, visibility: GPUShaderStage.COMPUTE, texture: { sampleType: "unfilterable-float", viewDimension: "2d" } },
        { binding: 3, visibility: GPUShaderStage.COMPUTE, sampler: { type: "non-filtering" } }
      ]
    });
    const msOutputLayout = device.createBindGroupLayout({
      entries: [{ binding: 0, visibility: GPUShaderStage.COMPUTE, storageTexture: { access: "write-only", format: "rgba32float", viewDimension: "2d" } }]
    });
    const msPipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [raymarchUniformsLayout, raymarchTexturesLayout, msOutputLayout] });
    this.multiScatteringPipeline = device.createComputePipeline({
      label: "Atmosphere MultiScattering Pipeline",
      layout: msPipelineLayout,
      compute: { module: raymarchModule, entryPoint: "computeMultiScattering" }
    });
    const skyViewPipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [raymarchUniformsLayout, raymarchTexturesLayout, msOutputLayout] });
    this.skyViewPipeline = device.createComputePipeline({
      label: "Atmosphere SkyView Pipeline",
      layout: skyViewPipelineLayout,
      compute: { module: raymarchModule, entryPoint: "computeSkyView" }
    });
    const cloudNoiseLayout = device.createBindGroupLayout({
      entries: [{ binding: 0, visibility: GPUShaderStage.COMPUTE, storageTexture: { access: "write-only", format: "rgba8unorm", viewDimension: "3d" } }]
    });
    const cloudNoisePipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [cloudNoiseLayout] });
    this.cloudNoisePipeline = device.createComputePipeline({
      label: "Cloud Noise Pipeline",
      layout: cloudNoisePipelineLayout,
      compute: { module: createShaderModuleSafe(device, { code: CloudNoiseCompute }), entryPoint: "main" }
    });
    this.dirty = true;
    this.noiseDirty = true;
  }
  multiScatteringBindGroup0 = null;
  multiScatteringBindGroup1 = null;
  multiScatteringBindGroup2 = null;
  skyViewBindGroup0 = null;
  skyViewBindGroup1 = null;
  skyViewBindGroup2 = null;
  device = null;
  placeholderTexture = null;
  time = 0;
  resize(width, height) {}
  updateUniforms(device, buffer, config2, camera) {
    const data = new Float32Array(128);
    let offset = 0;
    const setVec3 = (v) => {
      data[offset++] = v.x;
      data[offset++] = v.y;
      data[offset++] = v.z;
    };
    const setFloat = (f) => {
      data[offset++] = f;
    };
    setVec3(config2.sunIlluminance);
    setFloat(config2.sunDiskHalfAngle);
    setVec3(config2.absorptionExtinction);
    const maxSunZenith = Math.PI * 120 / 180;
    setFloat(Math.cos(maxSunZenith));
    setVec3(config2.rayleighScattering);
    setFloat(config2.miePhaseG);
    setVec3(config2.mieScattering);
    setFloat(config2.bottomRadius);
    setVec3(config2.mieExtinction);
    setFloat(config2.topRadius);
    setVec3(config2.mieAbsorption);
    setFloat(0);
    setVec3(config2.groundAlbedo);
    setFloat(0);
    setFloat(0);
    setFloat(0);
    setFloat(0);
    setFloat(0);
    setFloat(0);
    setFloat(0);
    setFloat(1);
    setFloat(config2.rayleighDensityExpScale);
    setFloat(0);
    setFloat(0);
    setFloat(0);
    setFloat(0);
    setFloat(0);
    setFloat(0);
    setFloat(0);
    setFloat(0);
    setFloat(0);
    setFloat(0);
    setFloat(1);
    setFloat(config2.mieDensityExpScale);
    setFloat(0);
    setFloat(0);
    setFloat(0);
    setFloat(0);
    setFloat(config2.absorptionDensity0LayerWidth);
    setFloat(0);
    setFloat(0);
    setFloat(config2.absorptionDensity0LinearTerm);
    setFloat(config2.absorptionDensity0ConstantTerm);
    setFloat(0);
    setFloat(0);
    setFloat(0);
    setFloat(config2.absorptionDensity1LinearTerm);
    setFloat(config2.absorptionDensity1ConstantTerm);
    setFloat(0);
    setFloat(0);
    setVec3(config2.sunDirection);
    setFloat(0);
    setVec3(camera);
    setFloat(0);
    setFloat(config2.sunDiskEnabled ? 1 : 0);
    setFloat(config2.sunDiskScale);
    setFloat(0);
    setFloat(0);
    setVec3(config2.moonDirection);
    setFloat(config2.moonEnabled ? 1 : 0);
    setFloat(config2.moonPhase);
    setFloat(config2.moonScale);
    setFloat(config2.moonAngularRadius);
    setFloat(0);
    setVec3(config2.moonColor);
    setFloat(0);
    setFloat(config2.starsEnabled ? 1 : 0);
    setFloat(config2.starsIntensity);
    setFloat(config2.starsTwinkle);
    setFloat(this.time);
    setFloat(config2.useCustomSkybox ? 1 : 0);
    setFloat(config2.customSkyboxBlend);
    setFloat(0);
    setFloat(0);
    setVec3(config2.cloudColor);
    setFloat(config2.cloudsEnabled ? 1 : 0);
    setVec3(config2.cloudWindDirection);
    setFloat(config2.cloudCoverage);
    setFloat(config2.cloudAltitude);
    setFloat(config2.cloudHeight);
    setFloat(config2.cloudDensity);
    setFloat(config2.cloudSpeed);
    const qualityMap = { low: 0, medium: 1, high: 2 };
    const uintView = new Uint32Array(data.buffer);
    uintView[offset] = qualityMap[config2.cloudQuality] ?? 2;
    offset += 4;
    device.queue.writeBuffer(buffer, 0, data);
  }
  execute(commandEncoder, context, globalResources) {
    if (!context.scene.atmosphere.enabled || !this.device)
      return;
    this.time += 0.016;
    const buffer = globalResources.atmosphereUniformsBuffer;
    if (!buffer)
      return;
    if (!this.transmittanceBindGroup && this.transmittancePipeline && this.scatteringPipeline && this.multiScatteringPipeline && this.skyViewPipeline && this.transmittanceTexture && this.scatteringTexture && this.multiScatteringTexture && this.skyViewTexture && this.placeholderTexture && this.sampler) {
      this.transmittanceBindGroup = this.device.createBindGroup({
        label: "Transmittance Bind Group",
        layout: this.transmittancePipeline.getBindGroupLayout(0),
        entries: [
          { binding: 0, resource: { buffer } },
          { binding: 1, resource: this.transmittanceTexture.createView() }
        ]
      });
      this.scatteringBindGroup = this.device.createBindGroup({
        label: "Scattering Bind Group",
        layout: this.scatteringPipeline.getBindGroupLayout(0),
        entries: [
          { binding: 0, resource: { buffer } },
          { binding: 1, resource: this.transmittanceTexture.createView() },
          { binding: 2, resource: this.sampler },
          { binding: 3, resource: this.scatteringTexture.createView() }
        ]
      });
      this.multiScatteringBindGroup0 = this.device.createBindGroup({
        label: "MultiScattering Bind Group",
        layout: this.multiScatteringPipeline.getBindGroupLayout(0),
        entries: [{ binding: 0, resource: { buffer } }]
      });
      this.multiScatteringBindGroup1 = this.device.createBindGroup({
        label: "MultiScat Texture Bind Group",
        layout: this.multiScatteringPipeline.getBindGroupLayout(1),
        entries: [
          { binding: 0, resource: this.transmittanceTexture.createView() },
          { binding: 1, resource: this.sampler },
          { binding: 2, resource: this.placeholderTexture.createView() },
          { binding: 3, resource: this.sampler }
        ]
      });
      this.multiScatteringBindGroup2 = this.device.createBindGroup({
        label: "MultiScat Output Bind Group",
        layout: this.multiScatteringPipeline.getBindGroupLayout(2),
        entries: [{ binding: 0, resource: this.multiScatteringTexture.createView() }]
      });
      this.skyViewBindGroup0 = this.device.createBindGroup({
        layout: this.skyViewPipeline.getBindGroupLayout(0),
        entries: [{ binding: 0, resource: { buffer } }]
      });
      this.skyViewBindGroup1 = this.device.createBindGroup({
        layout: this.skyViewPipeline.getBindGroupLayout(1),
        entries: [
          { binding: 0, resource: this.transmittanceTexture.createView() },
          { binding: 1, resource: this.sampler },
          { binding: 2, resource: this.multiScatteringTexture.createView() },
          { binding: 3, resource: this.sampler }
        ]
      });
      this.skyViewBindGroup2 = this.device.createBindGroup({
        layout: this.skyViewPipeline.getBindGroupLayout(2),
        entries: [{ binding: 0, resource: this.skyViewTexture.createView() }]
      });
      if (this.cloudNoisePipeline && this.cloudNoiseTexture) {
        this.cloudNoiseBindGroup = this.device.createBindGroup({
          layout: this.cloudNoisePipeline.getBindGroupLayout(0),
          entries: [{ binding: 0, resource: this.cloudNoiseTexture.createView() }]
        });
      }
    }
    this.updateUniforms(this.device, buffer, context.scene.atmosphere, context.camera.transform.position);
    if (this.noiseDirty && this.cloudNoisePipeline && this.cloudNoiseBindGroup) {
      console.log("AtmospherePass: Generating 3D Cloud Noise...");
      const pass = commandEncoder.beginComputePass({ label: "Cloud Noise Gen" });
      pass.setPipeline(this.cloudNoisePipeline);
      pass.setBindGroup(0, this.cloudNoiseBindGroup);
      pass.dispatchWorkgroups(128 / 8, 128 / 8, 128 / 4);
      pass.end();
      this.noiseDirty = false;
    }
    if (this.dirty) {
      console.log("AtmospherePass: Dispatching Compute Shaders (Dirty State)");
      if (this.transmittancePipeline && this.transmittanceBindGroup) {
        const pass = commandEncoder.beginComputePass({ label: "Atmosphere Transmittance Pass" });
        pass.setPipeline(this.transmittancePipeline);
        pass.setBindGroup(0, this.transmittanceBindGroup);
        pass.dispatchWorkgroups(Math.ceil(this.TRANSMITTANCE_W / 8), Math.ceil(this.TRANSMITTANCE_H / 8), 1);
        pass.end();
      }
      if (this.multiScatteringPipeline && this.multiScatteringBindGroup0 && this.multiScatteringBindGroup1 && this.multiScatteringBindGroup2) {
        const pass = commandEncoder.beginComputePass({ label: "Atmosphere MultiScattering Pass" });
        pass.setPipeline(this.multiScatteringPipeline);
        pass.setBindGroup(0, this.multiScatteringBindGroup0);
        pass.setBindGroup(1, this.multiScatteringBindGroup1);
        pass.setBindGroup(2, this.multiScatteringBindGroup2);
        pass.dispatchWorkgroups(Math.ceil(this.MULTISCAT_W / 1), Math.ceil(this.MULTISCAT_H / 1), 1);
        pass.end();
      }
      if (this.scatteringPipeline && this.scatteringBindGroup) {
        const pass = commandEncoder.beginComputePass({ label: "Atmosphere Scattering Pass" });
        pass.setPipeline(this.scatteringPipeline);
        pass.setBindGroup(0, this.scatteringBindGroup);
        pass.dispatchWorkgroups(Math.ceil(this.SCATTERING_W / 8), Math.ceil(this.SCATTERING_H / 8), Math.ceil(this.SCATTERING_D / 1));
        pass.end();
      }
      this.dirty = false;
    }
    if (this.skyViewPipeline && this.skyViewBindGroup0 && this.skyViewBindGroup1 && this.skyViewBindGroup2) {
      const pass = commandEncoder.beginComputePass({ label: "Atmosphere SkyView Pass" });
      pass.setPipeline(this.skyViewPipeline);
      pass.setBindGroup(0, this.skyViewBindGroup0);
      pass.setBindGroup(1, this.skyViewBindGroup1);
      pass.setBindGroup(2, this.skyViewBindGroup2);
      pass.dispatchWorkgroups(Math.ceil(this.SKYVIEW_W / 8), Math.ceil(this.SKYVIEW_H / 8), 1);
      pass.end();
    }
  }
}

// ../../src/core/renderer/VelocityFromDepthPass.ts
class VelocityFromDepthPass {
  gBuffer;
  pipeline = null;
  bindGroupLayout = null;
  device = null;
  constructor(gBuffer) {
    this.gBuffer = gBuffer;
  }
  init(device, context, presentationFormat) {
    this.device = device;
  }
  resize(width, height) {}
  execute(commandEncoder, context, globalResources) {
    if (!this.gBuffer.useComputedVelocity)
      return;
    if (!this.device || !this.gBuffer.depthTexture || !this.gBuffer.velocityTexture)
      return;
    if (!this.pipeline) {
      this.createPipeline(this.device, globalResources);
    }
    const bindGroup = this.device.createBindGroup({
      label: "Velocity From Depth Bind Group",
      layout: this.bindGroupLayout,
      entries: [
        { binding: 0, resource: { buffer: globalResources.sceneUniforms.buffer } },
        { binding: 1, resource: this.gBuffer.depthTexture.createView() }
      ]
    });
    const passDescriptor = {
      colorAttachments: [
        {
          view: this.gBuffer.velocityTexture.createView(),
          clearValue: { r: 0, g: 0, b: 0, a: 0 },
          loadOp: "clear",
          storeOp: "store"
        }
      ]
    };
    const pass = commandEncoder.beginRenderPass(passDescriptor);
    pass.setPipeline(this.pipeline);
    pass.setBindGroup(0, bindGroup);
    pass.draw(3);
    pass.end();
  }
  createPipeline(device, globalResources) {
    const code = `
      struct SceneUniforms {
        viewMatrix : mat4x4<f32>,
        projectionMatrix : mat4x4<f32>,
        lightViewProj : mat4x4<f32>,
        prevViewProj : mat4x4<f32>,
        inverseProjectionMatrix : mat4x4<f32>,
        cameraPosition : vec3<f32>,
        time : f32,
        lightCount : u32,
        debugMode : u32,
        shadowsEnabled : u32,
        environmentIntensity : f32,
      }

      @group(0) @binding(0) var<uniform> scene : SceneUniforms;
      @group(0) @binding(1) var depthTex : texture_depth_2d;

      struct VertexOutput {
        @builtin(position) position : vec4f,
        @location(0) uv : vec2f,
        @location(1) @interpolate(flat) invViewProj0 : vec4f,
        @location(2) @interpolate(flat) invViewProj1 : vec4f,
        @location(3) @interpolate(flat) invViewProj2 : vec4f,
        @location(4) @interpolate(flat) invViewProj3 : vec4f,
      }

      // Invert 4x4 matrix (for inverse view-projection)
      fn inverse(m: mat4x4f) -> mat4x4f {
        let a00 = m[0][0]; let a01 = m[0][1]; let a02 = m[0][2]; let a03 = m[0][3];
        let a10 = m[1][0]; let a11 = m[1][1]; let a12 = m[1][2]; let a13 = m[1][3];
        let a20 = m[2][0]; let a21 = m[2][1]; let a22 = m[2][2]; let a23 = m[2][3];
        let a30 = m[3][0]; let a31 = m[3][1]; let a32 = m[3][2]; let a33 = m[3][3];

        let b00 = a00 * a11 - a01 * a10;
        let b01 = a00 * a12 - a02 * a10;
        let b02 = a00 * a13 - a03 * a10;
        let b03 = a01 * a12 - a02 * a11;
        let b04 = a01 * a13 - a03 * a11;
        let b05 = a02 * a13 - a03 * a12;
        let b06 = a20 * a31 - a21 * a30;
        let b07 = a20 * a32 - a22 * a30;
        let b08 = a20 * a33 - a23 * a30;
        let b09 = a21 * a32 - a22 * a31;
        let b10 = a21 * a33 - a23 * a31;
        let b11 = a22 * a33 - a23 * a32;

        let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        let invDet = 1.0 / det;

        return mat4x4f(
          vec4f((a11 * b11 - a12 * b10 + a13 * b09) * invDet, (a02 * b10 - a01 * b11 - a03 * b09) * invDet, (a31 * b05 - a32 * b04 + a33 * b03) * invDet, (a22 * b04 - a21 * b05 - a23 * b03) * invDet),
          vec4f((a12 * b08 - a10 * b11 - a13 * b07) * invDet, (a00 * b11 - a02 * b08 + a03 * b07) * invDet, (a32 * b02 - a30 * b05 - a33 * b01) * invDet, (a20 * b05 - a22 * b02 + a23 * b01) * invDet),
          vec4f((a10 * b10 - a11 * b08 + a13 * b06) * invDet, (a01 * b08 - a00 * b10 - a03 * b06) * invDet, (a30 * b04 - a31 * b02 + a33 * b00) * invDet, (a21 * b02 - a20 * b04 - a23 * b00) * invDet),
          vec4f((a11 * b07 - a10 * b09 - a12 * b06) * invDet, (a00 * b09 - a01 * b07 + a02 * b06) * invDet, (a31 * b01 - a30 * b03 - a32 * b00) * invDet, (a20 * b03 - a21 * b01 + a22 * b00) * invDet)
        );
      }

      @vertex
      fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
        var output : VertexOutput;

        // Full-screen triangle
        let x = f32((vertexIndex << 1u) & 2u);
        let y = f32(vertexIndex & 2u);
        output.position = vec4f(x * 2.0 - 1.0, y * 2.0 - 1.0, 0.0, 1.0);
        output.uv = vec2f(x, 1.0 - y);

        // Compute inverse view-projection matrix
        let viewProj = scene.projectionMatrix * scene.viewMatrix;
        let invViewProj = inverse(viewProj);
        output.invViewProj0 = invViewProj[0];
        output.invViewProj1 = invViewProj[1];
        output.invViewProj2 = invViewProj[2];
        output.invViewProj3 = invViewProj[3];

        return output;
      }

      fn worldFromDepth(depth: f32, uv: vec2f, invViewProj: mat4x4f) -> vec3f {
        let ndc = vec2f(uv.x * 2.0 - 1.0, (1.0 - uv.y) * 2.0 - 1.0);
        let clipPos = vec4f(ndc, depth, 1.0);
        let worldPos = invViewProj * clipPos;
        return worldPos.xyz / worldPos.w;
      }

      @fragment
      fn fs_main(
        @location(0) uv : vec2f,
        @location(1) @interpolate(flat) invViewProj0: vec4f,
        @location(2) @interpolate(flat) invViewProj1: vec4f,
        @location(3) @interpolate(flat) invViewProj2: vec4f,
        @location(4) @interpolate(flat) invViewProj3: vec4f
      ) -> @location(0) vec2f {
        let invViewProj = mat4x4f(invViewProj0, invViewProj1, invViewProj2, invViewProj3);

        // Sample depth
        let texSize = vec2f(textureDimensions(depthTex));
        let fragCoord = uv * texSize;
        let depth = textureLoad(depthTex, vec2i(floor(fragCoord)), 0);

        // Skip sky pixels (depth = 1.0)
        if (depth >= 1.0) {
          return vec2f(0.0, 0.0);
        }

        // Reconstruct world position from depth
        let worldPos = worldFromDepth(depth, uv, invViewProj);

        // Project to previous frame's clip space
        let prevClip = scene.prevViewProj * vec4f(worldPos, 1.0);
        let prevNDC = prevClip.xy / prevClip.w;

        // Current NDC
        let currentNDC = vec2f(uv.x * 2.0 - 1.0, (1.0 - uv.y) * 2.0 - 1.0);

        // Velocity = current - previous (in NDC space, scaled to 0.5)
        let velocity = (currentNDC - prevNDC) * 0.5;

        // Invert Y to match texture UV space (Y down)
        return vec2f(velocity.x, -velocity.y);
      }
    `;
    const module = createShaderModuleSafe(device, {
      label: "Velocity From Depth Shader",
      code
    });
    this.bindGroupLayout = device.createBindGroupLayout({
      label: "Velocity From Depth Bind Group Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "depth" } }
      ]
    });
    const pipelineLayout = device.createPipelineLayout({
      label: "Velocity From Depth Pipeline Layout",
      bindGroupLayouts: [this.bindGroupLayout]
    });
    this.pipeline = device.createRenderPipeline({
      label: "Velocity From Depth Pipeline",
      layout: pipelineLayout,
      vertex: {
        module,
        entryPoint: "vs_main"
      },
      fragment: {
        module,
        entryPoint: "fs_main",
        targets: [{ format: "rg16float" }]
      },
      primitive: {
        topology: "triangle-list"
      }
    });
  }
}

// ../../src/core/renderer/DepthOfFieldPass.ts
class DepthOfFieldPass {
  gBuffer;
  device = null;
  width = 0;
  height = 0;
  cocPipeline = null;
  blurPipeline = null;
  compositePipeline = null;
  bindGroupLayout = null;
  sampler = null;
  cocTexture = null;
  blurTextureA = null;
  blurTextureB = null;
  inputTexture = null;
  enabled = false;
  focusDistance = 10;
  cocScale = 0.01;
  maxBlur = 8;
  intensity = 1;
  samples = 32;
  bokehShape = "circle";
  nearPlane = 0.1;
  farPlane = 1000;
  constructor(gBuffer) {
    this.gBuffer = gBuffer;
  }
  setInputTexture(texture) {
    this.inputTexture = texture;
  }
  getOutputTexture() {
    return this.blurTextureA;
  }
  init(device, context, presentationFormat) {
    this.device = device;
    this.sampler = device.createSampler({
      minFilter: "linear",
      magFilter: "linear",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    });
    this.bindGroupLayout = device.createBindGroupLayout({
      label: "DOF Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "depth" } },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, sampler: {} },
        { binding: 3, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
        { binding: 4, visibility: GPUShaderStage.FRAGMENT, texture: {} }
      ]
    });
    this.createPipelines(device);
  }
  resize(width, height) {
    if (width <= 0 || height <= 0)
      return;
    this.width = width;
    this.height = height;
    if (this.device) {
      this.destroyTextures();
      this.createTextures(this.device);
    }
  }
  destroyTextures() {
    if (this.cocTexture)
      this.cocTexture.destroy();
    if (this.blurTextureA)
      this.blurTextureA.destroy();
    if (this.blurTextureB)
      this.blurTextureB.destroy();
  }
  createTextures(device) {
    this.cocTexture = device.createTexture({
      label: "DOF CoC",
      size: [this.width, this.height],
      format: "r16float",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT
    });
    const blurDesc = {
      label: "DOF Blur",
      size: [this.width, this.height],
      format: "rgba16float",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT
    };
    this.blurTextureA = device.createTexture(blurDesc);
    this.blurTextureB = device.createTexture(blurDesc);
  }
  execute(commandEncoder, context, globalResources) {
    if (!this.enabled)
      return;
    if (!this.device || !this.inputTexture || !this.cocTexture || !this.blurTextureA || !this.blurTextureB)
      return;
    if (!this.gBuffer.depthTexture)
      return;
    const camera = context.camera;
    this.focusDistance = camera.physicalCamera.focusDistance;
    this.cocScale = camera.getCoCScale() * camera.depthOfField.intensity;
    this.maxBlur = camera.depthOfField.maxBlur;
    this.intensity = camera.depthOfField.intensity;
    this.samples = camera.depthOfField.samples;
    this.bokehShape = camera.depthOfField.bokehShape;
    this.nearPlane = camera.near;
    this.farPlane = camera.far;
    const uniformData = new Float32Array([
      this.focusDistance,
      this.cocScale,
      this.maxBlur,
      this.intensity,
      this.nearPlane,
      this.farPlane,
      this.width,
      this.height,
      this.samples,
      this.bokehShape === "hexagon" ? 1 : 0,
      0,
      0
    ]);
    const uniformBuffer = this.device.createBuffer({
      size: 48,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
      mappedAtCreation: true
    });
    new Float32Array(uniformBuffer.getMappedRange()).set(uniformData);
    uniformBuffer.unmap();
    this.executeCoCPass(commandEncoder, uniformBuffer);
    this.executeBlurPass(commandEncoder, uniformBuffer, true);
    this.executeBlurPass(commandEncoder, uniformBuffer, false);
    this.executeCompositePass(commandEncoder, uniformBuffer);
  }
  executeCoCPass(commandEncoder, uniformBuffer) {
    if (!this.device || !this.cocPipeline || !this.inputTexture || !this.gBuffer.depthTexture || !this.cocTexture || !this.blurTextureA)
      return;
    const bindGroup = this.device.createBindGroup({
      layout: this.bindGroupLayout,
      entries: [
        { binding: 0, resource: this.inputTexture.createView() },
        { binding: 1, resource: this.gBuffer.depthTexture.createView() },
        { binding: 2, resource: this.sampler },
        { binding: 3, resource: { buffer: uniformBuffer } },
        { binding: 4, resource: this.blurTextureA.createView() }
      ]
    });
    const pass = commandEncoder.beginRenderPass({
      colorAttachments: [{
        view: this.cocTexture.createView(),
        loadOp: "clear",
        storeOp: "store"
      }]
    });
    pass.setPipeline(this.cocPipeline);
    pass.setBindGroup(0, bindGroup);
    pass.draw(3);
    pass.end();
  }
  executeBlurPass(commandEncoder, uniformBuffer, horizontal) {
    if (!this.device || !this.blurPipeline || !this.inputTexture || !this.cocTexture || !this.blurTextureA || !this.blurTextureB)
      return;
    const source = horizontal ? this.inputTexture : this.blurTextureA;
    const target = horizontal ? this.blurTextureA : this.blurTextureB;
    const dirData = new Float32Array([horizontal ? 1 : 0, horizontal ? 0 : 1]);
    const dirBuffer = this.device.createBuffer({
      size: 16,
      usage: GPUBufferUsage.UNIFORM,
      mappedAtCreation: true
    });
    new Float32Array(dirBuffer.getMappedRange()).set([...dirData, 0, 0]);
    dirBuffer.unmap();
    const bindGroup = this.device.createBindGroup({
      layout: this.bindGroupLayout,
      entries: [
        { binding: 0, resource: source.createView() },
        { binding: 1, resource: this.gBuffer.depthTexture.createView() },
        { binding: 2, resource: this.sampler },
        { binding: 3, resource: { buffer: uniformBuffer } },
        { binding: 4, resource: this.cocTexture.createView() }
      ]
    });
    const pass = commandEncoder.beginRenderPass({
      colorAttachments: [{
        view: target.createView(),
        loadOp: "clear",
        storeOp: "store"
      }]
    });
    pass.setPipeline(this.blurPipeline);
    pass.setBindGroup(0, bindGroup);
    pass.draw(3);
    pass.end();
  }
  executeCompositePass(commandEncoder, uniformBuffer) {
    if (!this.device || !this.compositePipeline || !this.inputTexture || !this.blurTextureB || !this.blurTextureA || !this.cocTexture)
      return;
    const bindGroup = this.device.createBindGroup({
      layout: this.bindGroupLayout,
      entries: [
        { binding: 0, resource: this.blurTextureB.createView() },
        { binding: 1, resource: this.gBuffer.depthTexture.createView() },
        { binding: 2, resource: this.sampler },
        { binding: 3, resource: { buffer: uniformBuffer } },
        { binding: 4, resource: this.cocTexture.createView() }
      ]
    });
    const pass = commandEncoder.beginRenderPass({
      colorAttachments: [{
        view: this.blurTextureA.createView(),
        loadOp: "clear",
        storeOp: "store"
      }]
    });
    pass.setPipeline(this.compositePipeline);
    pass.setBindGroup(0, bindGroup);
    pass.draw(3);
    pass.end();
  }
  createPipelines(device) {
    const fullscreenVS = `
      struct VertexOutput {
        @builtin(position) position : vec4f,
        @location(0) uv : vec2f,
      }
      @vertex
      fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
        var output : VertexOutput;
        let pos = array(vec2f(-1.0, -1.0), vec2f(3.0, -1.0), vec2f(-1.0, 3.0));
        let p = pos[vertexIndex];
        output.position = vec4f(p, 0.0, 1.0);
        output.uv = p * 0.5 + 0.5;
        output.uv.y = 1.0 - output.uv.y;
        return output;
      }
    `;
    const cocFS = `
      @group(0) @binding(0) var colorTex : texture_2d<f32>;
      @group(0) @binding(1) var depthTex : texture_depth_2d;
      @group(0) @binding(2) var samp : sampler;
      struct Params {
        focusDistance: f32,
        cocScale: f32,
        maxBlur: f32,
        intensity: f32,
        nearPlane: f32,
        farPlane: f32,
        width: f32,
        height: f32,
        samples: f32,
        bokehShape: f32,
        pad1: f32,
        pad2: f32,
      }
      @group(0) @binding(3) var<uniform> params : Params;

      fn linearizeDepth(depth: f32) -> f32 {
        let near = params.nearPlane;
        let far = params.farPlane;
        return near * far / (far - depth * (far - near));
      }

      @fragment
      fn fs_main(@location(0) uv : vec2f) -> @location(0) f32 {
        // Use textureLoad for depth texture (requires integer coordinates)
        let texCoord = vec2i(vec2f(params.width, params.height) * uv);
        let depth = textureLoad(depthTex, texCoord, 0);
        let linearDepth = linearizeDepth(depth);

        // Calculate signed CoC (negative = foreground blur, positive = background blur)
        let coc = (linearDepth - params.focusDistance) * params.cocScale;

        // Clamp to max blur radius
        return clamp(coc, -params.maxBlur, params.maxBlur);
      }
    `;
    const blurFS = `
      @group(0) @binding(0) var colorTex : texture_2d<f32>;
      @group(0) @binding(1) var depthTex : texture_depth_2d;
      @group(0) @binding(2) var samp : sampler;
      struct Params {
        focusDistance: f32,
        cocScale: f32,
        maxBlur: f32,
        intensity: f32,
        nearPlane: f32,
        farPlane: f32,
        width: f32,
        height: f32,
        samples: f32,
        bokehShape: f32,
        pad1: f32,
        pad2: f32,
      }
      @group(0) @binding(3) var<uniform> params : Params;
      @group(0) @binding(4) var cocTex : texture_2d<f32>;

      const PI = 3.14159265359;
      const GOLDEN_ANGLE = 2.39996323;

      @fragment
      fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {
        let centerColor = textureSampleLevel(colorTex, samp, uv, 0.0);
        let centerCoc = textureSampleLevel(cocTex, samp, uv, 0.0).r;
        let absCoC = abs(centerCoc);

        // Always compute blur, then blend based on CoC
        let texelSize = vec2f(1.0 / params.width, 1.0 / params.height);
        var color = vec3f(0.0);
        var totalWeight = 0.0;

        let sampleCount = i32(params.samples);

        // Disc blur using golden angle spiral
        for (var i = 0; i < sampleCount; i++) {
          let fi = f32(i);
          let r = sqrt(fi / f32(sampleCount)) * absCoC;
          let theta = fi * GOLDEN_ANGLE;

          let offset = vec2f(cos(theta), sin(theta)) * r * texelSize;
          let sampleUV = uv + offset;

          let sampleColor = textureSampleLevel(colorTex, samp, sampleUV, 0.0).rgb;
          let sampleCoc = textureSampleLevel(cocTex, samp, sampleUV, 0.0).r;

          // Weight based on CoC similarity and distance
          // Foreground samples should not bleed into background
          let cocDiff = sampleCoc - centerCoc;
          let weight = select(1.0, smoothstep(0.0, 2.0, abs(sampleCoc)), cocDiff < 0.0);

          color += sampleColor * weight;
          totalWeight += weight;
        }

        color /= max(totalWeight, 1.0);

        // Blend between original and blurred based on CoC magnitude
        let blendFactor = smoothstep(0.0, 1.0, absCoC);
        let finalColor = mix(centerColor.rgb, color, blendFactor);

        return vec4f(finalColor, 1.0);
      }
    `;
    const compositeFS = `
      @group(0) @binding(0) var blurredTex : texture_2d<f32>;
      @group(0) @binding(1) var depthTex : texture_depth_2d;
      @group(0) @binding(2) var samp : sampler;
      struct Params {
        focusDistance: f32,
        cocScale: f32,
        maxBlur: f32,
        intensity: f32,
        nearPlane: f32,
        farPlane: f32,
        width: f32,
        height: f32,
        samples: f32,
        bokehShape: f32,
        pad1: f32,
        pad2: f32,
      }
      @group(0) @binding(3) var<uniform> params : Params;
      @group(0) @binding(4) var cocTex : texture_2d<f32>;

      @fragment
      fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {
        let blurred = textureSampleLevel(blurredTex, samp, uv, 0.0).rgb;
        let coc = abs(textureSampleLevel(cocTex, samp, uv, 0.0).r);

        // Smooth transition based on CoC
        let blendFactor = smoothstep(0.0, 2.0, coc) * params.intensity;

        return vec4f(blurred, 1.0);
      }
    `;
    const primitive = { topology: "triangle-list" };
    const layout = device.createPipelineLayout({ bindGroupLayouts: [this.bindGroupLayout] });
    this.cocPipeline = device.createRenderPipeline({
      label: "DOF CoC Pipeline",
      layout,
      vertex: { module: createShaderModuleSafe(device, { code: fullscreenVS }), entryPoint: "vs_main" },
      fragment: { module: createShaderModuleSafe(device, { code: cocFS }), entryPoint: "fs_main", targets: [{ format: "r16float" }] },
      primitive
    });
    this.blurPipeline = device.createRenderPipeline({
      label: "DOF Blur Pipeline",
      layout,
      vertex: { module: createShaderModuleSafe(device, { code: fullscreenVS }), entryPoint: "vs_main" },
      fragment: { module: createShaderModuleSafe(device, { code: blurFS }), entryPoint: "fs_main", targets: [{ format: "rgba16float" }] },
      primitive
    });
    this.compositePipeline = device.createRenderPipeline({
      label: "DOF Composite Pipeline",
      layout,
      vertex: { module: createShaderModuleSafe(device, { code: fullscreenVS }), entryPoint: "vs_main" },
      fragment: { module: createShaderModuleSafe(device, { code: compositeFS }), entryPoint: "fs_main", targets: [{ format: "rgba16float" }] },
      primitive
    });
  }
}

// ../../src/core/renderer/MotionBlurPass.ts
class MotionBlurPass {
  gBuffer;
  device = null;
  width = 0;
  height = 0;
  pipeline = null;
  tileMaxPipeline = null;
  neighborMaxPipeline = null;
  bindGroupLayout = null;
  sampler = null;
  outputTexture = null;
  tileMaxTexture = null;
  neighborMaxTexture = null;
  inputTexture = null;
  enabled = false;
  intensity = 1;
  samples = 16;
  maxBlur = 32;
  shutterAngle = 0.5;
  tileSize = 20;
  constructor(gBuffer) {
    this.gBuffer = gBuffer;
  }
  setInputTexture(texture) {
    this.inputTexture = texture;
  }
  getOutputTexture() {
    return this.outputTexture;
  }
  init(device, context, presentationFormat) {
    this.device = device;
    this.sampler = device.createSampler({
      minFilter: "linear",
      magFilter: "linear",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    });
    this.bindGroupLayout = device.createBindGroupLayout({
      label: "Motion Blur Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "depth" } },
        { binding: 3, visibility: GPUShaderStage.FRAGMENT, sampler: {} },
        { binding: 4, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
        { binding: 5, visibility: GPUShaderStage.FRAGMENT, texture: {} }
      ]
    });
    this.createPipelines(device);
  }
  resize(width, height) {
    if (width <= 0 || height <= 0)
      return;
    this.width = width;
    this.height = height;
    if (this.device) {
      this.destroyTextures();
      this.createTextures(this.device);
    }
  }
  destroyTextures() {
    if (this.outputTexture)
      this.outputTexture.destroy();
    if (this.tileMaxTexture)
      this.tileMaxTexture.destroy();
    if (this.neighborMaxTexture)
      this.neighborMaxTexture.destroy();
  }
  createTextures(device) {
    this.outputTexture = device.createTexture({
      label: "Motion Blur Output",
      size: [this.width, this.height],
      format: "rgba16float",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT
    });
    const tileWidth = Math.ceil(this.width / this.tileSize);
    const tileHeight = Math.ceil(this.height / this.tileSize);
    this.tileMaxTexture = device.createTexture({
      label: "Motion Blur Tile Max",
      size: [tileWidth, tileHeight],
      format: "rg16float",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT
    });
    this.neighborMaxTexture = device.createTexture({
      label: "Motion Blur Neighbor Max",
      size: [tileWidth, tileHeight],
      format: "rg16float",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT
    });
  }
  execute(commandEncoder, context, globalResources) {
    if (!this.enabled)
      return;
    if (!this.device || !this.inputTexture || !this.outputTexture || !this.gBuffer.velocityTexture)
      return;
    if (!this.gBuffer.depthTexture)
      return;
    const camera = context.camera;
    this.intensity = camera.motionBlur.intensity * camera.getMotionBlurScale();
    this.samples = camera.motionBlur.samples;
    this.maxBlur = camera.motionBlur.maxBlur;
    if (this.intensity < 0.01) {
      return;
    }
    const uniformData = new Float32Array([
      this.intensity,
      this.maxBlur,
      this.samples,
      this.shutterAngle,
      this.width,
      this.height,
      this.tileSize,
      0
    ]);
    const uniformBuffer = this.device.createBuffer({
      size: 32,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
      mappedAtCreation: true
    });
    new Float32Array(uniformBuffer.getMappedRange()).set(uniformData);
    uniformBuffer.unmap();
    this.executeTileMaxPass(commandEncoder, uniformBuffer);
    this.executeNeighborMaxPass(commandEncoder, uniformBuffer);
    this.executeBlurPass(commandEncoder, uniformBuffer);
  }
  executeTileMaxPass(commandEncoder, uniformBuffer) {
    if (!this.device || !this.tileMaxPipeline || !this.gBuffer.velocityTexture || !this.tileMaxTexture)
      return;
    const layout = this.device.createBindGroupLayout({
      label: "Tile Max Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, sampler: {} },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } }
      ]
    });
    const bindGroup = this.device.createBindGroup({
      layout,
      entries: [
        { binding: 0, resource: this.gBuffer.velocityTexture.createView() },
        { binding: 1, resource: this.sampler },
        { binding: 2, resource: { buffer: uniformBuffer } }
      ]
    });
    const pass = commandEncoder.beginRenderPass({
      colorAttachments: [{
        view: this.tileMaxTexture.createView(),
        loadOp: "clear",
        storeOp: "store"
      }]
    });
    pass.setPipeline(this.tileMaxPipeline);
    pass.setBindGroup(0, bindGroup);
    pass.draw(3);
    pass.end();
  }
  executeNeighborMaxPass(commandEncoder, uniformBuffer) {
    if (!this.device || !this.neighborMaxPipeline || !this.tileMaxTexture || !this.neighborMaxTexture)
      return;
    const layout = this.device.createBindGroupLayout({
      label: "Neighbor Max Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, sampler: {} },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } }
      ]
    });
    const bindGroup = this.device.createBindGroup({
      layout,
      entries: [
        { binding: 0, resource: this.tileMaxTexture.createView() },
        { binding: 1, resource: this.sampler },
        { binding: 2, resource: { buffer: uniformBuffer } }
      ]
    });
    const pass = commandEncoder.beginRenderPass({
      colorAttachments: [{
        view: this.neighborMaxTexture.createView(),
        loadOp: "clear",
        storeOp: "store"
      }]
    });
    pass.setPipeline(this.neighborMaxPipeline);
    pass.setBindGroup(0, bindGroup);
    pass.draw(3);
    pass.end();
  }
  executeBlurPass(commandEncoder, uniformBuffer) {
    if (!this.device || !this.pipeline || !this.inputTexture || !this.gBuffer.velocityTexture || !this.outputTexture || !this.neighborMaxTexture)
      return;
    const bindGroup = this.device.createBindGroup({
      layout: this.bindGroupLayout,
      entries: [
        { binding: 0, resource: this.inputTexture.createView() },
        { binding: 1, resource: this.gBuffer.velocityTexture.createView() },
        { binding: 2, resource: this.gBuffer.depthTexture.createView() },
        { binding: 3, resource: this.sampler },
        { binding: 4, resource: { buffer: uniformBuffer } },
        { binding: 5, resource: this.neighborMaxTexture.createView() }
      ]
    });
    const pass = commandEncoder.beginRenderPass({
      colorAttachments: [{
        view: this.outputTexture.createView(),
        loadOp: "clear",
        storeOp: "store"
      }]
    });
    pass.setPipeline(this.pipeline);
    pass.setBindGroup(0, bindGroup);
    pass.draw(3);
    pass.end();
  }
  createPipelines(device) {
    const fullscreenVS = `
      struct VertexOutput {
        @builtin(position) position : vec4f,
        @location(0) uv : vec2f,
      }
      @vertex
      fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
        var output : VertexOutput;
        let pos = array(vec2f(-1.0, -1.0), vec2f(3.0, -1.0), vec2f(-1.0, 3.0));
        let p = pos[vertexIndex];
        output.position = vec4f(p, 0.0, 1.0);
        output.uv = p * 0.5 + 0.5;
        output.uv.y = 1.0 - output.uv.y;
        return output;
      }
    `;
    const tileMaxFS = `
      @group(0) @binding(0) var velocityTex : texture_2d<f32>;
      @group(0) @binding(1) var samp : sampler;
      struct Params {
        intensity: f32,
        maxBlur: f32,
        samples: f32,
        shutterAngle: f32,
        width: f32,
        height: f32,
        tileSize: f32,
        pad: f32,
      }
      @group(0) @binding(2) var<uniform> params : Params;

      @fragment
      fn fs_main(@location(0) uv : vec2f) -> @location(0) vec2f {
        let texSize = vec2f(textureDimensions(velocityTex));
        let tileCoord = vec2i(uv * texSize / params.tileSize);

        var maxVel = vec2f(0.0);
        var maxLen = 0.0;

        let startX = i32(f32(tileCoord.x) * params.tileSize);
        let startY = i32(f32(tileCoord.y) * params.tileSize);
        let endX = min(startX + i32(params.tileSize), i32(texSize.x));
        let endY = min(startY + i32(params.tileSize), i32(texSize.y));

        for (var y = startY; y < endY; y++) {
          for (var x = startX; x < endX; x++) {
            let pixelUV = (vec2f(f32(x), f32(y)) + 0.5) / texSize;
            let vel = textureSampleLevel(velocityTex, samp, pixelUV, 0.0).xy;
            let len = length(vel);
            if (len > maxLen) {
              maxLen = len;
              maxVel = vel;
            }
          }
        }

        return maxVel * params.intensity;
      }
    `;
    const neighborMaxFS = `
      @group(0) @binding(0) var tileMaxTex : texture_2d<f32>;
      @group(0) @binding(1) var samp : sampler;
      struct Params {
        intensity: f32,
        maxBlur: f32,
        samples: f32,
        shutterAngle: f32,
        width: f32,
        height: f32,
        tileSize: f32,
        pad: f32,
      }
      @group(0) @binding(2) var<uniform> params : Params;

      @fragment
      fn fs_main(@location(0) uv : vec2f) -> @location(0) vec2f {
        let texSize = vec2f(textureDimensions(tileMaxTex));
        let texelSize = 1.0 / texSize;

        var maxVel = vec2f(0.0);
        var maxLen = 0.0;

        for (var y = -1; y <= 1; y++) {
          for (var x = -1; x <= 1; x++) {
            let offset = vec2f(f32(x), f32(y)) * texelSize;
            let vel = textureSampleLevel(tileMaxTex, samp, uv + offset, 0.0).xy;
            let len = length(vel);
            if (len > maxLen) {
              maxLen = len;
              maxVel = vel;
            }
          }
        }

        return maxVel;
      }
    `;
    const blurFS = `
      @group(0) @binding(0) var colorTex : texture_2d<f32>;
      @group(0) @binding(1) var velocityTex : texture_2d<f32>;
      @group(0) @binding(2) var depthTex : texture_depth_2d;
      @group(0) @binding(3) var samp : sampler;
      struct Params {
        intensity: f32,
        maxBlur: f32,
        samples: f32,
        shutterAngle: f32,
        width: f32,
        height: f32,
        tileSize: f32,
        pad: f32,
      }
      @group(0) @binding(4) var<uniform> params : Params;
      @group(0) @binding(5) var neighborMaxTex : texture_2d<f32>;

      fn softDepthCompare(depth0: f32, depth1: f32) -> f32 {
        return clamp(1.0 - (depth0 - depth1) / 0.01, 0.0, 1.0);
      }

      fn cone(dist: f32, vel: f32) -> f32 {
        return clamp(1.0 - dist / max(vel, 0.001), 0.0, 1.0);
      }

      fn cylinder(dist: f32, vel: f32) -> f32 {
        return 1.0 - smoothstep(0.95 * max(vel, 0.001), 1.05 * max(vel, 0.001), dist);
      }

      fn loadDepth(coord: vec2i) -> f32 {
        return textureLoad(depthTex, coord, 0);
      }

      @fragment
      fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {
        let texelSize = vec2f(1.0 / params.width, 1.0 / params.height);
        let texSize = vec2f(params.width, params.height);
        let centerCoord = vec2i(uv * texSize);

        // Get center sample
        let centerColor = textureSampleLevel(colorTex, samp, uv, 0.0).rgb;
        let centerVel = textureSampleLevel(velocityTex, samp, uv, 0.0).xy * params.intensity;
        let centerDepth = loadDepth(centerCoord);

        // Get neighbor max velocity for this tile
        let neighborMaxVel = textureSampleLevel(neighborMaxTex, samp, uv, 0.0).xy;
        let neighborMaxLen = length(neighborMaxVel);

        // Compute motion blur even if low motion (avoid non-uniform control flow)
        let centerVelLen = length(centerVel);

        // Clamp velocity to max blur
        let maxVelPixels = params.maxBlur;
        let velScale = min(1.0, maxVelPixels / max(neighborMaxLen, 0.001));
        let scaledVel = centerVel * velScale;
        let scaledVelLen = length(scaledVel);

        var color = vec3f(0.0);
        var totalWeight = 0.0;

        let sampleCount = i32(params.samples);
        let jitter = fract(sin(dot(uv, vec2f(12.9898, 78.233))) * 43758.5453);

        for (var i = 0; i < sampleCount; i++) {
          let t = (f32(i) + jitter) / f32(sampleCount) - 0.5;
          let sampleOffset = scaledVel * t * texelSize * 2.0;
          let sampleUV = uv + sampleOffset;

          // Clamp to screen
          let clampedUV = clamp(sampleUV, vec2f(0.0), vec2f(1.0));
          let sampleCoord = vec2i(clampedUV * texSize);

          let sampleColor = textureSampleLevel(colorTex, samp, clampedUV, 0.0).rgb;
          let sampleVel = textureSampleLevel(velocityTex, samp, clampedUV, 0.0).xy * params.intensity;
          let sampleDepth = loadDepth(sampleCoord);
          let sampleVelLen = length(sampleVel);

          let dist = length(sampleOffset / texelSize);

          // Foreground/background weighting
          let foreground = softDepthCompare(sampleDepth, centerDepth);
          let background = softDepthCompare(centerDepth, sampleDepth);

          // Cone weight from sample's velocity
          let sampleCone = cone(dist, sampleVelLen);
          // Cylinder weight from center's velocity
          let centerCyl = cylinder(dist, scaledVelLen);

          var weight = foreground * sampleCone + background * centerCyl;
          weight = max(weight, 0.001);

          color += sampleColor * weight;
          totalWeight += weight;
        }

        color /= max(totalWeight, 0.001);

        // Blend with original based on motion amount (smooth falloff for low motion)
        let motionAmount = max(neighborMaxLen, centerVelLen);
        let blendFactor = smoothstep(0.0, 1.0, motionAmount);
        let finalColor = mix(centerColor, color, blendFactor);

        return vec4f(finalColor, 1.0);
      }
    `;
    const primitive = { topology: "triangle-list" };
    const tileMaxLayout = device.createBindGroupLayout({
      label: "Tile Max Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, sampler: {} },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } }
      ]
    });
    this.tileMaxPipeline = device.createRenderPipeline({
      label: "Motion Blur Tile Max",
      layout: device.createPipelineLayout({ bindGroupLayouts: [tileMaxLayout] }),
      vertex: { module: createShaderModuleSafe(device, { code: fullscreenVS }), entryPoint: "vs_main" },
      fragment: { module: createShaderModuleSafe(device, { code: tileMaxFS }), entryPoint: "fs_main", targets: [{ format: "rg16float" }] },
      primitive
    });
    this.neighborMaxPipeline = device.createRenderPipeline({
      label: "Motion Blur Neighbor Max",
      layout: device.createPipelineLayout({ bindGroupLayouts: [tileMaxLayout] }),
      vertex: { module: createShaderModuleSafe(device, { code: fullscreenVS }), entryPoint: "vs_main" },
      fragment: { module: createShaderModuleSafe(device, { code: neighborMaxFS }), entryPoint: "fs_main", targets: [{ format: "rg16float" }] },
      primitive
    });
    this.pipeline = device.createRenderPipeline({
      label: "Motion Blur Pipeline",
      layout: device.createPipelineLayout({ bindGroupLayouts: [this.bindGroupLayout] }),
      vertex: { module: createShaderModuleSafe(device, { code: fullscreenVS }), entryPoint: "vs_main" },
      fragment: { module: createShaderModuleSafe(device, { code: blurFS }), entryPoint: "fs_main", targets: [{ format: "rgba16float" }] },
      primitive
    });
  }
}

// ../../src/core/renderer/LensEffectsPass.ts
class LensEffectsPass {
  device = null;
  width = 0;
  height = 0;
  pipeline = null;
  tiltShiftPipeline = null;
  bindGroupLayout = null;
  sampler = null;
  outputTexture = null;
  tiltShiftTempTexture = null;
  inputTexture = null;
  distortionEnabled = false;
  distortionAmount = 0;
  chromaticAberrationEnabled = false;
  chromaticAberrationIntensity = 0.005;
  vignetteEnabled = false;
  vignetteIntensity = 0.3;
  vignetteSmoothness = 0.5;
  tiltShiftEnabled = false;
  tiltShiftFocusPosition = 0.5;
  tiltShiftFocusWidth = 0.2;
  tiltShiftBlurAmount = 4;
  tiltShiftGradientSize = 0.3;
  tiltShiftHorizontal = true;
  constructor(_gBuffer) {}
  setInputTexture(texture) {
    this.inputTexture = texture;
  }
  getOutputTexture() {
    return this.outputTexture;
  }
  get enabled() {
    return this.distortionEnabled || this.chromaticAberrationEnabled || this.vignetteEnabled || this.tiltShiftEnabled;
  }
  init(device, context, presentationFormat) {
    this.device = device;
    this.sampler = device.createSampler({
      minFilter: "linear",
      magFilter: "linear",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    });
    this.bindGroupLayout = device.createBindGroupLayout({
      label: "Lens Effects Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, sampler: {} },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } }
      ]
    });
    this.createPipelines(device);
  }
  resize(width, height) {
    if (width <= 0 || height <= 0)
      return;
    this.width = width;
    this.height = height;
    if (this.device) {
      this.destroyTextures();
      this.createTextures(this.device);
    }
  }
  destroyTextures() {
    if (this.outputTexture)
      this.outputTexture.destroy();
    if (this.tiltShiftTempTexture)
      this.tiltShiftTempTexture.destroy();
  }
  createTextures(device) {
    const desc = {
      label: "Lens Effects Output",
      size: [this.width, this.height],
      format: "rgba16float",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT
    };
    this.outputTexture = device.createTexture(desc);
    this.tiltShiftTempTexture = device.createTexture({ ...desc, label: "Tilt Shift Temp" });
  }
  execute(commandEncoder, context, globalResources) {
    if (!this.device || !this.inputTexture || !this.outputTexture)
      return;
    const camera = context.camera;
    const lens = camera.lensEffects;
    const tilt = camera.tiltShift;
    this.distortionEnabled = lens.distortionEnabled;
    this.distortionAmount = lens.distortionAmount;
    this.chromaticAberrationEnabled = lens.chromaticAberrationEnabled;
    this.chromaticAberrationIntensity = lens.chromaticAberrationIntensity;
    this.vignetteEnabled = lens.vignetteEnabled;
    this.vignetteIntensity = lens.vignetteIntensity;
    this.vignetteSmoothness = lens.vignetteSmoothness;
    this.tiltShiftEnabled = tilt.enabled;
    this.tiltShiftFocusPosition = tilt.focusPosition;
    this.tiltShiftFocusWidth = tilt.focusWidth;
    this.tiltShiftBlurAmount = tilt.blurAmount;
    this.tiltShiftGradientSize = tilt.gradientSize;
    this.tiltShiftHorizontal = tilt.direction === "horizontal";
    if (!this.enabled)
      return;
    const uniformData = new Float32Array([
      this.distortionEnabled ? 1 : 0,
      this.distortionAmount,
      this.chromaticAberrationEnabled ? 1 : 0,
      this.chromaticAberrationIntensity,
      this.vignetteEnabled ? 1 : 0,
      this.vignetteIntensity,
      this.vignetteSmoothness,
      0,
      this.tiltShiftEnabled ? 1 : 0,
      this.tiltShiftFocusPosition,
      this.tiltShiftFocusWidth,
      this.tiltShiftBlurAmount,
      this.tiltShiftGradientSize,
      this.tiltShiftHorizontal ? 1 : 0,
      this.width,
      this.height
    ]);
    const uniformBuffer = this.device.createBuffer({
      size: 64,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
      mappedAtCreation: true
    });
    new Float32Array(uniformBuffer.getMappedRange()).set(uniformData);
    uniformBuffer.unmap();
    if (this.distortionEnabled || this.chromaticAberrationEnabled || this.vignetteEnabled) {
      this.executeLensPass(commandEncoder, uniformBuffer);
    }
    if (this.tiltShiftEnabled) {
      const source = this.distortionEnabled || this.chromaticAberrationEnabled || this.vignetteEnabled ? this.outputTexture : this.inputTexture;
      this.executeTiltShiftPass(commandEncoder, uniformBuffer, source);
    }
  }
  executeLensPass(commandEncoder, uniformBuffer) {
    if (!this.device || !this.pipeline || !this.inputTexture || !this.outputTexture)
      return;
    const bindGroup = this.device.createBindGroup({
      layout: this.bindGroupLayout,
      entries: [
        { binding: 0, resource: this.inputTexture.createView() },
        { binding: 1, resource: this.sampler },
        { binding: 2, resource: { buffer: uniformBuffer } }
      ]
    });
    const target = this.tiltShiftEnabled ? this.tiltShiftTempTexture : this.outputTexture;
    const pass = commandEncoder.beginRenderPass({
      colorAttachments: [{
        view: target.createView(),
        loadOp: "clear",
        storeOp: "store"
      }]
    });
    pass.setPipeline(this.pipeline);
    pass.setBindGroup(0, bindGroup);
    pass.draw(3);
    pass.end();
  }
  executeTiltShiftPass(commandEncoder, uniformBuffer, source) {
    if (!this.device || !this.tiltShiftPipeline || !this.outputTexture || !this.tiltShiftTempTexture)
      return;
    const actualSource = this.distortionEnabled || this.chromaticAberrationEnabled || this.vignetteEnabled ? this.tiltShiftTempTexture : source;
    const bindGroup = this.device.createBindGroup({
      layout: this.bindGroupLayout,
      entries: [
        { binding: 0, resource: actualSource.createView() },
        { binding: 1, resource: this.sampler },
        { binding: 2, resource: { buffer: uniformBuffer } }
      ]
    });
    const pass = commandEncoder.beginRenderPass({
      colorAttachments: [{
        view: this.outputTexture.createView(),
        loadOp: "clear",
        storeOp: "store"
      }]
    });
    pass.setPipeline(this.tiltShiftPipeline);
    pass.setBindGroup(0, bindGroup);
    pass.draw(3);
    pass.end();
  }
  createPipelines(device) {
    const fullscreenVS = `
      struct VertexOutput {
        @builtin(position) position : vec4f,
        @location(0) uv : vec2f,
      }
      @vertex
      fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
        var output : VertexOutput;
        let pos = array(vec2f(-1.0, -1.0), vec2f(3.0, -1.0), vec2f(-1.0, 3.0));
        let p = pos[vertexIndex];
        output.position = vec4f(p, 0.0, 1.0);
        output.uv = p * 0.5 + 0.5;
        output.uv.y = 1.0 - output.uv.y;
        return output;
      }
    `;
    const lensFS = `
      @group(0) @binding(0) var inputTex : texture_2d<f32>;
      @group(0) @binding(1) var samp : sampler;
      struct Params {
        distortionEnabled: f32,
        distortionAmount: f32,
        caEnabled: f32,
        caIntensity: f32,
        vignetteEnabled: f32,
        vignetteIntensity: f32,
        vignetteSmoothness: f32,
        pad1: f32,
        tiltShiftEnabled: f32,
        tiltShiftFocusPos: f32,
        tiltShiftFocusWidth: f32,
        tiltShiftBlurAmount: f32,
        tiltShiftGradient: f32,
        tiltShiftHorizontal: f32,
        width: f32,
        height: f32,
      }
      @group(0) @binding(2) var<uniform> params : Params;

      // Barrel/pincushion distortion
      fn distort(uv: vec2f, amount: f32) -> vec2f {
        let centered = uv - 0.5;
        let r2 = dot(centered, centered);
        let distorted = centered * (1.0 + amount * r2);
        return distorted + 0.5;
      }

      @fragment
      fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {
        // Apply distortion (always compute, blend based on enabled)
        let distortedUV = distort(uv, params.distortionAmount);
        let finalUV = select(uv, distortedUV, params.distortionEnabled > 0.5);

        // Check if UV is out of bounds after distortion
        let outOfBounds = finalUV.x < 0.0 || finalUV.x > 1.0 || finalUV.y < 0.0 || finalUV.y > 1.0;

        // Clamp UV for sampling (avoid artifacts at edges)
        let clampedUV = clamp(finalUV, vec2f(0.001), vec2f(0.999));

        // Always compute both paths, select based on CA enabled
        // Chromatic aberration path
        let centered = clampedUV - 0.5;
        let r = length(centered);
        let caOffset = centered * r * params.caIntensity;
        let rUV = clamp(clampedUV + caOffset, vec2f(0.0), vec2f(1.0));
        let bUV = clamp(clampedUV - caOffset, vec2f(0.0), vec2f(1.0));

        let caColor = vec3f(
          textureSampleLevel(inputTex, samp, rUV, 0.0).r,
          textureSampleLevel(inputTex, samp, clampedUV, 0.0).g,
          textureSampleLevel(inputTex, samp, bUV, 0.0).b
        );

        // Non-CA path
        let normalColor = textureSampleLevel(inputTex, samp, clampedUV, 0.0).rgb;

        // Select based on CA enabled
        var color = select(normalColor, caColor, params.caEnabled > 0.5);

        // Vignette (always compute, multiply by 1.0 if disabled)
        let vignetteCentered = uv - 0.5;
        let vignetteDist = length(vignetteCentered) * 2.0;
        let vignetteBase = 1.0 - smoothstep(1.0 - params.vignetteSmoothness, 1.0, vignetteDist);
        let vignetteValue = mix(1.0, vignetteBase, params.vignetteIntensity);
        let vignetteFactor = select(1.0, vignetteValue, params.vignetteEnabled > 0.5);
        color *= vignetteFactor;

        // Black out if out of bounds
        color = select(color, vec3f(0.0), outOfBounds);

        return vec4f(color, 1.0);
      }
    `;
    const tiltShiftFS = `
      @group(0) @binding(0) var inputTex : texture_2d<f32>;
      @group(0) @binding(1) var samp : sampler;
      struct Params {
        distortionEnabled: f32,
        distortionAmount: f32,
        caEnabled: f32,
        caIntensity: f32,
        vignetteEnabled: f32,
        vignetteIntensity: f32,
        vignetteSmoothness: f32,
        pad1: f32,
        tiltShiftEnabled: f32,
        tiltShiftFocusPos: f32,
        tiltShiftFocusWidth: f32,
        tiltShiftBlurAmount: f32,
        tiltShiftGradient: f32,
        tiltShiftHorizontal: f32,
        width: f32,
        height: f32,
      }
      @group(0) @binding(2) var<uniform> params : Params;

      const PI = 3.14159265359;
      const GOLDEN_ANGLE = 2.39996323;

      @fragment
      fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {
        let texelSize = vec2f(1.0 / params.width, 1.0 / params.height);

        // Calculate position based on direction (use select instead of if)
        let pos = select(uv.x, uv.y, params.tiltShiftHorizontal > 0.5);

        let focusCenter = params.tiltShiftFocusPos;
        let halfWidth = params.tiltShiftFocusWidth * 0.5;
        let gradient = max(params.tiltShiftGradient, 0.001); // Prevent division by zero

        // Distance from focus band (compute all cases, use math instead of branches)
        let belowFocus = focusCenter - halfWidth;
        let aboveFocus = focusCenter + halfWidth;

        // Signed distance from focus band edges
        let distBelow = (belowFocus - pos) / gradient;
        let distAbove = (pos - aboveFocus) / gradient;

        // Use max of both distances (one will be negative when inside)
        let distFromFocus = max(max(distBelow, distAbove), 0.0);

        let blurFactor = clamp(distFromFocus, 0.0, 1.0);
        let blurRadius = blurFactor * params.tiltShiftBlurAmount;

        // Always sample original color
        let originalColor = textureSampleLevel(inputTex, samp, uv, 0.0).rgb;

        // Always compute blur (even if blurRadius is small, the blend will handle it)
        var blurredColor = vec3f(0.0);
        let samples = 16;

        for (var i = 0; i < samples; i++) {
          let fi = f32(i);
          let r = sqrt(fi / f32(samples)) * max(blurRadius, 0.001);
          let theta = fi * GOLDEN_ANGLE;
          let offset = vec2f(cos(theta), sin(theta)) * r * texelSize;
          blurredColor += textureSampleLevel(inputTex, samp, uv + offset, 0.0).rgb;
        }
        blurredColor /= f32(samples);

        // Blend between original and blurred based on blur amount
        let blendFactor = smoothstep(0.0, 1.0, blurRadius);
        let finalColor = mix(originalColor, blurredColor, blendFactor);

        return vec4f(finalColor, 1.0);
      }
    `;
    const primitive = { topology: "triangle-list" };
    const layout = device.createPipelineLayout({ bindGroupLayouts: [this.bindGroupLayout] });
    const targets = [{ format: "rgba16float" }];
    this.pipeline = device.createRenderPipeline({
      label: "Lens Effects Pipeline",
      layout,
      vertex: { module: createShaderModuleSafe(device, { code: fullscreenVS }), entryPoint: "vs_main" },
      fragment: { module: createShaderModuleSafe(device, { code: lensFS }), entryPoint: "fs_main", targets },
      primitive
    });
    this.tiltShiftPipeline = device.createRenderPipeline({
      label: "Tilt-Shift Pipeline",
      layout,
      vertex: { module: createShaderModuleSafe(device, { code: fullscreenVS }), entryPoint: "vs_main" },
      fragment: { module: createShaderModuleSafe(device, { code: tiltShiftFS }), entryPoint: "fs_main", targets },
      primitive
    });
  }
}

// ../../src/core/renderer/GodRaysPass.ts
class GodRaysPass {
  device = null;
  gBuffer;
  width = 0;
  height = 0;
  godRaysTexture = null;
  pipeline = null;
  bindGroupLayout = null;
  bindGroup = null;
  uniformBuffer = null;
  sampler = null;
  enabled = false;
  intensity = 1;
  decay = 0.96;
  density = 0.96;
  weight = 0.4;
  exposure = 0.2;
  samples = 64;
  maxDistance = 1;
  inputTexture = null;
  constructor(gBuffer) {
    this.gBuffer = gBuffer;
  }
  init(device, context, presentationFormat) {
    this.device = device;
    this.sampler = device.createSampler({
      minFilter: "linear",
      magFilter: "linear",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    });
    this.uniformBuffer = device.createBuffer({
      label: "GodRays Uniform Buffer",
      size: 80,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.bindGroupLayout = device.createBindGroupLayout({
      label: "GodRays Bind Group Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "depth" } },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, sampler: {} },
        { binding: 3, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "non-filtering" } },
        { binding: 4, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } }
      ]
    });
    this.createPipeline(device);
  }
  resize(width, height) {
    this.width = width;
    this.height = height;
    if (this.device) {
      if (this.godRaysTexture) {
        this.godRaysTexture.destroy();
        this.godRaysTexture = null;
      }
      if (width <= 0 || height <= 0) {
        return;
      }
      this.godRaysTexture = this.device.createTexture({
        label: "God Rays Texture",
        size: [width, height],
        format: "rgba16float",
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
      });
      this.bindGroup = null;
    }
  }
  setInputTexture(texture) {
    this.inputTexture = texture;
    this.bindGroup = null;
  }
  getOutputTexture() {
    return this.godRaysTexture;
  }
  execute(commandEncoder, context, globalResources) {
    if (!this.enabled || !this.device || !this.pipeline || !this.godRaysTexture || !this.inputTexture) {
      return;
    }
    const sunLight = context.scene.lights.find((l) => l.type === 0 /* Directional */);
    if (!sunLight) {
      return;
    }
    const lightDir = sunLight.transform.getForwardVector().clone().multiplyScalar(-1);
    const sunWorldPos = context.camera.transform.position.clone().add(lightDir.clone().multiplyScalar(1000));
    const viewProj = context.camera.projectionMatrix.clone().multiply(context.camera.viewMatrix);
    const ndcPos = sunWorldPos.clone().applyMatrix4(viewProj);
    const screenX = ndcPos.x * 0.5 + 0.5;
    const screenY = 1 - (ndcPos.y * 0.5 + 0.5);
    const isOnScreen = screenX >= 0 && screenX <= 1 && screenY >= 0 && screenY <= 1;
    const clampedX = Math.max(0, Math.min(1, screenX));
    const clampedY = Math.max(0, Math.min(1, screenY));
    const offScreenDist = Math.sqrt(Math.pow(screenX - clampedX, 2) + Math.pow(screenY - clampedY, 2));
    const offScreenFalloff = Math.max(0, 1 - offScreenDist / this.maxDistance);
    const uniformData = new Float32Array([
      screenX,
      screenY,
      this.intensity,
      this.decay,
      this.density,
      this.weight,
      this.exposure,
      this.samples,
      sunLight.color.x * sunLight.intensity,
      sunLight.color.y * sunLight.intensity,
      sunLight.color.z * sunLight.intensity,
      offScreenFalloff,
      this.width,
      this.height,
      this.maxDistance,
      isOnScreen ? 1 : 0,
      clampedX,
      clampedY,
      0,
      0
    ]);
    this.device.queue.writeBuffer(this.uniformBuffer, 0, uniformData);
    if (!this.bindGroup) {
      this.createBindGroup();
    }
    if (!this.bindGroup)
      return;
    const passEncoder = commandEncoder.beginRenderPass({
      colorAttachments: [{
        view: this.godRaysTexture.createView(),
        loadOp: "clear",
        storeOp: "store",
        clearValue: { r: 0, g: 0, b: 0, a: 0 }
      }]
    });
    passEncoder.setPipeline(this.pipeline);
    passEncoder.setBindGroup(0, this.bindGroup);
    passEncoder.draw(3);
    passEncoder.end();
  }
  createPipeline(device) {
    const shaderCode = `
      struct Params {
        lightScreenPos: vec2f,      // Original light position (can be off-screen)
        intensity: f32,
        decay: f32,
        density: f32,
        weight: f32,
        exposure: f32,
        numSamples: f32,
        lightColor: vec3f,
        offScreenFalloff: f32,      // Intensity falloff for off-screen light
        resolution: vec2f,
        maxDistance: f32,
        isOnScreen: f32,
        clampedLightPos: vec2f,     // Light position clamped to screen edge
        _pad: vec2f,
      }

      @group(0) @binding(0) var colorTex: texture_2d<f32>;
      @group(0) @binding(1) var depthTex: texture_depth_2d;
      @group(0) @binding(2) var colorSamp: sampler;
      @group(0) @binding(3) var depthSamp: sampler;
      @group(0) @binding(4) var<uniform> params: Params;

      struct VertexOutput {
        @builtin(position) position: vec4f,
        @location(0) uv: vec2f,
      }

      @vertex
      fn vs_main(@builtin(vertex_index) vertexIndex: u32) -> VertexOutput {
        var output: VertexOutput;
        let pos = array(
          vec2f(-1.0, -1.0),
          vec2f(3.0, -1.0),
          vec2f(-1.0, 3.0)
        );
        let p = pos[vertexIndex];
        output.position = vec4f(p, 0.0, 1.0);
        output.uv = p * 0.5 + 0.5;
        output.uv.y = 1.0 - output.uv.y;
        return output;
      }

      // Hash function for dithering (removes banding artifacts)
      fn hash(p: vec2f) -> f32 {
        var p3 = fract(vec3f(p.xyx) * 0.1031);
        p3 += dot(p3, p3.yzx + 33.33);
        return fract((p3.x + p3.y) * p3.z);
      }

      @fragment
      fn fs_main(@builtin(position) fragCoord: vec4f, @location(0) uv: vec2f) -> @location(0) vec4f {
        // Use original light position for direction, but allow off-screen
        let lightPos = params.lightScreenPos;

        // Distance from pixel to light in screen space
        let toLight = lightPos - uv;
        let distToLight = length(toLight);

        // Skip if light is exactly at pixel (shouldn't happen normally)
        if (distToLight < 0.001) {
          return vec4f(0.0, 0.0, 0.0, 1.0);
        }

        // Dithering offset to reduce banding (based on screen position)
        let dither = hash(fragCoord.xy) * 0.5;

        // Vector from current pixel toward light
        let rayDir = normalize(toLight);

        // For off-screen lights, use extended ray distance based on maxDistance
        // This allows rays to appear even when looking away from the light
        let maxRayDist = params.maxDistance + 1.0;
        let rayDist = min(distToLight, maxRayDist);
        let stepSize = rayDist / params.numSamples * params.density;
        let deltaTexCoord = rayDir * stepSize;

        var sampleCoord = uv;
        var accumulatedLight = 0.0;
        var illuminationDecay = 1.0;

        let numSamples = i32(params.numSamples);
        let texSize = vec2i(textureDimensions(depthTex));

        // Apply initial dither offset to stagger samples and reduce banding
        sampleCoord += deltaTexCoord * dither;

        // March toward the light source
        for (var i = 0; i < numSamples; i++) {
          sampleCoord += deltaTexCoord;

          // Clamp to valid range for sampling
          let clampedCoord = clamp(sampleCoord, vec2f(0.001), vec2f(0.999));

          // Check if sample is still on screen
          let inBounds = sampleCoord.x >= 0.0 && sampleCoord.x <= 1.0 &&
                         sampleCoord.y >= 0.0 && sampleCoord.y <= 1.0;

          // Sample depth at this position
          let samplePixel = vec2i(clampedCoord * vec2f(texSize));
          let depth = textureLoad(depthTex, samplePixel, 0);

          // Only accumulate light from unoccluded areas (sky/background)
          // depth >= 0.9999 means nothing was rendered there (background/sky)
          let isSky = depth >= 0.9999;

          // Accumulate if in bounds and sky visible
          if (inBounds && isSky) {
            accumulatedLight += params.weight * illuminationDecay;
          }

          illuminationDecay *= params.decay;
        }

        // Apply light color, exposure and intensity
        // Use distance falloff based on actual light distance, with extended range
        let normalizedDist = distToLight / maxRayDist;
        let distanceFalloff = 1.0 - smoothstep(0.0, 1.0, normalizedDist);

        // Apply off-screen falloff if light is not on screen
        let screenFalloff = select(params.offScreenFalloff, 1.0, params.isOnScreen > 0.5);

        let finalColor = params.lightColor * accumulatedLight * params.exposure * params.intensity * distanceFalloff * screenFalloff;

        return vec4f(finalColor, 1.0);
      }
    `;
    const shaderModule = createShaderModuleSafe(device, { code: shaderCode });
    const pipelineLayout = device.createPipelineLayout({
      bindGroupLayouts: [this.bindGroupLayout]
    });
    this.pipeline = device.createRenderPipeline({
      label: "God Rays Pipeline",
      layout: pipelineLayout,
      vertex: {
        module: shaderModule,
        entryPoint: "vs_main"
      },
      fragment: {
        module: shaderModule,
        entryPoint: "fs_main",
        targets: [{ format: "rgba16float" }]
      },
      primitive: { topology: "triangle-list" }
    });
  }
  createBindGroup() {
    if (!this.device || !this.bindGroupLayout || !this.inputTexture || !this.gBuffer.depthTexture || !this.sampler || !this.uniformBuffer) {
      return;
    }
    const depthView = this.gBuffer.depthTexture.createView({
      aspect: "depth-only"
    });
    const depthSampler = this.device.createSampler({
      minFilter: "nearest",
      magFilter: "nearest"
    });
    this.bindGroup = this.device.createBindGroup({
      label: "God Rays Bind Group",
      layout: this.bindGroupLayout,
      entries: [
        { binding: 0, resource: this.inputTexture.createView() },
        { binding: 1, resource: depthView },
        { binding: 2, resource: this.sampler },
        { binding: 3, resource: depthSampler },
        { binding: 4, resource: { buffer: this.uniformBuffer } }
      ]
    });
  }
}

// ../../src/core/Engine.ts
class Engine {
  canvas;
  device = null;
  context = null;
  presentationFormat = null;
  renderGraph;
  gBuffer = null;
  taaPass = null;
  fxaaPass = null;
  ssgiPass = null;
  ssaoPass = null;
  bloomPass = null;
  ssrPass = null;
  toneMappingPass = null;
  depthOfFieldPass = null;
  motionBlurPass = null;
  lensEffectsPass = null;
  godRaysPass = null;
  frameIndex = 0;
  statsReadBuffer = null;
  static STATS_ZERO_BUFFER = new Uint32Array([0, 0, 0, 0]);
  currentDeltaTime = 0.016;
  totalTime = 0;
  lastRenderTime = 0;
  debugger = null;
  gpuProfiler;
  selectionRenderer;
  config;
  softwareConfig = {};
  rendererCapabilities = null;
  constructor(canvas, config2) {
    this.canvas = canvas;
    this.config = config2 ?? {};
    if (!this.config.disableDebugger) {
      this.debugger = new Debugger(canvas.parentElement);
    }
    this.gpuProfiler = getGPUProfiler();
    this.selectionRenderer = new SelectionRenderer;
    this.renderGraph = new RenderGraph;
  }
  async init() {
    if (!navigator.gpu) {
      throw new Error("WebGPU not supported on this browser.");
    }
    const adapter = await navigator.gpu.requestAdapter();
    if (!adapter) {
      throw new Error("No appropriate GPUAdapter found.");
    }
    this.rendererCapabilities = await detectRendererCapabilities(adapter);
    this.softwareConfig = getEffectiveSoftwareConfig({
      ...this.config.softwareRendering,
      forceSoftwareMode: this.config.softwareRendering?.forceSoftwareMode || this.rendererCapabilities.isSoftwareRenderer
    });
    if (this.rendererCapabilities.isSoftwareRenderer || this.config.softwareRendering?.forceSoftwareMode) {
      console.log("Engine: Running in software rendering mode. Some features will be disabled.");
      console.log("Engine: Software config:", this.softwareConfig);
    }
    this.presentationFormat = navigator.gpu.getPreferredCanvasFormat();
    console.log(`Configuring context: ${this.canvas.width}x${this.canvas.height}, format: ${this.presentationFormat}`);
    this.canvas.width = this.canvas.clientWidth || 800;
    this.canvas.height = this.canvas.clientHeight || 600;
    console.log(`Engine: Initial canvas size: ${this.canvas.width}x${this.canvas.height} (Client: ${this.canvas.clientWidth}x${this.canvas.clientHeight})`);
    const requiredLimits = {};
    if (adapter.limits.maxColorAttachmentBytesPerSample >= 64) {
      requiredLimits.maxColorAttachmentBytesPerSample = adapter.limits.maxColorAttachmentBytesPerSample;
    }
    if (adapter.limits.maxTextureDimension2D > 8192) {
      requiredLimits.maxTextureDimension2D = adapter.limits.maxTextureDimension2D;
      console.log(`Engine: Requesting maxTextureDimension2D: ${adapter.limits.maxTextureDimension2D}`);
    }
    const requiredFeatures = [];
    if (adapter.features.has("indirect-first-instance")) {
      requiredFeatures.push("indirect-first-instance");
      console.log("Engine: indirect-first-instance feature enabled");
    } else {
      console.warn("Engine: indirect-first-instance feature not available - indirect draws may not work correctly");
    }
    if (adapter.features.has("timestamp-query")) {
      requiredFeatures.push("timestamp-query");
      console.log("Engine: timestamp-query feature enabled for GPU profiling");
    } else {
      console.warn("Engine: timestamp-query feature not available - GPU timing will not be available");
    }
    console.log("Engine: Available adapter features:", [...adapter.features]);
    console.log("Engine: Adapter limits:", {
      maxBindGroups: adapter.limits.maxBindGroups,
      maxBindingsPerBindGroup: adapter.limits.maxBindingsPerBindGroup,
      maxUniformBufferBindingSize: adapter.limits.maxUniformBufferBindingSize,
      maxStorageBufferBindingSize: adapter.limits.maxStorageBufferBindingSize,
      maxSampledTexturesPerShaderStage: adapter.limits.maxSampledTexturesPerShaderStage,
      maxSamplersPerShaderStage: adapter.limits.maxSamplersPerShaderStage,
      maxStorageTexturesPerShaderStage: adapter.limits.maxStorageTexturesPerShaderStage,
      maxUniformBuffersPerShaderStage: adapter.limits.maxUniformBuffersPerShaderStage,
      maxStorageBuffersPerShaderStage: adapter.limits.maxStorageBuffersPerShaderStage,
      maxDynamicUniformBuffersPerPipelineLayout: adapter.limits.maxDynamicUniformBuffersPerPipelineLayout,
      maxDynamicStorageBuffersPerPipelineLayout: adapter.limits.maxDynamicStorageBuffersPerPipelineLayout
    });
    this.device = await adapter.requestDevice({ requiredLimits, requiredFeatures });
    this.gpuProfiler.init(this.device, adapter);
    this.selectionRenderer.init(this.device);
    if (this.device.addEventListener) {
      this.device.addEventListener("uncapturederror", (event) => {
        const error = event.error;
        console.error("WebGPU uncaptured error:", error.message);
        ErrorOverlay.getInstance().reportError(error.message, "Uncaptured WebGPU Error");
      });
    }
    this.context = this.canvas.getContext("webgpu");
    this.statsReadBuffer = this.device.createBuffer({
      size: 16,
      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
    });
    if (!this.context) {
      throw new Error("Could not get WebGPU context.");
    }
    this.context.configure({
      device: this.device,
      format: this.presentationFormat,
      alphaMode: "opaque"
    });
    this.gBuffer = new GBuffer(this.device, this.canvas.width, this.canvas.height);
    const gBuffer = this.gBuffer;
    const atmosphereEnabled = !this.softwareConfig.disableAtmosphere;
    const atmospherePass = atmosphereEnabled ? new AtmospherePass : null;
    const hiZPass = new HiZGenerationPass(gBuffer);
    const cullingPass = new GPUCullingPass(gBuffer);
    const shadowPass = new ShadowPass;
    const pointShadowPass = new PointShadowPass;
    const geometryPass = new GeometryPass(gBuffer);
    const ssaoPass = new SSAOPass(gBuffer);
    this.ssaoPass = ssaoPass;
    if (this.softwareConfig.disableSSAO) {
      ssaoPass.enabled = false;
    }
    const ssgiPass = new SSGIPass(gBuffer);
    this.ssgiPass = ssgiPass;
    if (this.softwareConfig.disableSSGI) {
      ssgiPass.enabled = false;
      console.log("Engine: SSGI disabled for software rendering compatibility");
    }
    const lightingPass = new DeferredLightingPass(gBuffer);
    const skyboxPass = new SkyboxPass(gBuffer);
    const forwardPass = new ForwardRenderPass(gBuffer);
    const ssrPass = new SSRPass(gBuffer);
    this.ssrPass = ssrPass;
    if (this.softwareConfig.disableSSR) {
      ssrPass.enabled = false;
      console.log("Engine: SSR disabled for software rendering compatibility");
    }
    const taaPass = new TAAPass(gBuffer);
    this.taaPass = taaPass;
    if (this.softwareConfig.disableTAA) {
      taaPass.enabled = false;
    }
    const fxaaPass = new FXAAPass(gBuffer);
    this.fxaaPass = fxaaPass;
    fxaaPass.enabled = false;
    const depthOfFieldPass = new DepthOfFieldPass(gBuffer);
    this.depthOfFieldPass = depthOfFieldPass;
    if (this.softwareConfig.disableDoF) {
      depthOfFieldPass.enabled = false;
      console.log("Engine: Depth of Field disabled for software rendering compatibility");
    }
    const motionBlurPass = new MotionBlurPass(gBuffer);
    this.motionBlurPass = motionBlurPass;
    if (this.softwareConfig.disableMotionBlur) {
      motionBlurPass.enabled = false;
      console.log("Engine: Motion Blur disabled for software rendering compatibility");
    }
    const lensEffectsPass = new LensEffectsPass(gBuffer);
    this.lensEffectsPass = lensEffectsPass;
    const godRaysPass = new GodRaysPass(gBuffer);
    this.godRaysPass = godRaysPass;
    const bloomPass = new BloomPass;
    this.bloomPass = bloomPass;
    if (this.softwareConfig.disableBloom) {
      bloomPass.enabled = false;
    }
    const toneMappingPass = new ToneMappingPass;
    this.toneMappingPass = toneMappingPass;
    if (atmospherePass) {
      this.renderGraph.addPass(atmospherePass);
    }
    this.renderGraph.addPass(cullingPass);
    this.renderGraph.addPass(shadowPass);
    this.renderGraph.addPass(pointShadowPass);
    this.renderGraph.addPass(geometryPass);
    this.renderGraph.addPass(hiZPass);
    const velocityFromDepthPass = new VelocityFromDepthPass(gBuffer);
    this.renderGraph.addPass(velocityFromDepthPass);
    this.renderGraph.addPass(ssaoPass);
    this.renderGraph.addPass(ssgiPass);
    this.renderGraph.addPass(lightingPass);
    this.renderGraph.addPass(skyboxPass);
    this.renderGraph.addPass(forwardPass);
    this.renderGraph.addPass(ssrPass);
    this.renderGraph.addPass(godRaysPass);
    this.renderGraph.addPass(taaPass);
    this.renderGraph.addPass(fxaaPass);
    this.renderGraph.addPass(depthOfFieldPass);
    this.renderGraph.addPass(motionBlurPass);
    this.renderGraph.addPass(lensEffectsPass);
    this.renderGraph.addPass(bloomPass);
    this.renderGraph.addPass(toneMappingPass);
    this.renderGraph.init(this.device, this.context, this.presentationFormat);
    this.renderGraph.resize(this.canvas.width, this.canvas.height);
    if (atmospherePass) {
      const globalRes = this.renderGraph.getGlobalResources();
      if (globalRes && atmospherePass.transmittanceTexture && atmospherePass.scatteringTexture && atmospherePass.irradianceTexture && atmospherePass.skyViewTexture) {
        globalRes.setAtmosphereLUTs(atmospherePass.transmittanceTexture, atmospherePass.scatteringTexture, atmospherePass.irradianceTexture, atmospherePass.skyViewTexture, atmospherePass.cloudNoiseTexture);
        globalRes.createBindGroup(this.device);
        if (globalRes.renderBindGroupLayout && globalRes.atmosphereBindGroupLayout) {
          skyboxPass.initAtmosphere(this.device, globalRes.renderBindGroupLayout, globalRes.atmosphereBindGroupLayout);
        }
      }
    }
    console.log("Mystral Engine Initialized");
  }
  getDevice() {
    return this.device;
  }
  getGlobalResources() {
    return this.renderGraph.getGlobalResources();
  }
  getRenderGraph() {
    return this.renderGraph;
  }
  getRendererCapabilities() {
    return this.rendererCapabilities;
  }
  isSoftwareRenderingMode() {
    return this.softwareConfig.forceSoftwareMode || this.rendererCapabilities?.isSoftwareRenderer || false;
  }
  getSoftwareRenderingConfig() {
    return { ...this.softwareConfig };
  }
  addRenderPass(pass) {
    if (!this.device || !this.context || !this.presentationFormat) {
      console.warn("Engine.addRenderPass: Engine not initialized yet");
      return;
    }
    this.renderGraph.addPass(pass);
    pass.init(this.device, this.context, this.presentationFormat);
    pass.resize(this.canvas.width, this.canvas.height);
    if (pass instanceof UIRenderPass) {
      this.debugger?.registerUIManager(pass.getUIManager());
      this.debugger?.registerCanvas(this.canvas, this.device);
    }
  }
  removeRenderPass(pass) {
    return this.renderGraph.removePass(pass);
  }
  getDebugOverlay() {
    return this.debugger;
  }
  getDebugger() {
    return this.debugger;
  }
  setDebugMode(mode) {
    this.renderGraph.setDebugMode(mode);
  }
  getGPUProfiler() {
    return this.gpuProfiler;
  }
  logGPUTimes() {
    this.gpuProfiler.logTimes();
  }
  async readDepthTexture(numSamples = 100) {
    if (!this.device || !this.gBuffer) {
      console.error("Engine or GBuffer not initialized");
      return;
    }
    const commandEncoder = this.device.createCommandEncoder({ label: "Depth Readback" });
    await this.gBuffer.readDepthValues(commandEncoder, numSamples);
    this.device.queue.submit([commandEncoder.finish()]);
  }
  render(scene, camera) {
    if (!this.device || !this.context || !this.presentationFormat)
      return;
    if (this.canvas.width === 0 || this.canvas.height === 0)
      return;
    const now = performance.now();
    if (this.lastRenderTime > 0) {
      const dt = (now - this.lastRenderTime) / 1000;
      if (dt >= 0.001 && dt < 1) {
        this.currentDeltaTime = dt;
        this.totalTime += dt;
      }
    }
    this.lastRenderTime = now;
    this.processSceneUpdates(scene, this.currentDeltaTime);
    if (this.taaPass) {
      this.taaPass.enabled = scene.postProcessing.aa.enabled;
    }
    if (this.fxaaPass) {
      this.fxaaPass.enabled = scene.postProcessing.fxaa.enabled;
    }
    if (this.ssaoPass) {
      this.ssaoPass.enabled = scene.postProcessing.ssao.enabled;
    }
    if (this.ssgiPass) {
      this.ssgiPass.enabled = scene.globalIllumination.enabled && !this.softwareConfig.disableSSGI;
      this.ssgiPass.intensity = scene.globalIllumination.intensity;
      this.ssgiPass.enableSpatialDenoise = scene.globalIllumination.spatialDenoise;
      this.ssgiPass.enableTemporalDenoise = scene.globalIllumination.temporalDenoise;
    }
    if (this.ssrPass) {
      this.ssrPass.enabled = scene.postProcessing.ssr.enabled && !this.softwareConfig.disableSSR;
    }
    if (this.bloomPass) {
      this.bloomPass.enabled = scene.postProcessing.bloom.enabled;
      this.bloomPass.threshold = scene.postProcessing.bloom.threshold;
      this.bloomPass.intensity = scene.postProcessing.bloom.intensity;
    }
    if (this.toneMappingPass) {
      this.toneMappingPass.bloomIntensity = scene.postProcessing.bloom.intensity;
      this.toneMappingPass.godRaysIntensity = scene.postProcessing.godRays.intensity;
    }
    if (this.godRaysPass) {
      this.godRaysPass.enabled = scene.postProcessing.godRays.enabled;
      this.godRaysPass.intensity = scene.postProcessing.godRays.intensity;
      this.godRaysPass.decay = scene.postProcessing.godRays.decay;
      this.godRaysPass.density = scene.postProcessing.godRays.density;
      this.godRaysPass.weight = scene.postProcessing.godRays.weight;
      this.godRaysPass.exposure = scene.postProcessing.godRays.exposure;
      this.godRaysPass.samples = scene.postProcessing.godRays.samples;
      this.godRaysPass.maxDistance = scene.postProcessing.godRays.maxDistance;
    }
    if (this.depthOfFieldPass) {
      this.depthOfFieldPass.enabled = camera.depthOfField.enabled && !this.softwareConfig.disableDoF;
    }
    if (this.motionBlurPass) {
      this.motionBlurPass.enabled = camera.motionBlur.enabled && !this.softwareConfig.disableMotionBlur;
    }
    if (this.lensEffectsPass) {
      this.lensEffectsPass.distortionEnabled = camera.lensEffects.distortionEnabled;
      this.lensEffectsPass.chromaticAberrationEnabled = camera.lensEffects.chromaticAberrationEnabled;
      this.lensEffectsPass.vignetteEnabled = camera.lensEffects.vignetteEnabled;
      this.lensEffectsPass.tiltShiftEnabled = camera.tiltShift.enabled;
    }
    this.debugger?.registerScene(scene);
    this.debugger?.registerCamera(camera);
    this.frameIndex++;
    if (this.taaPass && this.taaPass.enabled) {
      const width = this.canvas.width;
      const height = this.canvas.height;
      const halton = (index, base) => {
        let result = 0;
        let f = 1 / base;
        let i = index;
        while (i > 0) {
          result = result + f * (i % base);
          i = Math.floor(i / base);
          f = f / base;
        }
        return result;
      };
      const jitterX = halton(this.frameIndex % 16 + 1, 2) - 0.5;
      const jitterY = halton(this.frameIndex % 16 + 1, 3) - 0.5;
      camera.projectionJitter.set(2 * jitterX / width, 2 * jitterY / height);
    } else {
      camera.projectionJitter.set(0, 0);
    }
    camera.updateProjectionMatrix();
    camera.updateViewMatrix();
    if (this.canvas.width !== this.canvas.clientWidth || this.canvas.height !== this.canvas.clientHeight) {
      if (this.canvas.clientWidth === 0 || this.canvas.clientHeight === 0) {
        return;
      }
      console.log(`Engine: Resizing from ${this.canvas.width}x${this.canvas.height} to ${this.canvas.clientWidth}x${this.canvas.clientHeight}`);
      this.canvas.width = this.canvas.clientWidth;
      this.canvas.height = this.canvas.clientHeight;
      this.renderGraph.resize(this.canvas.width, this.canvas.height);
      camera.aspect = this.canvas.width / this.canvas.height;
      console.log(`Engine: Camera aspect updated to ${camera.aspect}`);
    }
    let currentSource = null;
    if (this.gBuffer && this.gBuffer.accumulationTexture) {
      currentSource = this.gBuffer.accumulationTexture;
    }
    if (this.ssrPass && this.ssrPass.enabled && currentSource) {
      this.ssrPass.setInputTexture(currentSource);
    }
    let godRaysOutput = null;
    if (this.godRaysPass && this.godRaysPass.enabled && currentSource) {
      this.godRaysPass.setInputTexture(currentSource);
      godRaysOutput = this.godRaysPass.getOutputTexture();
    }
    if (this.taaPass && this.taaPass.enabled) {
      const taaHistory = this.taaPass.getHistoryTexture();
      if (taaHistory) {
        currentSource = taaHistory;
      }
      if (this.ssgiPass) {
        const prevFrame = this.taaPass.getPreviousFrameTexture();
        if (prevFrame) {
          this.ssgiPass.setPreviousFrameTexture(prevFrame);
        }
      }
    }
    if (this.fxaaPass && this.fxaaPass.enabled && currentSource) {
      this.fxaaPass.setInputTexture(currentSource);
      const fxaaOutput = this.fxaaPass.getOutputTexture();
      if (fxaaOutput) {
        currentSource = fxaaOutput;
      }
    }
    if (this.depthOfFieldPass && this.depthOfFieldPass.enabled && currentSource) {
      this.depthOfFieldPass.setInputTexture(currentSource);
      const dofOutput = this.depthOfFieldPass.getOutputTexture();
      if (dofOutput) {
        currentSource = dofOutput;
      }
    }
    if (this.motionBlurPass && this.motionBlurPass.enabled && currentSource) {
      this.motionBlurPass.setInputTexture(currentSource);
      const motionBlurOutput = this.motionBlurPass.getOutputTexture();
      if (motionBlurOutput) {
        currentSource = motionBlurOutput;
      }
    }
    if (this.lensEffectsPass && this.lensEffectsPass.enabled && currentSource) {
      this.lensEffectsPass.setInputTexture(currentSource);
      const lensOutput = this.lensEffectsPass.getOutputTexture();
      if (lensOutput) {
        currentSource = lensOutput;
      }
    }
    let bloomOutput = null;
    if (this.bloomPass && this.bloomPass.enabled && currentSource) {
      this.bloomPass.setInputTexture(currentSource);
      bloomOutput = this.bloomPass.getOutputTexture();
    }
    if (this.toneMappingPass && currentSource) {
      this.toneMappingPass.setInputTexture(currentSource);
      this.toneMappingPass.setBloomTexture(bloomOutput);
      this.toneMappingPass.setGodRaysTexture(godRaysOutput);
    }
    const activeSubScene = scene.findActiveSubScene();
    const effectiveCamera = activeSubScene?.activeCamera ?? camera;
    const effectiveLights = activeSubScene?.lights ?? scene.lights;
    const context = {
      scene,
      camera: effectiveCamera,
      activeSubScene,
      modelMatrix: effectiveCamera.viewMatrix,
      lights: effectiveLights,
      deltaTime: this.currentDeltaTime,
      time: this.totalTime,
      frameStats: {
        triangles: 0,
        drawCalls: 0
      }
    };
    const globalRes = this.renderGraph.getGlobalResources();
    if (globalRes) {
      globalRes.updateLightBuffer(this.device, scene, camera);
      this.device.queue.writeBuffer(globalRes.statsBuffer, 0, Engine.STATS_ZERO_BUFFER);
    }
    this.renderGraph.execute(this.device, context);
    const selectedNode = this.debugger?.getSelectedNode();
    if (selectedNode && this.gBuffer && this.gBuffer.depthTexture && this.context) {
      this.selectionRenderer.setSelectedNode(selectedNode);
      const selectionEncoder = this.device.createCommandEncoder({ label: "Selection Render" });
      const colorView = this.context.getCurrentTexture().createView();
      const depthView = this.gBuffer.depthTexture.createView();
      this.selectionRenderer.render(selectionEncoder, colorView, depthView, camera);
      this.device.queue.submit([selectionEncoder.finish()]);
    }
    if (globalRes && this.statsReadBuffer && this.statsReadBuffer.mapState === "unmapped") {
      const copyEncoder = this.device.createCommandEncoder();
      copyEncoder.copyBufferToBuffer(globalRes.statsBuffer, 0, this.statsReadBuffer, 0, 16);
      this.device.queue.submit([copyEncoder.finish()]);
      this.statsReadBuffer.mapAsync(GPUMapMode.READ).then(() => {
        if (!this.statsReadBuffer)
          return;
        const arrayBuffer = this.statsReadBuffer.getMappedRange();
        const data = new Uint32Array(arrayBuffer);
        this.debugger?.setGpuStats(data[0], data[1]);
        this.statsReadBuffer.unmap();
      }).catch(() => {});
    }
    scene.updatePreviousFrame();
    camera.updatePreviousMatrices();
    this.debugger?.setFrameTriangles(context.frameStats.triangles);
    this.debugger?.setSceneTriangles(scene.totalTriangleCount);
    this.debugger?.update(performance.now());
  }
  preparedScenes = new WeakSet;
  initializingNodes = new WeakSet;
  async prepareScene(scene) {
    if (!this.device)
      return;
    if (this.preparedScenes.has(scene))
      return;
    const device = this.device;
    const pendingInits = [];
    scene.traverse((node) => {
      if (node.needsInit && !this.initializingNodes.has(node)) {
        this.initializingNodes.add(node);
        node._initState = "initializing";
        const initPromise = node.onInit(device).then(() => {
          node._initState = "ready";
          this.initializingNodes.delete(node);
        }).catch((err) => {
          console.error(`Failed to initialize ${node.name}:`, err);
          node._initState = "error";
          this.initializingNodes.delete(node);
        });
        pendingInits.push(initPromise);
      }
    });
    if (pendingInits.length > 0) {
      console.log(`Engine: Initializing ${pendingInits.length} nodes...`);
      await Promise.all(pendingInits);
      console.log(`Engine: Scene preparation complete`);
    }
    this.preparedScenes.add(scene);
  }
  processSceneUpdates(scene, deltaTime) {
    scene.traverse((node) => {
      if (node.needsUpdate && node.initState === "ready") {
        node.onUpdate(deltaTime);
      }
    });
  }
  run(callback) {
    let lastTime = performance.now();
    const loop = (time) => {
      if (!this.device)
        return;
      const dt = (time - lastTime) / 1000;
      lastTime = time;
      this.currentDeltaTime = dt;
      this.totalTime += dt;
      this.lastRenderTime = time;
      callback(dt);
      requestAnimationFrame(loop);
    };
    requestAnimationFrame(loop);
  }
  cleanup() {
    this.debugger?.cleanup();
    this.selectionRenderer.cleanup();
    const device = this.device;
    const context = this.context;
    this.device = null;
    this.context = null;
    try {
      this.statsReadBuffer?.destroy();
    } catch (e) {}
    this.statsReadBuffer = null;
    this.gBuffer = null;
    this.taaPass = null;
    this.ssgiPass = null;
    this.ssaoPass = null;
    this.bloomPass = null;
    this.ssrPass = null;
    this.toneMappingPass = null;
    this.depthOfFieldPass = null;
    this.motionBlurPass = null;
    this.lensEffectsPass = null;
    this.godRaysPass = null;
    if (context) {
      try {
        context.unconfigure();
      } catch (e) {}
    }
    if (device) {
      setTimeout(() => {
        try {
          device.destroy();
        } catch (e) {}
      }, 100);
    }
  }
}
// ../../src/core/InputManager.ts
class InputManager {
  digital = {
    forward: false,
    backward: false,
    left: false,
    right: false,
    up: false,
    down: false
  };
  keys = new Set;
  analog = {
    x: 0,
    y: 0,
    zoom: 0,
    touching: false
  };
  lastPinchDistance = null;
  element;
  handlers = {};
  constructor(element) {
    this.element = element;
    this.setupListeners();
  }
  setupListeners() {
    this.handlers.keydown = (e) => {
      this.keys.add(e.code);
      this.setDigital(e, true);
    };
    this.handlers.keyup = (e) => {
      this.keys.delete(e.code);
      this.setDigital(e, false);
    };
    this.handlers.pointerdown = (e) => {
      this.analog.touching = true;
      try {
        this.element.setPointerCapture(e.pointerId);
      } catch {}
    };
    this.handlers.pointerup = (e) => {
      this.analog.touching = false;
      try {
        this.element.releasePointerCapture(e.pointerId);
      } catch {}
      this.lastPinchDistance = null;
    };
    this.handlers.pointermove = (e) => {
      if (!e.isPrimary && e.pointerType === "touch")
        return;
      const isMouseDown = e.pointerType === "mouse" ? (e.buttons & 1) !== 0 : true;
      if (this.analog.touching || isMouseDown) {
        this.analog.x += e.movementX;
        this.analog.y += e.movementY;
      }
    };
    this.handlers.touchstart = (e) => {
      if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        this.lastPinchDistance = Math.sqrt(dx * dx + dy * dy);
      }
    };
    this.handlers.touchmove = (e) => {
      if (e.touches.length === 2 && this.lastPinchDistance !== null) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const delta = distance - this.lastPinchDistance;
        this.analog.zoom -= delta * 0.05;
        this.lastPinchDistance = distance;
        if (e.cancelable)
          e.preventDefault();
      }
    };
    this.handlers.touchend = (e) => {
      if (e.touches.length < 2) {
        this.lastPinchDistance = null;
      }
    };
    this.handlers.wheel = (e) => {
      e.preventDefault();
      this.analog.zoom += Math.sign(e.deltaY);
    };
    this.handlers.contextmenu = (e) => e.preventDefault();
    window.addEventListener("keydown", this.handlers.keydown);
    window.addEventListener("keyup", this.handlers.keyup);
    this.element.style.touchAction = "none";
    this.element.addEventListener("pointerdown", this.handlers.pointerdown);
    this.element.addEventListener("pointerup", this.handlers.pointerup);
    this.element.addEventListener("pointermove", this.handlers.pointermove);
    this.element.addEventListener("touchstart", this.handlers.touchstart, { passive: false });
    this.element.addEventListener("touchmove", this.handlers.touchmove, { passive: false });
    this.element.addEventListener("touchend", this.handlers.touchend);
    this.element.addEventListener("wheel", this.handlers.wheel, { passive: false });
    this.element.addEventListener("contextmenu", this.handlers.contextmenu);
  }
  dispose() {
    window.removeEventListener("keydown", this.handlers.keydown);
    window.removeEventListener("keyup", this.handlers.keyup);
    this.element.removeEventListener("pointerdown", this.handlers.pointerdown);
    this.element.removeEventListener("pointerup", this.handlers.pointerup);
    this.element.removeEventListener("pointermove", this.handlers.pointermove);
    this.element.removeEventListener("touchstart", this.handlers.touchstart);
    this.element.removeEventListener("touchmove", this.handlers.touchmove);
    this.element.removeEventListener("touchend", this.handlers.touchend);
    this.element.removeEventListener("wheel", this.handlers.wheel);
    this.element.removeEventListener("contextmenu", this.handlers.contextmenu);
  }
  setDigital(e, value) {
    switch (e.code) {
      case "KeyW":
      case "ArrowUp":
        this.digital.forward = value;
        break;
      case "KeyS":
      case "ArrowDown":
        this.digital.backward = value;
        break;
      case "KeyA":
      case "ArrowLeft":
        this.digital.left = value;
        break;
      case "KeyD":
      case "ArrowRight":
        this.digital.right = value;
        break;
      case "Space":
        this.digital.up = value;
        break;
      case "ControlLeft":
      case "KeyC":
        this.digital.down = value;
        break;
    }
  }
  update() {
    const state = {
      digital: { ...this.digital },
      keys: new Set(this.keys),
      analog: { ...this.analog }
    };
    this.analog.x = 0;
    this.analog.y = 0;
    this.analog.zoom = 0;
    return state;
  }
}

// ../../src/core/controllers/CameraController.ts
class CameraController {
  camera;
  constructor(camera) {
    this.camera = camera;
  }
}

// ../../src/core/controllers/WASDController.ts
class WASDController extends CameraController {
  pitch = 0;
  yaw = 0;
  velocity = Vector3.zero;
  movementSpeed = 10;
  rotationSpeed = 1;
  frictionCoefficient = 0.99;
  zoomSpeedMultiplier = 25;
  constructor(camera) {
    super(camera);
    const forward = this.camera.transform.getForwardVector();
    this.pitch = Math.asin(forward.y);
    this.yaw = Math.atan2(-forward.x, -forward.z);
  }
  update(deltaTime, input) {
    this.yaw -= input.analog.x * deltaTime * this.rotationSpeed;
    this.pitch -= input.analog.y * deltaTime * this.rotationSpeed;
    this.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.pitch));
    this.yaw = this.yaw % (Math.PI * 2);
    this.camera.transform.rotation = Quaternion.fromEuler(new Vector3(this.pitch, this.yaw, 0), "YXZ");
    const forward = this.camera.transform.getForwardVector();
    const right = this.camera.transform.getRightVector();
    const up = this.camera.transform.getUpVector();
    let keyboardDir = Vector3.zero;
    if (input.digital.forward)
      keyboardDir = keyboardDir.add(forward);
    if (input.digital.backward)
      keyboardDir = keyboardDir.subtract(forward);
    if (input.digital.right)
      keyboardDir = keyboardDir.add(right);
    if (input.digital.left)
      keyboardDir = keyboardDir.subtract(right);
    if (input.digital.up)
      keyboardDir = keyboardDir.add(up);
    if (input.digital.down)
      keyboardDir = keyboardDir.subtract(up);
    let moveDir = Vector3.zero;
    if (keyboardDir.magnitudeSquared() > 0) {
      moveDir = keyboardDir.normalize().multiply(this.movementSpeed);
    }
    if (input.analog.zoom !== 0) {
      const zoomSpeed = this.movementSpeed * this.zoomSpeedMultiplier;
      moveDir = moveDir.subtract(forward.multiply(input.analog.zoom * zoomSpeed));
    }
    const frictionFactor = Math.pow(1 - this.frictionCoefficient, deltaTime);
    this.velocity = moveDir.lerp(this.velocity, frictionFactor);
    this.camera.transform.position = this.camera.transform.position.add(this.velocity.multiply(deltaTime));
  }
}
// ../../src/core/TextureLibrary.ts
var TEXTURE_REGISTRY = {
  bark: {
    items: ["oak", "birch", "pine", "willow", "palm"],
    basePath: "/mystral/textures/bark",
    extension: "jpg",
    maps: ["color", "normal", "roughness", "ao"],
    namePattern: (name12, map) => `${name12}_${map}_1k`
  },
  leaves: {
    items: ["oak", "birch", "pine", "willow", "palm", "ash", "aspen"],
    basePath: "/mystral/textures/leaves",
    extension: "png",
    maps: ["color"],
    namePattern: (name12, map) => map === "color" ? `${name12}_color` : `${name12}_${map}`
  },
  ground: {
    items: ["grass", "dirt"],
    basePath: "/mystral/textures/ground",
    extension: "jpg",
    maps: ["color", "normal"],
    namePattern: (name12, map) => map === "color" ? name12 : `${name12}_${map}`
  }
};

class TextureLibrary {
  static getPath(category, name12, map = "color") {
    const categoryDef = TEXTURE_REGISTRY[category];
    if (!categoryDef) {
      const available = Object.keys(TEXTURE_REGISTRY).join(", ");
      console.warn(`TextureLibrary: Unknown category '${category}'. ` + `Available categories: ${available}`);
      return "";
    }
    if (!categoryDef.items.includes(name12)) {
      console.warn(`TextureLibrary: Texture '${name12}' not found in category '${category}'. ` + `Available textures: ${categoryDef.items.join(", ")}`);
    }
    if (!categoryDef.maps.includes(map)) {
      console.warn(`TextureLibrary: Map type '${map}' not available for '${category}'. ` + `Available maps: ${categoryDef.maps.join(", ")}`);
      return "";
    }
    const fileName = categoryDef.namePattern(name12, map);
    return `${categoryDef.basePath}/${fileName}.${categoryDef.extension}`;
  }
  static getPBRPaths(category, name12) {
    const categoryDef = TEXTURE_REGISTRY[category];
    const result = {
      color: this.getPath(category, name12, "color")
    };
    if (categoryDef?.maps.includes("normal")) {
      result.normal = this.getPath(category, name12, "normal");
    }
    if (categoryDef?.maps.includes("roughness")) {
      result.roughness = this.getPath(category, name12, "roughness");
    }
    if (categoryDef?.maps.includes("ao")) {
      result.ao = this.getPath(category, name12, "ao");
    }
    if (categoryDef?.maps.includes("displacement")) {
      result.displacement = this.getPath(category, name12, "displacement");
    }
    return result;
  }
  static list(category) {
    if (!category) {
      return Object.keys(TEXTURE_REGISTRY);
    }
    const categoryDef = TEXTURE_REGISTRY[category];
    if (!categoryDef) {
      const available = Object.keys(TEXTURE_REGISTRY).join(", ");
      console.warn(`TextureLibrary: Unknown category '${category}'. ` + `Available categories: ${available}`);
      return [];
    }
    return [...categoryDef.items];
  }
  static listMaps(category) {
    const categoryDef = TEXTURE_REGISTRY[category];
    if (!categoryDef) {
      return [];
    }
    return [...categoryDef.maps];
  }
  static has(category, name12) {
    const categoryDef = TEXTURE_REGISTRY[category];
    return categoryDef?.items.includes(name12) ?? false;
  }
  static register(category, config2) {
    TEXTURE_REGISTRY[category] = config2;
  }
  static suggestPath(wrongPath) {
    const suggestions = [];
    if (wrongPath.includes("/assets/terrain/")) {
      suggestions.push(`Path contains '/assets/terrain/' which doesn't exist. ` + `Did you mean '/mystral/textures/ground/'?`);
    }
    if (wrongPath.includes("/terrain/")) {
      suggestions.push(`Path contains '/terrain/'. Ground textures are at '/mystral/textures/ground/'.`);
    }
    if (!wrongPath.startsWith("/mystral/")) {
      suggestions.push(`Path should start with '/mystral/'. ` + `Available paths: /mystral/textures/bark/, /mystral/textures/leaves/, /mystral/textures/ground/`);
    }
    if (suggestions.length === 0) {
      suggestions.push(`Available categories: ${Object.keys(TEXTURE_REGISTRY).join(", ")}. ` + `Use TextureLibrary.getPath() to get correct paths.`);
    }
    return suggestions.join(`
`);
  }
}
var getTexturePath = TextureLibrary.getPath.bind(TextureLibrary);
var getPBRTexturePaths = TextureLibrary.getPBRPaths.bind(TextureLibrary);
var listTextures = TextureLibrary.list.bind(TextureLibrary);
// ../../src/core/DevWarnings.ts
function isProduction() {
  try {
    return ({ env: {}, url: "" }).env?.PROD === true;
  } catch {
    return false;
  }
}
var defaultConfig = {
  enabled: !isProduction(),
  throwOnError: false,
  level: "warn",
  prefix: "⚠️ Mystral"
};
var config2 = { ...defaultConfig };

class DevWarnings {
  static enable(enabled = true) {
    config2.enabled = enabled;
  }
  static configure(options) {
    config2 = { ...config2, ...options };
  }
  static reset() {
    config2 = { ...defaultConfig };
  }
  static isEnabled() {
    return config2.enabled;
  }
  static warnIf(condition, message, hint) {
    if (!config2.enabled || !condition)
      return;
    this.emit(message, hint);
  }
  static warn(message, hint) {
    if (!config2.enabled)
      return;
    this.emit(message, hint);
  }
  static emit(message, hint) {
    const fullMessage = hint ? `${config2.prefix}: ${message}
   Hint: ${hint}` : `${config2.prefix}: ${message}`;
    if (config2.throwOnError) {
      throw new Error(fullMessage);
    }
    switch (config2.level) {
      case "error":
        console.error(fullMessage);
        break;
      case "info":
        console.info(fullMessage);
        break;
      case "warn":
      default:
        console.warn(fullMessage);
    }
  }
  static checkScale(context, scale2, typicalMin, typicalMax) {
    const tooSmall = scale2 < typicalMin * 0.1;
    const tooLarge = scale2 > typicalMax * 10;
    if (tooSmall) {
      this.warnIf(true, `${context} scale ${scale2} is very small (typical: ${typicalMin}-${typicalMax})`, `Objects may be invisible or extremely tiny`);
    } else if (tooLarge) {
      this.warnIf(true, `${context} scale ${scale2} is very large (typical: ${typicalMin}-${typicalMax})`, `Did you mean ${scale2 / 100}?`);
    }
  }
  static checkFogDensity(density) {
    if (density > 0.02) {
      this.warn(`Fog density ${density} is very high. Typical range: 0.001-0.01`, `Did you mean ${(density / 100).toFixed(4)}? Scene may be completely fogged out.`);
    } else if (density < 0) {
      this.warn(`Fog density ${density} is negative, which is invalid`, `Use a value between 0.001 and 0.01 for typical fog`);
    }
  }
  static checkLightIntensity(context, intensity) {
    if (intensity > 100) {
      this.warn(`${context} intensity ${intensity} is very high (typical: 0.5-10)`, `Scene may be overexposed. Did you mean ${intensity / 100}?`);
    } else if (intensity < 0) {
      this.warn(`${context} intensity ${intensity} is negative, which is invalid`, `Use a positive value`);
    }
  }
  static checkTexturePath(url, context) {
    const prefix = context ? `${context} texture` : "Texture";
    if (url.includes("/assets/terrain/")) {
      this.warn(`${prefix} path contains '/assets/terrain/' which doesn't exist`, `Did you mean '/mystral/textures/ground/'? Use TextureLibrary.getPath() for correct paths.`);
    }
    if (!url.startsWith("/") && !url.startsWith("http")) {
      this.warn(`${prefix} path '${url}' is relative and may not resolve correctly`, `Use absolute paths starting with '/' or use TextureLibrary.getPath()`);
    }
    if (url.includes(".jpeg")) {
      this.warn(`${prefix} uses '.jpeg' extension`, `Most Mystral textures use '.jpg'. Check if the file exists.`);
    }
  }
  static checkCameraPosition(y, farPlane) {
    if (y < 0) {
      this.warnIf(y < -farPlane, `Camera Y position ${y} is below the far plane`, `The camera may not see anything. Did you mean y=${Math.abs(y)}?`);
    }
  }
  static checkResourceLoad(resourceType, path, success) {
    if (!success) {
      this.warn(`Failed to load ${resourceType}: ${path}`, `Check that the file exists and the path is correct. Use TextureLibrary.list() to see available textures.`);
    }
  }
  static checkTreeDensity(treeCount, landscapeSize) {
    const density = treeCount / (landscapeSize * landscapeSize);
    if (density > 0.1) {
      this.warn(`Tree density is very high (${(density * 100).toFixed(1)}% coverage)`, `This may cause performance issues. Consider reducing tree count or increasing landscape size.`);
    }
  }
  static checkRange(context, value, min, max) {
    if (value < min || value > max) {
      this.warn(`${context} value ${value} is outside valid range [${min}, ${max}]`, `Value will be clamped or may cause unexpected behavior`);
    }
  }
  static checkFinite(context, value) {
    if (!Number.isFinite(value)) {
      this.warn(`${context} has invalid value: ${value}`, `Value must be a finite number, not NaN or Infinity`);
    }
  }
}
var warnIf = DevWarnings.warnIf.bind(DevWarnings);
var devWarn = DevWarnings.warn.bind(DevWarnings);
var checkScale = DevWarnings.checkScale.bind(DevWarnings);
var checkFogDensity = DevWarnings.checkFogDensity.bind(DevWarnings);
// ../../src/loaders/GLBLoader.ts
var GLB_MAGIC = 1179937895;
var GLB_VERSION = 2;
var GLB_CHUNK_TYPE_JSON2 = 1313821514;
var GLB_CHUNK_TYPE_BIN2 = 5130562;
var COMPONENT_TYPES = {
  5120: { size: 1, array: Int8Array },
  5121: { size: 1, array: Uint8Array },
  5122: { size: 2, array: Int16Array },
  5123: { size: 2, array: Uint16Array },
  5125: { size: 4, array: Uint32Array },
  5126: { size: 4, array: Float32Array }
};
var TYPE_SIZES = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};

class GLBLoader {
  device;
  textures = new Map;
  materials = new Map;
  constructor(device) {
    this.device = device;
  }
  async load(url) {
    console.log(`GLBLoader: Loading ${url}...`);
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Failed to fetch ${url}: ${response.status}`);
    }
    const buffer = await response.arrayBuffer();
    return this.parse(buffer, url);
  }
  async parse(buffer, baseUrl) {
    const dataView = new DataView(buffer);
    const magic = dataView.getUint32(0, true);
    const version2 = dataView.getUint32(4, true);
    const length = dataView.getUint32(8, true);
    if (magic !== GLB_MAGIC) {
      throw new Error("Invalid GLB magic number");
    }
    if (version2 !== GLB_VERSION) {
      throw new Error(`Unsupported GLB version: ${version2}`);
    }
    let jsonChunk = null;
    let binChunk = null;
    let offset = 12;
    while (offset < length) {
      const chunkLength = dataView.getUint32(offset, true);
      const chunkType = dataView.getUint32(offset + 4, true);
      const chunkData = buffer.slice(offset + 8, offset + 8 + chunkLength);
      if (chunkType === GLB_CHUNK_TYPE_JSON2) {
        jsonChunk = new TextDecoder().decode(chunkData);
      } else if (chunkType === GLB_CHUNK_TYPE_BIN2) {
        binChunk = chunkData;
      }
      offset += 8 + chunkLength;
    }
    if (!jsonChunk) {
      throw new Error("GLB file has no JSON chunk");
    }
    const gltf = JSON.parse(jsonChunk);
    console.log(`GLBLoader: Parsed GLTF - ${gltf.meshes?.length || 0} meshes, ${gltf.materials?.length || 0} materials, ${gltf.images?.length || 0} images`);
    this.textures.clear();
    this.materials.clear();
    if (gltf.textures && gltf.images) {
      await this.loadTextures(gltf, binChunk);
    }
    if (gltf.materials) {
      this.loadMaterials(gltf);
    }
    const rootNode = this.buildSceneGraph(gltf, binChunk);
    return { rootNode };
  }
  async loadTextures(gltf, binChunk) {
    if (!gltf.textures || !gltf.images)
      return;
    for (let i = 0;i < gltf.textures.length; i++) {
      const texDef = gltf.textures[i];
      if (texDef.source === undefined)
        continue;
      const imgDef = gltf.images[texDef.source];
      if (!imgDef)
        continue;
      try {
        let imageData = null;
        if (imgDef.bufferView !== undefined && binChunk) {
          const bufferView = gltf.bufferViews[imgDef.bufferView];
          const start = bufferView.byteOffset || 0;
          imageData = binChunk.slice(start, start + bufferView.byteLength);
        } else if (imgDef.uri) {
          if (imgDef.uri.startsWith("data:")) {
            const base64 = imgDef.uri.split(",")[1];
            const binary = atob(base64);
            const bytes = new Uint8Array(binary.length);
            for (let j = 0;j < binary.length; j++) {
              bytes[j] = binary.charCodeAt(j);
            }
            imageData = bytes.buffer;
          }
        }
        if (imageData) {
          const blob = new Blob([imageData], { type: imgDef.mimeType || "image/png" });
          const bitmap = await createImageBitmap(blob);
          const isSrgb = this.isColorTexture(gltf, i);
          const texture = new Texture(`GLB Texture ${i}`, { srgb: isSrgb });
          texture.createFromImageBitmap(this.device, bitmap);
          this.textures.set(i, texture);
          console.log(`GLBLoader: Loaded texture ${i} (${bitmap.width}x${bitmap.height}, sRGB=${isSrgb})`);
        }
      } catch (e) {
        console.error(`GLBLoader: Failed to load texture ${i}:`, e);
      }
    }
  }
  isColorTexture(gltf, textureIndex) {
    if (!gltf.materials)
      return false;
    for (const mat of gltf.materials) {
      const pbr = mat.pbrMetallicRoughness;
      if (pbr?.baseColorTexture?.index === textureIndex)
        return true;
      if (mat.emissiveTexture?.index === textureIndex)
        return true;
    }
    return false;
  }
  loadMaterials(gltf) {
    if (!gltf.materials)
      return;
    for (let i = 0;i < gltf.materials.length; i++) {
      const matDef = gltf.materials[i];
      const material = new StandardMaterial;
      const pbr = matDef.pbrMetallicRoughness;
      if (pbr) {
        if (pbr.baseColorFactor) {
          material.albedo = new Vector3(pbr.baseColorFactor[0], pbr.baseColorFactor[1], pbr.baseColorFactor[2]);
        }
        if (pbr.baseColorTexture?.index !== undefined) {
          const tex = this.textures.get(pbr.baseColorTexture.index);
          if (tex)
            material.albedoMap = tex;
        }
        material.metallic = pbr.metallicFactor ?? 1;
        material.roughness = pbr.roughnessFactor ?? 1;
        if (pbr.metallicRoughnessTexture?.index !== undefined) {
          const tex = this.textures.get(pbr.metallicRoughnessTexture.index);
          if (tex) {
            material.metallicMap = tex;
            material.roughnessMap = tex;
          }
        }
      }
      if (matDef.normalTexture?.index !== undefined) {
        const tex = this.textures.get(matDef.normalTexture.index);
        if (tex)
          material.normalMap = tex;
      }
      if (matDef.occlusionTexture?.index !== undefined) {
        const tex = this.textures.get(matDef.occlusionTexture.index);
        if (tex)
          material.occlusionMap = tex;
      }
      if (matDef.emissiveFactor) {
        material.emissive = new Vector3(matDef.emissiveFactor[0], matDef.emissiveFactor[1], matDef.emissiveFactor[2]);
      }
      if (matDef.emissiveTexture?.index !== undefined) {
        const tex = this.textures.get(matDef.emissiveTexture.index);
        if (tex)
          material.emissiveMap = tex;
      }
      this.materials.set(i, material);
    }
  }
  buildSceneGraph(gltf, binChunk) {
    const rootNode = new Node("GLB Root");
    const nodeMap = new Map;
    if (gltf.nodes) {
      for (let i = 0;i < gltf.nodes.length; i++) {
        const nodeDef = gltf.nodes[i];
        const node = new Node(nodeDef.name || `Node ${i}`);
        if (nodeDef.translation) {
          node.transform.position = new Vector3(nodeDef.translation[0], nodeDef.translation[1], nodeDef.translation[2]);
        }
        if (nodeDef.rotation) {
          node.transform.rotation = new Quaternion(nodeDef.rotation[0], nodeDef.rotation[1], nodeDef.rotation[2], nodeDef.rotation[3]);
        }
        if (nodeDef.scale) {
          node.transform.scale = new Vector3(nodeDef.scale[0], nodeDef.scale[1], nodeDef.scale[2]);
        }
        if (nodeDef.mesh !== undefined && gltf.meshes && binChunk) {
          const meshDef = gltf.meshes[nodeDef.mesh];
          this.createMesh(node, meshDef, gltf, binChunk);
        }
        nodeMap.set(i, node);
      }
    }
    if (gltf.nodes) {
      for (let i = 0;i < gltf.nodes.length; i++) {
        const nodeDef = gltf.nodes[i];
        const node = nodeMap.get(i);
        if (nodeDef.children) {
          for (const childIdx of nodeDef.children) {
            const childNode = nodeMap.get(childIdx);
            if (childNode) {
              node.addChild(childNode);
            }
          }
        }
      }
    }
    const sceneIdx = gltf.scene ?? 0;
    const scene = gltf.scenes?.[sceneIdx];
    if (scene?.nodes) {
      for (const nodeIdx of scene.nodes) {
        const node = nodeMap.get(nodeIdx);
        if (node) {
          rootNode.addChild(node);
        }
      }
    } else {
      const childNodes = new Set;
      if (gltf.nodes) {
        for (const node of gltf.nodes) {
          if (node.children) {
            for (const child of node.children) {
              childNodes.add(child);
            }
          }
        }
        for (let i = 0;i < gltf.nodes.length; i++) {
          if (!childNodes.has(i)) {
            const node = nodeMap.get(i);
            if (node) {
              rootNode.addChild(node);
            }
          }
        }
      }
    }
    return rootNode;
  }
  createMesh(node, meshDef, gltf, binChunk) {
    for (const primDef of meshDef.primitives) {
      const geometry = new Geometry;
      if (primDef.attributes.POSITION !== undefined) {
        const positions2 = this.readAccessor(gltf, binChunk, primDef.attributes.POSITION);
        if (positions2) {
          geometry.setAttribute("position", positions2);
        }
      }
      if (primDef.attributes.NORMAL !== undefined) {
        const normals = this.readAccessor(gltf, binChunk, primDef.attributes.NORMAL);
        if (normals) {
          geometry.setAttribute("normal", normals);
        }
      }
      if (primDef.attributes.TEXCOORD_0 !== undefined) {
        const uvs = this.readAccessor(gltf, binChunk, primDef.attributes.TEXCOORD_0);
        if (uvs) {
          geometry.setAttribute("uv", uvs);
        }
      }
      if (primDef.attributes.TANGENT !== undefined) {
        const tangents = this.readAccessor(gltf, binChunk, primDef.attributes.TANGENT);
        if (tangents) {
          geometry.setAttribute("tangent", tangents);
        }
      }
      if (primDef.indices !== undefined) {
        const indices = this.readAccessor(gltf, binChunk, primDef.indices);
        if (indices) {
          geometry.setIndices(new Uint32Array(indices));
        }
      }
      const material = primDef.material !== undefined ? this.materials.get(primDef.material) : new StandardMaterial;
      const mesh = new Mesh(geometry, material || new StandardMaterial);
      mesh.name = meshDef.name || "GLB Mesh";
      console.log(`GLBLoader: Created mesh "${mesh.name}" with ${geometry.vertexCount} vertices`);
      if (geometry.attributes["position"]) {
        const pos = geometry.attributes["position"];
        console.log(`GLBLoader: Position attribute has ${pos.length} floats (${pos.length / 3} vertices)`);
      }
      if (geometry.indices) {
        console.log(`GLBLoader: Indices: ${geometry.indices.length} (${geometry.indices.length / 3} triangles)`);
      } else {
        console.log(`GLBLoader: No indices set!`);
      }
      const positions = geometry.attributes["position"];
      if (positions) {
        let minX = Infinity, minY = Infinity, minZ = Infinity;
        let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
        for (let i = 0;i < positions.length; i += 3) {
          minX = Math.min(minX, positions[i]);
          maxX = Math.max(maxX, positions[i]);
          minY = Math.min(minY, positions[i + 1]);
          maxY = Math.max(maxY, positions[i + 1]);
          minZ = Math.min(minZ, positions[i + 2]);
          maxZ = Math.max(maxZ, positions[i + 2]);
        }
        console.log(`GLBLoader: Bounds: (${minX.toFixed(2)}, ${minY.toFixed(2)}, ${minZ.toFixed(2)}) to (${maxX.toFixed(2)}, ${maxY.toFixed(2)}, ${maxZ.toFixed(2)})`);
      }
      node.addChild(mesh);
    }
  }
  readAccessor(gltf, binChunk, accessorIdx) {
    const accessor = gltf.accessors?.[accessorIdx];
    if (!accessor)
      return null;
    const bufferView = gltf.bufferViews?.[accessor.bufferView];
    if (!bufferView)
      return null;
    const componentInfo = COMPONENT_TYPES[accessor.componentType];
    if (!componentInfo) {
      console.warn(`GLBLoader: Unknown component type ${accessor.componentType}`);
      return null;
    }
    const typeSize = TYPE_SIZES[accessor.type];
    if (!typeSize) {
      console.warn(`GLBLoader: Unknown accessor type ${accessor.type}`);
      return null;
    }
    const byteOffset = (bufferView.byteOffset || 0) + (accessor.byteOffset || 0);
    const elementCount = accessor.count * typeSize;
    const ArrayType = componentInfo.array;
    const data = new ArrayType(binChunk, byteOffset, elementCount);
    return data;
  }
}
async function loadGLBModel(device, url) {
  const loader = new GLBLoader(device);
  try {
    console.log(`loadGLBModel: Loading ${url}...`);
    const result = await loader.load(url);
    console.log(`loadGLBModel: Loaded ${url}`, result.rootNode);
    return result.rootNode;
  } catch (e) {
    console.error(`loadGLBModel: Failed to load ${url}`, e);
    return null;
  }
}
// ../../src/loaders/HDRLoader.ts
class HDRLoader {
  static async load(device, url) {
    const response = await fetch(url);
    if (!response.ok)
      throw new Error(`HDRLoader: Failed to fetch ${url}`);
    const buffer = await response.arrayBuffer();
    return this.parse(device, buffer, url);
  }
  static parse(device, buffer, label = "HDR Texture") {
    const data = new Uint8Array(buffer);
    let pos = 0;
    while (pos < data.length) {
      let line = "";
      while (pos < data.length && data[pos] !== 10) {
        line += String.fromCharCode(data[pos]);
        pos++;
      }
      pos++;
      if (line.endsWith("\r"))
        line = line.slice(0, -1);
      if (line.length === 0)
        break;
    }
    let width = 0;
    let height = 0;
    const resLine = (() => {
      let line = "";
      while (pos < data.length && data[pos] !== 10) {
        line += String.fromCharCode(data[pos]);
        pos++;
      }
      pos++;
      if (line.endsWith("\r"))
        line = line.slice(0, -1);
      return line;
    })();
    const parts = resLine.trim().split(/\s+/);
    for (let i = 0;i < parts.length; i++) {
      if (parts[i] === "-Y" || parts[i] === "+Y")
        height = parseInt(parts[i + 1]);
      if (parts[i] === "+X" || parts[i] === "-X")
        width = parseInt(parts[i + 1]);
    }
    if (width === 0 || height === 0) {
      throw new Error(`HDRLoader: Invalid resolution in header: "${resLine}"`);
    }
    const floatData = new Float32Array(width * height * 4);
    this.readRGBE(data, pos, width, height, floatData);
    let maxVal = 0;
    for (let i = 0;i < floatData.length; i += 4) {
      const lum = floatData[i] * 0.2126 + floatData[i + 1] * 0.7152 + floatData[i + 2] * 0.0722;
      if (lum > maxVal)
        maxVal = lum;
    }
    console.log(`HDRLoader: Max Luminance in image: ${maxVal.toFixed(2)}`);
    const texture = new Texture(label);
    texture.gpuTexture = device.createTexture({
      label,
      size: [width, height, 1],
      format: "rgba16float",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
    });
    const halfData = this.packToHalf(floatData);
    device.queue.writeTexture({ texture: texture.gpuTexture }, halfData, { bytesPerRow: width * 8, rowsPerImage: height }, [width, height, 1]);
    texture.view = texture.gpuTexture.createView();
    texture.sampler = device.createSampler({
      magFilter: "linear",
      minFilter: "linear"
    });
    return texture;
  }
  static readRGBE(buffer, offset, width, height, out) {
    let ptr = offset;
    const scanlineBuffer = new Uint8Array(width * 4);
    for (let y = 0;y < height; y++) {
      const idxStart = y * width * 4;
      if (ptr + 4 <= buffer.length && buffer[ptr] === 2 && buffer[ptr + 1] === 2 && buffer[ptr + 2] === (width >> 8 & 255) && buffer[ptr + 3] === (width & 255)) {
        ptr += 4;
        for (let ch = 0;ch < 4; ch++) {
          let extracted = 0;
          while (extracted < width) {
            const val = buffer[ptr++];
            if (val > 128) {
              const count = val - 128;
              const runVal = buffer[ptr++];
              for (let i = 0;i < count; i++) {
                scanlineBuffer[extracted + ch * width] = runVal;
                extracted++;
              }
            } else {
              const count = val;
              for (let i = 0;i < count; i++) {
                scanlineBuffer[extracted + ch * width] = buffer[ptr++];
                extracted++;
              }
            }
          }
        }
        for (let x = 0;x < width; x++) {
          const r = scanlineBuffer[x];
          const g = scanlineBuffer[x + width];
          const b = scanlineBuffer[x + 2 * width];
          const e = scanlineBuffer[x + 3 * width];
          const outIdx = idxStart + x * 4;
          if (e === 0) {
            out[outIdx] = 0;
            out[outIdx + 1] = 0;
            out[outIdx + 2] = 0;
            out[outIdx + 3] = 1;
          } else {
            const f = Math.pow(2, e - 128 - 8);
            out[outIdx] = r * f;
            out[outIdx + 1] = g * f;
            out[outIdx + 2] = b * f;
            out[outIdx + 3] = 1;
          }
        }
      } else {
        for (let x = 0;x < width; x++) {
          const r = buffer[ptr++];
          const g = buffer[ptr++];
          const b = buffer[ptr++];
          const e = buffer[ptr++];
          const outIdx = idxStart + x * 4;
          if (e === 0) {
            out[outIdx] = 0;
            out[outIdx + 1] = 0;
            out[outIdx + 2] = 0;
            out[outIdx + 3] = 1;
          } else {
            const f = Math.pow(2, e - 128 - 8);
            out[outIdx] = r * f;
            out[outIdx + 1] = g * f;
            out[outIdx + 2] = b * f;
            out[outIdx + 3] = 1;
          }
        }
      }
    }
  }
  static packToHalf(data) {
    const out = new Uint16Array(data.length);
    const floatView = new Float32Array(1);
    const int32View = new Int32Array(floatView.buffer);
    const HALF_MAX = 31743;
    const toHalf = (val) => {
      if (Number.isNaN(val))
        return 0;
      floatView[0] = val;
      const x = int32View[0];
      const bits = x >> 16 & 32768;
      let m = x >> 12 & 2047;
      const e = x >> 23 & 255;
      if (e < 103)
        return bits;
      if (e > 142)
        return bits | HALF_MAX;
      if (e < 113) {
        m |= 2048;
        return bits | (m >> 114 - e) + (m >> 113 - e & 1);
      }
      return bits | e - 112 << 10 | (m >> 1) + (m & 1);
    };
    for (let i = 0;i < data.length; i++) {
      out[i] = toHalf(data[i]);
    }
    return out;
  }
}
// ../../src/core/controllers/ArcballController.ts
class ArcballController extends CameraController {
  distance = 0;
  angularVelocity = 0;
  axis = Vector3.up.clone();
  rotationSpeed = 1;
  zoomSpeed = 0.5;
  frictionCoefficient = 0.999;
  target = Vector3.zero;
  constructor(camera, target = Vector3.zero) {
    super(camera);
    this.target = target.clone();
    this.distance = this.camera.transform.position.distanceTo(this.target);
    this.camera.transform.lookAt(this.target);
  }
  update(deltaTime, input) {
    const epsilon = 0.0000001;
    if (input.analog.touching) {
      this.angularVelocity = 0;
    } else {
      this.angularVelocity *= Math.pow(1 - this.frictionCoefficient, deltaTime);
    }
    const right = this.camera.transform.getRightVector();
    const up = this.camera.transform.getUpVector();
    let back = this.camera.transform.getForwardVector().multiply(-1);
    let movement = Vector3.zero;
    movement = movement.add(right.multiply(input.analog.x));
    movement = movement.add(up.multiply(-input.analog.y));
    const crossProduct = movement.cross(back);
    const magnitude = crossProduct.magnitude();
    if (magnitude > epsilon) {
      this.axis = crossProduct.multiply(1 / magnitude);
      this.angularVelocity = magnitude * this.rotationSpeed;
    }
    const rotationAngle = this.angularVelocity * deltaTime;
    if (rotationAngle > epsilon) {
      const rotQuat = Quaternion.fromAxisAngle(this.axis, rotationAngle);
      const rotMat = rotQuat.toMatrix4();
      back = rotMat.transformDirection(back).normalize();
      const newRight = up.cross(back).normalize();
      const newUp = back.cross(newRight).normalize();
      const matrix = new Matrix4([
        newRight.x,
        newRight.y,
        newRight.z,
        0,
        newUp.x,
        newUp.y,
        newUp.z,
        0,
        back.x,
        back.y,
        back.z,
        0,
        0,
        0,
        0,
        1
      ]);
      this.camera.transform.rotation = Quaternion.fromRotationMatrix(matrix);
    }
    if (input.analog.zoom !== 0) {
      this.distance *= 1 + input.analog.zoom * this.zoomSpeed;
      this.distance = Math.max(0.1, this.distance);
    }
    const currentBack = this.camera.transform.getForwardVector().multiply(-1);
    this.camera.transform.position = this.target.add(currentBack.multiply(this.distance));
  }
}
// ../../src/core/controllers/ThirdPersonController.ts
class ThirdPersonController extends CameraController {
  target = null;
  distance;
  minDistance;
  maxDistance;
  heightOffset;
  minPitch;
  maxPitch;
  rotationSpeed;
  zoomSpeed;
  followSmoothness;
  rotationSmoothness;
  shoulderOffset;
  pitch;
  currentDistance;
  targetYaw = 0;
  targetPitch;
  smoothedPosition = Vector3.zero;
  smoothedYaw = 0;
  smoothedPitch;
  constructor(camera, config3 = {}) {
    super(camera);
    this.distance = config3.distance ?? 5;
    this.minDistance = config3.minDistance ?? 2;
    this.maxDistance = config3.maxDistance ?? 15;
    this.heightOffset = config3.heightOffset ?? 1.5;
    this.pitch = config3.initialPitch ?? 0.3;
    this.minPitch = config3.minPitch ?? -Math.PI / 3;
    this.maxPitch = config3.maxPitch ?? Math.PI / 2.5;
    this.rotationSpeed = config3.rotationSpeed ?? 1;
    this.zoomSpeed = config3.zoomSpeed ?? 1;
    this.followSmoothness = config3.followSmoothness ?? 0.1;
    this.rotationSmoothness = config3.rotationSmoothness ?? 0.15;
    this.shoulderOffset = config3.shoulderOffset?.clone() ?? Vector3.zero;
    this.currentDistance = this.distance;
    this.targetPitch = this.pitch;
    this.smoothedPitch = this.pitch;
  }
  setTarget(target) {
    this.target = target;
    if (target) {
      this.smoothedPosition = target.transform.position.clone();
    }
  }
  getForwardDirection() {
    return new Vector3(-Math.sin(this.smoothedYaw), 0, -Math.cos(this.smoothedYaw)).normalize();
  }
  getRightDirection() {
    return new Vector3(Math.cos(this.smoothedYaw), 0, -Math.sin(this.smoothedYaw)).normalize();
  }
  inputToWorldDirection(inputX, inputZ) {
    const forward = this.getForwardDirection();
    const right = this.getRightDirection();
    return forward.multiply(inputZ).add(right.multiply(inputX));
  }
  update(deltaTime, input) {
    if (!this.target)
      return;
    this.targetYaw -= input.analog.x * deltaTime * this.rotationSpeed;
    this.targetPitch -= input.analog.y * deltaTime * this.rotationSpeed;
    this.targetPitch = Math.max(this.minPitch, Math.min(this.maxPitch, this.targetPitch));
    this.targetYaw = this.targetYaw % (Math.PI * 2);
    this.currentDistance += input.analog.zoom * this.zoomSpeed;
    this.currentDistance = Math.max(this.minDistance, Math.min(this.maxDistance, this.currentDistance));
    this.smoothedYaw = this.lerpAngle(this.smoothedYaw, this.targetYaw, this.rotationSmoothness);
    this.smoothedPitch = this.lerpFloat(this.smoothedPitch, this.targetPitch, this.rotationSmoothness);
    const targetPos = this.target.transform.position.add(new Vector3(0, this.heightOffset, 0));
    this.smoothedPosition = this.smoothedPosition.lerp(targetPos, this.followSmoothness);
    const cosPitch = Math.cos(this.smoothedPitch);
    const sinPitch = Math.sin(this.smoothedPitch);
    const cosYaw = Math.cos(this.smoothedYaw);
    const sinYaw = Math.sin(this.smoothedYaw);
    const offset = new Vector3(sinYaw * cosPitch * this.currentDistance, sinPitch * this.currentDistance, cosYaw * cosPitch * this.currentDistance);
    const rotatedShoulderOffset = new Vector3(this.shoulderOffset.x * cosYaw - this.shoulderOffset.z * sinYaw, this.shoulderOffset.y, this.shoulderOffset.x * sinYaw + this.shoulderOffset.z * cosYaw);
    const cameraPos = this.smoothedPosition.add(offset).add(rotatedShoulderOffset);
    this.camera.transform.position = cameraPos;
    const lookTarget = this.smoothedPosition.add(rotatedShoulderOffset);
    this.camera.transform.lookAt(lookTarget);
  }
  resetBehindTarget() {
    if (!this.target)
      return;
    const targetForward = this.target.transform.getForwardVector();
    this.targetYaw = Math.atan2(-targetForward.x, -targetForward.z);
    this.smoothedYaw = this.targetYaw;
  }
  setYaw(yaw) {
    this.targetYaw = yaw;
    this.smoothedYaw = yaw;
  }
  setPitch(pitch) {
    this.targetPitch = Math.max(this.minPitch, Math.min(this.maxPitch, pitch));
    this.smoothedPitch = this.targetPitch;
  }
  setDistance(distance) {
    this.currentDistance = Math.max(this.minDistance, Math.min(this.maxDistance, distance));
  }
  getYaw() {
    return this.smoothedYaw;
  }
  getPitch() {
    return this.smoothedPitch;
  }
  getDistance() {
    return this.currentDistance;
  }
  lerpFloat(a, b, t) {
    return a + (b - a) * Math.min(1, t);
  }
  lerpAngle(a, b, t) {
    let diff = b - a;
    while (diff > Math.PI)
      diff -= Math.PI * 2;
    while (diff < -Math.PI)
      diff += Math.PI * 2;
    return a + diff * Math.min(1, t);
  }
}
// ../../src/core/physics/Collider.ts
class Collider {
  offset = Vector3.zero;
  isTrigger = false;
  layer = 0;
}

class AABB2 {
  min;
  max;
  constructor(min = Vector3.zero, max = Vector3.zero) {
    this.min = min.clone();
    this.max = max.clone();
  }
  get center() {
    return this.min.add(this.max).multiply(0.5);
  }
  get size() {
    return this.max.subtract(this.min);
  }
  get halfExtents() {
    return this.size.multiply(0.5);
  }
  containsPoint(point) {
    return point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y && point.z >= this.min.z && point.z <= this.max.z;
  }
  intersects(other) {
    return this.min.x <= other.max.x && this.max.x >= other.min.x && this.min.y <= other.max.y && this.max.y >= other.min.y && this.min.z <= other.max.z && this.max.z >= other.min.z;
  }
  getPenetration(other) {
    if (!this.intersects(other))
      return null;
    const overlapX = Math.min(this.max.x - other.min.x, other.max.x - this.min.x);
    const overlapY = Math.min(this.max.y - other.min.y, other.max.y - this.min.y);
    const overlapZ = Math.min(this.max.z - other.min.z, other.max.z - this.min.z);
    if (overlapX <= overlapY && overlapX <= overlapZ) {
      const normal = this.center.x < other.center.x ? new Vector3(-1, 0, 0) : new Vector3(1, 0, 0);
      return { depth: overlapX, normal };
    } else if (overlapY <= overlapX && overlapY <= overlapZ) {
      const normal = this.center.y < other.center.y ? new Vector3(0, -1, 0) : new Vector3(0, 1, 0);
      return { depth: overlapY, normal };
    } else {
      const normal = this.center.z < other.center.z ? new Vector3(0, 0, -1) : new Vector3(0, 0, 1);
      return { depth: overlapZ, normal };
    }
  }
  expand(amount) {
    return new AABB2(this.min.subtract(new Vector3(amount, amount, amount)), this.max.add(new Vector3(amount, amount, amount)));
  }
  clone() {
    return new AABB2(this.min.clone(), this.max.clone());
  }
  static fromCenterSize(center, size) {
    const halfSize = size.multiply(0.5);
    return new AABB2(center.subtract(halfSize), center.add(halfSize));
  }
}

class BoxCollider extends Collider {
  halfExtents;
  constructor(halfExtents = new Vector3(0.5, 0.5, 0.5)) {
    super();
    this.halfExtents = halfExtents.clone();
  }
  getType() {
    return "box";
  }
  getBoundingBox(worldPosition) {
    const center = worldPosition.add(this.offset);
    return new AABB2(center.subtract(this.halfExtents), center.add(this.halfExtents));
  }
  containsPoint(worldPosition, point) {
    return this.getBoundingBox(worldPosition).containsPoint(point);
  }
}

class SphereCollider extends Collider {
  radius;
  constructor(radius = 0.5) {
    super();
    this.radius = radius;
  }
  getType() {
    return "sphere";
  }
  getBoundingBox(worldPosition) {
    const center = worldPosition.add(this.offset);
    const r = new Vector3(this.radius, this.radius, this.radius);
    return new AABB2(center.subtract(r), center.add(r));
  }
  containsPoint(worldPosition, point) {
    const center = worldPosition.add(this.offset);
    return center.subtract(point).magnitudeSquared() <= this.radius * this.radius;
  }
  intersectsSphere(worldPositionA, other, worldPositionB) {
    const centerA = worldPositionA.add(this.offset);
    const centerB = worldPositionB.add(other.offset);
    const delta = centerB.subtract(centerA);
    const distSq = delta.magnitudeSquared();
    const radiusSum = this.radius + other.radius;
    if (distSq >= radiusSum * radiusSum)
      return null;
    const dist = Math.sqrt(distSq);
    const normal = dist > 0.0001 ? delta.normalize() : new Vector3(0, 1, 0);
    const depth = radiusSum - dist;
    return { depth, normal };
  }
}

class CapsuleCollider extends Collider {
  radius;
  height;
  constructor(radius = 0.5, height = 2) {
    super();
    this.radius = radius;
    this.height = Math.max(height, radius * 2);
  }
  getType() {
    return "capsule";
  }
  get halfHeight() {
    return (this.height - this.radius * 2) / 2;
  }
  getSegmentPoints(worldPosition) {
    const center = worldPosition.add(this.offset);
    const hh = this.halfHeight;
    return {
      top: center.add(new Vector3(0, hh, 0)),
      bottom: center.subtract(new Vector3(0, hh, 0))
    };
  }
  getBoundingBox(worldPosition) {
    const center = worldPosition.add(this.offset);
    const halfExtent = new Vector3(this.radius, this.height / 2, this.radius);
    return new AABB2(center.subtract(halfExtent), center.add(halfExtent));
  }
  containsPoint(worldPosition, point) {
    const { top, bottom } = this.getSegmentPoints(worldPosition);
    const closest = closestPointOnLineSegment(bottom, top, point);
    return closest.subtract(point).magnitudeSquared() <= this.radius * this.radius;
  }
  intersectsSphere(worldPosition, sphere, sphereWorldPosition) {
    const { top, bottom } = this.getSegmentPoints(worldPosition);
    const sphereCenter = sphereWorldPosition.add(sphere.offset);
    const closest = closestPointOnLineSegment(bottom, top, sphereCenter);
    const delta = sphereCenter.subtract(closest);
    const distSq = delta.magnitudeSquared();
    const radiusSum = this.radius + sphere.radius;
    if (distSq >= radiusSum * radiusSum)
      return null;
    const dist = Math.sqrt(distSq);
    const normal = dist > 0.0001 ? delta.normalize() : new Vector3(0, 1, 0);
    const depth = radiusSum - dist;
    return { depth, normal };
  }
  intersectsCapsule(worldPositionA, other, worldPositionB) {
    const segA = this.getSegmentPoints(worldPositionA);
    const segB = other.getSegmentPoints(worldPositionB);
    const { closestA, closestB } = closestPointsBetweenSegments(segA.bottom, segA.top, segB.bottom, segB.top);
    const delta = closestB.subtract(closestA);
    const distSq = delta.magnitudeSquared();
    const radiusSum = this.radius + other.radius;
    if (distSq >= radiusSum * radiusSum)
      return null;
    const dist = Math.sqrt(distSq);
    const normal = dist > 0.0001 ? delta.normalize() : new Vector3(0, 1, 0);
    const depth = radiusSum - dist;
    return { depth, normal };
  }
  intersectsBox(worldPosition, box, boxWorldPosition) {
    const { top, bottom } = this.getSegmentPoints(worldPosition);
    const aabb = box.getBoundingBox(boxWorldPosition);
    const closestOnSegment = closestPointOnLineSegment(bottom, top, aabb.center);
    const closestOnBox = closestPointOnAABB(aabb, closestOnSegment);
    const delta = closestOnSegment.subtract(closestOnBox);
    const distSq = delta.magnitudeSquared();
    if (distSq >= this.radius * this.radius)
      return null;
    const dist = Math.sqrt(distSq);
    if (dist < 0.0001) {
      const dx1 = closestOnSegment.x - aabb.min.x;
      const dx2 = aabb.max.x - closestOnSegment.x;
      const dy1 = closestOnSegment.y - aabb.min.y;
      const dy2 = aabb.max.y - closestOnSegment.y;
      const dz1 = closestOnSegment.z - aabb.min.z;
      const dz2 = aabb.max.z - closestOnSegment.z;
      const minDist = Math.min(dx1, dx2, dy1, dy2, dz1, dz2);
      let normal2;
      if (minDist === dx1)
        normal2 = new Vector3(-1, 0, 0);
      else if (minDist === dx2)
        normal2 = new Vector3(1, 0, 0);
      else if (minDist === dy1)
        normal2 = new Vector3(0, -1, 0);
      else if (minDist === dy2)
        normal2 = new Vector3(0, 1, 0);
      else if (minDist === dz1)
        normal2 = new Vector3(0, 0, -1);
      else
        normal2 = new Vector3(0, 0, 1);
      return { depth: this.radius + minDist, normal: normal2 };
    }
    const normal = delta.normalize();
    const depth = this.radius - dist;
    return { depth, normal };
  }
}
function closestPointOnLineSegment(segA, segB, point) {
  const ab = segB.subtract(segA);
  const ap = point.subtract(segA);
  const lengthSq = ab.magnitudeSquared();
  if (lengthSq < 0.0001)
    return segA.clone();
  let t = ap.dot(ab) / lengthSq;
  t = Math.max(0, Math.min(1, t));
  return segA.add(ab.multiply(t));
}
function closestPointsBetweenSegments(a0, a1, b0, b1) {
  const d12 = a1.subtract(a0);
  const d2 = b1.subtract(b0);
  const r = a0.subtract(b0);
  const a = d12.dot(d12);
  const e = d2.dot(d2);
  const f = d2.dot(r);
  let s = 0, t = 0;
  if (a < 0.0001 && e < 0.0001) {
    return { closestA: a0.clone(), closestB: b0.clone() };
  }
  if (a < 0.0001) {
    s = 0;
    t = Math.max(0, Math.min(1, f / e));
  } else {
    const c = d12.dot(r);
    if (e < 0.0001) {
      t = 0;
      s = Math.max(0, Math.min(1, -c / a));
    } else {
      const b = d12.dot(d2);
      const denom = a * e - b * b;
      if (denom !== 0) {
        s = Math.max(0, Math.min(1, (b * f - c * e) / denom));
      } else {
        s = 0;
      }
      t = (b * s + f) / e;
      if (t < 0) {
        t = 0;
        s = Math.max(0, Math.min(1, -c / a));
      } else if (t > 1) {
        t = 1;
        s = Math.max(0, Math.min(1, (b - c) / a));
      }
    }
  }
  return {
    closestA: a0.add(d12.multiply(s)),
    closestB: b0.add(d2.multiply(t))
  };
}
function closestPointOnAABB(aabb, point) {
  return new Vector3(Math.max(aabb.min.x, Math.min(aabb.max.x, point.x)), Math.max(aabb.min.y, Math.min(aabb.max.y, point.y)), Math.max(aabb.min.z, Math.min(aabb.max.z, point.z)));
}
// ../../src/core/physics/RigidBody.ts
class RigidBody {
  type;
  mass;
  friction;
  restitution;
  velocity = Vector3.zero;
  angularVelocity = Vector3.zero;
  linearDamping;
  angularDamping;
  useGravity;
  canSleep = true;
  isSleeping = false;
  sleepThreshold = 0.1;
  collider = null;
  node = null;
  _position = Vector3.zero;
  isKinematic = false;
  _force = Vector3.zero;
  _torque = Vector3.zero;
  constructor(config3 = {}) {
    this.type = config3.type ?? "dynamic" /* Dynamic */;
    this.mass = config3.mass ?? 1;
    this.friction = config3.friction ?? 0.5;
    this.restitution = config3.restitution ?? 0.3;
    this.linearDamping = config3.linearDamping ?? 0;
    this.angularDamping = config3.angularDamping ?? 0.05;
    this.useGravity = config3.useGravity ?? true;
    if (this.type === "kinematic" /* Kinematic */) {
      this.isKinematic = true;
    }
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position = value.clone();
    this.syncToNode();
  }
  addCollider(collider) {
    this.collider = collider;
  }
  addBoxCollider(halfExtents = new Vector3(0.5, 0.5, 0.5)) {
    const collider = new BoxCollider(halfExtents);
    this.collider = collider;
    return collider;
  }
  addSphereCollider(radius = 0.5) {
    const collider = new SphereCollider(radius);
    this.collider = collider;
    return collider;
  }
  addCapsuleCollider(radius = 0.5, height = 2) {
    const collider = new CapsuleCollider(radius, height);
    this.collider = collider;
    return collider;
  }
  attachToNode(node) {
    this.node = node;
    this._position = node.transform.position.clone();
  }
  syncToNode() {
    if (this.node) {
      this.node.transform.position = this._position.clone();
    }
  }
  syncFromNode() {
    if (this.node) {
      this._position = this.node.transform.position.clone();
    }
  }
  applyForce(force) {
    if (this.type === "static" /* Static */)
      return;
    this._force = this._force.add(force);
    this.wake();
  }
  applyForceAtPosition(force, position) {
    if (this.type === "static" /* Static */)
      return;
    this._force = this._force.add(force);
    const r = position.subtract(this._position);
    this._torque = this._torque.add(r.cross(force));
    this.wake();
  }
  applyImpulse(impulse) {
    if (this.type === "static" /* Static */)
      return;
    this.velocity = this.velocity.add(impulse.multiply(1 / this.mass));
    this.wake();
  }
  applyImpulseAtPosition(impulse, position) {
    if (this.type === "static" /* Static */)
      return;
    this.velocity = this.velocity.add(impulse.multiply(1 / this.mass));
    const r = position.subtract(this._position);
    this.angularVelocity = this.angularVelocity.add(r.cross(impulse).multiply(1 / this.mass));
    this.wake();
  }
  applyTorque(torque) {
    if (this.type === "static" /* Static */)
      return;
    this._torque = this._torque.add(torque);
    this.wake();
  }
  setVelocity(velocity) {
    this.velocity = velocity.clone();
    this.wake();
  }
  movePosition(position) {
    if (this.type === "kinematic" /* Kinematic */) {
      this._position = position.clone();
      this.syncToNode();
    }
  }
  integrateForces(dt, gravity) {
    if (this.type === "static" /* Static */ || this.isSleeping)
      return;
    if (this.useGravity && this.type === "dynamic" /* Dynamic */) {
      this.velocity = this.velocity.add(gravity.multiply(dt));
    }
    if (this._force.magnitudeSquared() > 0) {
      this.velocity = this.velocity.add(this._force.multiply(dt / this.mass));
      this._force = Vector3.zero;
    }
    if (this._torque.magnitudeSquared() > 0) {
      this.angularVelocity = this.angularVelocity.add(this._torque.multiply(dt / this.mass));
      this._torque = Vector3.zero;
    }
    this.velocity = this.velocity.multiply(1 - this.linearDamping);
    this.angularVelocity = this.angularVelocity.multiply(1 - this.angularDamping);
  }
  integratePosition(dt) {
    if (this.type === "static" /* Static */ || this.isSleeping)
      return;
    this._position = this._position.add(this.velocity.multiply(dt));
    this.syncToNode();
    if (this.canSleep) {
      if (this.velocity.magnitudeSquared() < this.sleepThreshold * this.sleepThreshold && this.angularVelocity.magnitudeSquared() < this.sleepThreshold * this.sleepThreshold) {
        this.sleep();
      }
    }
  }
  sleep() {
    if (!this.canSleep)
      return;
    this.isSleeping = true;
    this.velocity = Vector3.zero;
    this.angularVelocity = Vector3.zero;
  }
  wake() {
    this.isSleeping = false;
  }
  setStatic() {
    this.type = "static" /* Static */;
    this.velocity = Vector3.zero;
    this.angularVelocity = Vector3.zero;
  }
  setDynamic() {
    this.type = "dynamic" /* Dynamic */;
    this.isKinematic = false;
  }
  setKinematic() {
    this.type = "kinematic" /* Kinematic */;
    this.isKinematic = true;
  }
}
// ../../src/core/physics/CharacterController.ts
class CharacterController {
  node;
  physicsWorld;
  body;
  radius;
  height;
  stepHeight;
  slopeLimit;
  moveSpeed;
  jumpForce;
  gravityMultiplier;
  groundFriction;
  stopDeceleration;
  airControl;
  skinWidth;
  _velocity = Vector3.zero;
  _isGrounded = false;
  _groundNormal = null;
  _groundDistance = 0;
  _slopeAngle = 0;
  _coyoteTime = 0;
  _jumpBufferTime = 0;
  COYOTE_DURATION = 0.1;
  JUMP_BUFFER_DURATION = 0.1;
  constructor(node, physicsWorld, config3 = {}) {
    this.node = node;
    this.physicsWorld = physicsWorld;
    this.radius = config3.radius ?? 0.3;
    this.height = config3.height ?? 1.8;
    this.stepHeight = config3.stepHeight ?? 0.3;
    this.slopeLimit = config3.slopeLimit ?? 45;
    this.moveSpeed = config3.moveSpeed ?? 5;
    this.jumpForce = config3.jumpForce ?? 8;
    this.gravityMultiplier = config3.gravityMultiplier ?? 2.5;
    this.groundFriction = config3.groundFriction ?? 0.1;
    this.stopDeceleration = config3.stopDeceleration ?? 0.85;
    this.airControl = config3.airControl ?? 0.3;
    this.skinWidth = config3.skinWidth ?? 0.01;
    this.body = new RigidBody({
      type: "kinematic" /* Kinematic */,
      mass: 70,
      friction: this.groundFriction
    });
    const collider = new CapsuleCollider(this.radius, this.height);
    collider.offset = new Vector3(0, this.height / 2, 0);
    this.body.addCollider(collider);
    this.body.attachToNode(node);
    physicsWorld.addBody(this.body);
  }
  get velocity() {
    return this._velocity.clone();
  }
  get isGrounded() {
    return this._isGrounded;
  }
  get groundInfo() {
    return {
      isGrounded: this._isGrounded,
      normal: this._groundNormal?.clone() ?? null,
      groundDistance: this._groundDistance,
      slopeAngle: this._slopeAngle
    };
  }
  move(input, deltaTime, jump = false) {
    this.detectGround();
    if (jump) {
      this._jumpBufferTime = this.JUMP_BUFFER_DURATION;
    } else {
      this._jumpBufferTime = Math.max(0, this._jumpBufferTime - deltaTime);
    }
    if (this._isGrounded) {
      this._coyoteTime = this.COYOTE_DURATION;
    } else {
      this._coyoteTime = Math.max(0, this._coyoteTime - deltaTime);
    }
    const moveDir = this.getWorldMoveDirection(input);
    if (this._isGrounded || this._coyoteTime > 0) {
      this.applyGroundMovement(moveDir, deltaTime);
    } else {
      this.applyAirMovement(moveDir, deltaTime);
    }
    if (this._jumpBufferTime > 0 && (this._isGrounded || this._coyoteTime > 0)) {
      this.doJump();
      this._jumpBufferTime = 0;
      this._coyoteTime = 0;
    }
    this.applyGravity(deltaTime);
    this.resolveMovement(deltaTime);
  }
  getWorldMoveDirection(input) {
    return new Vector3(input.x, 0, input.z).normalize();
  }
  applyGroundMovement(moveDir, dt) {
    if (moveDir.magnitudeSquared() < 0.01) {
      const decayFactor = Math.pow(1 - this.stopDeceleration, dt * 60);
      this._velocity.x *= decayFactor;
      this._velocity.z *= decayFactor;
      if (Math.abs(this._velocity.x) < 0.01)
        this._velocity.x = 0;
      if (Math.abs(this._velocity.z) < 0.01)
        this._velocity.z = 0;
    } else {
      let finalDir = moveDir;
      if (this._groundNormal && this._slopeAngle > 0.1) {
        const right = moveDir.cross(Vector3.up);
        if (right.magnitudeSquared() > 0.001) {
          const slopeDir = this._groundNormal.cross(right.normalize()).normalize();
          finalDir = slopeDir.multiply(moveDir.magnitude());
        }
      }
      const targetVel = finalDir.multiply(this.moveSpeed);
      const acceleration = 25;
      this._velocity.x = this.lerpFloat(this._velocity.x, targetVel.x, acceleration * dt);
      this._velocity.z = this.lerpFloat(this._velocity.z, targetVel.z, acceleration * dt);
      if (finalDir.y !== 0) {
        this._velocity.y = this.lerpFloat(this._velocity.y, targetVel.y, acceleration * dt);
      }
    }
  }
  applyAirMovement(moveDir, dt) {
    if (moveDir.magnitudeSquared() < 0.01)
      return;
    const airAccel = this.moveSpeed * this.airControl * 10;
    const targetVel = moveDir.multiply(this.moveSpeed);
    this._velocity.x = this.lerpFloat(this._velocity.x, targetVel.x, airAccel * dt);
    this._velocity.z = this.lerpFloat(this._velocity.z, targetVel.z, airAccel * dt);
  }
  applyGravity(dt) {
    if (!this._isGrounded) {
      const gravity = this.physicsWorld.gravity.y * this.gravityMultiplier;
      this._velocity.y += gravity * dt;
      this._velocity.y = Math.max(this._velocity.y, -50);
    } else if (this._velocity.y < 0) {
      this._velocity.y = -0.5;
    }
  }
  doJump() {
    this._velocity.y = this.jumpForce;
    this._isGrounded = false;
  }
  resolveMovement(dt) {
    const startPos = this.body.position.clone();
    const horizontalVel = new Vector3(this._velocity.x, 0, this._velocity.z);
    const hasHorizontalMovement = horizontalVel.magnitudeSquared() > 0.001;
    const result = this.physicsWorld.moveAndSlide(this.body, this._velocity, dt);
    const endPos = result.position;
    const actualHorizontalMove = new Vector3(endPos.x - startPos.x, 0, endPos.z - startPos.z);
    const expectedHorizontalMove = horizontalVel.multiply(dt);
    const wasBlocked = hasHorizontalMovement && this._isGrounded && actualHorizontalMove.magnitude() < expectedHorizontalMove.magnitude() * 0.5;
    if (wasBlocked && this.stepHeight > 0) {
      const blockedPos = result.position.clone();
      const stepUpPos = startPos.add(new Vector3(0, this.stepHeight, 0));
      this.body.position = stepUpPos;
      const stepResult = this.physicsWorld.moveAndSlide(this.body, new Vector3(this._velocity.x, 0, this._velocity.z), dt);
      const stepHorizontalMove = new Vector3(stepResult.position.x - stepUpPos.x, 0, stepResult.position.z - stepUpPos.z);
      if (stepHorizontalMove.magnitude() > actualHorizontalMove.magnitude() + 0.01) {
        const testPos = stepResult.position;
        const groundCheck = this.physicsWorld.raycast(testPos.add(new Vector3(0, this.height / 2, 0)), new Vector3(0, -1, 0), this.height / 2 + this.stepHeight + 0.1);
        if (groundCheck && groundCheck.body !== this.body) {
          const groundY = groundCheck.point.y;
          this.body.position = new Vector3(testPos.x, groundY, testPos.z);
          this._velocity.y = 0;
          this._isGrounded = true;
          this._groundNormal = groundCheck.normal;
          return;
        }
      }
      this.body.position = blockedPos;
    } else {
      this.body.position = result.position;
    }
    if (result.grounded && this._velocity.y < 0) {
      this._velocity.y = 0;
    }
    if (result.grounded) {
      this._isGrounded = true;
      this._groundNormal = result.normal;
    }
  }
  detectGround() {
    const origin = this.body.position.add(new Vector3(0, this.height / 2, 0));
    const direction = new Vector3(0, -1, 0);
    const maxDistance = this.height / 2 + this.stepHeight + 0.1;
    const hit = this.physicsWorld.raycast(origin, direction, maxDistance);
    if (hit && hit.body !== this.body) {
      this._groundDistance = hit.distance - this.height / 2;
      this._groundNormal = hit.normal;
      this._slopeAngle = Math.acos(Math.min(1, hit.normal.dot(Vector3.up))) * (180 / Math.PI);
      const groundTolerance = 0.15;
      this._isGrounded = this._groundDistance <= groundTolerance && this._slopeAngle <= this.slopeLimit;
    } else {
      this._isGrounded = false;
      this._groundNormal = null;
      this._groundDistance = Infinity;
      this._slopeAngle = 0;
    }
  }
  setPosition(position) {
    this.body.position = position.clone();
    this._velocity = Vector3.zero;
  }
  setVelocity(velocity) {
    this._velocity = velocity.clone();
  }
  addImpulse(impulse) {
    this._velocity = this._velocity.add(impulse);
  }
  forceJump(force) {
    this._velocity.y = force ?? this.jumpForce;
    this._isGrounded = false;
  }
  lerpFloat(a, b, t) {
    return a + (b - a) * Math.min(1, t);
  }
  destroy() {
    this.physicsWorld.removeBody(this.body);
  }
}
// ../../src/core/utils/EquirectangularToCubemap.ts
class EquirectangularToCubemap {
  static pipelines = new WeakMap;
  static bindGroupLayouts = new WeakMap;
  static convert(device, source, resolution = 512) {
    const cubeTexture = new CubeTexture("Converted Cube Map");
    const mipLevels = Math.floor(Math.log2(resolution)) + 1;
    cubeTexture.gpuTexture = device.createTexture({
      label: "Converted Cube Map",
      size: [resolution, resolution, 6],
      format: "rgba16float",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_DST,
      mipLevelCount: mipLevels
    });
    cubeTexture.view = cubeTexture.gpuTexture.createView({ dimension: "cube" });
    cubeTexture.sampler = device.createSampler({ magFilter: "linear", minFilter: "linear", mipmapFilter: "linear" });
    if (!this.pipelines.has(device)) {
      this.createPipeline(device, "rgba16float");
    }
    const pipeline = this.pipelines.get(device);
    const bindGroupLayout = this.bindGroupLayouts.get(device);
    const faceMatrices = [
      [
        0,
        0,
        -1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        1
      ],
      [
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        -1,
        0,
        0,
        0,
        0,
        0,
        0,
        1
      ],
      [
        1,
        0,
        0,
        0,
        0,
        0,
        -1,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1
      ],
      [
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        -1,
        0,
        0,
        0,
        0,
        0,
        1
      ],
      [
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ],
      [
        -1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        -1,
        0,
        0,
        0,
        0,
        1
      ]
    ];
    const commandEncoder = device.createCommandEncoder({ label: "Equirect to Cubemap" });
    for (let i = 0;i < 6; i++) {
      const view = cubeTexture.gpuTexture.createView({
        dimension: "2d",
        baseArrayLayer: i,
        arrayLayerCount: 1,
        mipLevelCount: 1
      });
      const uniformBuffer = device.createBuffer({
        size: 64,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
      });
      const mat = new Float32Array(faceMatrices[i]);
      device.queue.writeBuffer(uniformBuffer, 0, mat);
      const bindGroup = device.createBindGroup({
        layout: bindGroupLayout,
        entries: [
          { binding: 0, resource: { buffer: uniformBuffer } },
          { binding: 1, resource: source.view },
          { binding: 2, resource: source.sampler }
        ]
      });
      const pass = commandEncoder.beginRenderPass({
        colorAttachments: [{
          view,
          loadOp: "clear",
          storeOp: "store"
        }]
      });
      pass.setPipeline(pipeline);
      pass.setBindGroup(0, bindGroup);
      pass.draw(3);
      pass.end();
    }
    device.queue.submit([commandEncoder.finish()]);
    this.generateMipmaps(device, cubeTexture, resolution, mipLevels);
    return cubeTexture;
  }
  static createPipeline(device, format) {
    const bindGroupLayout = device.createBindGroupLayout({
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, sampler: {} }
      ]
    });
    this.bindGroupLayouts.set(device, bindGroupLayout);
    const layout = device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] });
    const code = `
        struct VertexOutput {
            @builtin(position) position : vec4f,
            @location(0) uv : vec2f,
        }

        @vertex
        fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
            var output : VertexOutput;
            let pos = array(vec2f(-1.0, -1.0), vec2f(3.0, -1.0), vec2f(-1.0, 3.0));
            output.position = vec4f(pos[vertexIndex], 0.0, 1.0);
            output.uv = pos[vertexIndex] * 0.5 + 0.5;
            output.uv.y = 1.0 - output.uv.y; // Flip Y
            return output;
        }

        @group(0) @binding(0) var<uniform> faceMatrix : mat4x4f;
        @group(0) @binding(1) var equirectTex : texture_2d<f32>;
        @group(0) @binding(2) var samp : sampler;

        const PI = 3.14159265359;
        const TWO_PI = 6.28318530718;

        @fragment
        fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {
            // UV (0..1) to NDC (-1..1)
            let ndc = vec2f(uv.x * 2.0 - 1.0, 1.0 - uv.y * 2.0); // Flip Y again for direction?
            // Actually, construct ray in view space
            // Face Matrix transforms from View Space to World Space (or Direction)
            
            // Standard Cube Mapping:
            // Right-handed, Y-up.
            // Z- is forward.
            // Matrix should rotate (0,0,-1) to face direction.
            // But we can just use the matrix to rotate the vector (ndc.x, ndc.y, -1.0)?
            // Actually, we usually render a cube geometry. Here we use a fullscreen quad.
            
            let dirRaw = faceMatrix * vec4f(ndc, 1.0, 0.0); // Assume w=0 for direction
            let dir = normalize(dirRaw.xyz);
            
            // Cartesian to Spherical (Equirectangular UV)
            let phi = atan2(dir.z, dir.x);
            let theta = acos(dir.y);
            
            // Map to 0..1
            // phi: -PI..PI -> 0..1
            // theta: 0..PI -> 0..1
            let u = (phi + PI) / TWO_PI;
            let v = theta / PI;
            
            return textureSample(equirectTex, samp, vec2f(u, v));
        }
      `;
    const pipeline = device.createRenderPipeline({
      layout,
      vertex: { module: createShaderModuleSafe(device, { code }), entryPoint: "vs_main" },
      fragment: { module: createShaderModuleSafe(device, { code }), entryPoint: "fs_main", targets: [{ format }] },
      primitive: { topology: "triangle-list" }
    });
    this.pipelines.set(device, pipeline);
  }
  static generateMipmaps(device, texture, size, mips) {
    if (mips <= 1)
      return;
    const blitLayout = device.createBindGroupLayout({
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: { viewDimension: "2d" } },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, sampler: {} }
      ]
    });
    const layout = device.createPipelineLayout({ bindGroupLayouts: [blitLayout] });
    const code = `
        @vertex fn vs_main(@builtin(vertex_index) vi : u32) -> @builtin(position) vec4f {
             let pos = array(vec2f(-1.0, -1.0), vec2f(3.0, -1.0), vec2f(-1.0, 3.0));
             return vec4f(pos[vi], 0.0, 1.0);
        }
        @group(0) @binding(0) var tex : texture_2d<f32>;
        @group(0) @binding(1) var samp : sampler;
        @fragment fn fs_main(@builtin(position) fragCoord : vec4f) -> @location(0) vec4f {
             let uv = fragCoord.xy / vec2f(textureDimensions(tex));
             return textureSample(tex, samp, uv);
        }
      `;
    const pipeline = device.createRenderPipeline({
      layout,
      vertex: { module: createShaderModuleSafe(device, { code }), entryPoint: "vs_main" },
      fragment: { module: createShaderModuleSafe(device, { code }), entryPoint: "fs_main", targets: [{ format: texture.gpuTexture.format }] },
      primitive: { topology: "triangle-list" }
    });
    const sampler = device.createSampler({ minFilter: "linear", magFilter: "linear" });
    const commandEncoder = device.createCommandEncoder({ label: "Mipmap Generation" });
    let srcMip = 0;
    for (let i = 1;i < mips; i++) {
      for (let face = 0;face < 6; face++) {
        const srcView = texture.gpuTexture.createView({
          baseMipLevel: srcMip,
          mipLevelCount: 1,
          baseArrayLayer: face,
          arrayLayerCount: 1,
          dimension: "2d"
        });
        const dstView = texture.gpuTexture.createView({
          baseMipLevel: i,
          mipLevelCount: 1,
          baseArrayLayer: face,
          arrayLayerCount: 1,
          dimension: "2d"
        });
        const bindGroup = device.createBindGroup({
          layout: blitLayout,
          entries: [
            { binding: 0, resource: srcView },
            { binding: 1, resource: sampler }
          ]
        });
        const pass = commandEncoder.beginRenderPass({
          colorAttachments: [{ view: dstView, loadOp: "clear", storeOp: "store" }]
        });
        pass.setPipeline(pipeline);
        pass.setBindGroup(0, bindGroup);
        pass.draw(3);
        pass.end();
      }
      srcMip = i;
    }
    device.queue.submit([commandEncoder.finish()]);
  }
}
// ../../src/core/ui/FocusManager.ts
class FocusCursor {
  position = { x: 0, y: 0 };
  size = { width: 0, height: 0 };
  targetElement = null;
  style = {
    type: "outline",
    color: "#5599ff",
    thickness: 2,
    padding: 4,
    animationSpeed: 8,
    glowRadius: 8
  };
  visible = false;
  _animationPhase = 0;
  _currentX = 0;
  _currentY = 0;
  _currentWidth = 0;
  _currentHeight = 0;
  constructor(style) {
    if (style) {
      this.style = { ...this.style, ...style };
    }
  }
  setTarget(element) {
    this.targetElement = element;
    if (element) {
      const bounds = element.getBounds();
      this.position = { x: bounds.x, y: bounds.y };
      this.size = { width: bounds.width, height: bounds.height };
    }
  }
  update(dt) {
    if (!this.targetElement) {
      this.visible = false;
      return;
    }
    const bounds = this.targetElement.getBounds();
    const targetX = bounds.x - this.style.padding;
    const targetY = bounds.y - this.style.padding;
    const targetWidth = bounds.width + this.style.padding * 2;
    const targetHeight = bounds.height + this.style.padding * 2;
    const speed = this.style.animationSpeed;
    this._currentX += (targetX - this._currentX) * Math.min(1, dt * speed);
    this._currentY += (targetY - this._currentY) * Math.min(1, dt * speed);
    this._currentWidth += (targetWidth - this._currentWidth) * Math.min(1, dt * speed);
    this._currentHeight += (targetHeight - this._currentHeight) * Math.min(1, dt * speed);
    this.position = { x: this._currentX, y: this._currentY };
    this.size = { width: this._currentWidth, height: this._currentHeight };
    this._animationPhase += dt * 3;
    if (this._animationPhase > Math.PI * 2) {
      this._animationPhase -= Math.PI * 2;
    }
  }
  get animationPhase() {
    return this._animationPhase;
  }
  getBounds() {
    return {
      x: this._currentX,
      y: this._currentY,
      width: this._currentWidth,
      height: this._currentHeight
    };
  }
}

class FocusManager {
  focusableElements = new Map;
  _currentFocus = null;
  _inputMode = "mouse";
  _cursor;
  onFocusChange;
  onInputModeChange;
  gamepadIndex = -1;
  lastGamepadInput = 0;
  gamepadDeadzone = 0.5;
  gamepadRepeatDelay = 0.4;
  gamepadRepeatRate = 0.1;
  _repeatTimer = 0;
  _repeatDirection = null;
  constructor() {
    this._cursor = new FocusCursor;
    this.setupGamepadListeners();
  }
  get currentFocus() {
    return this._currentFocus;
  }
  get cursor() {
    return this._cursor;
  }
  get cursorVisible() {
    return this._cursor.visible && this._inputMode !== "mouse";
  }
  get inputMode() {
    return this._inputMode;
  }
  set inputMode(mode) {
    if (this._inputMode !== mode) {
      this._inputMode = mode;
      this._cursor.visible = mode !== "mouse";
      this.onInputModeChange?.(mode);
    }
  }
  register(element) {
    this.focusableElements.set(element.id, element);
  }
  unregister(element) {
    this.focusableElements.delete(element.id);
    if (this._currentFocus === element) {
      this._currentFocus = null;
      this._cursor.setTarget(null);
    }
  }
  setFocus(element) {
    if (this._currentFocus === element)
      return;
    const previous = this._currentFocus;
    if (previous) {
      previous.onBlur();
      previous.setFocus(false);
    }
    this._currentFocus = element;
    if (element) {
      element.onFocus();
      element.setFocus(true);
      this._cursor.setTarget(element);
      this._cursor.visible = this._inputMode !== "mouse";
    } else {
      this._cursor.setTarget(null);
    }
    this.onFocusChange?.(element, previous);
  }
  moveFocus(direction) {
    if (!this._currentFocus) {
      const first = this.getFirstFocusable();
      if (first) {
        this.setFocus(first);
        return true;
      }
      return false;
    }
    let next = null;
    switch (direction) {
      case "up":
        next = this._currentFocus.focusUp ?? null;
        break;
      case "down":
        next = this._currentFocus.focusDown ?? null;
        break;
      case "left":
        next = this._currentFocus.focusLeft ?? null;
        break;
      case "right":
        next = this._currentFocus.focusRight ?? null;
        break;
    }
    if (!next) {
      next = this.findNearestInDirection(this._currentFocus, direction);
    }
    if (next && next !== this._currentFocus) {
      this.setFocus(next);
      return true;
    }
    return false;
  }
  getFirstFocusable() {
    let first = null;
    let lowestOrder = Infinity;
    for (const element of this.focusableElements.values()) {
      if (element.isFocusable && element.visible && element.focusOrder < lowestOrder) {
        first = element;
        lowestOrder = element.focusOrder;
      }
    }
    return first;
  }
  findNearestInDirection(from, direction) {
    const fromBounds = from.getBounds();
    const fromCenterX = fromBounds.x + fromBounds.width / 2;
    const fromCenterY = fromBounds.y + fromBounds.height / 2;
    let best = null;
    let bestScore = Infinity;
    for (const element of this.focusableElements.values()) {
      if (element === from || !element.isFocusable || !element.visible)
        continue;
      const bounds = element.getBounds();
      const centerX = bounds.x + bounds.width / 2;
      const centerY = bounds.y + bounds.height / 2;
      const dx = centerX - fromCenterX;
      const dy = centerY - fromCenterY;
      let inDirection = false;
      let primaryDist = 0;
      let secondaryDist = 0;
      switch (direction) {
        case "up":
          inDirection = dy < -10;
          primaryDist = -dy;
          secondaryDist = Math.abs(dx);
          break;
        case "down":
          inDirection = dy > 10;
          primaryDist = dy;
          secondaryDist = Math.abs(dx);
          break;
        case "left":
          inDirection = dx < -10;
          primaryDist = -dx;
          secondaryDist = Math.abs(dy);
          break;
        case "right":
          inDirection = dx > 10;
          primaryDist = dx;
          secondaryDist = Math.abs(dy);
          break;
      }
      if (!inDirection)
        continue;
      const score = primaryDist + secondaryDist * 2;
      if (score < bestScore) {
        best = element;
        bestScore = score;
      }
    }
    return best;
  }
  submit() {
    if (this._currentFocus?.onSubmit) {
      this._currentFocus.onSubmit();
      return true;
    }
    return false;
  }
  cancel() {
    if (this._currentFocus?.onCancel) {
      this._currentFocus.onCancel();
      return true;
    }
    return false;
  }
  setupGamepadListeners() {
    window.addEventListener("gamepadconnected", (e) => {
      console.log(`Gamepad connected: ${e.gamepad.id}`);
      this.gamepadIndex = e.gamepad.index;
      this.inputMode = "controller";
    });
    window.addEventListener("gamepaddisconnected", (e) => {
      console.log(`Gamepad disconnected: ${e.gamepad.id}`);
      if (this.gamepadIndex === e.gamepad.index) {
        this.gamepadIndex = -1;
      }
    });
  }
  pollGamepad(dt) {
    if (this.gamepadIndex < 0)
      return;
    const gamepads = navigator.getGamepads();
    const gamepad = gamepads[this.gamepadIndex];
    if (!gamepad)
      return;
    const now = performance.now();
    const leftX = gamepad.axes[0] ?? 0;
    const leftY = gamepad.axes[1] ?? 0;
    const dpadUp = gamepad.buttons[12]?.pressed ?? false;
    const dpadDown = gamepad.buttons[13]?.pressed ?? false;
    const dpadLeft = gamepad.buttons[14]?.pressed ?? false;
    const dpadRight = gamepad.buttons[15]?.pressed ?? false;
    let direction = null;
    if (dpadUp || leftY < -this.gamepadDeadzone) {
      direction = "up";
    } else if (dpadDown || leftY > this.gamepadDeadzone) {
      direction = "down";
    } else if (dpadLeft || leftX < -this.gamepadDeadzone) {
      direction = "left";
    } else if (dpadRight || leftX > this.gamepadDeadzone) {
      direction = "right";
    }
    if (direction) {
      if (direction !== this._repeatDirection) {
        this._repeatDirection = direction;
        this._repeatTimer = this.gamepadRepeatDelay;
        this.moveFocus(direction);
        this.lastGamepadInput = now;
      } else {
        this._repeatTimer -= dt;
        if (this._repeatTimer <= 0) {
          this._repeatTimer = this.gamepadRepeatRate;
          this.moveFocus(direction);
        }
      }
    } else {
      this._repeatDirection = null;
      this._repeatTimer = 0;
    }
    const aButton = gamepad.buttons[0];
    if (aButton?.pressed && now - this.lastGamepadInput > 200) {
      this.submit();
      this.lastGamepadInput = now;
    }
    const bButton = gamepad.buttons[1];
    if (bButton?.pressed && now - this.lastGamepadInput > 200) {
      this.cancel();
      this.lastGamepadInput = now;
    }
  }
  handleKeyDown(key) {
    this.inputMode = "keyboard";
    switch (key) {
      case "ArrowUp":
      case "w":
      case "W":
        return this.moveFocus("up");
      case "ArrowDown":
      case "s":
      case "S":
        return this.moveFocus("down");
      case "ArrowLeft":
      case "a":
      case "A":
        return this.moveFocus("left");
      case "ArrowRight":
      case "d":
      case "D":
        return this.moveFocus("right");
      case "Enter":
      case " ":
        return this.submit();
      case "Escape":
        return this.cancel();
    }
    return false;
  }
  handleMouseInput() {
    this.inputMode = "mouse";
  }
  update(dt) {
    this.pollGamepad(dt);
    this._cursor.update(dt);
  }
  clear() {
    this.setFocus(null);
    this.focusableElements.clear();
  }
  destroy() {
    this.clear();
  }
}
// ../../src/core/ui/components/TypewriterBox.ts
class TypewriterBox extends UIElement {
  _speakerName = "";
  _fullText = "";
  _displayedText = "";
  _charIndex = 0;
  _characters = new Map;
  _characterOpacities = new Map;
  _typewriterTimer = 0;
  _isTyping = false;
  _isComplete = false;
  _isPaused = false;
  _pauseRemaining = 0;
  _processedPauseCount = 0;
  _continueIndicatorPhase = 0;
  _animationTime = 0;
  _dialogueQueue = [];
  _currentEntry = null;
  _parsedSegments = [];
  onDialogueStart;
  onDialogueComplete;
  onQueueComplete;
  onCharacterTyped;
  onAdvance;
  onVoiceLine;
  _localizationManager;
  static defaultStyle = {
    anchor: "bottom-center",
    pivot: { x: 0.5, y: 1 },
    width: "90%",
    height: 180,
    y: -20,
    padding: { top: 20, right: 24, bottom: 20, left: 24 },
    zIndex: 900,
    boxBackgroundColor: "rgba(10, 12, 20, 0.92)",
    boxBackgroundAlpha: 1,
    boxBorderColor: "rgba(180, 200, 220, 0.35)",
    boxBorderWidth: 2,
    boxBorderRadius: 8,
    namePlateEnabled: true,
    namePlateBackgroundColor: "rgba(40, 50, 70, 0.6)",
    namePlateBorderRadius: 4,
    namePlatePadding: 8,
    namePlateOffset: { x: 0, y: 0 },
    nameColor: "#e8f0ff",
    nameFontSize: 17,
    nameFontFamily: 'Georgia, "Times New Roman", serif',
    textColor: "#f0f4fa",
    textFontSize: 17,
    textFontFamily: '"Segoe UI", system-ui, -apple-system, sans-serif',
    textLineHeight: 1.65,
    textPadding: { top: 10, right: 0, bottom: 0, left: 0 },
    textShadow: "1px 1px 2px rgba(0, 0, 0, 0.8)",
    textLetterSpacing: "0.015em",
    namePlatePrefix: "◆ ",
    namePlateBorderColor: "rgba(120, 140, 180, 0.3)",
    namePlateBorderWidth: 1,
    typewriterSpeed: 40,
    pausePeriod: 8,
    pauseComma: 3,
    pauseQuestion: 8,
    pauseExclamation: 8,
    continueIndicatorEnabled: true,
    continueIndicatorColor: "rgba(200, 220, 255, 0.9)",
    continueIndicatorSize: 8,
    continueIndicatorOffset: { x: -28, y: -24 },
    continueIndicatorStyle: "bounce",
    characterDisplayHeight: 400,
    characterDimOpacity: 0.5,
    characterTransitionDuration: 0.3
  };
  constructor(style) {
    const mergedStyle = { ...TypewriterBox.defaultStyle, ...style };
    super(mergedStyle);
    this._interactive = true;
    this._visible = false;
  }
  get speakerName() {
    return this._speakerName;
  }
  get fullText() {
    return this._fullText;
  }
  get displayedText() {
    return this._displayedText;
  }
  get isTyping() {
    return this._isTyping;
  }
  get isComplete() {
    return this._isComplete;
  }
  get hasMoreDialogue() {
    return this._dialogueQueue.length > 0;
  }
  get currentEntry() {
    return this._currentEntry;
  }
  setLocalizationManager(manager) {
    this._localizationManager = manager;
  }
  get localizationManager() {
    return this._localizationManager;
  }
  setCharacter(data) {
    this._characters.set(data.id, { ...data });
    if (!this._characterOpacities.has(data.id)) {
      this._characterOpacities.set(data.id, data.opacity ?? 1);
    }
    this.markDirty();
  }
  removeCharacter(id) {
    this._characters.delete(id);
    this._characterOpacities.delete(id);
    this.markDirty();
  }
  clearCharacters() {
    this._characters.clear();
    this._characterOpacities.clear();
    this.markDirty();
  }
  getCharacter(id) {
    return this._characters.get(id);
  }
  setCharacterSpeaking(id, speaking) {
    const char = this._characters.get(id);
    if (char) {
      char.speaking = speaking;
      this.markDirty();
    }
  }
  showDialogue(entry) {
    this._dialogueQueue = [];
    this.startDialogue(entry);
    this.visible = true;
  }
  queueDialogue(entries) {
    this._dialogueQueue = [...entries];
    if (!this._currentEntry) {
      this.advanceDialogue();
    }
    this.visible = true;
  }
  appendDialogue(entries) {
    this._dialogueQueue.push(...entries);
    if (!this._currentEntry) {
      this.advanceDialogue();
    }
    this.visible = true;
  }
  showLocalizedDialogue(entry, localizationManager) {
    const manager = localizationManager ?? this._localizationManager;
    if (!manager) {
      throw new Error("No localization manager set. Call setLocalizationManager() first or pass one to showLocalizedDialogue()");
    }
    const resolved = this.resolveLocalizedEntry(entry, manager);
    this.showDialogue(resolved);
  }
  queueLocalizedDialogue(entries, localizationManager) {
    const manager = localizationManager ?? this._localizationManager;
    if (!manager) {
      throw new Error("No localization manager set. Call setLocalizationManager() first or pass one to queueLocalizedDialogue()");
    }
    const resolved = entries.map((e) => this.resolveLocalizedEntry(e, manager));
    this.queueDialogue(resolved);
  }
  appendLocalizedDialogue(entries, localizationManager) {
    const manager = localizationManager ?? this._localizationManager;
    if (!manager) {
      throw new Error("No localization manager set. Call setLocalizationManager() first or pass one to appendLocalizedDialogue()");
    }
    const resolved = entries.map((e) => this.resolveLocalizedEntry(e, manager));
    this.appendDialogue(resolved);
  }
  resolveLocalizedEntry(entry, manager) {
    const dialogue = manager.getDialogue(entry.textKey, entry.textVars);
    const name12 = entry.nameKey ? manager.t(entry.nameKey, entry.nameVars) : undefined;
    return {
      name: name12,
      text: dialogue.text,
      voiceLine: dialogue.audio,
      speakerId: entry.speakerId,
      nameColor: entry.nameColor,
      textColor: entry.textColor
    };
  }
  startDialogue(entry) {
    this._currentEntry = entry;
    if (entry.name) {
      const { text: strippedName, color: extractedColor } = TypewriterBox.stripRichTextTags(entry.name);
      this._speakerName = strippedName;
      if (!entry.nameColor && extractedColor) {
        entry.nameColor = extractedColor;
      }
    } else {
      this._speakerName = "";
    }
    this._fullText = entry.text;
    this._displayedText = "";
    this._charIndex = 0;
    this._isTyping = true;
    this._isComplete = false;
    this._isPaused = false;
    this._processedPauseCount = 0;
    this._pauseRemaining = 0;
    this._typewriterTimer = 0;
    this._parsedSegments = this.parseRichText(entry.text);
    if (entry.speakerId) {
      for (const [id, char] of this._characters) {
        char.speaking = id === entry.speakerId;
      }
    }
    this.onDialogueStart?.(entry);
    this.markDirty();
  }
  advanceDialogue() {
    if (this._dialogueQueue.length > 0) {
      const next = this._dialogueQueue.shift();
      this.startDialogue(next);
      return true;
    } else {
      this.onQueueComplete?.();
      return false;
    }
  }
  skipTypewriter() {
    if (this._isTyping || this._isPaused) {
      this._displayedText = this.getPlainText(this._parsedSegments);
      this._charIndex = this._displayedText.length;
      this._isTyping = false;
      this._isComplete = true;
      this._isPaused = false;
      this._pauseRemaining = 0;
      if (this._currentEntry) {
        this.onDialogueComplete?.(this._currentEntry);
      }
      this.markDirty();
    }
  }
  advance() {
    this.onAdvance?.();
    if (this._isTyping || this._isPaused) {
      this.skipTypewriter();
      return true;
    } else if (this._isComplete) {
      if (this._dialogueQueue.length > 0) {
        this.advanceDialogue();
        return true;
      } else {
        this.onQueueComplete?.();
        this.hide();
        return false;
      }
    }
    return false;
  }
  hide() {
    this._visible = false;
    this._isTyping = false;
    this._isComplete = false;
    this._currentEntry = null;
    this.markDirty();
  }
  pause() {
    this._visible = false;
    this.markDirty();
  }
  resume() {
    this._visible = true;
    this.markDirty();
  }
  show() {
    this.visible = true;
  }
  static stripRichTextTags(text) {
    let extractedColor;
    const colorMatch = text.match(/^\[c=([^\]]+)\](.*?)\[\/c\]$/);
    if (colorMatch) {
      extractedColor = colorMatch[1];
      text = colorMatch[2];
    }
    const stripped = text.replace(/\[\/?\w+(?:=[^\]]+)?\]/g, "");
    return { text: stripped, color: extractedColor };
  }
  parseRichText(text) {
    const segments = [];
    const style = this.style;
    let currentColor = style.textColor ?? "#ffffff";
    let currentBold = false;
    let currentItalic = false;
    let currentSize = style.textFontSize ?? 16;
    let currentShake = false;
    let currentWave = false;
    const colorStack = [];
    const sizeStack = [];
    let i = 0;
    let currentText = "";
    const pushSegment = () => {
      if (currentText) {
        segments.push({
          text: currentText,
          color: currentColor,
          bold: currentBold,
          italic: currentItalic,
          fontSize: currentSize,
          shake: currentShake,
          wave: currentWave
        });
        currentText = "";
      }
    };
    while (i < text.length) {
      if (text[i] === "[") {
        const closeTagEnd = text.indexOf("]", i);
        if (closeTagEnd !== -1) {
          const tagContent = text.substring(i + 1, closeTagEnd);
          if (tagContent.startsWith("c=")) {
            pushSegment();
            colorStack.push(currentColor);
            currentColor = tagContent.substring(2);
            i = closeTagEnd + 1;
            continue;
          }
          if (tagContent === "/c") {
            pushSegment();
            currentColor = colorStack.pop() ?? (style.textColor ?? "#ffffff");
            i = closeTagEnd + 1;
            continue;
          }
          if (tagContent === "b") {
            pushSegment();
            currentBold = true;
            i = closeTagEnd + 1;
            continue;
          }
          if (tagContent === "/b") {
            pushSegment();
            currentBold = false;
            i = closeTagEnd + 1;
            continue;
          }
          if (tagContent === "i") {
            pushSegment();
            currentItalic = true;
            i = closeTagEnd + 1;
            continue;
          }
          if (tagContent === "/i") {
            pushSegment();
            currentItalic = false;
            i = closeTagEnd + 1;
            continue;
          }
          if (tagContent.startsWith("s=")) {
            pushSegment();
            sizeStack.push(currentSize);
            currentSize = parseInt(tagContent.substring(2)) || currentSize;
            i = closeTagEnd + 1;
            continue;
          }
          if (tagContent === "/s") {
            pushSegment();
            currentSize = sizeStack.pop() ?? (style.textFontSize ?? 16);
            i = closeTagEnd + 1;
            continue;
          }
          if (tagContent === "shake") {
            pushSegment();
            currentShake = true;
            i = closeTagEnd + 1;
            continue;
          }
          if (tagContent === "/shake") {
            pushSegment();
            currentShake = false;
            i = closeTagEnd + 1;
            continue;
          }
          if (tagContent === "wave") {
            pushSegment();
            currentWave = true;
            i = closeTagEnd + 1;
            continue;
          }
          if (tagContent === "/wave") {
            pushSegment();
            currentWave = false;
            i = closeTagEnd + 1;
            continue;
          }
          if (tagContent.startsWith("p=")) {
            pushSegment();
            const duration = parseFloat(tagContent.substring(2)) || 0.5;
            segments.push({
              text: "",
              color: currentColor,
              bold: currentBold,
              italic: currentItalic,
              fontSize: currentSize,
              shake: currentShake,
              wave: currentWave,
              pause: duration
            });
            i = closeTagEnd + 1;
            continue;
          }
        }
      }
      currentText += text[i];
      i++;
    }
    pushSegment();
    return segments;
  }
  getPlainText(segments) {
    return segments.map((s) => s.text).join("");
  }
  getDisplayedText(charIndex) {
    let result = "";
    let count = 0;
    for (const segment of this._parsedSegments) {
      if (segment.pause !== undefined)
        continue;
      for (const char of segment.text) {
        if (count >= charIndex)
          break;
        result += char;
        count++;
      }
      if (count >= charIndex)
        break;
    }
    return result;
  }
  getDisplayedSegments(charIndex) {
    const result = [];
    let count = 0;
    for (const segment of this._parsedSegments) {
      if (segment.pause !== undefined)
        continue;
      let segmentText = "";
      for (const char of segment.text) {
        if (count >= charIndex)
          break;
        segmentText += char;
        count++;
      }
      if (segmentText.length > 0) {
        result.push({
          text: segmentText,
          color: segment.color,
          bold: segment.bold,
          italic: segment.italic,
          fontSize: segment.fontSize,
          shake: segment.shake,
          wave: segment.wave
        });
      }
      if (count >= charIndex)
        break;
    }
    return result;
  }
  getCharAt(index) {
    let count = 0;
    for (const segment of this._parsedSegments) {
      if (segment.pause !== undefined)
        continue;
      for (let i = 0;i < segment.text.length; i++) {
        if (count === index) {
          return { char: segment.text[i], segment };
        }
        count++;
      }
    }
    return null;
  }
  getPauseAtIndex(charIndex) {
    let count = 0;
    let pauseIndex = 0;
    for (const segment of this._parsedSegments) {
      if (segment.pause !== undefined) {
        if (count === charIndex && pauseIndex >= this._processedPauseCount) {
          return segment.pause;
        }
        pauseIndex++;
        continue;
      }
      count += segment.text.length;
    }
    return null;
  }
  markPauseProcessed() {
    this._processedPauseCount++;
  }
  handlePointerEvent(event) {
    switch (event.type) {
      case "pointerdown":
      case "click":
        this.advance();
        return true;
      case "keydown":
        if (event.key === "Enter" || event.key === " " || event.key === "z" || event.key === "Z") {
          this.advance();
          return true;
        }
        break;
    }
    return super.handlePointerEvent(event);
  }
  update(dt) {
    super.update(dt);
    if (!this._visible)
      return;
    const style = this.style;
    this._animationTime += dt;
    if (this._isPaused) {
      this._pauseRemaining -= dt;
      if (this._pauseRemaining <= 0) {
        this._isPaused = false;
        this._isTyping = true;
      }
      this.markDirty();
      return;
    }
    const plainText = this.getPlainText(this._parsedSegments);
    if (this._isTyping && this._charIndex < plainText.length) {
      const speed = style.typewriterSpeed ?? 40;
      this._typewriterTimer += dt * speed;
      while (this._typewriterTimer >= 1 && this._charIndex < plainText.length) {
        this._typewriterTimer -= 1;
        const pause = this.getPauseAtIndex(this._charIndex);
        if (pause !== null) {
          this._isPaused = true;
          this._isTyping = false;
          this._pauseRemaining = pause;
          this.markPauseProcessed();
          break;
        }
        const charInfo = this.getCharAt(this._charIndex);
        if (charInfo) {
          this._charIndex++;
          this._displayedText = this.getDisplayedText(this._charIndex);
          this.onCharacterTyped?.(charInfo.char, this._charIndex);
          const char = charInfo.char;
          if (char === "." || char === ":") {
            this._typewriterTimer -= style.pausePeriod ?? 8;
          } else if (char === ",") {
            this._typewriterTimer -= style.pauseComma ?? 3;
          } else if (char === "?") {
            this._typewriterTimer -= style.pauseQuestion ?? 8;
          } else if (char === "!") {
            this._typewriterTimer -= style.pauseExclamation ?? 8;
          }
        } else {
          this._charIndex++;
        }
      }
      if (this._charIndex >= plainText.length) {
        this._isTyping = false;
        this._isComplete = true;
        this._displayedText = plainText;
        if (this._currentEntry) {
          this.onDialogueComplete?.(this._currentEntry);
        }
      }
      this.markDirty();
    }
    if (this._isComplete) {
      this._continueIndicatorPhase += dt * 4;
      if (this._continueIndicatorPhase > Math.PI * 2) {
        this._continueIndicatorPhase -= Math.PI * 2;
      }
      this.markDirty();
    }
    const transitionSpeed = 1 / (style.characterTransitionDuration ?? 0.3);
    const dimOpacity = style.characterDimOpacity ?? 0.5;
    for (const [id, char] of this._characters) {
      const targetOpacity = char.speaking ? char.opacity ?? 1 : char.dimWhenNotSpeaking !== false ? dimOpacity : char.opacity ?? 1;
      let current = this._characterOpacities.get(id) ?? 1;
      if (current !== targetOpacity) {
        if (current < targetOpacity) {
          current = Math.min(current + dt * transitionSpeed, targetOpacity);
        } else {
          current = Math.max(current - dt * transitionSpeed, targetOpacity);
        }
        this._characterOpacities.set(id, current);
        this.markDirty();
      }
    }
  }
  measureContent() {
    const width = typeof this.style.width === "number" ? this.style.width : 800;
    const height = typeof this.style.height === "number" ? this.style.height : 180;
    this._contentSize = { width, height };
    return this._contentSize;
  }
  getRenderData(data) {
    if (!this._visible)
      return;
    const style = this.style;
    const zIndex = style.zIndex ?? 900;
    const padding = this.getPadding();
    this.renderCharacters(data, zIndex - 10);
    if (style.boxBackgroundImage && style.boxBackgroundImage.gpuTexture) {
      data.push({
        type: style.boxBackgroundSlices ? "nine-slice" : "image",
        bounds: { ...this._bounds },
        zIndex,
        texture: style.boxBackgroundImage.gpuTexture,
        textureView: style.boxBackgroundImage.view,
        uvRect: { u0: 0, v0: 0, u1: 1, v1: 1 },
        backgroundAlpha: style.boxBackgroundAlpha ?? 1
      });
    } else {
      data.push({
        type: "quad",
        bounds: { ...this._bounds },
        zIndex,
        backgroundColor: style.boxBackgroundColor ?? "rgba(10, 10, 20, 0.92)",
        backgroundAlpha: style.boxBackgroundAlpha ?? 1,
        borderColor: style.boxBorderColor,
        borderWidth: style.boxBorderWidth ?? 2,
        borderRadius: style.boxBorderRadius ?? 8
      });
    }
    const nameFontSize = style.nameFontSize ?? 18;
    const nameOffset = style.namePlateOffset ?? { x: 0, y: 0 };
    const nameHeight = nameFontSize * 1.4;
    const hasName = style.namePlateEnabled !== false && this._speakerName;
    if (hasName) {
      const namePadding = style.namePlatePadding ?? 8;
      const nameBgColor = style.namePlateBackgroundColor ?? "transparent";
      const namePrefix = style.namePlatePrefix ?? "";
      const displayName = namePrefix + this._speakerName;
      const nameX = this._bounds.x + padding.left + nameOffset.x;
      const nameY = this._bounds.y + padding.top + nameOffset.y;
      if (nameBgColor !== "transparent") {
        const nameWidth = displayName.length * nameFontSize * 0.55 + namePadding * 2;
        const bgHeight = nameFontSize + namePadding * 1.4;
        data.push({
          type: "quad",
          bounds: {
            x: nameX,
            y: nameY,
            width: nameWidth,
            height: bgHeight
          },
          zIndex: zIndex + 0.2,
          backgroundColor: nameBgColor,
          borderRadius: style.namePlateBorderRadius ?? 4,
          borderColor: style.namePlateBorderColor,
          borderWidth: style.namePlateBorderWidth ?? 0
        });
      }
      const nameColor = this._currentEntry?.nameColor ?? style.nameColor ?? "#e8f0ff";
      data.push({
        type: "text",
        bounds: {
          x: nameX + namePadding,
          y: nameY + (nameBgColor !== "transparent" ? namePadding * 0.35 : 0),
          width: this._bounds.width - padding.left - padding.right - namePadding * 2,
          height: nameHeight
        },
        zIndex: zIndex + 0.3,
        text: displayName,
        color: nameColor,
        fontSize: nameFontSize,
        fontFamily: style.nameFontFamily ?? "Georgia, serif",
        textAlign: "left"
      });
    }
    const textPadding = this.resolveTextPadding(style.textPadding);
    const contentX = this._bounds.x + padding.left + textPadding.left;
    const nameAreaHeight = hasName ? nameHeight + 8 : 0;
    const contentY = this._bounds.y + padding.top + textPadding.top + nameAreaHeight;
    const contentWidth = this._bounds.width - padding.left - padding.right - textPadding.left - textPadding.right;
    const contentHeight = this._bounds.height - padding.top - padding.bottom - textPadding.top - textPadding.bottom - nameAreaHeight;
    if (this._charIndex > 0) {
      const textColor = this._currentEntry?.textColor ?? style.textColor ?? "#ffffff";
      const displayedSegments = this.getDisplayedSegments(this._charIndex);
      data.push({
        type: "text",
        bounds: {
          x: contentX,
          y: contentY,
          width: contentWidth,
          height: contentHeight
        },
        zIndex: zIndex + 0.1,
        text: this._displayedText,
        richTextSegments: displayedSegments,
        color: textColor,
        fontSize: style.textFontSize ?? 16,
        fontFamily: style.textFontFamily ?? "sans-serif",
        textAlign: "left"
      });
    }
    if (style.continueIndicatorEnabled !== false && this._isComplete) {
      const indicatorSize = style.continueIndicatorSize ?? 10;
      const indicatorOffset = style.continueIndicatorOffset ?? { x: -24, y: -20 };
      const indicatorStyle = style.continueIndicatorStyle ?? "bounce";
      const indicatorTexture = style.continueIndicatorTexture;
      let animOffset = 0;
      let animAlpha = 1;
      switch (indicatorStyle) {
        case "bounce":
          animOffset = Math.sin(this._continueIndicatorPhase) * 4;
          break;
        case "pulse":
          animAlpha = 0.5 + Math.sin(this._continueIndicatorPhase * 2) * 0.5;
          break;
        case "blink":
          animAlpha = Math.sin(this._continueIndicatorPhase * 2) > 0 ? 1 : 0.3;
          break;
      }
      const indicatorX = this._bounds.x + this._bounds.width + indicatorOffset.x;
      const indicatorY = this._bounds.y + this._bounds.height + indicatorOffset.y + animOffset;
      if (indicatorTexture && indicatorTexture.gpuTexture) {
        data.push({
          type: "image",
          bounds: {
            x: indicatorX - indicatorSize / 2,
            y: indicatorY - indicatorSize / 2,
            width: indicatorSize,
            height: indicatorSize
          },
          zIndex: zIndex + 0.4,
          texture: indicatorTexture.gpuTexture,
          textureView: indicatorTexture.view,
          uvRect: { u0: 0, v0: 0, u1: 1, v1: 1 },
          backgroundAlpha: animAlpha
        });
      } else {
        data.push({
          type: "quad",
          bounds: {
            x: indicatorX - indicatorSize / 2,
            y: indicatorY - indicatorSize / 2,
            width: indicatorSize,
            height: indicatorSize
          },
          zIndex: zIndex + 0.4,
          backgroundColor: style.continueIndicatorColor ?? "#ffffff",
          backgroundAlpha: animAlpha,
          borderRadius: indicatorSize / 4
        });
      }
    }
  }
  renderCharacters(data, baseZIndex) {
    const style = this.style;
    const characterHeight = style.characterDisplayHeight ?? 400;
    const sortedChars = Array.from(this._characters.values()).sort((a, b) => {
      const posOrder = { "far-left": 0, left: 1, center: 2, right: 3, "far-right": 4 };
      return (posOrder[a.position] ?? 2) - (posOrder[b.position] ?? 2);
    });
    for (const char of sortedChars) {
      if (!char.texture || !char.texture.gpuTexture)
        continue;
      const scale2 = char.scale ?? 1;
      const offset = char.offset ?? { x: 0, y: 0 };
      const opacity = this._characterOpacities.get(char.id) ?? 1;
      let baseX = 0;
      const screenWidth = this._bounds.x + this._bounds.width;
      switch (char.position) {
        case "far-left":
          baseX = screenWidth * 0.1;
          break;
        case "left":
          baseX = screenWidth * 0.25;
          break;
        case "center":
          baseX = screenWidth * 0.5;
          break;
        case "right":
          baseX = screenWidth * 0.75;
          break;
        case "far-right":
          baseX = screenWidth * 0.9;
          break;
      }
      const texWidth = char.texture.gpuTexture?.width || 256;
      const texHeight = char.texture.gpuTexture?.height || 512;
      const aspectRatio = texWidth / texHeight;
      const displayHeight = characterHeight * scale2;
      const displayWidth = displayHeight * aspectRatio;
      const x = baseX - displayWidth / 2 + offset.x;
      const y = this._bounds.y - displayHeight + offset.y;
      data.push({
        type: "image",
        bounds: {
          x,
          y,
          width: displayWidth,
          height: displayHeight
        },
        zIndex: baseZIndex + (char.speaking ? 1 : 0),
        texture: char.texture.gpuTexture,
        textureView: char.texture.view,
        uvRect: { u0: 0, v0: 0, u1: 1, v1: 1 },
        backgroundAlpha: opacity,
        tint: char.speaking ? undefined : `rgba(128, 128, 128, ${opacity})`
      });
    }
  }
  resolveTextPadding(value) {
    if (value === undefined) {
      return { top: 0, right: 0, bottom: 0, left: 0 };
    }
    if (typeof value === "number") {
      return { top: value, right: value, bottom: value, left: value };
    }
    return value;
  }
}
// ../../src/core/ui/components/CharacterDisplay.ts
class CharacterDisplay extends UIElement {
  _texture = null;
  _currentOpacity = 1;
  _targetOpacity = 1;
  _entranceProgress = 1;
  _isEntering = false;
  _speaking = false;
  onEntranceComplete;
  onExitComplete;
  constructor(style) {
    super({
      position: "absolute",
      width: "fill",
      height: "fill",
      pointerEvents: false,
      ...style
    });
    this._interactive = false;
  }
  get texture() {
    return this._texture;
  }
  get speaking() {
    return this._speaking;
  }
  set speaking(value) {
    if (this._speaking !== value) {
      this._speaking = value;
      const style = this.style;
      this._targetOpacity = value ? 1 : style.dimOpacity ?? 0.6;
      this.markDirty();
    }
  }
  setTexture(texture, animate = true) {
    const wasNull = this._texture === null;
    this._texture = texture;
    if (texture && wasNull && animate) {
      const style = this.style;
      const animation = style.entranceAnimation ?? "fade";
      if (animation !== "none") {
        this._isEntering = true;
        this._entranceProgress = 0;
        this._currentOpacity = 0;
      }
    }
    this.markDirty();
  }
  clear(animate = true) {
    if (animate) {
      this._targetOpacity = 0;
    } else {
      this._texture = null;
      this._currentOpacity = 1;
    }
    this.markDirty();
  }
  setPosition(position) {
    this.style.characterPosition = position;
    this.markDirty();
  }
  setCustomPosition(x) {
    const style = this.style;
    style.characterPosition = "custom";
    style.customPositionX = x;
    this.markDirty();
  }
  getPositionX(screenWidth) {
    const style = this.style;
    const charPosition = style.characterPosition ?? "center";
    switch (charPosition) {
      case "far-left":
        return screenWidth * 0.1;
      case "left":
        return screenWidth * 0.25;
      case "center":
        return screenWidth * 0.5;
      case "right":
        return screenWidth * 0.75;
      case "far-right":
        return screenWidth * 0.9;
      case "custom":
        return screenWidth * (style.customPositionX ?? 0.5);
      default:
        return screenWidth * 0.5;
    }
  }
  update(dt) {
    super.update(dt);
    const style = this.style;
    const transitionDuration = style.transitionDuration ?? 0.3;
    const transitionSpeed = transitionDuration > 0 ? 1 / transitionDuration : 100;
    if (this._currentOpacity !== this._targetOpacity) {
      if (this._currentOpacity < this._targetOpacity) {
        this._currentOpacity = Math.min(this._currentOpacity + dt * transitionSpeed, this._targetOpacity);
      } else {
        this._currentOpacity = Math.max(this._currentOpacity - dt * transitionSpeed, this._targetOpacity);
      }
      if (this._currentOpacity <= 0 && this._targetOpacity <= 0) {
        this._texture = null;
        this._currentOpacity = 1;
        this._targetOpacity = this._speaking ? 1 : style.dimOpacity ?? 0.6;
        this.onExitComplete?.();
      }
      this.markDirty();
    }
    if (this._isEntering) {
      this._entranceProgress += dt * transitionSpeed;
      if (this._entranceProgress >= 1) {
        this._entranceProgress = 1;
        this._isEntering = false;
        this.onEntranceComplete?.();
      }
      this.markDirty();
    }
  }
  measureContent() {
    this._contentSize = { width: 0, height: 0 };
    return this._contentSize;
  }
  getRenderData(data, baseZIndex) {
    if (!this._texture || !this._texture.gpuTexture)
      return;
    const style = this.style;
    const spriteMaxHeight = style.spriteMaxHeight ?? 400;
    const scale2 = style.characterScale ?? 1;
    const texWidth = this._texture.gpuTexture?.width || 256;
    const texHeight = this._texture.gpuTexture?.height || 512;
    const aspectRatio = texWidth / texHeight;
    const displayHeight = spriteMaxHeight * scale2;
    const displayWidth = displayHeight * aspectRatio;
    const screenWidth = this._bounds.width;
    const screenHeight = this._bounds.height;
    const centerX = this.getPositionX(screenWidth);
    const verticalOffset = style.verticalOffset ?? 0;
    const horizontalOffset = style.horizontalOffset ?? 0;
    let offsetX = horizontalOffset;
    let offsetY = 0;
    let opacity = this._currentOpacity;
    if (this._isEntering && this._entranceProgress < 1) {
      const easeProgress = this.easeOutQuad(this._entranceProgress);
      const animation = style.entranceAnimation ?? "fade";
      switch (animation) {
        case "fade":
          opacity = this._currentOpacity * easeProgress;
          break;
        case "slide-left":
          offsetX = -100 * (1 - easeProgress);
          opacity = this._currentOpacity * easeProgress;
          break;
        case "slide-right":
          offsetX = 100 * (1 - easeProgress);
          opacity = this._currentOpacity * easeProgress;
          break;
        case "slide-up":
          offsetY = 50 * (1 - easeProgress);
          opacity = this._currentOpacity * easeProgress;
          break;
      }
    }
    let x = this._bounds.x + centerX - displayWidth / 2 + offsetX;
    let y = 0;
    const verticalAlign = style.verticalAlign ?? "bottom";
    switch (verticalAlign) {
      case "top":
        y = this._bounds.y + offsetY + verticalOffset;
        break;
      case "center":
        y = this._bounds.y + (screenHeight - displayHeight) / 2 + offsetY + verticalOffset;
        break;
      case "bottom":
        y = this._bounds.y + screenHeight - displayHeight + offsetY + verticalOffset;
        break;
    }
    const flip = style.flipHorizontal ?? false;
    const u0 = flip ? 1 : 0;
    const u1 = flip ? 0 : 1;
    let tint;
    if (!this._speaking && opacity < 1) {
      tint = style.dimTint ?? `rgba(180, 180, 180, 1)`;
    }
    data.push({
      type: "image",
      bounds: {
        x,
        y,
        width: displayWidth,
        height: displayHeight
      },
      zIndex: baseZIndex,
      texture: this._texture.gpuTexture,
      textureView: this._texture.view,
      uvRect: { u0, v0: 0, u1, v1: 1 },
      backgroundAlpha: opacity,
      tint
    });
  }
  easeOutQuad(t) {
    return t * (2 - t);
  }
}

class CharacterDisplayManager extends UIElement {
  _characters = new Map;
  constructor(style) {
    super({
      width: "fill",
      height: "fill",
      pointerEvents: false,
      ...style
    });
    this._interactive = false;
  }
  addCharacter(id, texture, options) {
    let char = this._characters.get(id);
    if (!char) {
      char = new CharacterDisplay({
        characterPosition: options?.position ?? "center",
        characterScale: options?.scale ?? 1
      });
      this._characters.set(id, char);
      this.addChild(char);
    }
    char.setTexture(texture, options?.animate ?? true);
    char.speaking = options?.speaking ?? false;
    if (options?.position) {
      char.setPosition(options.position);
    }
    return char;
  }
  removeCharacter(id, animate = true) {
    const char = this._characters.get(id);
    if (char) {
      if (animate) {
        char.clear(true);
        char.onExitComplete = () => {
          this.removeChild(char);
          this._characters.delete(id);
        };
      } else {
        this.removeChild(char);
        this._characters.delete(id);
      }
    }
  }
  getCharacter(id) {
    return this._characters.get(id);
  }
  setSpeaker(speakerId) {
    for (const [id, char] of this._characters) {
      char.speaking = speakerId === id;
    }
  }
  updateCharacterTexture(id, texture, animate = false) {
    const char = this._characters.get(id);
    if (char) {
      char.setTexture(texture, animate);
    }
  }
  moveCharacter(id, position) {
    const char = this._characters.get(id);
    if (char) {
      char.setPosition(position);
    }
  }
  clearAll(animate = true) {
    for (const [id] of this._characters) {
      this.removeCharacter(id, animate);
    }
  }
  getCharacterIds() {
    return Array.from(this._characters.keys());
  }
  hasCharacter(id) {
    return this._characters.has(id);
  }
  getRenderData(data, baseZIndex) {}
}
// ../../src/core/i18n/LocalizationManager.ts
class LocalizationManager {
  locales = new Map;
  currentLocale = "en";
  defaultLocale = "en";
  config;
  static registry = new Map;
  missingTranslations = new Set;
  constructor(config3 = {}) {
    this.config = {
      defaultLocale: "en",
      warnOnMissing: true,
      ...config3
    };
    this.defaultLocale = this.config.defaultLocale;
    this.currentLocale = this.defaultLocale;
  }
  async loadLocaleFromUrl(locale, url) {
    try {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`Failed to load locale ${locale}: ${response.statusText}`);
      }
      const data = await response.json();
      this.loadLocale(locale, data);
    } catch (error) {
      console.error(`Failed to load locale ${locale} from ${url}:`, error);
      throw error;
    }
  }
  loadLocale(locale, data) {
    data.locale = locale;
    this.locales.set(locale, data);
  }
  setLocale(locale) {
    if (!this.locales.has(locale)) {
      const baseLocale = locale.split("-")[0];
      if (this.locales.has(baseLocale)) {
        this.currentLocale = baseLocale;
        return true;
      }
      console.warn(`Locale ${locale} not loaded, staying on ${this.currentLocale}`);
      return false;
    }
    this.currentLocale = locale;
    return true;
  }
  getLocale() {
    return this.currentLocale;
  }
  getAvailableLocales() {
    return Array.from(this.locales.keys());
  }
  getLocaleDisplayName(locale) {
    return this.locales.get(locale)?.displayName ?? locale;
  }
  getLocaleDirection(locale) {
    const loc = locale ?? this.currentLocale;
    return this.locales.get(loc)?.direction ?? "ltr";
  }
  getLocaleFontFamily(locale) {
    const loc = locale ?? this.currentLocale;
    return this.locales.get(loc)?.fontFamily;
  }
  t(key, vars, options) {
    const locale = options?.locale ?? this.currentLocale;
    const entry = this.getEntry(key, locale);
    if (!entry) {
      return this.handleMissing(key, locale);
    }
    let text;
    if (typeof entry === "string") {
      text = entry;
    } else if ("text" in entry) {
      text = entry.text;
    } else if ("one" in entry || "other" in entry) {
      text = this.selectPlural(entry, options?.count ?? 1, locale);
    } else {
      return this.handleMissing(key, locale);
    }
    if (vars) {
      text = this.interpolate(text, vars);
    }
    return text;
  }
  getDialogue(key, vars, locale) {
    const loc = locale ?? this.currentLocale;
    const entry = this.getEntry(key, loc);
    let text;
    let audio;
    let entryData;
    if (!entry) {
      text = this.handleMissing(key, loc);
    } else if (typeof entry === "string") {
      text = entry;
    } else if ("text" in entry) {
      entryData = entry;
      text = entry.text;
      audio = entry.audio;
    } else {
      text = this.handleMissing(key, loc);
    }
    if (vars) {
      text = this.interpolate(text, vars);
    }
    return {
      key,
      text,
      audio,
      entry: entryData
    };
  }
  has(key, locale) {
    const loc = locale ?? this.currentLocale;
    return this.getEntry(key, loc) !== undefined;
  }
  getEntry(key, locale) {
    let data = this.locales.get(locale);
    if (data?.translations[key] !== undefined) {
      return data.translations[key];
    }
    while (data?.fallback) {
      data = this.locales.get(data.fallback);
      if (data?.translations[key] !== undefined) {
        return data.translations[key];
      }
    }
    if (locale !== this.defaultLocale) {
      data = this.locales.get(this.defaultLocale);
      if (data?.translations[key] !== undefined) {
        return data.translations[key];
      }
    }
    return;
  }
  handleMissing(key, locale) {
    const cacheKey = `${locale}:${key}`;
    if (!this.missingTranslations.has(cacheKey)) {
      this.missingTranslations.add(cacheKey);
      if (this.config.warnOnMissing) {
        console.warn(`Missing translation: "${key}" for locale "${locale}"`);
      }
    }
    if (this.config.onMissingTranslation) {
      const result = this.config.onMissingTranslation(key, locale);
      if (result !== undefined)
        return result;
    }
    return `[${key}]`;
  }
  interpolate(text, vars) {
    return text.replace(/\{(\w+)\}/g, (match, varName) => {
      if (varName in vars) {
        return String(vars[varName]);
      }
      return match;
    });
  }
  selectPlural(plural, count, _locale) {
    if (count === 0 && plural.zero)
      return plural.zero;
    if (count === 1)
      return plural.one;
    if (count === 2 && plural.two)
      return plural.two;
    return plural.other;
  }
  static register(key, defaultText, context) {
    if (!LocalizationManager.registry.has(key)) {
      LocalizationManager.registry.set(key, {
        key,
        defaultText,
        context
      });
    }
    return key;
  }
  static getRegistry() {
    return LocalizationManager.registry;
  }
  static exportRegistry() {
    const result = {};
    for (const [key, entry] of LocalizationManager.registry) {
      result[key] = entry;
    }
    return result;
  }
  getMissingTranslations() {
    return Array.from(this.missingTranslations);
  }
  clearMissingTranslations() {
    this.missingTranslations.clear();
  }
  generateMissingReport() {
    const report = {};
    for (const entry of this.missingTranslations) {
      const [locale, key] = entry.split(":", 2);
      if (!report[locale]) {
        report[locale] = [];
      }
      report[locale].push(key);
    }
    return report;
  }
}
// ../../src/core/assets/AssetCache.ts
class AssetCache {
  cache = new Map;
  maxSize;
  typeLimits;
  pinnedPaths;
  constructor(maxSize = 512 * 1024 * 1024, typeLimits = {}, pinnedAssets = []) {
    this.maxSize = maxSize;
    this.typeLimits = typeLimits;
    this.pinnedPaths = new Set(pinnedAssets);
  }
  get(path) {
    const entry = this.cache.get(path);
    if (entry) {
      entry.lastAccessed = performance.now();
      return entry.data;
    }
    return null;
  }
  has(path) {
    return this.cache.has(path);
  }
  set(path, data, type, size) {
    this.ensureCapacity(size, type);
    const entry = {
      data,
      type,
      size,
      lastAccessed: performance.now(),
      pinned: this.pinnedPaths.has(path),
      refCount: 0
    };
    this.cache.set(path, entry);
  }
  delete(path) {
    const entry = this.cache.get(path);
    if (entry) {
      if (entry.pinned) {
        console.warn(`AssetCache: Attempted to delete pinned asset: ${path}`);
        return false;
      }
      if (entry.refCount > 0) {
        console.warn(`AssetCache: Attempted to delete asset with active references: ${path} (refCount: ${entry.refCount})`);
        return false;
      }
      this.cache.delete(path);
      return true;
    }
    return false;
  }
  forceDelete(path) {
    return this.cache.delete(path);
  }
  addRef(path) {
    const entry = this.cache.get(path);
    if (entry) {
      entry.refCount++;
    }
  }
  releaseRef(path) {
    const entry = this.cache.get(path);
    if (entry && entry.refCount > 0) {
      entry.refCount--;
    }
  }
  pin(path) {
    this.pinnedPaths.add(path);
    const entry = this.cache.get(path);
    if (entry) {
      entry.pinned = true;
    }
  }
  unpin(path) {
    this.pinnedPaths.delete(path);
    const entry = this.cache.get(path);
    if (entry) {
      entry.pinned = false;
    }
  }
  clear() {
    for (const [path, entry] of this.cache.entries()) {
      if (!entry.pinned && entry.refCount === 0) {
        this.cache.delete(path);
      }
    }
  }
  forceClear() {
    this.cache.clear();
  }
  getMemoryUsage() {
    let total = 0;
    const byType = {};
    let pinnedCount = 0;
    for (const entry of this.cache.values()) {
      total += entry.size;
      byType[entry.type] = (byType[entry.type] || 0) + entry.size;
      if (entry.pinned)
        pinnedCount++;
    }
    return {
      total,
      byType,
      cached: this.cache.size,
      pinned: pinnedCount
    };
  }
  keys() {
    return Array.from(this.cache.keys());
  }
  get size() {
    return this.cache.size;
  }
  ensureCapacity(requiredSize, type) {
    const usage = this.getMemoryUsage();
    if (usage.total + requiredSize <= this.maxSize) {
      const typeLimit = this.typeLimits[type];
      if (!typeLimit || (usage.byType[type] || 0) + requiredSize <= typeLimit) {
        return;
      }
    }
    const candidates = this.getEvictionCandidates();
    candidates.sort((a, b) => a.lastAccessed - b.lastAccessed);
    let freedSpace = 0;
    const targetFree = requiredSize * 1.5;
    for (const candidate of candidates) {
      if (freedSpace >= targetFree)
        break;
      this.cache.delete(candidate.path);
      freedSpace += candidate.size;
    }
    if (freedSpace < requiredSize) {
      console.warn(`AssetCache: Could not free enough space for new asset. Needed: ${requiredSize}, freed: ${freedSpace}`);
    }
  }
  getEvictionCandidates() {
    const candidates = [];
    for (const [path, entry] of this.cache.entries()) {
      if (!entry.pinned && entry.refCount === 0) {
        candidates.push({
          path,
          size: entry.size,
          lastAccessed: entry.lastAccessed
        });
      }
    }
    return candidates;
  }
  trimToSize(targetSize) {
    const usage = this.getMemoryUsage();
    if (usage.total <= targetSize)
      return 0;
    const toFree = usage.total - targetSize;
    const candidates = this.getEvictionCandidates();
    candidates.sort((a, b) => a.lastAccessed - b.lastAccessed);
    let freed = 0;
    for (const candidate of candidates) {
      if (freed >= toFree)
        break;
      this.cache.delete(candidate.path);
      freed += candidate.size;
    }
    return freed;
  }
  gc(maxAge = 60000) {
    const now = performance.now();
    let freed = 0;
    for (const [path, entry] of this.cache.entries()) {
      if (!entry.pinned && entry.refCount === 0 && now - entry.lastAccessed > maxAge) {
        freed += entry.size;
        this.cache.delete(path);
      }
    }
    return freed;
  }
}

// ../../src/core/assets/AssetLoader.ts
function getFileExtension(url) {
  const cleanUrl = url.split("?")[0].split("#")[0];
  const parts = cleanUrl.split(".");
  if (parts.length < 2)
    return "";
  return parts[parts.length - 1].toLowerCase();
}
function detectAssetType(url) {
  const ext = getFileExtension(url);
  const textureExtensions = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ktx2", "basis"];
  const modelExtensions = ["gltf", "glb", "fbx", "obj"];
  const audioExtensions = ["mp3", "wav", "ogg", "flac", "aac", "m4a", "webm"];
  const dataExtensions = ["json", "yaml", "yml", "xml", "csv", "txt"];
  const shaderExtensions = ["wgsl", "glsl", "vert", "frag"];
  const fontExtensions = ["ttf", "otf", "woff", "woff2", "fnt"];
  if (textureExtensions.includes(ext))
    return "texture";
  if (modelExtensions.includes(ext))
    return "model";
  if (audioExtensions.includes(ext))
    return "audio";
  if (dataExtensions.includes(ext))
    return "data";
  if (shaderExtensions.includes(ext))
    return "shader";
  if (fontExtensions.includes(ext))
    return "font";
  return null;
}
async function fetchWithProgress(url, onProgress) {
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Failed to fetch ${url}: ${response.status} ${response.statusText}`);
  }
  const contentLength = response.headers.get("content-length");
  const total = contentLength ? parseInt(contentLength, 10) : 0;
  if (!response.body || !onProgress || total === 0) {
    return response.arrayBuffer();
  }
  const reader = response.body.getReader();
  const chunks = [];
  let loaded = 0;
  while (true) {
    const { done, value } = await reader.read();
    if (done)
      break;
    chunks.push(value);
    loaded += value.length;
    onProgress(loaded, total);
  }
  const result = new Uint8Array(loaded);
  let offset = 0;
  for (const chunk of chunks) {
    result.set(chunk, offset);
    offset += chunk.length;
  }
  return result.buffer;
}

// ../../src/core/assets/loaders/TextureLoader.ts
class TextureLoader {
  type = "texture";
  extensions = ["png", "jpg", "jpeg", "gif", "webp", "bmp"];
  device;
  constructor(device) {
    this.device = device;
  }
  async load(url, options, onProgress) {
    const arrayBuffer = await fetchWithProgress(url, onProgress);
    const blob = new Blob([arrayBuffer]);
    const imgBitmap = await createImageBitmap(blob);
    const texture = new Texture(url);
    if (options?.mipMaps === false) {
      this.createTextureNoMipmaps(texture, imgBitmap, options);
    } else {
      texture.createFromImageBitmap(this.device, imgBitmap);
    }
    if (options?.addressModeU || options?.addressModeV || options?.magFilter || options?.minFilter) {
      texture.sampler = this.device.createSampler({
        magFilter: options.magFilter || "linear",
        minFilter: options.minFilter || "linear",
        mipmapFilter: "linear",
        addressModeU: options.addressModeU || "repeat",
        addressModeV: options.addressModeV || "repeat",
        maxAnisotropy: 4
      });
    }
    const mipFactor = options?.mipMaps === false ? 1 : 1.33;
    const size = Math.ceil(imgBitmap.width * imgBitmap.height * 4 * mipFactor);
    return { data: texture, size };
  }
  createTextureNoMipmaps(texture, imgBitmap, options) {
    const format = options?.format || "rgba8unorm";
    texture.gpuTexture = this.device.createTexture({
      label: texture.label,
      size: [imgBitmap.width, imgBitmap.height, 1],
      format,
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
      mipLevelCount: 1
    });
    this.device.queue.copyExternalImageToTexture({ source: imgBitmap }, { texture: texture.gpuTexture }, [imgBitmap.width, imgBitmap.height]);
    texture.view = texture.gpuTexture.createView();
    texture.sampler = this.device.createSampler({
      magFilter: options?.magFilter || "linear",
      minFilter: options?.minFilter || "linear",
      addressModeU: options?.addressModeU || "repeat",
      addressModeV: options?.addressModeV || "repeat"
    });
  }
  unload(texture) {
    if (texture.gpuTexture) {
      texture.gpuTexture.destroy();
      texture.gpuTexture = null;
      texture.view = null;
      texture.sampler = null;
    }
  }
  async estimateSize(url) {
    try {
      const response = await fetch(url, { method: "HEAD" });
      const contentLength = response.headers.get("content-length");
      if (contentLength) {
        return parseInt(contentLength, 10) * 4 * 1.33;
      }
    } catch {}
    return null;
  }
}

// ../../src/core/assets/loaders/ModelLoader.ts
class ModelLoader {
  type = "model";
  extensions = ["gltf", "glb"];
  gltfLoader;
  constructor(device) {
    this.gltfLoader = new GLTFLoader2(device);
  }
  async load(url, options, _onProgress) {
    const result = await this.gltfLoader.load(url);
    const rootNode = result.rootNode;
    if (options?.scale && options.scale !== 1) {
      rootNode.transform.scale.multiplyScalar(options.scale);
    }
    const size = this.estimateNodeSize(rootNode);
    return { data: rootNode, size };
  }
  estimateNodeSize(node) {
    let size = 0;
    if ("geometry" in node && node.geometry) {
      const geometry = node.geometry;
      if (geometry.positions) {
        size += geometry.positions.byteLength || geometry.positions.length * 4;
      }
      if (geometry.normals) {
        size += geometry.normals.byteLength || geometry.normals.length * 4;
      }
      if (geometry.uvs) {
        size += geometry.uvs.byteLength || geometry.uvs.length * 4;
      }
      if (geometry.indices) {
        size += geometry.indices.byteLength || geometry.indices.length * 2;
      }
    }
    for (const child of node.children) {
      size += this.estimateNodeSize(child);
    }
    return size + 1024;
  }
  unload(node) {
    this.destroyNode(node);
  }
  destroyNode(node) {
    if ("geometry" in node && node.geometry) {
      const geometry = node.geometry;
      if (geometry.destroy) {
        geometry.destroy();
      }
    }
    for (const child of node.children) {
      this.destroyNode(child);
    }
  }
  async estimateSize(url) {
    try {
      const response = await fetch(url, { method: "HEAD" });
      const contentLength = response.headers.get("content-length");
      if (contentLength) {
        return parseInt(contentLength, 10) * 2;
      }
    } catch {}
    return null;
  }
}

// ../../src/core/assets/loaders/AudioLoader.ts
class AudioLoader {
  type = "audio";
  extensions = ["mp3", "wav", "ogg", "flac", "aac", "m4a", "webm"];
  audioContext = null;
  constructor() {}
  getAudioContext() {
    if (!this.audioContext) {
      this.audioContext = new AudioContext;
    }
    return this.audioContext;
  }
  async load(url, options, onProgress) {
    const arrayBuffer = await fetchWithProgress(url, onProgress);
    const audioContext = this.getAudioContext();
    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer.slice(0));
    const clip = {
      buffer: audioBuffer,
      url,
      duration: audioBuffer.duration,
      channels: audioBuffer.numberOfChannels,
      sampleRate: audioBuffer.sampleRate
    };
    const size = audioBuffer.length * audioBuffer.numberOfChannels * 4;
    return { data: clip, size };
  }
  unload(clip) {
    clip.buffer = null;
  }
  async estimateSize(url) {
    try {
      const response = await fetch(url, { method: "HEAD" });
      const contentLength = response.headers.get("content-length");
      if (contentLength) {
        return parseInt(contentLength, 10) * 10;
      }
    } catch {}
    return null;
  }
  resumeContext() {
    return this.getAudioContext().resume();
  }
  suspendContext() {
    if (this.audioContext) {
      return this.audioContext.suspend();
    }
    return Promise.resolve();
  }
}

// ../../src/core/assets/loaders/DataLoader.ts
class DataLoader {
  type = "data";
  extensions = ["json", "yaml", "yml", "xml", "csv", "txt"];
  async load(url, options, onProgress) {
    const arrayBuffer = await fetchWithProgress(url, onProgress);
    const text = new TextDecoder().decode(arrayBuffer);
    const format = options?.parseAs || this.detectFormat(url);
    let data;
    switch (format) {
      case "json":
        data = JSON.parse(text);
        break;
      case "yaml":
        data = this.parseYaml(text);
        break;
      case "xml":
        data = this.parseXml(text);
        break;
      case "csv":
        data = this.parseCsv(text, options?.csvDelimiter, options?.csvHeaders);
        break;
      default:
        data = text;
    }
    const size = arrayBuffer.byteLength;
    return { data, size };
  }
  detectFormat(url) {
    const ext = getFileExtension(url);
    switch (ext) {
      case "json":
        return "json";
      case "yaml":
      case "yml":
        return "yaml";
      case "xml":
        return "xml";
      case "csv":
        return "csv";
      default:
        return "text";
    }
  }
  parseYaml(text) {
    const result = {};
    const lines = text.split(`
`);
    const stack = [{ obj: result, indent: -1 }];
    for (const rawLine of lines) {
      const line = rawLine.replace(/\r$/, "");
      if (line.trim() === "" || line.trim().startsWith("#"))
        continue;
      const indent = line.search(/\S/);
      const content = line.trim();
      if (content.startsWith("- ")) {
        const value = content.slice(2).trim();
        const parent = stack[stack.length - 1].obj;
        const lastKey = Object.keys(parent).pop();
        if (lastKey && !Array.isArray(parent[lastKey])) {
          parent[lastKey] = [];
        }
        if (lastKey && Array.isArray(parent[lastKey])) {
          parent[lastKey].push(this.parseValue(value));
        }
        continue;
      }
      const colonIndex = content.indexOf(":");
      if (colonIndex > 0) {
        const key = content.slice(0, colonIndex).trim();
        const valueStr = content.slice(colonIndex + 1).trim();
        while (stack.length > 1 && stack[stack.length - 1].indent >= indent) {
          stack.pop();
        }
        const parent = stack[stack.length - 1].obj;
        if (valueStr === "") {
          const newObj = {};
          parent[key] = newObj;
          stack.push({ obj: newObj, indent });
        } else {
          parent[key] = this.parseValue(valueStr);
        }
      }
    }
    return result;
  }
  parseValue(str) {
    if (str.startsWith('"') && str.endsWith('"') || str.startsWith("'") && str.endsWith("'")) {
      return str.slice(1, -1);
    }
    if (str === "true")
      return true;
    if (str === "false")
      return false;
    if (str === "null" || str === "~")
      return null;
    const num = Number(str);
    if (!isNaN(num))
      return num;
    return str;
  }
  parseXml(text) {
    const parser = new DOMParser;
    const doc = parser.parseFromString(text, "text/xml");
    const parseNode = (node) => {
      const result = {};
      for (const attr of Array.from(node.attributes)) {
        result[`@${attr.name}`] = attr.value;
      }
      const children = Array.from(node.children);
      if (children.length === 0) {
        const textContent = node.textContent?.trim();
        if (textContent) {
          if (Object.keys(result).length === 0) {
            return this.parseValue(textContent);
          }
          result["#text"] = this.parseValue(textContent);
        }
      } else {
        for (const child of children) {
          const childResult = parseNode(child);
          const tagName = child.tagName;
          if (result[tagName] !== undefined) {
            if (!Array.isArray(result[tagName])) {
              result[tagName] = [result[tagName]];
            }
            result[tagName].push(childResult);
          } else {
            result[tagName] = childResult;
          }
        }
      }
      return result;
    };
    return parseNode(doc.documentElement);
  }
  parseCsv(text, delimiter = ",", useHeaders = true) {
    const lines = text.split(`
`).filter((line) => line.trim() !== "");
    if (lines.length === 0)
      return [];
    const parseRow = (line) => {
      const result = [];
      let current = "";
      let inQuotes = false;
      for (let i = 0;i < line.length; i++) {
        const char = line[i];
        if (char === '"') {
          if (inQuotes && line[i + 1] === '"') {
            current += '"';
            i++;
          } else {
            inQuotes = !inQuotes;
          }
        } else if (char === delimiter && !inQuotes) {
          result.push(current.trim());
          current = "";
        } else {
          current += char;
        }
      }
      result.push(current.trim());
      return result;
    };
    const rows = lines.map(parseRow);
    if (useHeaders && rows.length > 1) {
      const headers = rows[0];
      return rows.slice(1).map((row) => {
        const obj = {};
        headers.forEach((header, i) => {
          obj[header] = row[i] !== undefined ? this.parseValue(row[i]) : null;
        });
        return obj;
      });
    }
    return rows;
  }
  unload(_data) {}
  async estimateSize(url) {
    try {
      const response = await fetch(url, { method: "HEAD" });
      const contentLength = response.headers.get("content-length");
      if (contentLength) {
        return parseInt(contentLength, 10);
      }
    } catch {}
    return null;
  }
}

// ../../src/core/assets/AssetManager.ts
var PRIORITY_VALUES = {
  critical: 0,
  high: 1,
  normal: 2,
  low: 3,
  background: 4
};

class AssetManager {
  static instance = null;
  _device = null;
  config;
  cache;
  loaders = new Map;
  loadQueue = [];
  activeLoads = new Map;
  currentConcurrent = 0;
  onProgressCallbacks = new Set;
  onErrorCallbacks = new Set;
  totalToLoad = 0;
  totalLoaded = 0;
  totalBytesLoaded = 0;
  totalBytesTotal = 0;
  loadStartTime = 0;
  currentLoadingAsset = "";
  constructor() {
    this.config = {
      basePath: "",
      maxCacheSize: 512 * 1024 * 1024,
      maxConcurrent: 4,
      enablePreloading: true,
      typeLimits: {},
      pinnedAssets: []
    };
    this.cache = new AssetCache;
  }
  static getInstance() {
    if (!AssetManager.instance) {
      AssetManager.instance = new AssetManager;
    }
    return AssetManager.instance;
  }
  async init(device, config3) {
    this._device = device;
    if (config3) {
      this.config = { ...this.config, ...config3 };
    }
    this.cache = new AssetCache(this.config.maxCacheSize, this.config.typeLimits, this.config.pinnedAssets);
    this.loaders.set("texture", new TextureLoader(device));
    this.loaders.set("model", new ModelLoader(device));
    this.loaders.set("audio", new AudioLoader);
    this.loaders.set("data", new DataLoader);
    console.log("AssetManager initialized with config:", this.config);
  }
  configure(config3) {
    this.config = { ...this.config, ...config3 };
    if (config3.maxCacheSize || config3.typeLimits || config3.pinnedAssets) {
      this.cache = new AssetCache(this.config.maxCacheSize, this.config.typeLimits, this.config.pinnedAssets);
    }
  }
  async load(path, options) {
    const fullPath = this.resolvePath(path);
    const cached = this.cache.get(fullPath);
    if (cached && !options?.forceReload) {
      return cached;
    }
    const existing = this.activeLoads.get(fullPath);
    if (existing) {
      return existing;
    }
    const type = options?.type || detectAssetType(fullPath);
    if (!type) {
      throw new Error(`AssetManager: Could not detect asset type for: ${path}`);
    }
    const loadPromise = this.queueLoad(fullPath, type, options);
    this.activeLoads.set(fullPath, loadPromise);
    try {
      const result = await loadPromise;
      return result;
    } finally {
      this.activeLoads.delete(fullPath);
    }
  }
  async loadTexture(path, options) {
    return this.load(path, { ...options, type: "texture" });
  }
  async loadModel(path, options) {
    return this.load(path, { ...options, type: "model" });
  }
  async loadAudio(path, options) {
    return this.load(path, { ...options, type: "audio" });
  }
  async loadData(path, options) {
    return this.load(path, { ...options, type: "data" });
  }
  async loadAll(paths, options) {
    const results = new Map;
    this.totalToLoad = paths.length;
    this.totalLoaded = 0;
    this.loadStartTime = performance.now();
    if (options?.onProgress) {
      this.onProgressCallbacks.add(options.onProgress);
    }
    try {
      const promises = paths.map(async (path) => {
        try {
          const result = await this.load(path, { priority: options?.priority });
          results.set(path, result);
          this.totalLoaded++;
          this.emitProgress();
        } catch (error) {
          console.error(`AssetManager: Failed to load ${path}:`, error);
          this.emitError(error, path);
        }
      });
      await Promise.all(promises);
    } finally {
      if (options?.onProgress) {
        this.onProgressCallbacks.delete(options.onProgress);
      }
      this.resetLoadingState();
    }
    return results;
  }
  isLoaded(path) {
    return this.cache.has(this.resolvePath(path));
  }
  get(path) {
    return this.cache.get(this.resolvePath(path));
  }
  unload(path) {
    const fullPath = this.resolvePath(path);
    const asset = this.cache.get(fullPath);
    if (asset) {
      const type = detectAssetType(fullPath);
      if (type) {
        const loader = this.loaders.get(type);
        if (loader?.unload) {
          loader.unload(asset);
        }
      }
      return this.cache.delete(fullPath);
    }
    return false;
  }
  clearCache() {
    this.cache.clear();
  }
  getMemoryUsage() {
    return this.cache.getMemoryUsage();
  }
  gc(maxAge) {
    return this.cache.gc(maxAge);
  }
  trimToSize(targetSize) {
    return this.cache.trimToSize(targetSize);
  }
  pin(path) {
    this.cache.pin(this.resolvePath(path));
  }
  unpin(path) {
    this.cache.unpin(this.resolvePath(path));
  }
  onProgress(callback) {
    this.onProgressCallbacks.add(callback);
    return () => this.onProgressCallbacks.delete(callback);
  }
  onError(callback) {
    this.onErrorCallbacks.add(callback);
    return () => this.onErrorCallbacks.delete(callback);
  }
  getProgress() {
    return {
      percent: this.totalToLoad > 0 ? this.totalLoaded / this.totalToLoad * 100 : 0,
      currentAsset: this.currentLoadingAsset,
      loaded: this.totalLoaded,
      total: this.totalToLoad,
      bytesLoaded: this.totalBytesLoaded,
      bytesTotal: this.totalBytesTotal,
      elapsedTime: performance.now() - this.loadStartTime
    };
  }
  get isLoading() {
    return this.activeLoads.size > 0 || this.loadQueue.length > 0;
  }
  get isInitialized() {
    return this._device !== null;
  }
  getDevice() {
    return this._device;
  }
  getCachedPaths() {
    return this.cache.keys();
  }
  resolvePath(path) {
    if (path.startsWith("http://") || path.startsWith("https://") || path.startsWith("/")) {
      return path;
    }
    const base = this.config.basePath.endsWith("/") ? this.config.basePath : this.config.basePath + "/";
    return base + path;
  }
  async queueLoad(path, type, options) {
    return new Promise((resolve2, reject) => {
      const item = {
        path,
        type,
        priority: options?.priority || "normal",
        options,
        resolve: resolve2,
        reject,
        onProgress: (loaded, total) => {
          this.totalBytesLoaded += loaded;
          if (total > 0) {
            this.totalBytesTotal = Math.max(this.totalBytesTotal, total);
          }
        }
      };
      const insertIndex = this.loadQueue.findIndex((q) => PRIORITY_VALUES[q.priority] > PRIORITY_VALUES[item.priority]);
      if (insertIndex === -1) {
        this.loadQueue.push(item);
      } else {
        this.loadQueue.splice(insertIndex, 0, item);
      }
      this.processQueue();
    });
  }
  async processQueue() {
    while (this.loadQueue.length > 0 && this.currentConcurrent < this.config.maxConcurrent) {
      const item = this.loadQueue.shift();
      if (!item)
        break;
      this.currentConcurrent++;
      this.currentLoadingAsset = item.path;
      this.emitProgress();
      try {
        const result = await this.loadAsset(item);
        item.resolve(result);
      } catch (error) {
        item.reject(error);
      } finally {
        this.currentConcurrent--;
        this.processQueue();
      }
    }
  }
  async loadAsset(item) {
    const loader = this.loaders.get(item.type);
    if (!loader) {
      throw new Error(`AssetManager: No loader registered for type: ${item.type}`);
    }
    const result = await loader.load(item.path, item.options, item.onProgress);
    this.cache.set(item.path, result.data, item.type, result.size);
    return result.data;
  }
  emitProgress() {
    const progress = this.getProgress();
    for (const callback of this.onProgressCallbacks) {
      try {
        callback(progress);
      } catch (e) {
        console.error("AssetManager: Error in progress callback:", e);
      }
    }
  }
  emitError(error, path) {
    for (const callback of this.onErrorCallbacks) {
      try {
        callback(error, path);
      } catch (e) {
        console.error("AssetManager: Error in error callback:", e);
      }
    }
  }
  resetLoadingState() {
    this.totalToLoad = 0;
    this.totalLoaded = 0;
    this.totalBytesLoaded = 0;
    this.totalBytesTotal = 0;
    this.currentLoadingAsset = "";
  }
  destroy() {
    this.cache.forceClear();
    this.loaders.clear();
    this.loadQueue = [];
    this.activeLoads.clear();
    this.onProgressCallbacks.clear();
    this.onErrorCallbacks.clear();
    this._device = null;
    AssetManager.instance = null;
  }
}
// ../../src/core/assets/preload/SceneManifest.ts
class SceneManifestRegistry {
  manifests = new Map;
  loadedScenes = new Set;
  preloadStatus = new Map;
  register(sceneId, manifest) {
    this.manifests.set(sceneId, manifest);
  }
  registerAll(manifests) {
    for (const [sceneId, manifest] of Object.entries(manifests)) {
      this.register(sceneId, manifest);
    }
  }
  get(sceneId) {
    return this.manifests.get(sceneId);
  }
  has(sceneId) {
    return this.manifests.has(sceneId);
  }
  unregister(sceneId) {
    return this.manifests.delete(sceneId);
  }
  getRequiredAssets(sceneId) {
    const manifest = this.manifests.get(sceneId);
    if (!manifest)
      return [];
    return manifest.required.map((a) => typeof a === "string" ? { path: a } : a);
  }
  getOptionalAssets(sceneId) {
    const manifest = this.manifests.get(sceneId);
    if (!manifest?.optional)
      return [];
    return manifest.optional.map((a) => typeof a === "string" ? { path: a } : a);
  }
  getAllAssets(sceneId) {
    return [...this.getRequiredAssets(sceneId), ...this.getOptionalAssets(sceneId)];
  }
  getPreloadTargets(sceneId) {
    const manifest = this.manifests.get(sceneId);
    return manifest?.preloadNext || [];
  }
  async loadScene(sceneId, assetManager, onProgress) {
    const required = this.getRequiredAssets(sceneId);
    const results = new Map;
    if (required.length === 0) {
      console.warn(`SceneManifestRegistry: No required assets for scene "${sceneId}"`);
      return results;
    }
    let loaded = 0;
    const total = required.length;
    for (const asset of required) {
      try {
        const result = await assetManager.load(asset.path, {
          priority: asset.priority || "high",
          type: asset.type,
          ...asset.options
        });
        results.set(asset.path, result);
      } catch (error) {
        console.error(`SceneManifestRegistry: Failed to load required asset ${asset.path}:`, error);
        throw error;
      }
      loaded++;
      if (onProgress) {
        onProgress({ percent: loaded / total * 100, loaded, total });
      }
    }
    this.loadedScenes.add(sceneId);
    return results;
  }
  async loadOptionalAssets(sceneId, assetManager) {
    const optional = this.getOptionalAssets(sceneId);
    const results = new Map;
    const promises = optional.map(async (asset) => {
      try {
        const result = await assetManager.load(asset.path, {
          priority: asset.priority || "low",
          type: asset.type,
          ...asset.options
        });
        results.set(asset.path, result);
      } catch (error) {
        console.warn(`SceneManifestRegistry: Optional asset ${asset.path} failed to load:`, error);
      }
    });
    await Promise.all(promises);
    return results;
  }
  unloadScene(sceneId, assetManager) {
    const allAssets = this.getAllAssets(sceneId);
    for (const asset of allAssets) {
      assetManager.unload(asset.path);
    }
    this.loadedScenes.delete(sceneId);
  }
  isSceneLoaded(sceneId, assetManager) {
    const required = this.getRequiredAssets(sceneId);
    return required.every((asset) => assetManager.isLoaded(asset.path));
  }
  isSceneActive(sceneId) {
    return this.loadedScenes.has(sceneId);
  }
  getSceneLoadProgress(sceneId, assetManager) {
    const required = this.getRequiredAssets(sceneId);
    const optional = this.getOptionalAssets(sceneId);
    return {
      required: {
        loaded: required.filter((a) => assetManager.isLoaded(a.path)).length,
        total: required.length
      },
      optional: {
        loaded: optional.filter((a) => assetManager.isLoaded(a.path)).length,
        total: optional.length
      }
    };
  }
  setPreloadStatus(sceneId, status) {
    this.preloadStatus.set(sceneId, status);
  }
  getPreloadStatus(sceneId) {
    return this.preloadStatus.get(sceneId) || {
      state: "not-started",
      percent: 0,
      loaded: 0,
      total: 0,
      errors: []
    };
  }
  getSceneIds() {
    return Array.from(this.manifests.keys());
  }
  clear() {
    this.manifests.clear();
    this.loadedScenes.clear();
    this.preloadStatus.clear();
  }
}

// ../../src/core/assets/preload/PreloadScheduler.ts
var PRELOAD_PRIORITY = {
  critical: 0,
  high: 1,
  normal: 2,
  low: 3,
  background: 4
};

class PreloadScheduler {
  assetManager;
  manifestRegistry;
  queue = [];
  isPreloading = false;
  isPaused = false;
  maxBandwidth;
  activeLoads = 0;
  sceneStatus = new Map;
  completionCallbacks = new Map;
  constructor(assetManager, manifestRegistry, options) {
    this.assetManager = assetManager;
    this.manifestRegistry = manifestRegistry;
    this.maxBandwidth = options?.maxBandwidth ?? 2;
  }
  startPreloading(currentSceneId) {
    const manifest = this.manifestRegistry.get(currentSceneId);
    if (!manifest?.preloadNext)
      return;
    for (const nextScene of manifest.preloadNext) {
      this.queueScene(nextScene, "background");
    }
    this.processQueue();
  }
  queueScene(sceneId, priority = "background") {
    const status = this.getStatus(sceneId);
    if (status.state === "complete" || status.state === "preloading") {
      return;
    }
    const assets = this.manifestRegistry.getRequiredAssets(sceneId);
    const toLoad = assets.filter((a) => !this.assetManager.isLoaded(a.path));
    if (toLoad.length === 0) {
      this.updateStatus(sceneId, "complete", 100, assets.length, assets.length);
      return;
    }
    this.updateStatus(sceneId, "preloading", 0, 0, toLoad.length);
    for (const asset of toLoad) {
      this.queue.push({
        sceneId,
        asset,
        priority: asset.priority || priority
      });
    }
    this.sortQueue();
  }
  elevate(sceneId, priority = "high") {
    let elevated = false;
    for (const item of this.queue) {
      if (item.sceneId === sceneId) {
        item.priority = priority;
        elevated = true;
      }
    }
    if (elevated) {
      this.sortQueue();
      if (this.isPaused && priority === "high" || priority === "critical") {
        this.resume();
      }
    }
  }
  cancel(sceneId) {
    this.queue = this.queue.filter((item) => item.sceneId !== sceneId);
    const status = this.getStatus(sceneId);
    if (status.state === "preloading") {
      this.updateStatus(sceneId, "not-started", 0, 0, 0);
    }
  }
  pause() {
    this.isPaused = true;
  }
  resume() {
    this.isPaused = false;
    this.processQueue();
  }
  getStatus(sceneId) {
    return this.sceneStatus.get(sceneId) || {
      state: "not-started",
      percent: 0,
      loaded: 0,
      total: 0,
      errors: []
    };
  }
  isComplete(sceneId) {
    return this.getStatus(sceneId).state === "complete";
  }
  onComplete(sceneId, callback) {
    if (this.isComplete(sceneId)) {
      callback();
      return () => {};
    }
    if (!this.completionCallbacks.has(sceneId)) {
      this.completionCallbacks.set(sceneId, []);
    }
    this.completionCallbacks.get(sceneId).push(callback);
    return () => {
      const callbacks = this.completionCallbacks.get(sceneId);
      if (callbacks) {
        const index = callbacks.indexOf(callback);
        if (index !== -1) {
          callbacks.splice(index, 1);
        }
      }
    };
  }
  clearQueue() {
    this.queue = [];
  }
  get queueSize() {
    return this.queue.length;
  }
  get isActive() {
    return this.isPreloading && !this.isPaused;
  }
  sortQueue() {
    this.queue.sort((a, b) => PRELOAD_PRIORITY[a.priority] - PRELOAD_PRIORITY[b.priority]);
  }
  async processQueue() {
    if (this.isPaused || this.isPreloading)
      return;
    this.isPreloading = true;
    while (this.queue.length > 0 && !this.isPaused) {
      while (this.activeLoads >= this.maxBandwidth) {
        await this.wait(50);
        if (this.isPaused)
          break;
      }
      if (this.isPaused)
        break;
      const item = this.queue.shift();
      if (!item)
        break;
      if (this.assetManager.isLoaded(item.asset.path)) {
        this.onAssetLoaded(item.sceneId);
        continue;
      }
      this.activeLoads++;
      this.loadAsset(item).finally(() => {
        this.activeLoads--;
      });
    }
    this.isPreloading = false;
  }
  async loadAsset(item) {
    try {
      await this.assetManager.load(item.asset.path, {
        priority: "background",
        type: item.asset.type,
        ...item.asset.options
      });
      this.onAssetLoaded(item.sceneId);
    } catch (error) {
      console.warn(`PreloadScheduler: Failed to preload ${item.asset.path}:`, error);
      this.onAssetError(item.sceneId, item.asset.path);
    }
  }
  onAssetLoaded(sceneId) {
    const status = this.getStatus(sceneId);
    if (status.state !== "preloading")
      return;
    const loaded = status.loaded + 1;
    const percent = loaded / status.total * 100;
    if (loaded >= status.total) {
      this.updateStatus(sceneId, "complete", 100, loaded, status.total);
      this.notifyCompletion(sceneId);
    } else {
      this.updateStatus(sceneId, "preloading", percent, loaded, status.total);
    }
  }
  onAssetError(sceneId, path) {
    const status = this.getStatus(sceneId);
    const errors = [...status.errors, path];
    const loaded = status.loaded + 1;
    const percent = loaded / status.total * 100;
    if (loaded >= status.total) {
      this.updateStatus(sceneId, errors.length === status.total ? "error" : "complete", percent, loaded, status.total, errors);
      this.notifyCompletion(sceneId);
    } else {
      this.updateStatus(sceneId, "preloading", percent, loaded, status.total, errors);
    }
  }
  updateStatus(sceneId, state, percent, loaded, total, errors = []) {
    const status = { state, percent, loaded, total, errors };
    this.sceneStatus.set(sceneId, status);
    this.manifestRegistry.setPreloadStatus(sceneId, status);
  }
  notifyCompletion(sceneId) {
    const callbacks = this.completionCallbacks.get(sceneId);
    if (callbacks) {
      for (const callback of callbacks) {
        try {
          callback();
        } catch (e) {
          console.error("PreloadScheduler: Error in completion callback:", e);
        }
      }
      this.completionCallbacks.delete(sceneId);
    }
  }
  wait(ms) {
    return new Promise((resolve2) => setTimeout(resolve2, ms));
  }
  destroy() {
    this.pause();
    this.clearQueue();
    this.sceneStatus.clear();
    this.completionCallbacks.clear();
  }
}
// ../../src/core/sprites/Spritesheet.ts
class Spritesheet {
  texture;
  frames = new Map;
  animations = new Map;
  textureWidth = 0;
  textureHeight = 0;
  constructor(texture, textureWidth, textureHeight) {
    this.texture = texture;
    if (textureWidth !== undefined && textureHeight !== undefined) {
      this.textureWidth = textureWidth;
      this.textureHeight = textureHeight;
    } else if (texture.gpuTexture) {
      this.textureWidth = texture.gpuTexture.width;
      this.textureHeight = texture.gpuTexture.height;
    }
  }
  static async load(device, atlasUrl, dataUrl) {
    const texture = new Texture("Spritesheet");
    await texture.load(device, atlasUrl);
    const response = await fetch(dataUrl);
    const data = await response.json();
    return Spritesheet.fromJSON(texture, data);
  }
  static fromGrid(texture, frameWidth, frameHeight, frameCount, options) {
    if (!texture.gpuTexture) {
      throw new Error("Texture must be loaded before creating spritesheet");
    }
    const textureWidth = texture.gpuTexture.width;
    const textureHeight = texture.gpuTexture.height;
    const spritesheet = new Spritesheet(texture, textureWidth, textureHeight);
    const startX = options?.startX ?? 0;
    const startY = options?.startY ?? 0;
    const spacing = options?.spacing ?? 0;
    const margin = options?.margin ?? 0;
    const cols = Math.floor((textureWidth - margin * 2 + spacing) / (frameWidth + spacing));
    const rows = Math.floor((textureHeight - margin * 2 + spacing) / (frameHeight + spacing));
    const maxFrames = frameCount ?? cols * rows;
    let frameIndex = 0;
    for (let row = 0;row < rows && frameIndex < maxFrames; row++) {
      for (let col = 0;col < cols && frameIndex < maxFrames; col++) {
        const x = margin + startX + col * (frameWidth + spacing);
        const y = margin + startY + row * (frameHeight + spacing);
        spritesheet.addFrame({
          name: `frame_${frameIndex}`,
          x,
          y,
          width: frameWidth,
          height: frameHeight
        });
        frameIndex++;
      }
    }
    return spritesheet;
  }
  static fromJSON(texture, data) {
    let textureWidth = 0;
    let textureHeight = 0;
    if (data.meta?.size) {
      textureWidth = data.meta.size.w;
      textureHeight = data.meta.size.h;
    } else if (texture.gpuTexture) {
      textureWidth = texture.gpuTexture.width;
      textureHeight = texture.gpuTexture.height;
    }
    const spritesheet = new Spritesheet(texture, textureWidth, textureHeight);
    if (Array.isArray(data.frames)) {
      data.frames.forEach((frame, index) => {
        spritesheet.addFrame({
          name: frame.name ?? `frame_${index}`,
          x: frame.x,
          y: frame.y,
          width: frame.w,
          height: frame.h
        });
      });
    } else {
      for (const [name12, frame] of Object.entries(data.frames)) {
        spritesheet.addFrame({
          name: name12,
          x: frame.x,
          y: frame.y,
          width: frame.w,
          height: frame.h
        });
      }
    }
    if (data.animations) {
      for (const [name12, anim] of Object.entries(data.animations)) {
        spritesheet.addAnimation({
          name: name12,
          frames: anim.frames,
          frameRate: anim.frameRate ?? 12,
          loop: anim.loop ?? true
        });
      }
    }
    return spritesheet;
  }
  nextFrameIndex = 0;
  addFrame(frame) {
    this.frames.set(frame.name, frame);
    this.frames.set(this.nextFrameIndex, frame);
    this.nextFrameIndex++;
  }
  addAnimation(animation) {
    this.animations.set(animation.name, animation);
  }
  getFrame(nameOrIndex) {
    return this.frames.get(nameOrIndex) ?? null;
  }
  getFrameUV(nameOrIndex) {
    const frame = this.getFrame(nameOrIndex);
    if (!frame || this.textureWidth === 0 || this.textureHeight === 0) {
      return null;
    }
    return {
      offset: {
        x: frame.x / this.textureWidth,
        y: frame.y / this.textureHeight
      },
      scale: {
        x: frame.width / this.textureWidth,
        y: frame.height / this.textureHeight
      }
    };
  }
  getAnimation(name12) {
    return this.animations.get(name12) ?? null;
  }
  getFrameNames() {
    const names = [];
    this.frames.forEach((frame, key) => {
      if (typeof key === "string") {
        names.push(key);
      }
    });
    return names;
  }
  getAnimationNames() {
    return Array.from(this.animations.keys());
  }
  get frameCount() {
    let count = 0;
    this.frames.forEach((_, key) => {
      if (typeof key === "string") {
        count++;
      }
    });
    return count;
  }
  getTextureSize() {
    return { width: this.textureWidth, height: this.textureHeight };
  }
}
// ../../src/core/tilemaps/Tileset.ts
class Tileset {
  texture;
  tileWidth;
  tileHeight;
  columns;
  rows;
  tileCount;
  firstGid;
  textureWidth;
  textureHeight;
  margin;
  spacing;
  uvCache = new Map;
  constructor(texture, config3) {
    this.texture = texture;
    this.tileWidth = config3.tileWidth;
    this.tileHeight = config3.tileHeight;
    this.margin = config3.margin ?? 0;
    this.spacing = config3.spacing ?? 0;
    this.firstGid = config3.firstGid ?? 1;
    if (texture.gpuTexture) {
      this.textureWidth = texture.gpuTexture.width;
      this.textureHeight = texture.gpuTexture.height;
    } else {
      throw new Error("Tileset texture must be loaded before creating tileset");
    }
    const usableWidth = this.textureWidth - this.margin * 2;
    const usableHeight = this.textureHeight - this.margin * 2;
    this.columns = config3.columns ?? Math.floor((usableWidth + this.spacing) / (this.tileWidth + this.spacing));
    this.rows = Math.floor((usableHeight + this.spacing) / (this.tileHeight + this.spacing));
    this.tileCount = this.columns * this.rows;
  }
  getTileUV(tileId) {
    if (tileId < this.firstGid) {
      return null;
    }
    if (this.uvCache.has(tileId)) {
      return this.uvCache.get(tileId);
    }
    const localIndex = tileId - this.firstGid;
    if (localIndex >= this.tileCount) {
      return null;
    }
    const col = localIndex % this.columns;
    const row = Math.floor(localIndex / this.columns);
    const pixelX = this.margin + col * (this.tileWidth + this.spacing);
    const pixelY = this.margin + row * (this.tileHeight + this.spacing);
    const uv = {
      u: pixelX / this.textureWidth,
      v: pixelY / this.textureHeight,
      uSize: this.tileWidth / this.textureWidth,
      vSize: this.tileHeight / this.textureHeight
    };
    this.uvCache.set(tileId, uv);
    return uv;
  }
  getTileIdAt(col, row) {
    if (col < 0 || col >= this.columns || row < 0 || row >= this.rows) {
      return 0;
    }
    return this.firstGid + row * this.columns + col;
  }
  getTextureSize() {
    return { width: this.textureWidth, height: this.textureHeight };
  }
  getTileSize() {
    return { width: this.tileWidth, height: this.tileHeight };
  }
  getGridSize() {
    return { columns: this.columns, rows: this.rows };
  }
  isValidTileId(tileId) {
    if (tileId < this.firstGid)
      return false;
    const localIndex = tileId - this.firstGid;
    return localIndex < this.tileCount;
  }
  static fromGrid(texture, tileWidth, tileHeight, options) {
    return new Tileset(texture, {
      tileWidth,
      tileHeight,
      margin: options?.margin,
      spacing: options?.spacing,
      firstGid: options?.firstGid,
      columns: options?.columns
    });
  }
  static async load(device, imageUrl, config3) {
    const texture = new Texture("Tileset");
    await texture.load(device, imageUrl);
    return new Tileset(texture, config3);
  }
}
// ../../src/core/tilemaps/TilemapData.ts
class TilemapData {
  width;
  height;
  data;
  _dirty = true;
  constructor(config3) {
    this.width = config3.width;
    this.height = config3.height;
    this.data = new Uint32Array(this.width * this.height);
    if (config3.data) {
      const copyLength = Math.min(config3.data.length, this.data.length);
      for (let i = 0;i < copyLength; i++) {
        this.data[i] = config3.data[i];
      }
    }
  }
  getTile(x, y) {
    if (x < 0 || x >= this.width || y < 0 || y >= this.height) {
      return 0;
    }
    return this.data[y * this.width + x];
  }
  setTile(x, y, tileId) {
    if (x < 0 || x >= this.width || y < 0 || y >= this.height) {
      return;
    }
    const index = y * this.width + x;
    if (this.data[index] !== tileId) {
      this.data[index] = tileId;
      this._dirty = true;
    }
  }
  fill(tileId) {
    this.data.fill(tileId);
    this._dirty = true;
  }
  clear() {
    this.fill(0);
  }
  fillRect(x, y, width, height, tileId) {
    const x1 = Math.max(0, x);
    const y1 = Math.max(0, y);
    const x2 = Math.min(this.width, x + width);
    const y2 = Math.min(this.height, y + height);
    for (let ty = y1;ty < y2; ty++) {
      for (let tx = x1;tx < x2; tx++) {
        this.data[ty * this.width + tx] = tileId;
      }
    }
    this._dirty = true;
  }
  copyFrom(source, srcX, srcY, destX, destY, width, height) {
    for (let dy = 0;dy < height; dy++) {
      for (let dx = 0;dx < width; dx++) {
        const tile = source.getTile(srcX + dx, srcY + dy);
        this.setTile(destX + dx, destY + dy, tile);
      }
    }
  }
  get dirty() {
    return this._dirty;
  }
  markClean() {
    this._dirty = false;
  }
  markDirty() {
    this._dirty = true;
  }
  get tileCount() {
    return this.width * this.height;
  }
  get nonEmptyCount() {
    let count = 0;
    for (let i = 0;i < this.data.length; i++) {
      if (this.data[i] !== 0)
        count++;
    }
    return count;
  }
  forEach(callback) {
    for (let y = 0;y < this.height; y++) {
      for (let x = 0;x < this.width; x++) {
        callback(this.data[y * this.width + x], x, y);
      }
    }
  }
  findTile(tileId) {
    const positions = [];
    this.forEach((id, x, y) => {
      if (id === tileId) {
        positions.push({ x, y });
      }
    });
    return positions;
  }
  clone() {
    const cloned = new TilemapData({ width: this.width, height: this.height });
    cloned.data.set(this.data);
    return cloned;
  }
  static fromArray(width, height, data) {
    return new TilemapData({ width, height, data });
  }
  static fromTiledLayer(tiledLayer) {
    return new TilemapData({
      width: tiledLayer.width,
      height: tiledLayer.height,
      data: tiledLayer.data
    });
  }
  static empty(width, height) {
    return new TilemapData({ width, height });
  }
}
// ../../src/core/tilemaps/Tilemap.ts
class Tilemap extends Node {
  _layers = new Map;
  _layerOrder = [];
  _tilesets = new Map;
  width;
  height;
  tileWidth;
  tileHeight;
  tileScaleX = 1;
  tileScaleY = 1;
  _device = null;
  constructor(config3) {
    super("Tilemap");
    this.width = config3.width;
    this.height = config3.height;
    this.tileWidth = config3.tileWidth;
    this.tileHeight = config3.tileHeight;
    this.tileScaleX = config3.tileScaleX ?? 1;
    this.tileScaleY = config3.tileScaleY ?? 1;
  }
  addTileset(name12, tileset) {
    this._tilesets.set(name12, tileset);
  }
  getTileset(name12) {
    return this._tilesets.get(name12) ?? null;
  }
  removeTileset(name12) {
    return this._tilesets.delete(name12);
  }
  getTilesetNames() {
    return Array.from(this._tilesets.keys());
  }
  createLayer(name12, tilesetName, options) {
    const tileset = this._tilesets.get(tilesetName);
    if (!tileset) {
      console.warn(`Tilemap: Tileset '${tilesetName}' not found`);
      return null;
    }
    let data;
    if (options?.data instanceof TilemapData) {
      data = options.data;
    } else if (Array.isArray(options?.data)) {
      data = TilemapData.fromArray(this.width, this.height, options.data);
    } else {
      data = TilemapData.empty(this.width, this.height);
    }
    const layer = new TilemapLayer(tileset, data, {
      tileScaleX: this.tileScaleX,
      tileScaleY: this.tileScaleY
    });
    layer.name = name12;
    if (options?.visible !== undefined) {
      layer.visible = options.visible;
    }
    if (options?.opacity !== undefined) {
      layer.opacity = options.opacity;
    }
    this._layers.set(name12, layer);
    const zIndex = options?.zIndex ?? this._layerOrder.length;
    this._layerOrder.splice(zIndex, 0, name12);
    this.addChild(layer);
    this.updateLayerZPositions();
    if (this._device) {
      layer.initGPU(this._device);
    }
    return layer;
  }
  addLayer(name12, layer, zIndex) {
    if (this._layers.has(name12)) {
      console.warn(`Tilemap: Layer '${name12}' already exists`);
      return;
    }
    layer.name = name12;
    this._layers.set(name12, layer);
    const index = zIndex ?? this._layerOrder.length;
    this._layerOrder.splice(index, 0, name12);
    this.addChild(layer);
    this.updateLayerZPositions();
    if (this._device) {
      layer.initGPU(this._device);
    }
  }
  getLayer(name12) {
    return this._layers.get(name12) ?? null;
  }
  removeLayer(name12) {
    const layer = this._layers.get(name12);
    if (!layer)
      return false;
    this._layers.delete(name12);
    const index = this._layerOrder.indexOf(name12);
    if (index >= 0) {
      this._layerOrder.splice(index, 1);
    }
    this.removeChild(layer);
    layer.destroy();
    return true;
  }
  getLayerNames() {
    return [...this._layerOrder];
  }
  getLayers() {
    return this._layerOrder.map((name12) => this._layers.get(name12));
  }
  setLayerOrder(names) {
    for (const name12 of names) {
      if (!this._layers.has(name12)) {
        console.warn(`Tilemap: Layer '${name12}' not found`);
        return;
      }
    }
    this._layerOrder = [...names];
    this.updateLayerZPositions();
  }
  moveLayer(name12, newIndex) {
    const oldIndex = this._layerOrder.indexOf(name12);
    if (oldIndex < 0)
      return;
    this._layerOrder.splice(oldIndex, 1);
    this._layerOrder.splice(newIndex, 0, name12);
    this.updateLayerZPositions();
  }
  setTile(layerName, x, y, tileId) {
    const layer = this._layers.get(layerName);
    if (layer) {
      layer.setTile(x, y, tileId);
    }
  }
  getTile(layerName, x, y) {
    const layer = this._layers.get(layerName);
    return layer ? layer.getTile(x, y) : 0;
  }
  getTilesAt(x, y) {
    const result = [];
    for (const name12 of this._layerOrder) {
      const layer = this._layers.get(name12);
      const tileId = layer.getTile(x, y);
      if (tileId !== 0) {
        result.push({ layer: name12, tileId });
      }
    }
    return result;
  }
  worldToTile(worldX, worldY) {
    const localX = worldX - this.transform.position.x;
    const localY = worldY - this.transform.position.y;
    return {
      x: Math.floor(localX / this.tileScaleX),
      y: Math.floor(localY / this.tileScaleY)
    };
  }
  tileToWorld(tileX, tileY) {
    return {
      x: this.transform.position.x + (tileX + 0.5) * this.tileScaleX,
      y: this.transform.position.y + (tileY + 0.5) * this.tileScaleY
    };
  }
  isValidTile(x, y) {
    return x >= 0 && x < this.width && y >= 0 && y < this.height;
  }
  getWorldSize() {
    return {
      width: this.width * this.tileScaleX,
      height: this.height * this.tileScaleY
    };
  }
  initGPU(device) {
    this._device = device;
    for (const layer of this._layers.values()) {
      layer.initGPU(device);
    }
  }
  syncAllLayers() {
    for (const layer of this._layers.values()) {
      layer.syncDataTexture();
    }
  }
  updateLayerZPositions() {
    const zStep = 0.1;
    for (let i = 0;i < this._layerOrder.length; i++) {
      const layer = this._layers.get(this._layerOrder[i]);
      if (layer) {
        layer.transform.position.z = i * zStep;
      }
    }
  }
  destroy() {
    for (const layer of this._layers.values()) {
      layer.destroy();
      this.removeChild(layer);
    }
    this._layers.clear();
    this._layerOrder = [];
    this._tilesets.clear();
    this._device = null;
  }
  static empty(config3) {
    return new Tilemap(config3);
  }
}
// ../../src/core/tilemaps/TileMaterial.ts
class TileMaterial extends Material {
  tileset;
  _tileId = 1;
  tint = new Vector3(1, 1, 1);
  opacity = 1;
  alphaMode = "BLEND";
  alphaCutoff = 0.1;
  pixelPerfect = true;
  _pixelSampler = null;
  _linearSampler = null;
  static MAX_LIGHTS = 8;
  constructor(tileset, tileId = 1) {
    super();
    this.tileset = tileset;
    this._tileId = tileId;
    const commonDefines = `
      struct Light {
        position: vec3f,
        _pad1: f32,
        direction: vec3f,
        _pad2: f32,
        color: vec3f,
        intensity: f32,
        attenuation: vec3f,
        lightType: u32,
        coneAngles: vec2f,
        shadowIndex: i32,
        shadowRadius: f32,
        shadowIntensity: f32,
        _pad3: f32,
        _pad4: f32,
        _pad5: f32,
      }

      struct SceneUniforms {
        viewMatrix : mat4x4<f32>,
        projectionMatrix : mat4x4<f32>,
        lightViewProj : mat4x4<f32>,
        prevViewProj : mat4x4<f32>,
        inverseProjectionMatrix : mat4x4<f32>,
        cameraPosition : vec3f,
        time : f32,
        lightCount : u32,
        debugMode : u32,
        flags : u32,
        environmentIntensity : f32,
        fogColor: vec3f,
        fogDensity: f32,
        fogParams: vec4f,
        fogSettings: vec4u,
        lights : array<Light, ${TileMaterial.MAX_LIGHTS}>,
      }

      struct ObjectData {
        modelMatrix : mat4x4<f32>,
        normalMatrix : mat4x4<f32>,
        aabbMin : vec3f,
        _pad1 : f32,
        aabbMax : vec3f,
        _pad2 : f32,
        prevModelMatrix : mat4x4<f32>,
        _pad3 : vec4<f32>,
        _pad4 : vec4<f32>,
      }

      struct TileUniforms {
        modelMatrix : mat4x4<f32>,
        uvOffset : vec2<f32>,          // Tile UV offset in tileset
        uvScale : vec2<f32>,           // Tile UV scale
        tint : vec3<f32>,
        opacity : f32,
        alphaCutoff : f32,
        alphaMode : u32,
        textureFlags : u32,
        _pad : u32,
      }

      @group(0) @binding(0) var<uniform> scene : SceneUniforms;
      @group(0) @binding(1) var<storage, read> objects : array<ObjectData>;

      @group(1) @binding(0) var<uniform> material : TileUniforms;
      @group(1) @binding(1) var tileSampler : sampler;
      @group(1) @binding(2) var tilesetTex : texture_2d<f32>;

      struct VertexInput {
        @location(0) position : vec3<f32>,
        @location(1) normal : vec3<f32>,
        @location(2) uv : vec2<f32>,
      }

      struct VertexOutput {
        @builtin(position) position : vec4<f32>,
        @location(0) uv : vec2<f32>,
        @location(1) worldPosition : vec3<f32>,
        @location(2) worldNormal : vec3<f32>,
      }
    `;
    this.vertexShaderCode = `
      ${commonDefines}

      @vertex
      fn vs_main(input : VertexInput, @builtin(instance_index) instanceIndex : u32) -> VertexOutput {
        var output : VertexOutput;

        let modelMatrix = material.modelMatrix;
        let worldPos = modelMatrix * vec4f(input.position, 1.0);

        output.worldPosition = worldPos.xyz;
        output.position = scene.projectionMatrix * scene.viewMatrix * worldPos;
        output.worldNormal = (modelMatrix * vec4f(input.normal, 0.0)).xyz;

        // Transform UV to tile region
        output.uv = input.uv * material.uvScale + material.uvOffset;

        return output;
      }
    `;
    this.fragmentShaderCode = `
      ${commonDefines}

      @fragment
      fn fs_main(
        @location(0) uv : vec2<f32>,
        @location(1) worldPosition : vec3<f32>,
        @location(2) worldNormal : vec3<f32>
      ) -> @location(0) vec4<f32> {
        // Sample tileset texture
        var texColor = vec4f(1.0, 1.0, 1.0, 1.0);
        if ((material.textureFlags & 1u) != 0u) {
          texColor = textureSample(tilesetTex, tileSampler, uv);
        }

        // Apply tint and opacity
        var finalColor = texColor.rgb * material.tint;
        var finalAlpha = texColor.a * material.opacity;

        // Alpha cutoff for MASK mode
        if (material.alphaMode == 1u && finalAlpha < material.alphaCutoff) {
          discard;
        }

        // For OPAQUE mode, force alpha to 1
        if (material.alphaMode == 0u) {
          finalAlpha = 1.0;
        }

        // Simple ambient + directional lighting
        let N = normalize(worldNormal);
        let ambient = 0.3;
        var diffuse = 0.0;

        if (scene.lightCount > 0u) {
          let light = scene.lights[0];
          var L = vec3f(0.0);
          if (light.lightType == 0u) {
            L = normalize(-light.direction);
          } else {
            L = normalize(light.position - worldPosition);
          }
          diffuse = max(dot(N, L), 0.0) * 0.7;
        }

        finalColor = finalColor * (ambient + diffuse);

        return vec4f(finalColor, finalAlpha);
      }
    `;
  }
  get tileId() {
    return this._tileId;
  }
  set tileId(id) {
    this._tileId = id;
  }
  setTileByPosition(col, row) {
    this._tileId = this.tileset.getTileIdAt(col, row);
  }
  getTileUV() {
    return this.tileset.getTileUV(this._tileId);
  }
  getRenderingPath() {
    return "forward";
  }
  getTextureFlags() {
    return this.tileset.texture ? 1 : 0;
  }
  getAlphaModeFlag() {
    switch (this.alphaMode) {
      case "OPAQUE":
        return 0;
      case "MASK":
        return 1;
      case "BLEND":
        return 2;
      default:
        return 2;
    }
  }
  getUniformBufferSize() {
    return 112;
  }
  updateUniforms(device, buffer, offset, context) {
    const arrayBuffer = new ArrayBuffer(this.getUniformBufferSize());
    const floatView = new Float32Array(arrayBuffer);
    const uintView = new Uint32Array(arrayBuffer);
    let i = 0;
    if (context.modelMatrix) {
      const m = context.modelMatrix.elements;
      for (let j = 0;j < 16; j++) {
        floatView[i++] = m[j];
      }
    } else {
      floatView[i++] = 1;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 1;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 1;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 1;
    }
    const tileUV = this.getTileUV();
    floatView[i++] = tileUV?.u ?? 0;
    floatView[i++] = tileUV?.v ?? 0;
    floatView[i++] = tileUV?.uSize ?? 1;
    floatView[i++] = tileUV?.vSize ?? 1;
    floatView[i++] = this.tint.x;
    floatView[i++] = this.tint.y;
    floatView[i++] = this.tint.z;
    floatView[i++] = this.opacity;
    floatView[i++] = this.alphaCutoff;
    uintView[i++] = this.getAlphaModeFlag();
    uintView[i++] = this.getTextureFlags();
    uintView[i++] = 0;
    device.queue.writeBuffer(buffer, offset, arrayBuffer);
  }
  getSampler(device) {
    if (this.pixelPerfect) {
      if (!this._pixelSampler) {
        this._pixelSampler = device.createSampler({
          magFilter: "nearest",
          minFilter: "nearest",
          mipmapFilter: "nearest",
          addressModeU: "clamp-to-edge",
          addressModeV: "clamp-to-edge"
        });
      }
      return this._pixelSampler;
    } else {
      if (!this._linearSampler) {
        this._linearSampler = device.createSampler({
          magFilter: "linear",
          minFilter: "linear",
          mipmapFilter: "linear",
          addressModeU: "clamp-to-edge",
          addressModeV: "clamp-to-edge"
        });
      }
      return this._linearSampler;
    }
  }
  getBindGroupEntries(device, uniformBuffer) {
    const defaultTex = Texture.getDefault(device);
    const sampler = this.getSampler(device);
    return [
      { binding: 0, resource: { buffer: uniformBuffer } },
      { binding: 1, resource: sampler },
      { binding: 2, resource: this.tileset.texture?.view || defaultTex.view }
    ];
  }
  createBindGroupLayout(device) {
    return device.createBindGroupLayout({
      label: "TileMaterial Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX, buffer: { type: "uniform" } },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "filtering" } },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "float" } }
      ]
    });
  }
}
// ../../src/core/ai/pathfinding/AStar.ts
class AStar {
  grid;
  allowDiagonal;
  maxIterations;
  heuristicWeight;
  constructor(grid, config3 = {}) {
    this.grid = grid;
    this.allowDiagonal = config3.allowDiagonal ?? true;
    this.maxIterations = config3.maxIterations ?? 1e4;
    this.heuristicWeight = config3.heuristicWeight ?? 1;
  }
  findPath(start, goal) {
    const startCoord = this.grid.worldToGrid(start);
    const goalCoord = this.grid.worldToGrid(goal);
    return this.findPathGrid(startCoord, goalCoord);
  }
  findPathGrid(start, goal) {
    if (!this.grid.isWalkable(start.x, start.z)) {
      const nearest = this.grid.findNearestWalkable(this.grid.gridToWorld(start.x, start.z));
      if (!nearest) {
        return { found: false, path: [], worldPath: [], cost: 0, nodesExplored: 0 };
      }
      start = nearest;
    }
    if (!this.grid.isWalkable(goal.x, goal.z)) {
      const nearest = this.grid.findNearestWalkable(this.grid.gridToWorld(goal.x, goal.z));
      if (!nearest) {
        return { found: false, path: [], worldPath: [], cost: 0, nodesExplored: 0 };
      }
      goal = nearest;
    }
    if (start.x === goal.x && start.z === goal.z) {
      const worldPos = this.grid.gridToWorld(start.x, start.z);
      return { found: true, path: [start], worldPath: [worldPos], cost: 0, nodesExplored: 0 };
    }
    const openSet = [];
    const closedSet = new Set;
    const nodeMap = new Map;
    const keyOf = (coord) => `${coord.x},${coord.z}`;
    const heuristic = (a, b) => {
      return this.allowDiagonal ? this.grid.octileDistance(a, b) : this.grid.manhattanDistance(a, b);
    };
    const startNode = {
      coord: start,
      gCost: 0,
      hCost: heuristic(start, goal) * this.heuristicWeight,
      fCost: 0,
      parent: null
    };
    startNode.fCost = startNode.gCost + startNode.hCost;
    openSet.push(startNode);
    nodeMap.set(keyOf(start), startNode);
    let iterations = 0;
    while (openSet.length > 0 && iterations < this.maxIterations) {
      iterations++;
      let lowestIndex = 0;
      for (let i = 1;i < openSet.length; i++) {
        if (openSet[i].fCost < openSet[lowestIndex].fCost || openSet[i].fCost === openSet[lowestIndex].fCost && openSet[i].hCost < openSet[lowestIndex].hCost) {
          lowestIndex = i;
        }
      }
      const current = openSet[lowestIndex];
      openSet.splice(lowestIndex, 1);
      closedSet.add(keyOf(current.coord));
      if (current.coord.x === goal.x && current.coord.z === goal.z) {
        return this.reconstructPath(current, iterations);
      }
      const neighbors = this.allowDiagonal ? this.grid.getNeighbors(current.coord.x, current.coord.z) : this.grid.getCardinalNeighbors(current.coord.x, current.coord.z);
      for (const neighbor of neighbors) {
        const neighborKey = keyOf(neighbor);
        if (closedSet.has(neighborKey))
          continue;
        const isDiagonal = neighbor.x !== current.coord.x && neighbor.z !== current.coord.z;
        const moveCost = isDiagonal ? Math.SQRT2 : 1;
        const cellCost = this.grid.getCost(neighbor.x, neighbor.z);
        const tentativeG = current.gCost + moveCost * cellCost;
        let neighborNode = nodeMap.get(neighborKey);
        if (!neighborNode) {
          neighborNode = {
            coord: neighbor,
            gCost: tentativeG,
            hCost: heuristic(neighbor, goal) * this.heuristicWeight,
            fCost: 0,
            parent: current
          };
          neighborNode.fCost = neighborNode.gCost + neighborNode.hCost;
          nodeMap.set(neighborKey, neighborNode);
          openSet.push(neighborNode);
        } else if (tentativeG < neighborNode.gCost) {
          neighborNode.gCost = tentativeG;
          neighborNode.fCost = neighborNode.gCost + neighborNode.hCost;
          neighborNode.parent = current;
        }
      }
    }
    return { found: false, path: [], worldPath: [], cost: 0, nodesExplored: iterations };
  }
  reconstructPath(goalNode, nodesExplored) {
    const path = [];
    let current = goalNode;
    while (current) {
      path.unshift(current.coord);
      current = current.parent;
    }
    const worldPath = path.map((coord) => this.grid.gridToWorld(coord.x, coord.z));
    return {
      found: true,
      path,
      worldPath,
      cost: goalNode.gCost,
      nodesExplored
    };
  }
}
function smoothPath(grid, path) {
  if (path.length <= 2)
    return path;
  const smoothed = [path[0]];
  let current = 0;
  while (current < path.length - 1) {
    let furthest = current + 1;
    for (let i = path.length - 1;i > current + 1; i--) {
      if (grid.hasLineOfSight(path[current], path[i])) {
        furthest = i;
        break;
      }
    }
    smoothed.push(path[furthest]);
    current = furthest;
  }
  return smoothed;
}
// ../../src/core/ai/pathfinding/PathFollower.ts
class PathFollower {
  navGrid;
  pathfinder;
  arrivalThreshold;
  waypointThreshold;
  shouldSmoothPath;
  pathAge;
  speed;
  slowingRadius;
  state = "idle" /* Idle */;
  currentPath = [];
  currentWaypointIndex = 0;
  targetPosition = null;
  lastPathTime = 0;
  _lastResult = null;
  constructor(navGrid, config3 = {}) {
    this.navGrid = navGrid;
    this.pathfinder = new AStar(navGrid);
    this.arrivalThreshold = config3.arrivalThreshold ?? 0.5;
    this.waypointThreshold = config3.waypointThreshold ?? 1;
    this.shouldSmoothPath = config3.smoothPath ?? true;
    this.pathAge = config3.pathAge ?? 2;
    this.speed = config3.speed ?? 5;
    this.slowingRadius = config3.slowingRadius ?? 3;
  }
  getState() {
    return this.state;
  }
  getPath() {
    return this.currentPath;
  }
  getCurrentWaypointIndex() {
    return this.currentWaypointIndex;
  }
  getCurrentWaypoint() {
    if (this.currentWaypointIndex < this.currentPath.length) {
      return this.currentPath[this.currentWaypointIndex];
    }
    return null;
  }
  getTargetPosition() {
    return this.targetPosition;
  }
  getLastResult() {
    return this._lastResult;
  }
  setDestination(currentPosition, destination) {
    this.targetPosition = destination;
    return this.computePath(currentPosition);
  }
  computePath(currentPosition) {
    if (!this.targetPosition) {
      this.state = "idle" /* Idle */;
      return false;
    }
    this.state = "computing" /* Computing */;
    const result = this.pathfinder.findPath(currentPosition, this.targetPosition);
    this._lastResult = result;
    if (!result.found || result.worldPath.length === 0) {
      this.state = "failed" /* Failed */;
      this.currentPath = [];
      return false;
    }
    if (this.shouldSmoothPath && result.path.length > 2) {
      const smoothedGrid = smoothPath(this.navGrid, result.path);
      this.currentPath = smoothedGrid.map((coord) => this.navGrid.gridToWorld(coord.x, coord.z));
    } else {
      this.currentPath = result.worldPath;
    }
    this.currentWaypointIndex = 0;
    if (this.currentPath.length > 1) {
      const distToFirst = currentPosition.subtract(this.currentPath[0]).magnitude();
      if (distToFirst < this.waypointThreshold) {
        this.currentWaypointIndex = 1;
      }
    }
    this.state = "following" /* Following */;
    this.lastPathTime = performance.now() / 1000;
    return true;
  }
  update(currentPosition, dt) {
    if (this.state !== "following" /* Following */) {
      return Vector3.zero;
    }
    const currentTime = performance.now() / 1000;
    if (currentTime - this.lastPathTime > this.pathAge && this.targetPosition) {
      this.computePath(currentPosition);
    }
    const waypoint = this.getCurrentWaypoint();
    if (!waypoint) {
      this.state = "arrived" /* Arrived */;
      return Vector3.zero;
    }
    const toWaypoint = waypoint.subtract(currentPosition);
    const distToWaypoint = new Vector3(toWaypoint.x, 0, toWaypoint.z).magnitude();
    const isFinalWaypoint = this.currentWaypointIndex >= this.currentPath.length - 1;
    if (isFinalWaypoint) {
      if (distToWaypoint < this.arrivalThreshold) {
        this.state = "arrived" /* Arrived */;
        return Vector3.zero;
      }
      const direction = new Vector3(toWaypoint.x, 0, toWaypoint.z);
      if (direction.magnitude() > 0.001) {
        const speedMultiplier = Math.min(1, distToWaypoint / this.slowingRadius);
        return direction.normalize().multiply(this.speed * speedMultiplier);
      }
      return Vector3.zero;
    } else {
      if (distToWaypoint < this.waypointThreshold) {
        this.currentWaypointIndex++;
        return this.update(currentPosition, dt);
      }
      const direction = new Vector3(toWaypoint.x, 0, toWaypoint.z);
      if (direction.magnitude() > 0.001) {
        return direction.normalize().multiply(this.speed);
      }
      return Vector3.zero;
    }
  }
  stop() {
    this.state = "idle" /* Idle */;
    this.currentPath = [];
    this.currentWaypointIndex = 0;
    this.targetPosition = null;
  }
  isFollowing() {
    return this.state === "following" /* Following */;
  }
  hasArrived() {
    return this.state === "arrived" /* Arrived */;
  }
  hasFailed() {
    return this.state === "failed" /* Failed */;
  }
  getRemainingDistance(currentPosition) {
    if (this.currentPath.length === 0)
      return 0;
    let distance = 0;
    if (this.currentWaypointIndex < this.currentPath.length) {
      const waypoint = this.currentPath[this.currentWaypointIndex];
      distance += new Vector3(waypoint.x - currentPosition.x, 0, waypoint.z - currentPosition.z).magnitude();
    }
    for (let i = this.currentWaypointIndex;i < this.currentPath.length - 1; i++) {
      const from = this.currentPath[i];
      const to = this.currentPath[i + 1];
      distance += new Vector3(to.x - from.x, 0, to.z - from.z).magnitude();
    }
    return distance;
  }
}
// ../../src/core/ai/steering/SteeringBehavior.ts
class SteeringBehavior {
  weight = 1;
  enabled = true;
  constructor(weight = 1) {
    this.weight = weight;
  }
  getWeightedForce(agent) {
    if (!this.enabled)
      return Vector3.zero;
    return this.calculate(agent).multiply(this.weight);
  }
}
class Separation extends SteeringBehavior {
  getNeighbors;
  desiredSeparation;
  constructor(getNeighbors, desiredSeparation = 2, weight = 1.5) {
    super(weight);
    this.getNeighbors = getNeighbors;
    this.desiredSeparation = desiredSeparation;
  }
  calculate(agent) {
    const neighbors = this.getNeighbors();
    if (neighbors.length === 0)
      return Vector3.zero;
    let steeringForce = Vector3.zero;
    let count = 0;
    for (const neighbor of neighbors) {
      const toAgent = agent.position.subtract(neighbor.position);
      const distance = toAgent.magnitude();
      if (distance < 0.001 || distance > this.desiredSeparation)
        continue;
      const strength = 1 - distance / this.desiredSeparation;
      steeringForce = steeringForce.add(toAgent.normalize().multiply(strength));
      count++;
    }
    if (count > 0) {
      steeringForce = steeringForce.divide(count);
      steeringForce = steeringForce.normalize().multiply(agent.maxSpeed);
      steeringForce = steeringForce.subtract(agent.velocity);
      return this.limitForce(steeringForce, agent.maxForce);
    }
    return Vector3.zero;
  }
  limitForce(force, maxForce) {
    const mag = force.magnitude();
    if (mag > maxForce) {
      return force.normalize().multiply(maxForce);
    }
    return force;
  }
}
class SteeringCombiner {
  behaviors = [];
  addBehavior(behavior) {
    this.behaviors.push(behavior);
  }
  removeBehavior(behavior) {
    const index = this.behaviors.indexOf(behavior);
    if (index !== -1) {
      this.behaviors.splice(index, 1);
    }
  }
  calculate(agent) {
    let totalForce = Vector3.zero;
    for (const behavior of this.behaviors) {
      const force = behavior.getWeightedForce(agent);
      totalForce = totalForce.add(force);
    }
    return totalForce.clampMagnitude(agent.maxForce);
  }
  calculatePrioritized(agent) {
    let totalForce = Vector3.zero;
    let remainingForce = agent.maxForce;
    const sorted = [...this.behaviors].sort((a, b) => b.weight - a.weight);
    for (const behavior of sorted) {
      if (remainingForce <= 0)
        break;
      const force = behavior.calculate(agent);
      const magnitude = force.magnitude();
      if (magnitude > 0) {
        const usedMagnitude = Math.min(magnitude, remainingForce);
        totalForce = totalForce.add(force.normalize().multiply(usedMagnitude));
        remainingForce -= usedMagnitude;
      }
    }
    return totalForce;
  }
  clear() {
    this.behaviors = [];
  }
}
// ../../src/core/ai/NPCController.ts
class NPCController {
  node;
  physicsWorld;
  navGrid;
  body;
  pathFollower;
  position;
  velocity = Vector3.zero;
  maxSpeed;
  maxForce;
  radius;
  height;
  rotationSpeed;
  gravityMultiplier;
  groundOffset;
  detectionRange;
  attackRange;
  pathRecomputeInterval;
  separationDistance;
  _state = "idle" /* Idle */;
  _isGrounded = false;
  _target = null;
  _targetNode = null;
  _verticalVelocity = 0;
  _lastPathTime = 0;
  steeringCombiner;
  separationBehavior;
  _neighbors = [];
  constructor(node, physicsWorld, navGrid, config3 = {}) {
    this.node = node;
    this.physicsWorld = physicsWorld;
    this.navGrid = navGrid;
    this.radius = config3.radius ?? 0.3;
    this.height = config3.height ?? 1.8;
    this.maxSpeed = config3.moveSpeed ?? 4;
    this.maxForce = this.maxSpeed * 2;
    this.rotationSpeed = config3.rotationSpeed ?? 8;
    this.gravityMultiplier = config3.gravityMultiplier ?? 2;
    this.groundOffset = config3.groundOffset ?? 0.1;
    this.detectionRange = config3.detectionRange ?? 15;
    this.attackRange = config3.attackRange ?? 1.5;
    this.pathRecomputeInterval = config3.pathRecomputeInterval ?? 0.5;
    this.separationDistance = config3.separationDistance ?? 1.5;
    this.position = node.transform.position.clone();
    this.body = new RigidBody({
      type: "kinematic" /* Kinematic */,
      mass: 70,
      friction: 0.5
    });
    const collider = new CapsuleCollider(this.radius, this.height);
    collider.offset = new Vector3(0, this.height / 2, 0);
    this.body.addCollider(collider);
    this.body.attachToNode(node);
    physicsWorld.addBody(this.body);
    const pathConfig = {
      speed: this.maxSpeed,
      arrivalThreshold: this.attackRange * 0.5,
      waypointThreshold: 1,
      smoothPath: true,
      pathAge: 3,
      ...config3.pathFollower
    };
    this.pathFollower = new PathFollower(navGrid, pathConfig);
    this.steeringCombiner = new SteeringCombiner;
    this.separationBehavior = new Separation(() => this._neighbors, this.separationDistance, 1.5);
    this.steeringCombiner.addBehavior(this.separationBehavior);
  }
  get state() {
    return this._state;
  }
  set state(value) {
    if (this._state !== value) {
      this.onStateExit(this._state);
      this._state = value;
      this.onStateEnter(value);
    }
  }
  get isGrounded() {
    return this._isGrounded;
  }
  get target() {
    return this._target;
  }
  get targetNode() {
    return this._targetNode;
  }
  setNeighbors(neighbors) {
    this._neighbors = neighbors.filter((n) => n !== this);
  }
  setTarget(target) {
    this._target = target;
    this._targetNode = null;
  }
  setTargetNode(target) {
    this._targetNode = target;
    this._target = target.transform.position.clone();
  }
  clearTarget() {
    this._target = null;
    this._targetNode = null;
    this.pathFollower.stop();
  }
  canSeeTarget() {
    if (!this._target)
      return false;
    const toTarget = this._target.subtract(this.position);
    const distance = new Vector3(toTarget.x, 0, toTarget.z).magnitude();
    return distance <= this.detectionRange;
  }
  canAttackTarget() {
    if (!this._target)
      return false;
    const toTarget = this._target.subtract(this.position);
    const distance = new Vector3(toTarget.x, 0, toTarget.z).magnitude();
    return distance <= this.attackRange;
  }
  getDistanceToTarget() {
    if (!this._target)
      return Infinity;
    const toTarget = this._target.subtract(this.position);
    return new Vector3(toTarget.x, 0, toTarget.z).magnitude();
  }
  onStateEnter(state) {
    switch (state) {
      case "idle" /* Idle */:
        this.pathFollower.stop();
        break;
      case "chase" /* Chase */:
        if (this._target) {
          this.pathFollower.setDestination(this.position, this._target);
        }
        break;
      case "attack" /* Attack */:
        this.pathFollower.stop();
        break;
    }
  }
  onStateExit(state) {}
  update(dt) {
    this.position = this.node.transform.position.clone();
    if (this._targetNode) {
      this._target = this._targetNode.transform.position.clone();
    }
    this.detectGround();
    switch (this._state) {
      case "idle" /* Idle */:
        this.updateIdle(dt);
        break;
      case "chase" /* Chase */:
        this.updateChase(dt);
        break;
      case "attack" /* Attack */:
        this.updateAttack(dt);
        break;
      case "patrol" /* Patrol */:
        this.updatePatrol(dt);
        break;
      case "flee" /* Flee */:
        this.updateFlee(dt);
        break;
    }
    if (!this._isGrounded) {
      this._verticalVelocity += this.physicsWorld.gravity.y * this.gravityMultiplier * dt;
      this._verticalVelocity = Math.max(this._verticalVelocity, -50);
    } else if (this._verticalVelocity < 0) {
      this._verticalVelocity = 0;
    }
    this.velocity.y = this._verticalVelocity;
    const separationForce = this.steeringCombiner.calculate(this);
    const horizontalVel = new Vector3(this.velocity.x, 0, this.velocity.z);
    const adjustedVel = horizontalVel.add(separationForce.multiply(dt));
    const horizontalMag = adjustedVel.magnitude();
    if (horizontalMag > this.maxSpeed) {
      const clampedHorizontal = adjustedVel.normalize().multiply(this.maxSpeed);
      this.velocity = new Vector3(clampedHorizontal.x, this.velocity.y, clampedHorizontal.z);
    } else {
      this.velocity = new Vector3(adjustedVel.x, this.velocity.y, adjustedVel.z);
    }
    this.move(dt);
    this.position = this.node.transform.position.clone();
  }
  updateIdle(dt) {
    this.velocity.x *= 0.9;
    this.velocity.z *= 0.9;
    if (Math.abs(this.velocity.x) < 0.01)
      this.velocity.x = 0;
    if (Math.abs(this.velocity.z) < 0.01)
      this.velocity.z = 0;
  }
  updateChase(dt) {
    if (!this._target) {
      this.state = "idle" /* Idle */;
      return;
    }
    if (this.canAttackTarget()) {
      this.state = "attack" /* Attack */;
      return;
    }
    const currentTime = performance.now() / 1000;
    if (currentTime - this._lastPathTime > this.pathRecomputeInterval) {
      this.pathFollower.setDestination(this.position, this._target);
      this._lastPathTime = currentTime;
    }
    const moveDir = this.pathFollower.update(this.position, dt);
    if (moveDir.magnitudeSquared() > 0.001) {
      this.velocity.x = moveDir.x;
      this.velocity.z = moveDir.z;
      this.rotateTowards(moveDir, dt);
    } else {
      const toTarget = this._target.subtract(this.position);
      const dir = new Vector3(toTarget.x, 0, toTarget.z);
      if (dir.magnitude() > this.attackRange) {
        const moveVel = dir.normalize().multiply(this.maxSpeed);
        this.velocity.x = moveVel.x;
        this.velocity.z = moveVel.z;
        this.rotateTowards(dir, dt);
      }
    }
  }
  updateAttack(dt) {
    if (this._target) {
      const toTarget = this._target.subtract(this.position);
      this.rotateTowards(toTarget, dt);
    }
    this.velocity.x *= 0.8;
    this.velocity.z *= 0.8;
    if (!this.canAttackTarget()) {
      this.state = "chase" /* Chase */;
    }
  }
  updatePatrol(dt) {
    const moveDir = this.pathFollower.update(this.position, dt);
    if (moveDir.magnitudeSquared() > 0.001) {
      this.velocity.x = moveDir.x;
      this.velocity.z = moveDir.z;
      this.rotateTowards(moveDir, dt);
    } else {
      this.state = "idle" /* Idle */;
    }
  }
  updateFlee(dt) {
    if (!this._target) {
      this.state = "idle" /* Idle */;
      return;
    }
    const fromTarget = this.position.subtract(this._target);
    const dir = new Vector3(fromTarget.x, 0, fromTarget.z);
    if (dir.magnitude() > 0.001) {
      const moveVel = dir.normalize().multiply(this.maxSpeed);
      this.velocity.x = moveVel.x;
      this.velocity.z = moveVel.z;
      this.rotateTowards(dir, dt);
    }
    if (this.getDistanceToTarget() > this.detectionRange * 1.5) {
      this.state = "idle" /* Idle */;
    }
  }
  detectGround() {
    const origin = this.position.add(new Vector3(0, this.height / 2, 0));
    const direction = new Vector3(0, -1, 0);
    const maxDistance = this.height / 2 + this.groundOffset + 0.1;
    const hit = this.physicsWorld.raycast(origin, direction, maxDistance);
    if (hit && hit.body !== this.body) {
      this._isGrounded = hit.distance <= this.height / 2 + this.groundOffset;
    } else {
      this._isGrounded = false;
    }
  }
  rotateTowards(direction, dt) {
    const dir = new Vector3(direction.x, 0, direction.z);
    if (dir.magnitudeSquared() < 0.001)
      return;
    const targetYaw = Math.atan2(dir.x, dir.z);
    const currentRot = this.node.transform.rotation;
    const targetRot = Quaternion.fromAxisAngle(new Vector3(0, 1, 0), targetYaw);
    const t2 = Math.min(1, this.rotationSpeed * dt);
    this.node.transform.rotation = currentRot.slerp(targetRot, t2);
  }
  move(dt) {
    const result = this.physicsWorld.moveAndSlide(this.body, this.velocity, dt);
    this.body.position = result.position;
    if (result.grounded && this._verticalVelocity < 0) {
      this._verticalVelocity = 0;
      this._isGrounded = true;
    }
  }
  destroy() {
    this.physicsWorld.removeBody(this.body);
    this.pathFollower.stop();
  }
}
// ../../src/core/gaussianSplats/GaussianSplatData.ts
class GaussianSplatData {
  splatCount;
  positions;
  scales;
  rotations;
  colors;
  boundsMin = [Infinity, Infinity, Infinity];
  boundsMax = [-Infinity, -Infinity, -Infinity];
  constructor(splatCount) {
    this.splatCount = splatCount;
    this.positions = new Float32Array(splatCount * 3);
    this.scales = new Float32Array(splatCount * 3);
    this.rotations = new Float32Array(splatCount * 4);
    this.colors = new Float32Array(splatCount * 4);
  }
  setSplat(index, position, scale2, rotation, color) {
    const posOffset = index * 3;
    const scaleOffset = index * 3;
    const rotOffset = index * 4;
    const colorOffset = index * 4;
    this.positions[posOffset] = position[0];
    this.positions[posOffset + 1] = position[1];
    this.positions[posOffset + 2] = position[2];
    this.scales[scaleOffset] = scale2[0];
    this.scales[scaleOffset + 1] = scale2[1];
    this.scales[scaleOffset + 2] = scale2[2];
    this.rotations[rotOffset] = rotation[0];
    this.rotations[rotOffset + 1] = rotation[1];
    this.rotations[rotOffset + 2] = rotation[2];
    this.rotations[rotOffset + 3] = rotation[3];
    this.colors[colorOffset] = color[0];
    this.colors[colorOffset + 1] = color[1];
    this.colors[colorOffset + 2] = color[2];
    this.colors[colorOffset + 3] = color[3];
    this.boundsMin[0] = Math.min(this.boundsMin[0], position[0]);
    this.boundsMin[1] = Math.min(this.boundsMin[1], position[1]);
    this.boundsMin[2] = Math.min(this.boundsMin[2], position[2]);
    this.boundsMax[0] = Math.max(this.boundsMax[0], position[0]);
    this.boundsMax[1] = Math.max(this.boundsMax[1], position[1]);
    this.boundsMax[2] = Math.max(this.boundsMax[2], position[2]);
  }
  getInfo() {
    return {
      splatCount: this.splatCount,
      boundsMin: [...this.boundsMin],
      boundsMax: [...this.boundsMax]
    };
  }
  createPackedBuffer() {
    const bytesPerSplat = 16;
    const buffer = new Float32Array(this.splatCount * bytesPerSplat);
    for (let i = 0;i < this.splatCount; i++) {
      const bufferOffset = i * bytesPerSplat;
      const posOffset = i * 3;
      const scaleOffset = i * 3;
      const rotOffset = i * 4;
      const colorOffset = i * 4;
      buffer[bufferOffset + 0] = this.positions[posOffset];
      buffer[bufferOffset + 1] = this.positions[posOffset + 1];
      buffer[bufferOffset + 2] = this.positions[posOffset + 2];
      buffer[bufferOffset + 3] = this.scales[scaleOffset];
      buffer[bufferOffset + 4] = this.scales[scaleOffset + 1];
      buffer[bufferOffset + 5] = this.scales[scaleOffset + 2];
      buffer[bufferOffset + 6] = this.rotations[rotOffset];
      buffer[bufferOffset + 7] = this.rotations[rotOffset + 1];
      buffer[bufferOffset + 8] = this.rotations[rotOffset + 2];
      buffer[bufferOffset + 9] = this.rotations[rotOffset + 3];
      buffer[bufferOffset + 10] = this.colors[colorOffset];
      buffer[bufferOffset + 11] = this.colors[colorOffset + 1];
      buffer[bufferOffset + 12] = this.colors[colorOffset + 2];
      buffer[bufferOffset + 13] = this.colors[colorOffset + 3];
      buffer[bufferOffset + 14] = 0;
      buffer[bufferOffset + 15] = 0;
    }
    return buffer;
  }
}
// ../../src/core/gaussianSplats/SplatLoader.ts
var SPLAT_ROW_SIZE = 32;
function parseSplatFile(buffer) {
  const splatCount = Math.floor(buffer.byteLength / SPLAT_ROW_SIZE);
  if (splatCount === 0) {
    throw new Error("Empty or invalid .splat file");
  }
  const data = new GaussianSplatData(splatCount);
  const dataView = new DataView(buffer);
  const u8View = new Uint8Array(buffer);
  for (let i = 0;i < splatCount; i++) {
    const byteOffset = i * SPLAT_ROW_SIZE;
    const x = dataView.getFloat32(byteOffset + 0, true);
    const y = dataView.getFloat32(byteOffset + 4, true);
    const z = dataView.getFloat32(byteOffset + 8, true);
    let sx = dataView.getFloat32(byteOffset + 12, true);
    let sy = dataView.getFloat32(byteOffset + 16, true);
    let sz = dataView.getFloat32(byteOffset + 20, true);
    const looksLikeLog = sx < 1 && sy < 1 && sz < 1;
    if (looksLikeLog) {
      sx = Math.exp(sx);
      sy = Math.exp(sy);
      sz = Math.exp(sz);
    }
    const r = u8View[byteOffset + 24] / 255;
    const g = u8View[byteOffset + 25] / 255;
    const b = u8View[byteOffset + 26] / 255;
    const a = u8View[byteOffset + 27] / 255;
    const qx_raw = (u8View[byteOffset + 28] - 128) / 128;
    const qy_raw = (u8View[byteOffset + 29] - 128) / 128;
    const qz_raw = (u8View[byteOffset + 30] - 128) / 128;
    const qw_raw = (u8View[byteOffset + 31] - 128) / 128;
    const qLen = Math.sqrt(qx_raw * qx_raw + qy_raw * qy_raw + qz_raw * qz_raw + qw_raw * qw_raw);
    const qx = qLen > 0 ? qx_raw / qLen : 0;
    const qy = qLen > 0 ? qy_raw / qLen : 0;
    const qz = qLen > 0 ? qz_raw / qLen : 0;
    const qw = qLen > 0 ? qw_raw / qLen : 1;
    data.setSplat(i, [x, y, z], [sx, sy, sz], [qx, qy, qz, qw], [r, g, b, a]);
  }
  return data;
}
function parsePlyHeader(buffer) {
  const decoder = new TextDecoder("utf-8");
  const headerView = new Uint8Array(buffer, 0, Math.min(buffer.byteLength, 8192));
  const headerText = decoder.decode(headerView);
  const headerEnd = headerText.indexOf("end_header");
  if (headerEnd === -1) {
    throw new Error("Invalid PLY file: missing end_header");
  }
  const headerEndOffset = headerEnd + "end_header".length + 1;
  const lines = headerText.substring(0, headerEnd).split(`
`);
  let vertexCount = 0;
  let isBinary = false;
  let isLittleEndian = true;
  const propertyMap = new Map;
  let propertyIndex = 0;
  let inVertexElement = false;
  for (const line of lines) {
    const trimmed = line.trim();
    const parts = trimmed.split(/\s+/);
    if (parts[0] === "format") {
      isBinary = parts[1] !== "ascii";
      isLittleEndian = parts[1] === "binary_little_endian";
    } else if (parts[0] === "element" && parts[1] === "vertex") {
      vertexCount = parseInt(parts[2], 10);
      inVertexElement = true;
    } else if (parts[0] === "element" && parts[1] !== "vertex") {
      inVertexElement = false;
    } else if (parts[0] === "property" && inVertexElement) {
      const propName = parts[parts.length - 1];
      propertyMap.set(propName, propertyIndex);
      propertyIndex++;
    }
  }
  return {
    vertexCount,
    propertyMap,
    headerEndOffset,
    isBinary,
    isLittleEndian
  };
}
function parsePlyFile(buffer) {
  const header = parsePlyHeader(buffer);
  if (header.vertexCount === 0) {
    throw new Error("PLY file has no vertices");
  }
  if (!header.isBinary) {
    throw new Error("Only binary PLY files are supported");
  }
  const data = new GaussianSplatData(header.vertexCount);
  const map = header.propertyMap;
  const numProperties = map.size;
  const bytesPerVertex = numProperties * 4;
  const dataView = new DataView(buffer, header.headerEndOffset);
  const xIdx = map.get("x") ?? -1;
  const yIdx = map.get("y") ?? -1;
  const zIdx = map.get("z") ?? -1;
  const scaleXIdx = map.get("scale_0") ?? map.get("sx") ?? map.get("scale_x") ?? -1;
  const scaleYIdx = map.get("scale_1") ?? map.get("sy") ?? map.get("scale_y") ?? -1;
  const scaleZIdx = map.get("scale_2") ?? map.get("sz") ?? map.get("scale_z") ?? -1;
  const rot0Idx = map.get("rot_0") ?? map.get("qw") ?? map.get("f_rest_0") ?? -1;
  const rot1Idx = map.get("rot_1") ?? map.get("qx") ?? map.get("f_rest_1") ?? -1;
  const rot2Idx = map.get("rot_2") ?? map.get("qy") ?? map.get("f_rest_2") ?? -1;
  const rot3Idx = map.get("rot_3") ?? map.get("qz") ?? map.get("f_rest_3") ?? -1;
  const f_dc_0 = map.get("f_dc_0") ?? -1;
  const f_dc_1 = map.get("f_dc_1") ?? -1;
  const f_dc_2 = map.get("f_dc_2") ?? -1;
  const redIdx = map.get("red") ?? map.get("r") ?? -1;
  const greenIdx = map.get("green") ?? map.get("g") ?? -1;
  const blueIdx = map.get("blue") ?? map.get("b") ?? -1;
  const opacityIdx = map.get("opacity") ?? map.get("alpha") ?? map.get("a") ?? -1;
  const SH_C0 = 0.28209479177387814;
  for (let i = 0;i < header.vertexCount; i++) {
    const offset = i * bytesPerVertex;
    const x = xIdx >= 0 ? dataView.getFloat32(offset + xIdx * 4, header.isLittleEndian) : 0;
    const y = yIdx >= 0 ? dataView.getFloat32(offset + yIdx * 4, header.isLittleEndian) : 0;
    const z = zIdx >= 0 ? dataView.getFloat32(offset + zIdx * 4, header.isLittleEndian) : 0;
    let sx = scaleXIdx >= 0 ? dataView.getFloat32(offset + scaleXIdx * 4, header.isLittleEndian) : 1;
    let sy = scaleYIdx >= 0 ? dataView.getFloat32(offset + scaleYIdx * 4, header.isLittleEndian) : 1;
    let sz = scaleZIdx >= 0 ? dataView.getFloat32(offset + scaleZIdx * 4, header.isLittleEndian) : 1;
    sx = Math.exp(sx);
    sy = Math.exp(sy);
    sz = Math.exp(sz);
    let qw = rot0Idx >= 0 ? dataView.getFloat32(offset + rot0Idx * 4, header.isLittleEndian) : 1;
    let qx = rot1Idx >= 0 ? dataView.getFloat32(offset + rot1Idx * 4, header.isLittleEndian) : 0;
    let qy = rot2Idx >= 0 ? dataView.getFloat32(offset + rot2Idx * 4, header.isLittleEndian) : 0;
    let qz = rot3Idx >= 0 ? dataView.getFloat32(offset + rot3Idx * 4, header.isLittleEndian) : 0;
    const qLen = Math.sqrt(qx * qx + qy * qy + qz * qz + qw * qw);
    if (qLen > 0) {
      qx /= qLen;
      qy /= qLen;
      qz /= qLen;
      qw /= qLen;
    }
    let r, g, b;
    if (f_dc_0 >= 0 && f_dc_1 >= 0 && f_dc_2 >= 0) {
      const sh_r = dataView.getFloat32(offset + f_dc_0 * 4, header.isLittleEndian);
      const sh_g = dataView.getFloat32(offset + f_dc_1 * 4, header.isLittleEndian);
      const sh_b = dataView.getFloat32(offset + f_dc_2 * 4, header.isLittleEndian);
      r = Math.max(0, Math.min(1, 0.5 + SH_C0 * sh_r));
      g = Math.max(0, Math.min(1, 0.5 + SH_C0 * sh_g));
      b = Math.max(0, Math.min(1, 0.5 + SH_C0 * sh_b));
    } else if (redIdx >= 0 && greenIdx >= 0 && blueIdx >= 0) {
      r = dataView.getFloat32(offset + redIdx * 4, header.isLittleEndian);
      g = dataView.getFloat32(offset + greenIdx * 4, header.isLittleEndian);
      b = dataView.getFloat32(offset + blueIdx * 4, header.isLittleEndian);
      if (r > 1 || g > 1 || b > 1) {
        r /= 255;
        g /= 255;
        b /= 255;
      }
    } else {
      r = 1;
      g = 1;
      b = 1;
    }
    let a = 1;
    if (opacityIdx >= 0) {
      const opacityLogit = dataView.getFloat32(offset + opacityIdx * 4, header.isLittleEndian);
      a = 1 / (1 + Math.exp(-opacityLogit));
    }
    data.setSplat(i, [x, y, z], [sx, sy, sz], [qx, qy, qz, qw], [r, g, b, a]);
  }
  return data;
}
async function loadSplatFromURL(url) {
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Failed to load splat file: ${response.statusText}`);
  }
  const buffer = await response.arrayBuffer();
  return loadSplatFromBuffer(buffer, url);
}
function loadSplatFromBuffer(buffer, filename2 = "") {
  const ext = filename2.toLowerCase().split(".").pop();
  if (ext === "ply") {
    return parsePlyFile(buffer);
  } else if (ext === "splat") {
    return parseSplatFile(buffer);
  }
  const header = new Uint8Array(buffer, 0, 4);
  const isPly = header[0] === 112 && header[1] === 108 && header[2] === 121;
  if (isPly) {
    return parsePlyFile(buffer);
  }
  return parseSplatFile(buffer);
}

class SplatLoader {
  static async load(url) {
    return loadSplatFromURL(url);
  }
  static loadFromBuffer(buffer, filename2) {
    return loadSplatFromBuffer(buffer, filename2);
  }
}
// ../../src/core/gaussianSplats/GaussianSplats.ts
class GaussianSplats extends Node {
  isGaussianSplats = true;
  _data = null;
  splatScale = 1;
  opacity = 1;
  sortByDepth = true;
  splatBuffer = null;
  indexBuffer = null;
  uniformBuffer = null;
  bindGroup = null;
  worldBounds = new AABB;
  worldBoundingSphere = {
    center: new Vector3,
    radius: 0
  };
  renderIndex = -1;
  previousWorldMatrix = new Matrix4;
  gpuDirty = true;
  constructor(options) {
    super("GaussianSplats");
    if (options?.splatScale !== undefined) {
      this.splatScale = options.splatScale;
    }
    if (options?.opacity !== undefined) {
      this.opacity = options.opacity;
    }
    if (options?.sortByDepth !== undefined) {
      this.sortByDepth = options.sortByDepth;
    }
  }
  get data() {
    return this._data;
  }
  set data(value) {
    this._data = value;
    this.gpuDirty = true;
    this.updateLocalBounds();
  }
  get splatCount() {
    return this._data?.splatCount ?? 0;
  }
  getInfo() {
    return this._data?.getInfo() ?? null;
  }
  async load(url) {
    this._data = await SplatLoader.load(url);
    this.gpuDirty = true;
    this.updateLocalBounds();
  }
  loadFromBuffer(buffer, filename2) {
    this._data = SplatLoader.loadFromBuffer(buffer, filename2);
    this.gpuDirty = true;
    this.updateLocalBounds();
  }
  updateLocalBounds() {
    if (!this._data) {
      this.worldBounds.min.set(0, 0, 0);
      this.worldBounds.max.set(0, 0, 0);
      this.worldBoundingSphere.center.set(0, 0, 0);
      this.worldBoundingSphere.radius = 0;
      return;
    }
    const min = this._data.boundsMin;
    const max = this._data.boundsMax;
    this.worldBounds.min.set(min[0], min[1], min[2]);
    this.worldBounds.max.set(max[0], max[1], max[2]);
    const center = new Vector3((min[0] + max[0]) / 2, (min[1] + max[1]) / 2, (min[2] + max[2]) / 2);
    const radius = Math.sqrt(Math.pow(max[0] - min[0], 2) + Math.pow(max[1] - min[1], 2) + Math.pow(max[2] - min[2], 2)) / 2;
    this.worldBoundingSphere.center.copy(center);
    this.worldBoundingSphere.radius = radius;
  }
  updateWorldBounds() {
    if (!this._data)
      return;
    const min = this._data.boundsMin;
    const max = this._data.boundsMax;
    const corners = [
      new Vector3(min[0], min[1], min[2]),
      new Vector3(min[0], min[1], max[2]),
      new Vector3(min[0], max[1], min[2]),
      new Vector3(min[0], max[1], max[2]),
      new Vector3(max[0], min[1], min[2]),
      new Vector3(max[0], min[1], max[2]),
      new Vector3(max[0], max[1], min[2]),
      new Vector3(max[0], max[1], max[2])
    ];
    this.worldBounds.min.set(Infinity, Infinity, Infinity);
    this.worldBounds.max.set(-Infinity, -Infinity, -Infinity);
    for (const corner of corners) {
      corner.applyMatrix4(this.transform.worldMatrix);
      this.worldBounds.min.min(corner);
      this.worldBounds.max.max(corner);
    }
    const localCenter = new Vector3((min[0] + max[0]) / 2, (min[1] + max[1]) / 2, (min[2] + max[2]) / 2);
    this.worldBoundingSphere.center = localCenter.applyMatrix4(this.transform.worldMatrix);
    const scale2 = this.transform.scale;
    const maxScale = Math.max(Math.abs(scale2.x), Math.abs(scale2.y), Math.abs(scale2.z));
    const localRadius = Math.sqrt(Math.pow(max[0] - min[0], 2) + Math.pow(max[1] - min[1], 2) + Math.pow(max[2] - min[2], 2)) / 2;
    this.worldBoundingSphere.radius = localRadius * maxScale;
  }
  dispose() {
    this.splatBuffer?.destroy();
    this.indexBuffer?.destroy();
    this.uniformBuffer?.destroy();
    this.splatBuffer = null;
    this.indexBuffer = null;
    this.uniformBuffer = null;
    this.bindGroup = null;
  }
  static async fromURL(url, options) {
    const splats = new GaussianSplats(options);
    await splats.load(url);
    return splats;
  }
}
// examples/internal/mystral-test/main.ts
async function main() {
  console.log("Mystral Engine Test - Starting");
  const canvas = document.getElementById("canvas");
  if (!canvas) {
    throw new Error("No canvas found");
  }
  console.log("Creating Engine...");
  const engine = new Engine(canvas, { disableDebugger: true });
  await engine.init();
  console.log("Engine initialized");
  const scene = new Scene(engine);
  console.log("Scene created");
  scene.shadows.resolution = 1024;
  scene.shadows.pointShadowResolution = 512;
  console.log("Shadow config:", JSON.stringify(scene.shadows));
  scene.postProcessing.bloom.enabled = false;
  scene.postProcessing.ssao.enabled = false;
  scene.postProcessing.fxaa.enabled = false;
  scene.postProcessing.aa.enabled = false;
  scene.postProcessing.ssr.enabled = false;
  scene.postProcessing.godRays.enabled = false;
  scene.postProcessing.tonemapping.enabled = true;
  scene.postProcessing.tonemapping.exposure = 1;
  console.log("Post-processing minimal");
  scene.debugMode = 0;
  console.log("Debug mode set to:", scene.debugMode);
  const camera = new Camera;
  camera.transform.position = new Vector3(0, 0.3, 2.5);
  camera.transform.lookAt(new Vector3(0, 0, 0));
  console.log("Canvas properties check:", {
    hasStyle: !!canvas.style,
    hasAddEventListener: !!canvas.addEventListener,
    hasSetPointerCapture: !!canvas.setPointerCapture
  });
  const inputManager = new InputManager(canvas);
  const cameraController = new ArcballController(camera, new Vector3(0, 0, 0));
  cameraController.rotationSpeed = 1;
  cameraController.zoomSpeed = 0.3;
  console.log("InputManager and ArcballController initialized");
  const sun = new DirectionalLight;
  sun.direction = new Vector3(1, 1, 0.5).normalize();
  sun.intensity = 3;
  sun.color = new Vector3(1, 0.98, 0.95);
  scene.addLight(sun);
  console.log("Loading HDR environment...");
  const device = engine.getDevice();
  try {
    const hdrPath = "./examples/assets/environment.hdr";
    const hdrTexture = await HDRLoader.load(device, hdrPath);
    const envMap = EquirectangularToCubemap.convert(device, hdrTexture, 512);
    scene.environmentMap = envMap;
    scene.environmentIntensity = 0.4;
    console.log("Environment loaded");
  } catch (e) {
    console.log("Failed to load environment:", e);
  }
  console.log("Loading DamagedHelmet GLB...");
  let helmetNode = null;
  try {
    const helmetPath = "./examples/assets/DamagedHelmet.glb";
    const helmet = await loadGLBModel(device, helmetPath);
    helmetNode = helmet;
    if (helmet) {
      scene.addChild(helmet);
      console.log("Helmet loaded and added to scene");
    }
    console.log("Helmet transform:", JSON.stringify({
      position: { x: helmet.transform.position.x, y: helmet.transform.position.y, z: helmet.transform.position.z },
      scale: { x: helmet.transform.scale.x, y: helmet.transform.scale.y, z: helmet.transform.scale.z }
    }));
  } catch (e) {
    console.log("Failed to load helmet:", e.message || e);
  }
  let frame = 0;
  let lastTime = performance.now();
  function render() {
    const now = performance.now();
    const deltaTime = (now - lastTime) / 1000;
    lastTime = now;
    const inputState = inputManager.update();
    cameraController.update(deltaTime, inputState);
    if (frame % 60 === 0) {
      console.log(`Frame ${frame}: Camera at (${camera.transform.position.x.toFixed(2)}, ${camera.transform.position.y.toFixed(2)}, ${camera.transform.position.z.toFixed(2)})`);
    }
    if (frame === 0) {
      console.log("Camera viewMatrix diagonal:", [
        camera.viewMatrix.elements[0].toFixed(3),
        camera.viewMatrix.elements[5].toFixed(3),
        camera.viewMatrix.elements[10].toFixed(3),
        camera.viewMatrix.elements[15].toFixed(3)
      ].join(", "));
      console.log("Camera projectionMatrix diagonal:", [
        camera.projectionMatrix.elements[0].toFixed(3),
        camera.projectionMatrix.elements[5].toFixed(3),
        camera.projectionMatrix.elements[10].toFixed(3),
        camera.projectionMatrix.elements[15].toFixed(3)
      ].join(", "));
      if (helmetNode) {
        helmetNode.traverse((node) => {
          if (node instanceof Mesh) {
            console.log(`Helmet mesh renderIndex: ${node.renderIndex}, visible: ${node.visible}`);
          }
        });
      }
    }
    engine.render(scene, camera);
    frame++;
    requestAnimationFrame(render);
  }
  console.log("Setting up input listeners...");
  document.addEventListener("keydown", (e) => {
    console.log(`Key down: ${e.key} (code: ${e.code})`);
  });
  document.addEventListener("keyup", (e) => {
    console.log(`Key up: ${e.key}`);
  });
  document.addEventListener("mousemove", (e) => {
    if (Math.random() < 0.01) {
      console.log(`Mouse: ${e.clientX.toFixed(0)}, ${e.clientY.toFixed(0)}`);
    }
  });
  document.addEventListener("click", (e) => {
    console.log(`Click at: ${e.clientX.toFixed(0)}, ${e.clientY.toFixed(0)}, button: ${e.button}`);
  });
  document.addEventListener("wheel", (e) => {
    console.log(`Wheel: deltaY=${e.deltaY.toFixed(0)}`);
  });
  window.addEventListener("gamepadconnected", (e) => {
    console.log(`Gamepad connected: ${e.gamepad.id}`);
  });
  window.addEventListener("gamepaddisconnected", (e) => {
    console.log(`Gamepad disconnected`);
  });
  console.log("Starting render loop...");
  render();
}
main().catch((e) => {
  console.log("Error:", e.message || e);
});
