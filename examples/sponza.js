// ../../src/core/debug/components/Panel.ts
class Panel {
  element;
  summary;
  content;
  title;
  isOpen = false;
  constructor(title, options = {}) {
    this.title = title;
    this.isOpen = options.defaultOpen ?? false;
    this.element = document.createElement("details");
    this.element.style.marginTop = "8px";
    this.element.style.borderTop = "1px solid #555";
    this.element.style.paddingTop = "4px";
    if (this.isOpen) {
      this.element.open = true;
    }
    this.summary = document.createElement("summary");
    this.summary.style.cursor = "pointer";
    this.summary.style.fontWeight = "bold";
    this.summary.style.marginBottom = "4px";
    this.summary.style.outline = "none";
    this.summary.style.display = "flex";
    this.summary.style.justifyContent = "space-between";
    this.summary.style.alignItems = "center";
    this.summary.style.userSelect = "none";
    const titleSpan = document.createElement("span");
    titleSpan.innerText = title;
    this.summary.appendChild(titleSpan);
    if (options.showRefresh && options.onRefresh) {
      const refreshBtn = document.createElement("button");
      refreshBtn.innerText = "Refresh";
      refreshBtn.style.fontSize = "10px";
      refreshBtn.style.marginLeft = "10px";
      refreshBtn.style.padding = "2px 6px";
      refreshBtn.style.cursor = "pointer";
      refreshBtn.onclick = (e) => {
        e.stopPropagation();
        options.onRefresh?.();
      };
      this.summary.appendChild(refreshBtn);
    }
    this.element.appendChild(this.summary);
    this.content = document.createElement("div");
    this.content.style.marginTop = "5px";
    this.content.style.fontSize = "11px";
    this.content.style.paddingLeft = "4px";
    this.element.appendChild(this.content);
    this.element.addEventListener("toggle", () => {
      this.isOpen = this.element.open;
      this.onToggle(this.isOpen);
    });
  }
  onToggle(isOpen) {}
  getElement() {
    return this.element;
  }
  setOpen(open) {
    this.element.open = open;
    this.isOpen = open;
  }
  update() {}
  cleanup() {}
}

// ../../src/core/debug/panels/PerformancePanel.ts
class PerformancePanel extends Panel {
  canvas;
  ctx;
  triangleInfo;
  history = [];
  maxHistory = 60;
  currentFps = 0;
  frameTriangles = 0;
  sceneTriangles = 0;
  gpuDraws = 0;
  gpuTriangles = 0;
  constructor() {
    super("Performance", { defaultOpen: false });
    this.canvas = document.createElement("canvas");
    this.canvas.width = 120;
    this.canvas.height = 40;
    this.canvas.style.display = "block";
    this.canvas.style.backgroundColor = "#222";
    this.canvas.style.marginBottom = "5px";
    this.canvas.style.borderRadius = "3px";
    this.content.appendChild(this.canvas);
    this.ctx = this.canvas.getContext("2d");
    this.triangleInfo = document.createElement("div");
    this.content.appendChild(this.triangleInfo);
    this.updateStats();
  }
  setFps(fps) {
    this.currentFps = fps;
    this.history.push(fps);
    if (this.history.length > this.maxHistory) {
      this.history.shift();
    }
  }
  setFrameTriangles(count) {
    this.frameTriangles = count;
  }
  setSceneTriangles(count) {
    this.sceneTriangles = count;
  }
  setGpuStats(draws, triangles) {
    this.gpuDraws = draws;
    this.gpuTriangles = triangles;
  }
  update() {
    if (!this.isOpen)
      return;
    this.drawGraph();
    this.updateStats();
  }
  drawGraph() {
    if (!this.ctx)
      return;
    const ctx = this.ctx;
    const w = this.canvas.width;
    const h = this.canvas.height;
    ctx.clearRect(0, 0, w, h);
    const maxFps = Math.max(60, ...this.history);
    ctx.fillStyle = "#4CAF50";
    const barWidth = w / this.maxHistory;
    for (let i = 0;i < this.history.length; i++) {
      const fps = this.history[i];
      const height = fps / maxFps * h;
      const x = i * barWidth;
      const y = h - height;
      if (fps < 30) {
        ctx.fillStyle = "#f44336";
      } else if (fps < 50) {
        ctx.fillStyle = "#ff9800";
      } else {
        ctx.fillStyle = "#4CAF50";
      }
      ctx.fillRect(x, y, barWidth - 1, height);
    }
    ctx.strokeStyle = "#666";
    ctx.setLineDash([2, 2]);
    ctx.beginPath();
    const y60 = h - 60 / maxFps * h;
    ctx.moveTo(0, y60);
    ctx.lineTo(w, y60);
    ctx.stroke();
    ctx.setLineDash([]);
  }
  updateStats() {
    this.triangleInfo.innerHTML = `
      <div style="margin-bottom: 2px;">CPU Tris: ${this.formatNumber(this.frameTriangles)}</div>
      <div style="margin-bottom: 2px;">Scene Tris: ${this.formatNumber(this.sceneTriangles)}</div>
      <div style="border-top: 1px solid #444; margin-top: 2px; padding-top: 2px;">
        <div style="color: #8f8;">GPU Draws: ${this.formatNumber(this.gpuDraws)}</div>
        <div style="color: #8f8;">GPU Tris: ${this.formatNumber(this.gpuTriangles)}</div>
      </div>
    `;
  }
  formatNumber(num) {
    if (num >= 1e6)
      return (num / 1e6).toFixed(1) + "M";
    if (num >= 1000)
      return (num / 1000).toFixed(1) + "k";
    return num.toString();
  }
  getFps() {
    return this.currentFps;
  }
}

// ../../src/core/debug/components/CopyButton.ts
function createCopyButton(label, getText, options = {}) {
  const btn = document.createElement("button");
  btn.innerText = label;
  btn.style.fontSize = "9px";
  btn.style.padding = "2px 6px";
  btn.style.cursor = "pointer";
  btn.style.backgroundColor = "#333";
  btn.style.color = "#fff";
  btn.style.border = "1px solid #555";
  btn.style.borderRadius = "3px";
  if (options.fullWidth) {
    btn.style.width = "100%";
  }
  btn.onmouseenter = () => {
    btn.style.backgroundColor = "#444";
  };
  btn.onmouseleave = () => {
    btn.style.backgroundColor = "#333";
  };
  btn.onclick = (e) => {
    e.stopPropagation();
    const text = getText();
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(text).then(() => {
        showSuccess();
      }).catch(() => {
        fallbackCopy(text);
      });
    } else {
      fallbackCopy(text);
    }
  };
  function fallbackCopy(text) {
    const textArea = document.createElement("textarea");
    textArea.value = text;
    textArea.style.position = "fixed";
    textArea.style.left = "-9999px";
    document.body.appendChild(textArea);
    textArea.select();
    try {
      document.execCommand("copy");
      showSuccess();
    } catch (err) {
      console.error("Copy failed:", err);
      showError();
    }
    document.body.removeChild(textArea);
  }
  function showSuccess() {
    const originalText = btn.innerText;
    btn.innerText = "✓";
    btn.style.color = "#4f4";
    setTimeout(() => {
      btn.innerText = originalText;
      btn.style.color = "#fff";
    }, 1500);
  }
  function showError() {
    const originalText = btn.innerText;
    btn.innerText = "✗";
    btn.style.color = "#f44";
    setTimeout(() => {
      btn.innerText = originalText;
      btn.style.color = "#fff";
    }, 1500);
  }
  return btn;
}

// ../../src/math/Vector3.ts
class Vector3 {
  x;
  y;
  z;
  constructor(x = 0, y = 0, z = 0) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  static get zero() {
    return new Vector3(0, 0, 0);
  }
  static get one() {
    return new Vector3(1, 1, 1);
  }
  static get up() {
    return new Vector3(0, 1, 0);
  }
  static get down() {
    return new Vector3(0, -1, 0);
  }
  static get right() {
    return new Vector3(1, 0, 0);
  }
  static get left() {
    return new Vector3(-1, 0, 0);
  }
  static get forward() {
    return new Vector3(0, 0, -1);
  }
  static get back() {
    return new Vector3(0, 0, 1);
  }
  static min(a, b) {
    return new Vector3(Math.min(a.x, b.x), Math.min(a.y, b.y), Math.min(a.z, b.z));
  }
  static max(a, b) {
    return new Vector3(Math.max(a.x, b.x), Math.max(a.y, b.y), Math.max(a.z, b.z));
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    return this;
  }
  add(v) {
    return new Vector3(this.x + v.x, this.y + v.y, this.z + v.z);
  }
  subtract(v) {
    return new Vector3(this.x - v.x, this.y - v.y, this.z - v.z);
  }
  multiply(scalar) {
    return new Vector3(this.x * scalar, this.y * scalar, this.z * scalar);
  }
  multiplyScalar(scalar) {
    return this.multiply(scalar);
  }
  divide(scalar) {
    if (scalar === 0) {
      throw new Error("Cannot divide by zero");
    }
    return new Vector3(this.x / scalar, this.y / scalar, this.z / scalar);
  }
  magnitude() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  magnitudeSquared() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  normalize() {
    const mag = this.magnitude();
    if (mag === 0) {
      return Vector3.zero;
    }
    return this.divide(mag);
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  }
  cross(v) {
    return new Vector3(this.y * v.z - this.z * v.y, this.z * v.x - this.x * v.z, this.x * v.y - this.y * v.x);
  }
  distanceTo(v) {
    return this.subtract(v).magnitude();
  }
  distanceToSquared(v) {
    return this.subtract(v).magnitudeSquared();
  }
  clampMagnitude(maxMagnitude) {
    const mag = this.magnitude();
    if (mag > maxMagnitude) {
      return this.normalize().multiply(maxMagnitude);
    }
    return this.clone();
  }
  lerp(v, t) {
    return this.add(v.subtract(this).multiply(t));
  }
  slerp(v, t) {
    const dot = this.dot(v);
    const theta = Math.acos(Math.max(-1, Math.min(1, dot)));
    const sinTheta = Math.sin(theta);
    if (sinTheta === 0) {
      return this.lerp(v, t);
    }
    const a = Math.sin((1 - t) * theta) / sinTheta;
    const b = Math.sin(t * theta) / sinTheta;
    return this.multiply(a).add(v.multiply(b));
  }
  reflect(normal) {
    return this.subtract(normal.multiply(2 * this.dot(normal)));
  }
  projectOn(v) {
    const vMagSq = v.magnitudeSquared();
    if (vMagSq === 0) {
      return Vector3.zero;
    }
    return v.multiply(this.dot(v) / vMagSq);
  }
  angleTo(v) {
    const dotProduct = this.dot(v);
    const magProduct = this.magnitude() * v.magnitude();
    if (magProduct === 0) {
      return 0;
    }
    return Math.acos(Math.max(-1, Math.min(1, dotProduct / magProduct)));
  }
  equals(v, epsilon = 0.000001) {
    return Math.abs(this.x - v.x) < epsilon && Math.abs(this.y - v.y) < epsilon && Math.abs(this.z - v.z) < epsilon;
  }
  clone() {
    return new Vector3(this.x, this.y, this.z);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
  }
  set(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }
  toString() {
    return `Vector3(${this.x.toFixed(3)}, ${this.y.toFixed(3)}, ${this.z.toFixed(3)})`;
  }
  toArray() {
    return [this.x, this.y, this.z];
  }
  static fromArray(array) {
    return new Vector3(array[0], array[1], array[2]);
  }
  applyMatrix4(m) {
    const x = this.x, y = this.y, z = this.z;
    const e = m.elements;
    const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
    return this;
  }
}

// ../../src/core/debug/components/NumberInput.ts
function createNumberInput(initialValue, options = {}) {
  const {
    min = -Infinity,
    max = Infinity,
    step = 0.1,
    precision = 2,
    label,
    width = "60px",
    onChange
  } = options;
  const container = document.createElement("div");
  container.style.display = "flex";
  container.style.alignItems = "center";
  container.style.gap = "4px";
  if (label) {
    const labelEl = document.createElement("span");
    labelEl.innerText = label;
    labelEl.style.fontSize = "10px";
    labelEl.style.color = "#aaa";
    labelEl.style.minWidth = "20px";
    container.appendChild(labelEl);
  }
  const input = document.createElement("input");
  input.type = "number";
  input.value = initialValue.toFixed(precision);
  input.style.width = width;
  input.style.fontSize = "10px";
  input.style.padding = "2px 4px";
  input.style.backgroundColor = "#222";
  input.style.color = "#fff";
  input.style.border = "1px solid #555";
  input.style.borderRadius = "3px";
  input.step = step.toString();
  if (min !== -Infinity)
    input.min = min.toString();
  if (max !== Infinity)
    input.max = max.toString();
  let currentValue = initialValue;
  input.oninput = () => {
    const val = parseFloat(input.value);
    if (!isNaN(val)) {
      currentValue = Math.max(min, Math.min(max, val));
      onChange?.(currentValue);
    }
  };
  input.onblur = () => {
    input.value = currentValue.toFixed(precision);
  };
  input.onkeydown = (e) => {
    if (e.key === "ArrowUp") {
      e.preventDefault();
      currentValue = Math.min(max, currentValue + step);
      input.value = currentValue.toFixed(precision);
      onChange?.(currentValue);
    } else if (e.key === "ArrowDown") {
      e.preventDefault();
      currentValue = Math.max(min, currentValue - step);
      input.value = currentValue.toFixed(precision);
      onChange?.(currentValue);
    }
  };
  container.appendChild(input);
  return {
    element: container,
    getValue: () => currentValue,
    setValue: (v) => {
      currentValue = Math.max(min, Math.min(max, v));
      input.value = currentValue.toFixed(precision);
    }
  };
}

// ../../src/core/debug/components/Vector3Input.ts
function createVector3Input(initialValue, options = {}) {
  const {
    precision = 2,
    step = 0.1,
    labels = { x: "X", y: "Y", z: "Z" },
    colors = { x: "#ff6666", y: "#66ff66", z: "#6666ff" },
    onChange
  } = options;
  const container = document.createElement("div");
  container.style.display = "flex";
  container.style.gap = "4px";
  container.style.alignItems = "center";
  const currentValue = new Vector3(initialValue.x, initialValue.y, initialValue.z);
  const createAxisInput = (axis) => {
    const axisContainer = document.createElement("div");
    axisContainer.style.display = "flex";
    axisContainer.style.alignItems = "center";
    axisContainer.style.gap = "2px";
    const label = document.createElement("span");
    label.innerText = labels[axis] || axis.toUpperCase();
    label.style.fontSize = "10px";
    label.style.color = colors[axis] || "#fff";
    label.style.fontWeight = "bold";
    label.style.minWidth = "12px";
    axisContainer.appendChild(label);
    const inputOpts = {
      precision,
      step,
      width: "55px",
      onChange: (val) => {
        currentValue[axis] = val;
        onChange?.(currentValue.clone());
      }
    };
    const input = createNumberInput(initialValue[axis], inputOpts);
    axisContainer.appendChild(input.element);
    return { container: axisContainer, input };
  };
  const xInput = createAxisInput("x");
  const yInput = createAxisInput("y");
  const zInput = createAxisInput("z");
  container.appendChild(xInput.container);
  container.appendChild(yInput.container);
  container.appendChild(zInput.container);
  return {
    element: container,
    getValue: () => currentValue.clone(),
    setValue: (v) => {
      currentValue.x = v.x;
      currentValue.y = v.y;
      currentValue.z = v.z;
      xInput.input.setValue(v.x);
      yInput.input.setValue(v.y);
      zInput.input.setValue(v.z);
    }
  };
}

// ../../src/math/Matrix4.ts
class Matrix4 {
  elements;
  constructor(elements) {
    this.elements = new Float32Array(elements || [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ]);
  }
  static get identity() {
    return new Matrix4;
  }
  static zero() {
    return new Matrix4([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
  }
  copy(m) {
    this.elements.set(m.elements);
    return this;
  }
  clone() {
    return new Matrix4(Array.from(this.elements));
  }
  multiply(m) {
    return this.multiplyMatrices(this, m);
  }
  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
    const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
    const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
    const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
    const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
    const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
    const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
    const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }
  transpose() {
    const te = this.elements;
    let tmp;
    tmp = te[1];
    te[1] = te[4];
    te[4] = tmp;
    tmp = te[2];
    te[2] = te[8];
    te[8] = tmp;
    tmp = te[3];
    te[3] = te[12];
    te[12] = tmp;
    tmp = te[6];
    te[6] = te[9];
    te[9] = tmp;
    tmp = te[7];
    te[7] = te[13];
    te[13] = tmp;
    tmp = te[11];
    te[11] = te[14];
    te[14] = tmp;
    return this;
  }
  determinant() {
    const te = this.elements;
    const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
    const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
    const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
    const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  }
  inverse() {
    const te = this.elements;
    const n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3];
    const n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7];
    const n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11];
    const n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15];
    const t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
    const t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
    const t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
    const t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (Math.abs(det) < 0.0000000001) {
      console.warn("Matrix4.inverse(): Can not invert matrix, determinant is too small:", det);
      return this.identity();
    }
    const detInv = 1 / det;
    const out = this.elements;
    out[0] = t11 * detInv;
    out[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    out[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    out[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    out[4] = t12 * detInv;
    out[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    out[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    out[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    out[8] = t13 * detInv;
    out[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    out[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    out[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    out[12] = t14 * detInv;
    out[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    out[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    out[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  }
  invert() {
    return this.inverse();
  }
  identity() {
    this.elements.set([
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ]);
    return this;
  }
  makeTranslation(v) {
    this.elements.set([
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      v.x,
      v.y,
      v.z,
      1
    ]);
    return this;
  }
  makeRotationFromAxisAngle(axis, angle) {
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    const t = 1 - c;
    const { x, y, z } = axis;
    const tx = t * x, ty = t * y;
    this.elements.set([
      tx * x + c,
      tx * y - s * z,
      tx * z + s * y,
      0,
      tx * y + s * z,
      ty * y + c,
      ty * z - s * x,
      0,
      tx * z - s * y,
      ty * z + s * x,
      t * z * z + c,
      0,
      0,
      0,
      0,
      1
    ]);
    return this;
  }
  makeRotationX(angle) {
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    this.elements.set([
      1,
      0,
      0,
      0,
      0,
      c,
      -s,
      0,
      0,
      s,
      c,
      0,
      0,
      0,
      0,
      1
    ]);
    return this;
  }
  makeRotationY(angle) {
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    this.elements.set([
      c,
      0,
      s,
      0,
      0,
      1,
      0,
      0,
      -s,
      0,
      c,
      0,
      0,
      0,
      0,
      1
    ]);
    return this;
  }
  makeRotationZ(angle) {
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    this.elements.set([
      c,
      -s,
      0,
      0,
      s,
      c,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ]);
    return this;
  }
  makeScale(v) {
    this.elements.set([
      v.x,
      0,
      0,
      0,
      0,
      v.y,
      0,
      0,
      0,
      0,
      v.z,
      0,
      0,
      0,
      0,
      1
    ]);
    return this;
  }
  makePerspective(fov, aspect, near, far) {
    const f = 1 / Math.tan(fov / 2);
    this.elements.set([
      f / aspect,
      0,
      0,
      0,
      0,
      f,
      0,
      0,
      0,
      0,
      far / (near - far),
      -1,
      0,
      0,
      far * near / (near - far),
      0
    ]);
    return this;
  }
  makeOrthographic(left, right, top, bottom, near, far) {
    const te = this.elements;
    const w = 1 / (right - left);
    const h = 1 / (top - bottom);
    const p = 1 / (far - near);
    te[0] = 2 * w;
    te[1] = 0;
    te[2] = 0;
    te[3] = 0;
    te[4] = 0;
    te[5] = 2 * h;
    te[6] = 0;
    te[7] = 0;
    te[8] = 0;
    te[9] = 0;
    te[10] = -p;
    te[11] = 0;
    te[12] = -(right + left) * w;
    te[13] = -(top + bottom) * h;
    te[14] = -near * p;
    te[15] = 1;
    return this;
  }
  lookAt(eye, target, up) {
    const ze = eye.subtract(target).normalize();
    let xe = up.cross(ze);
    if (xe.magnitudeSquared() < 0.000001) {
      if (Math.abs(up.z) < 0.999) {
        xe = new Vector3(0, 0, 1).cross(ze);
      } else {
        xe = new Vector3(1, 0, 0).cross(ze);
      }
    }
    xe = xe.normalize();
    const ye = ze.cross(xe);
    const te = this.elements;
    te[0] = xe.x;
    te[4] = xe.y;
    te[8] = xe.z;
    te[12] = -xe.dot(eye);
    te[1] = ye.x;
    te[5] = ye.y;
    te[9] = ye.z;
    te[13] = -ye.dot(eye);
    te[2] = ze.x;
    te[6] = ze.y;
    te[10] = ze.z;
    te[14] = -ze.dot(eye);
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  }
  decompose() {
    const te = this.elements;
    const sx = Math.sqrt(te[0] * te[0] + te[1] * te[1] + te[2] * te[2]);
    const sy = Math.sqrt(te[4] * te[4] + te[5] * te[5] + te[6] * te[6]);
    const sz = Math.sqrt(te[8] * te[8] + te[9] * te[9] + te[10] * te[10]);
    const scale = new Vector3(sx, sy, sz);
    const position = new Vector3(te[12], te[13], te[14]);
    const rotation = this.clone();
    const invScaleX = 1 / sx;
    const invScaleY = 1 / sy;
    const invScaleZ = 1 / sz;
    rotation.elements[0] *= invScaleX;
    rotation.elements[1] *= invScaleX;
    rotation.elements[2] *= invScaleX;
    rotation.elements[4] *= invScaleY;
    rotation.elements[5] *= invScaleY;
    rotation.elements[6] *= invScaleY;
    rotation.elements[8] *= invScaleZ;
    rotation.elements[9] *= invScaleZ;
    rotation.elements[10] *= invScaleZ;
    return { position, rotation, scale };
  }
  compose(position, rotation, scale) {
    const te = this.elements;
    te[0] = rotation.elements[0] * scale.x;
    te[1] = rotation.elements[1] * scale.x;
    te[2] = rotation.elements[2] * scale.x;
    te[3] = 0;
    te[4] = rotation.elements[4] * scale.y;
    te[5] = rotation.elements[5] * scale.y;
    te[6] = rotation.elements[6] * scale.y;
    te[7] = 0;
    te[8] = rotation.elements[8] * scale.z;
    te[9] = rotation.elements[9] * scale.z;
    te[10] = rotation.elements[10] * scale.z;
    te[11] = 0;
    te[12] = position.x;
    te[13] = position.y;
    te[14] = position.z;
    te[15] = 1;
    return this;
  }
  equals(m, epsilon = 0.000001) {
    const te = this.elements;
    const me = m.elements;
    for (let i = 0;i < 16; i++) {
      if (Math.abs(te[i] - me[i]) > epsilon) {
        return false;
      }
    }
    return true;
  }
  toString() {
    const te = this.elements;
    return `Matrix4(
  ${te[0].toFixed(3)}, ${te[4].toFixed(3)}, ${te[8].toFixed(3)}, ${te[12].toFixed(3)},
  ${te[1].toFixed(3)}, ${te[5].toFixed(3)}, ${te[9].toFixed(3)}, ${te[13].toFixed(3)},
  ${te[2].toFixed(3)}, ${te[6].toFixed(3)}, ${te[10].toFixed(3)}, ${te[14].toFixed(3)},
  ${te[3].toFixed(3)}, ${te[7].toFixed(3)}, ${te[11].toFixed(3)}, ${te[15].toFixed(3)}
)`;
  }
  transformVector(v) {
    const te = this.elements;
    const { x, y, z } = v;
    return new Vector3(te[0] * x + te[4] * y + te[8] * z + te[12], te[1] * x + te[5] * y + te[9] * z + te[13], te[2] * x + te[6] * y + te[10] * z + te[14]);
  }
  transformDirection(v) {
    const te = this.elements;
    const { x, y, z } = v;
    return new Vector3(te[0] * x + te[4] * y + te[8] * z, te[1] * x + te[5] * y + te[9] * z, te[2] * x + te[6] * y + te[10] * z);
  }
  toArray() {
    return this.elements.slice();
  }
}

// ../../src/math/Quaternion.ts
class Quaternion {
  x;
  y;
  z;
  w;
  constructor(x = 0, y = 0, z = 0, w = 1) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  static get identity() {
    return new Quaternion(0, 0, 0, 1);
  }
  copy(q) {
    this.x = q.x;
    this.y = q.y;
    this.z = q.z;
    this.w = q.w;
    return this;
  }
  clone() {
    return new Quaternion(this.x, this.y, this.z, this.w);
  }
  multiply(q) {
    return this.multiplyQuaternions(this.clone(), q);
  }
  multiplyQuaternions(a, b) {
    const { x: qax, y: qay, z: qaz, w: qaw } = a;
    const { x: qbx, y: qby, z: qbz, w: qbw } = b;
    this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    return this;
  }
  slerp(qb, t) {
    if (t === 0)
      return this;
    if (t === 1) {
      this.x = qb.x;
      this.y = qb.y;
      this.z = qb.z;
      this.w = qb.w;
      return this;
    }
    const x = this.x, y = this.y, z = this.z, w = this.w;
    let cosHalfTheta = w * qb.w + x * qb.x + y * qb.y + z * qb.z;
    let { w: qbw, x: qbx, y: qby, z: qbz } = qb;
    if (cosHalfTheta < 0) {
      qbw = -qb.w;
      qbx = -qb.x;
      qby = -qb.y;
      qbz = -qb.z;
      cosHalfTheta = -cosHalfTheta;
    }
    if (cosHalfTheta >= 1) {
      return this;
    }
    const sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta;
    const ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    this.x = x * ratioA + qbx * ratioB;
    this.y = y * ratioA + qby * ratioB;
    this.z = z * ratioA + qbz * ratioB;
    this.w = w * ratioA + qbw * ratioB;
    return this;
  }
  lerp(qb, t) {
    return new Quaternion(this.x + (qb.x - this.x) * t, this.y + (qb.y - this.y) * t, this.z + (qb.z - this.z) * t, this.w + (qb.w - this.w) * t);
  }
  equals(q, epsilon = 0.000001) {
    const directMatch = Math.abs(this.x - q.x) < epsilon && Math.abs(this.y - q.y) < epsilon && Math.abs(this.z - q.z) < epsilon && Math.abs(this.w - q.w) < epsilon;
    const inverseMatch = Math.abs(this.x + q.x) < epsilon && Math.abs(this.y + q.y) < epsilon && Math.abs(this.z + q.z) < epsilon && Math.abs(this.w + q.w) < epsilon;
    return directMatch || inverseMatch;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  lengthSquared() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  normalize() {
    let length = this.length();
    if (length === 0) {
      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.w = 1;
    } else {
      length = 1 / length;
      this.x *= length;
      this.y *= length;
      this.z *= length;
      this.w *= length;
    }
    return this;
  }
  inverse() {
    return new Quaternion(-this.x, -this.y, -this.z, this.w).normalize();
  }
  conjugate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
  }
  setFromAxisAngle(axis, angle) {
    const normAxis = axis.normalize();
    const halfAngle = angle / 2;
    const s = Math.sin(halfAngle);
    this.x = normAxis.x * s;
    this.y = normAxis.y * s;
    this.z = normAxis.z * s;
    this.w = Math.cos(halfAngle);
    return this;
  }
  setFromEuler(xOrEuler, yOrOrder, z, order) {
    let x, y, zVal, eulerOrder;
    if (typeof xOrEuler === "object") {
      x = xOrEuler.x;
      y = xOrEuler.y;
      zVal = xOrEuler.z;
      eulerOrder = yOrOrder ?? "XYZ";
    } else {
      x = xOrEuler;
      y = yOrOrder;
      zVal = z;
      eulerOrder = order ?? "XYZ";
    }
    const c1 = Math.cos(x / 2);
    const c2 = Math.cos(y / 2);
    const c3 = Math.cos(zVal / 2);
    const s1 = Math.sin(x / 2);
    const s2 = Math.sin(y / 2);
    const s3 = Math.sin(zVal / 2);
    switch (eulerOrder) {
      case "XYZ":
        this.x = s1 * c2 * c3 + c1 * s2 * s3;
        this.y = c1 * s2 * c3 - s1 * c2 * s3;
        this.z = c1 * c2 * s3 + s1 * s2 * c3;
        this.w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "YXZ":
        this.x = s1 * c2 * c3 + c1 * s2 * s3;
        this.y = c1 * s2 * c3 - s1 * c2 * s3;
        this.z = c1 * c2 * s3 - s1 * s2 * c3;
        this.w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "ZXY":
        this.x = s1 * c2 * c3 - c1 * s2 * s3;
        this.y = c1 * s2 * c3 + s1 * c2 * s3;
        this.z = c1 * c2 * s3 + s1 * s2 * c3;
        this.w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "ZYX":
        this.x = s1 * c2 * c3 - c1 * s2 * s3;
        this.y = c1 * s2 * c3 + s1 * c2 * s3;
        this.z = c1 * c2 * s3 - s1 * s2 * c3;
        this.w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "YZX":
        this.x = s1 * c2 * c3 + c1 * s2 * s3;
        this.y = c1 * s2 * c3 + s1 * c2 * s3;
        this.z = c1 * c2 * s3 - s1 * s2 * c3;
        this.w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "XZY":
        this.x = s1 * c2 * c3 - c1 * s2 * s3;
        this.y = c1 * s2 * c3 - s1 * c2 * s3;
        this.z = c1 * c2 * s3 + s1 * s2 * c3;
        this.w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      default:
        throw new Error(`Euler order ${eulerOrder} not supported`);
    }
    return this;
  }
  static fromAxisAngle(axis, angle) {
    const normAxis = axis.normalize();
    const halfAngle = angle / 2;
    const s = Math.sin(halfAngle);
    return new Quaternion(normAxis.x * s, normAxis.y * s, normAxis.z * s, Math.cos(halfAngle));
  }
  static fromEuler(euler, order = "XYZ") {
    const x = euler.x;
    const y = euler.y;
    const z = euler.z;
    const c1 = Math.cos(x / 2);
    const c2 = Math.cos(y / 2);
    const c3 = Math.cos(z / 2);
    const s1 = Math.sin(x / 2);
    const s2 = Math.sin(y / 2);
    const s3 = Math.sin(z / 2);
    let qx, qy, qz, qw;
    switch (order) {
      case "XYZ":
        qx = s1 * c2 * c3 + c1 * s2 * s3;
        qy = c1 * s2 * c3 - s1 * c2 * s3;
        qz = c1 * c2 * s3 + s1 * s2 * c3;
        qw = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "YXZ":
        qx = s1 * c2 * c3 + c1 * s2 * s3;
        qy = c1 * s2 * c3 - s1 * c2 * s3;
        qz = c1 * c2 * s3 - s1 * s2 * c3;
        qw = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "ZXY":
        qx = s1 * c2 * c3 - c1 * s2 * s3;
        qy = c1 * s2 * c3 + s1 * c2 * s3;
        qz = c1 * c2 * s3 + s1 * s2 * c3;
        qw = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "ZYX":
        qx = s1 * c2 * c3 - c1 * s2 * s3;
        qy = c1 * s2 * c3 + s1 * c2 * s3;
        qz = c1 * c2 * s3 - s1 * s2 * c3;
        qw = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "YZX":
        qx = s1 * c2 * c3 + c1 * s2 * s3;
        qy = c1 * s2 * c3 + s1 * c2 * s3;
        qz = c1 * c2 * s3 - s1 * s2 * c3;
        qw = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "XZY":
        qx = s1 * c2 * c3 - c1 * s2 * s3;
        qy = c1 * s2 * c3 - s1 * c2 * s3;
        qz = c1 * c2 * s3 + s1 * s2 * c3;
        qw = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      default:
        throw new Error(`Euler order ${order} not supported`);
    }
    return new Quaternion(qx, qy, qz, qw);
  }
  static fromRotationMatrix(m) {
    const te = m.elements;
    const m11 = te[0], m12 = te[4], m13 = te[8];
    const m21 = te[1], m22 = te[5], m23 = te[9];
    const m31 = te[2], m32 = te[6], m33 = te[10];
    const trace = m11 + m22 + m33;
    let q;
    if (trace > 0) {
      const s = 0.5 / Math.sqrt(trace + 1);
      q = new Quaternion((m32 - m23) * s, (m13 - m31) * s, (m21 - m12) * s, 0.25 / s);
    } else if (m11 > m22 && m11 > m33) {
      const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
      q = new Quaternion(0.25 * s, (m12 + m21) / s, (m13 + m31) / s, (m32 - m23) / s);
    } else if (m22 > m33) {
      const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
      q = new Quaternion((m12 + m21) / s, 0.25 * s, (m23 + m32) / s, (m13 - m31) / s);
    } else {
      const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
      q = new Quaternion((m13 + m31) / s, (m23 + m32) / s, 0.25 * s, (m21 - m12) / s);
    }
    return q.normalize();
  }
  toMatrix4() {
    const te = new Matrix4().elements;
    const x = this.x, y = this.y, z = this.z, w = this.w;
    const x2 = x + x, y2 = y + y, z2 = z + z;
    const xx = x * x2, xy = x * y2, xz = x * z2;
    const yy = y * y2, yz = y * z2, zz = z * z2;
    const wx = w * x2, wy = w * y2, wz = w * z2;
    te[0] = 1 - (yy + zz);
    te[4] = xy - wz;
    te[8] = xz + wy;
    te[12] = 0;
    te[1] = xy + wz;
    te[5] = 1 - (xx + zz);
    te[9] = yz - wx;
    te[13] = 0;
    te[2] = xz - wy;
    te[6] = yz + wx;
    te[10] = 1 - (xx + yy);
    te[14] = 0;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return new Matrix4(Array.from(te));
  }
  angleTo(q) {
    return 2 * Math.acos(Math.abs(Math.max(-1, Math.min(1, this.dot(q)))));
  }
  rotateTowards(q, step) {
    const angle = this.angleTo(q);
    if (angle === 0)
      return this;
    const t = Math.min(1, step / angle);
    return this.slerp(q, t);
  }
  invert() {
    return this.conjugate().normalize();
  }
  toString() {
    return `Quaternion(${this.x.toFixed(3)}, ${this.y.toFixed(3)}, ${this.z.toFixed(3)}, ${this.w.toFixed(3)})`;
  }
  toArray() {
    return [this.x, this.y, this.z, this.w];
  }
  static fromArray(array) {
    return new Quaternion(array[0], array[1], array[2], array[3]);
  }
  toEuler(order = "YXZ") {
    const x = this.x, y = this.y, z = this.z, w = this.w;
    const x2 = x * x, y2 = y * y, z2 = z * z, w2 = w * w;
    let ex, ey, ez;
    switch (order) {
      case "XYZ": {
        const sinp = 2 * (w * x - y * z);
        if (Math.abs(sinp) >= 1) {
          ex = Math.sign(sinp) * Math.PI / 2;
        } else {
          ex = Math.asin(sinp);
        }
        ey = Math.atan2(2 * (w * y + x * z), 1 - 2 * (x2 + y2));
        ez = Math.atan2(2 * (w * z + x * y), 1 - 2 * (x2 + z2));
        break;
      }
      case "YXZ": {
        const sinp = 2 * (w * x - y * z);
        if (Math.abs(sinp) >= 1) {
          ex = Math.sign(sinp) * Math.PI / 2;
        } else {
          ex = Math.asin(sinp);
        }
        ey = Math.atan2(2 * (w * y + x * z), w2 - x2 - y2 + z2);
        ez = Math.atan2(2 * (w * z + x * y), w2 - x2 + y2 - z2);
        break;
      }
      default: {
        const sinp = 2 * (w * x - y * z);
        if (Math.abs(sinp) >= 1) {
          ex = Math.sign(sinp) * Math.PI / 2;
        } else {
          ex = Math.asin(sinp);
        }
        ey = Math.atan2(2 * (w * y + x * z), w2 - x2 - y2 + z2);
        ez = Math.atan2(2 * (w * z + x * y), w2 - x2 + y2 - z2);
        break;
      }
    }
    return new Vector3(ex, ey, ez);
  }
  toEulerDegrees(order = "YXZ") {
    const euler = this.toEuler(order);
    const rad2deg = 180 / Math.PI;
    return new Vector3(euler.x * rad2deg, euler.y * rad2deg, euler.z * rad2deg);
  }
}

// ../../src/math/Transform.ts
class Transform {
  _position;
  _rotation;
  _scale;
  _matrix;
  _matrixDirty = true;
  _parent = null;
  _children = [];
  _worldMatrix;
  _worldMatrixDirty = true;
  constructor(position = Vector3.zero, rotation = Quaternion.identity, scale = Vector3.one) {
    this._position = position.clone();
    this._rotation = rotation.clone();
    this._scale = scale.clone();
    this._matrix = Matrix4.identity;
    this._worldMatrix = Matrix4.identity;
  }
  get position() {
    return this._position;
  }
  set position(value) {
    if (!this._position.equals(value)) {
      this._position = value.clone();
      this._markDirty();
    }
  }
  get rotation() {
    return this._rotation;
  }
  set rotation(value) {
    if (!this._rotation.equals(value)) {
      this._rotation = value.clone();
      this._markDirty();
    }
  }
  get scale() {
    return this._scale;
  }
  set scale(value) {
    if (!this._scale.equals(value)) {
      this._scale = value.clone();
      this._markDirty();
    }
  }
  get matrix() {
    if (this._matrixDirty) {
      this._matrix = new Matrix4().compose(this._position, this._rotation.toMatrix4(), this._scale);
      this._matrixDirty = false;
    }
    return this._matrix;
  }
  get worldMatrix() {
    if (this._worldMatrixDirty) {
      if (this._parent) {
        this._worldMatrix = new Matrix4().multiplyMatrices(this._parent.worldMatrix, this.matrix);
      } else {
        this._worldMatrix = this.matrix.clone();
      }
      this._worldMatrixDirty = false;
    }
    return this._worldMatrix;
  }
  get parent() {
    return this._parent;
  }
  get children() {
    return this._children.slice();
  }
  set parent(parent) {
    if (this._parent === parent)
      return;
    if (this._parent) {
      const index = this._parent._children.indexOf(this);
      if (index !== -1) {
        this._parent._children.splice(index, 1);
      }
    }
    this._parent = parent;
    if (this._parent) {
      this._parent._children.push(this);
    }
    this._markWorldMatrixDirty();
  }
  addChild(child) {
    child.parent = this;
  }
  removeChild(child) {
    if (child.parent === this) {
      child.parent = null;
    }
  }
  translate(translation, space = "local") {
    if (space === "local") {
      const rotationMatrix = this.rotation.toMatrix4();
      this.position = this.position.add(rotationMatrix.transformDirection(translation));
    } else {
      this.position = this.position.add(translation);
    }
  }
  rotate(axis, angle, space = "local") {
    if (space === "local") {
      const rotation = Quaternion.fromAxisAngle(axis.normalize(), angle);
      this.rotation = this.rotation.multiply(rotation).normalize();
    } else {
      const worldRotation = Quaternion.fromAxisAngle(axis.normalize(), angle);
      const currentWorldRotation = this.getWorldRotation();
      const newWorldRotation = worldRotation.multiply(currentWorldRotation).normalize();
      this.setWorldRotation(newWorldRotation);
    }
  }
  lookAt(target, up = Vector3.up) {
    const matrix = Matrix4.identity.lookAt(this.position, target, up);
    const { rotation } = matrix.decompose();
    this.rotation = Quaternion.fromRotationMatrix(rotation).invert();
    this._markDirty();
  }
  setWorldPosition(position) {
    if (this._parent) {
      const parentWorldMatrixInverse = this._parent.worldMatrix.clone().inverse();
      this.position = parentWorldMatrixInverse.transformVector(position);
    } else {
      this.position = position.clone();
    }
  }
  setWorldRotation(rotation) {
    if (this._parent) {
      const parentRotation = this._parent.worldMatrix.decompose().rotation;
      const parentQuaternion = Quaternion.fromRotationMatrix(parentRotation);
      this.rotation = parentQuaternion.invert().multiply(rotation).normalize();
    } else {
      this.rotation = rotation.clone();
    }
    this._markDirty();
  }
  setWorldScale(scale) {
    if (this._parent) {
      const parentScale = this._parent.worldMatrix.decompose().scale;
      this.scale = new Vector3(scale.x / parentScale.x, scale.y / parentScale.y, scale.z / parentScale.z);
    } else {
      this.scale = scale.clone();
    }
    this._markDirty();
  }
  getWorldPosition() {
    const { position } = this.worldMatrix.decompose();
    return position;
  }
  getWorldRotation() {
    const { rotation } = this.worldMatrix.decompose();
    return Quaternion.fromRotationMatrix(rotation);
  }
  getWorldScale() {
    const { scale } = this.worldMatrix.decompose();
    return scale;
  }
  getForwardVector() {
    const rotationMatrix = this.rotation.toMatrix4();
    return rotationMatrix.transformDirection(Vector3.forward).normalize();
  }
  getRightVector() {
    const rotationMatrix = this.rotation.toMatrix4();
    return rotationMatrix.transformDirection(Vector3.right).normalize();
  }
  getUpVector() {
    const rotationMatrix = this.rotation.toMatrix4();
    return rotationMatrix.transformDirection(Vector3.up).normalize();
  }
  transformPoint(point) {
    return this.worldMatrix.transformVector(point);
  }
  transformDirection(direction) {
    return this.worldMatrix.transformDirection(direction).normalize();
  }
  inverseTransformPoint(point) {
    const worldPos = this.getWorldPosition();
    const worldScale = this.getWorldScale();
    const worldRot = this.getWorldRotation();
    const translated = point.subtract(worldPos);
    const inverseRot = worldRot.invert();
    const rotated = inverseRot.toMatrix4().transformDirection(translated);
    return new Vector3(rotated.x / worldScale.x, rotated.y / worldScale.y, rotated.z / worldScale.z);
  }
  inverseTransformDirection(direction) {
    const worldMatrixInverse = this.worldMatrix.clone().inverse();
    return worldMatrixInverse.transformDirection(direction).normalize();
  }
  copy(transform) {
    this.position.copy(transform.position);
    this.rotation.copy(transform.rotation);
    this.scale.copy(transform.scale);
    this._markDirty();
    return this;
  }
  clone() {
    return new Transform(this.position, this.rotation, this.scale);
  }
  equals(transform, epsilon = 0.000001) {
    return this.position.equals(transform.position, epsilon) && this.rotation.equals(transform.rotation, epsilon) && this.scale.equals(transform.scale, epsilon);
  }
  reset() {
    this.position.copy(Vector3.zero);
    this.rotation.copy(Quaternion.identity);
    this.scale.copy(Vector3.one);
    this._markDirty();
  }
  _markDirty() {
    this._matrixDirty = true;
    this._markWorldMatrixDirty();
  }
  _markWorldMatrixDirty() {
    this._worldMatrixDirty = true;
    for (const child of this._children) {
      child._markWorldMatrixDirty();
    }
  }
  toString() {
    return `Transform(
  Position: ${this.position.toString()},
  Rotation: ${this.rotation.toString()},
  Scale: ${this.scale.toString()}
)`;
  }
  toJSON() {
    return {
      position: this.position.toArray(),
      rotation: this.rotation.toArray(),
      scale: this.scale.toArray()
    };
  }
  static fromJSON(json) {
    return new Transform(Vector3.fromArray(json.position), Quaternion.fromArray(json.rotation), Vector3.fromArray(json.scale));
  }
}

// ../../src/core/Node.ts
class Node {
  transform;
  name;
  children = [];
  parent = null;
  visible = true;
  renderOrder = 0;
  _initState = "ready";
  _needsUpdate = false;
  get initState() {
    return this._initState;
  }
  get needsInit() {
    return this._initState === "pending";
  }
  get needsUpdate() {
    return this._needsUpdate;
  }
  async onInit(device) {}
  onUpdate(deltaTime) {}
  constructor(name = "Node") {
    this.name = name;
    this.transform = new Transform;
  }
  addChild(child) {
    if (child.parent) {
      child.parent.removeChild(child);
    }
    child.parent = this;
    this.children.push(child);
    this.transform.addChild(child.transform);
  }
  removeChild(child) {
    const index = this.children.indexOf(child);
    if (index !== -1) {
      this.children.splice(index, 1);
      child.parent = null;
      this.transform.removeChild(child.transform);
    }
  }
  traverse(callback) {
    const result = callback(this);
    if (result === false)
      return;
    for (const child of this.children) {
      child.traverse(callback);
    }
  }
}

// ../../src/core/Geometry.ts
class AABB {
  min;
  max;
  constructor(min = new Vector3(Infinity, Infinity, Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
    this.min = min;
    this.max = max;
  }
  get center() {
    return this.min.clone().add(this.max).multiply(0.5);
  }
  get size() {
    return this.max.subtract(this.min);
  }
}

class Geometry {
  attributes = {};
  indices = null;
  vertexCount = 0;
  indexCount = 0;
  vertexBuffers = {};
  indexBuffer = null;
  aabb = new AABB;
  boundingSphere = { center: new Vector3, radius: 0 };
  _buffersDirty = true;
  setAttribute(name, data) {
    this.attributes[name] = data;
    this._buffersDirty = true;
    if (name === "position") {
      this.vertexCount = data.length / 3;
      this.computeBounds();
    }
  }
  setIndices(data) {
    this.indices = data;
    this.indexCount = data.length;
    this._buffersDirty = true;
  }
  get buffersDirty() {
    return this._buffersDirty;
  }
  markBuffersClean() {
    this._buffersDirty = false;
  }
  markBuffersDirty() {
    this._buffersDirty = true;
  }
  destroyBuffers() {
    for (const key in this.vertexBuffers) {
      this.vertexBuffers[key]?.destroy();
    }
    this.vertexBuffers = {};
    this.indexBuffer?.destroy();
    this.indexBuffer = null;
    this._buffersDirty = true;
  }
  get triangleCount() {
    if (this.indices) {
      return this.indexCount / 3;
    }
    return this.vertexCount / 3;
  }
  computeBounds() {
    const positions = this.attributes["position"];
    if (!positions)
      return;
    this.aabb.min = new Vector3(Infinity, Infinity, Infinity);
    this.aabb.max = new Vector3(-Infinity, -Infinity, -Infinity);
    const v = new Vector3;
    for (let i = 0;i < positions.length; i += 3) {
      v.set(positions[i], positions[i + 1], positions[i + 2]);
      this.aabb.min.min(v);
      this.aabb.max.max(v);
    }
    this.boundingSphere.center = this.aabb.center;
    let maxRadiusSq = 0;
    for (let i = 0;i < positions.length; i += 3) {
      v.set(positions[i], positions[i + 1], positions[i + 2]);
      maxRadiusSq = Math.max(maxRadiusSq, v.distanceToSquared(this.boundingSphere.center));
    }
    this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
  }
}

// ../../src/core/Material.ts
class Material {
  vertexShaderCode;
  fragmentShaderCode;
  pipeline = null;
  constructor(vertexShaderCode = "", fragmentShaderCode = "") {
    this.vertexShaderCode = vertexShaderCode;
    this.fragmentShaderCode = fragmentShaderCode;
  }
  getVertexShader(pass) {
    return this.vertexShaderCode;
  }
  getRenderingPath() {
    return "forward";
  }
  getFragmentShader(pass) {
    return this.fragmentShaderCode;
  }
  getBindGroupEntries(device, uniformBuffer, shadowMap = null, shadowSampler = null) {
    return [
      {
        binding: 0,
        resource: {
          buffer: uniformBuffer
        }
      }
    ];
  }
}

// ../../src/core/materials/legacy/BasicMaterial.ts
class BasicMaterial extends Material {
  color;
  constructor(color = new Vector3(1, 0, 0)) {
    const vertexShader = `
      struct Uniforms {
        modelViewProjectionMatrix : mat4x4<f32>,
        color : vec3f,
      }
      @group(0) @binding(0) var<uniform> uniforms : Uniforms;

      struct VertexOutput {
        @builtin(position) position : vec4f,
        @location(0) color : vec3f,
      }

      @vertex
      fn vs_main(@location(0) position : vec3f) -> VertexOutput {
        var output : VertexOutput;
        output.position = uniforms.modelViewProjectionMatrix * vec4f(position, 1.0);
        output.color = uniforms.color;
        return output;
      }
    `;
    const fragmentShader = `
      @fragment
      fn fs_main(@location(0) color : vec3f) -> @location(0) vec4f {
        return vec4f(color, 1.0);
      }
    `;
    super(vertexShader, fragmentShader);
    this.color = color;
  }
  getUniformBufferSize() {
    return 80;
  }
  updateUniforms(device, buffer, offset, context) {
    const { camera, modelMatrix } = context;
    const viewMatrix = camera.viewMatrix;
    const projectionMatrix = camera.projectionMatrix;
    const mvpMatrix = new Matrix4().multiplyMatrices(projectionMatrix, viewMatrix).multiply(modelMatrix);
    const uniformData = new Float32Array(20);
    uniformData.set(mvpMatrix.elements, 0);
    uniformData[16] = this.color.x;
    uniformData[17] = this.color.y;
    uniformData[18] = this.color.z;
    uniformData[19] = 0;
    device.queue.writeBuffer(buffer, offset, uniformData);
  }
}

// ../../src/core/Mesh.ts
class Mesh extends Node {
  geometry;
  material;
  uniformBuffer = null;
  bindGroup = null;
  worldBounds = new AABB;
  worldBoundingSphere = { center: new Vector3, radius: 0 };
  renderIndex = -1;
  previousWorldMatrix = new Matrix4;
  constructor(geometry, material) {
    super("Mesh");
    this.geometry = geometry;
    this.material = material || new BasicMaterial;
  }
  updateWorldBounds() {
    const min = this.geometry.aabb.min;
    const max = this.geometry.aabb.max;
    const corners = [
      new Vector3(min.x, min.y, min.z),
      new Vector3(min.x, min.y, max.z),
      new Vector3(min.x, max.y, min.z),
      new Vector3(min.x, max.y, max.z),
      new Vector3(max.x, min.y, min.z),
      new Vector3(max.x, min.y, max.z),
      new Vector3(max.x, max.y, min.z),
      new Vector3(max.x, max.y, max.z)
    ];
    this.worldBounds.min.set(Infinity, Infinity, Infinity);
    this.worldBounds.max.set(-Infinity, -Infinity, -Infinity);
    for (const corner of corners) {
      corner.applyMatrix4(this.transform.worldMatrix);
      this.worldBounds.min.min(corner);
      this.worldBounds.max.max(corner);
    }
    this.worldBoundingSphere.center = this.geometry.boundingSphere.center.clone().applyMatrix4(this.transform.worldMatrix);
    const scale = this.transform.scale;
    const maxScale = Math.max(Math.abs(scale.x), Math.max(Math.abs(scale.y), Math.abs(scale.z)));
    this.worldBoundingSphere.radius = this.geometry.boundingSphere.radius * maxScale;
  }
}

// ../../src/core/Light.ts
var DEFAULT_LIGHT_SHADOW_CONFIG = {
  castShadow: false,
  bias: 0.002,
  normalBias: 0.01,
  radius: 0.05,
  intensity: 0.7
};

class Light extends Node {
  color;
  intensity;
  shadow;
  shadowAtlasIndex = -1;
  constructor(name = "Light", color = new Vector3(1, 1, 1), intensity = 1) {
    super(name);
    this.color = color;
    this.intensity = intensity;
    this.shadow = { ...DEFAULT_LIGHT_SHADOW_CONFIG };
  }
}

class DirectionalLight extends Light {
  static _counter = 0;
  type = 0 /* Directional */;
  constructor(color = new Vector3(1, 1, 1), intensity = 1, name) {
    super(name ?? `DirectionalLight_${DirectionalLight._counter++}`, color, intensity);
  }
}

class PointLight extends Light {
  static _counter = 0;
  type = 1 /* Point */;
  distance = 0;
  decay = 2;
  constructor(color = new Vector3(1, 1, 1), intensity = 1, distance = 0, decay = 2, name) {
    super(name ?? `PointLight_${PointLight._counter++}`, color, intensity);
    this.distance = distance;
    this.decay = decay;
  }
}
class AmbientLight extends Light {
  static _counter = 0;
  type = 3 /* Ambient */;
  constructor(color = new Vector3(1, 1, 1), intensity = 0.1, name) {
    super(name ?? `AmbientLight_${AmbientLight._counter++}`, color, intensity);
  }
}

// ../../src/core/ui/StyleParser.ts
function parseNumericValue(value) {
  if (typeof value === "number") {
    return value;
  }
  const trimmed = value.trim();
  if (trimmed.endsWith("px")) {
    return parseFloat(trimmed.slice(0, -2));
  }
  if (trimmed.endsWith("rem")) {
    return parseFloat(trimmed.slice(0, -3)) * 16;
  }
  if (trimmed.endsWith("em")) {
    return parseFloat(trimmed.slice(0, -2)) * 16;
  }
  const num = parseFloat(trimmed);
  return isNaN(num) ? 0 : num;
}
function parseBoxValues(value) {
  if (value === undefined) {
    return { top: 0, right: 0, bottom: 0, left: 0 };
  }
  if (typeof value === "number") {
    return { top: value, right: value, bottom: value, left: value };
  }
  if (typeof value === "object") {
    return value;
  }
  if (typeof value === "string") {
    const parts = value.trim().split(/\s+/).map(parseNumericValue);
    switch (parts.length) {
      case 1:
        return { top: parts[0], right: parts[0], bottom: parts[0], left: parts[0] };
      case 2:
        return { top: parts[0], right: parts[1], bottom: parts[0], left: parts[1] };
      case 3:
        return { top: parts[0], right: parts[1], bottom: parts[2], left: parts[1] };
      case 4:
        return { top: parts[0], right: parts[1], bottom: parts[2], left: parts[3] };
      default:
        console.warn(`Invalid box value format: "${value}". Expected 1-4 values.`);
        return { top: 0, right: 0, bottom: 0, left: 0 };
    }
  }
  return { top: 0, right: 0, bottom: 0, left: 0 };
}
function parseGap(value) {
  if (value === undefined) {
    return 0;
  }
  return parseNumericValue(value);
}

// ../../src/core/ui/UIElement.ts
class UIElement {
  id = "";
  name = "";
  parent = null;
  children = [];
  style = {};
  _bounds = { x: 0, y: 0, width: 0, height: 0 };
  _contentSize = { width: 0, height: 0 };
  _dirty = true;
  _visible = true;
  _interactive = true;
  _hovered = false;
  _pressed = false;
  _focused = false;
  onClick;
  onPointerDown;
  onPointerUp;
  onPointerEnter;
  onPointerLeave;
  onFocus;
  onBlur;
  onKeyDown;
  constructor(style) {
    if (style) {
      this.style = { ...style };
      const hasNonDefaultAnchor = style.anchor && style.anchor !== "top-left";
      const hasPivot = style.pivot !== undefined;
      if ((hasNonDefaultAnchor || hasPivot) && !style.position) {
        this.style.position = "absolute";
      }
    }
    this.id = `ui_${Math.random().toString(36).substr(2, 9)}`;
  }
  get bounds() {
    return this._bounds;
  }
  get visible() {
    return this._visible && this.style.visible !== false;
  }
  get interactive() {
    return this._interactive && this.style.pointerEvents !== false;
  }
  get hovered() {
    return this._hovered;
  }
  get pressed() {
    return this._pressed;
  }
  get focused() {
    return this._focused;
  }
  set visible(value) {
    this._visible = value;
    this.style.visible = value;
    this.markDirty();
  }
  set interactive(value) {
    this._interactive = value;
  }
  addChild(child) {
    if (child.parent) {
      child.parent.removeChild(child);
    }
    child.parent = this;
    this.children.push(child);
    this.markDirty();
    return this;
  }
  removeChild(child) {
    const index = this.children.indexOf(child);
    if (index !== -1) {
      this.children.splice(index, 1);
      child.parent = null;
      this.markDirty();
      return true;
    }
    return false;
  }
  clearChildren() {
    for (const child of this.children) {
      child.parent = null;
    }
    this.children = [];
    this.markDirty();
  }
  findById(id) {
    if (this.id === id)
      return this;
    for (const child of this.children) {
      const found = child.findById(id);
      if (found)
        return found;
    }
    return null;
  }
  markDirty() {
    this._dirty = true;
    if (this.parent) {
      this.parent.markDirty();
    }
  }
  getPadding() {
    return parseBoxValues(this.style.padding);
  }
  getMargin() {
    return parseBoxValues(this.style.margin);
  }
  resolveSize(value, parentSize, contentSize) {
    if (value === undefined || value === "auto") {
      return contentSize;
    }
    if (value === "fill" || value === "100%") {
      return parentSize;
    }
    if (typeof value === "number") {
      return value;
    }
    if (typeof value === "string" && value.endsWith("%")) {
      const percent = parseFloat(value) / 100;
      return parentSize * percent;
    }
    return contentSize;
  }
  resolveValue(value, parentSize, defaultValue = 0) {
    if (value === undefined) {
      return defaultValue;
    }
    if (typeof value === "number") {
      return value;
    }
    if (typeof value === "string" && value.endsWith("%")) {
      const percent = parseFloat(value) / 100;
      return parentSize * percent;
    }
    return defaultValue;
  }
  getDefaultPivotForAnchor(anchor) {
    let x = 0;
    if (anchor.includes("center") && !anchor.includes("center-left") && !anchor.includes("center-right")) {
      x = 0.5;
    } else if (anchor.endsWith("-center")) {
      x = 0.5;
    } else if (anchor.includes("right")) {
      x = 1;
    }
    let y = 0;
    if (anchor.startsWith("center")) {
      y = 0.5;
    } else if (anchor.includes("bottom")) {
      y = 1;
    }
    return { x, y };
  }
  layout(parentBounds, screenWidth, screenHeight) {
    const anchor = this.style.anchor ?? "top-left";
    const pivot = this.style.pivot ?? this.getDefaultPivotForAnchor(anchor);
    let width = this.resolveSize(this.style.width, parentBounds.width, this._contentSize.width);
    let height = this.resolveSize(this.style.height, parentBounds.height, this._contentSize.height);
    const minW = this.resolveValue(this.style.minWidth, parentBounds.width, 0);
    const maxW = this.resolveValue(this.style.maxWidth, parentBounds.width, Infinity);
    const minH = this.resolveValue(this.style.minHeight, parentBounds.height, 0);
    const maxH = this.resolveValue(this.style.maxHeight, parentBounds.height, Infinity);
    width = Math.max(minW, Math.min(maxW, width));
    height = Math.max(minH, Math.min(maxH, height));
    let anchorX = parentBounds.x;
    let anchorY = parentBounds.y;
    switch (anchor) {
      case "top-center":
      case "center":
      case "bottom-center":
        anchorX = parentBounds.x + parentBounds.width / 2;
        break;
      case "top-right":
      case "center-right":
      case "bottom-right":
        anchorX = parentBounds.x + parentBounds.width;
        break;
    }
    switch (anchor) {
      case "center-left":
      case "center":
      case "center-right":
        anchorY = parentBounds.y + parentBounds.height / 2;
        break;
      case "bottom-left":
      case "bottom-center":
      case "bottom-right":
        anchorY = parentBounds.y + parentBounds.height;
        break;
    }
    const offsetX = this.resolveValue(this.style.x, parentBounds.width, 0);
    const offsetY = this.resolveValue(this.style.y, parentBounds.height, 0);
    const x = anchorX + offsetX - width * pivot.x;
    const y = anchorY + offsetY - height * pivot.y;
    this._bounds = { x, y, width, height };
    this.layoutChildren(screenWidth, screenHeight);
    this._dirty = false;
  }
  layoutChildren(screenWidth, screenHeight) {
    const padding = this.getPadding();
    const childBounds = {
      x: this._bounds.x + padding.left,
      y: this._bounds.y + padding.top,
      width: this._bounds.width - padding.left - padding.right,
      height: this._bounds.height - padding.top - padding.bottom
    };
    for (const child of this.children) {
      child.layout(childBounds, screenWidth, screenHeight);
    }
  }
  measureContent() {
    let maxWidth = 0;
    let maxHeight = 0;
    for (const child of this.children) {
      const childSize = child.measureContent();
      const margin = child.getMargin();
      maxWidth = Math.max(maxWidth, childSize.width + margin.left + margin.right);
      maxHeight = Math.max(maxHeight, childSize.height + margin.top + margin.bottom);
    }
    const padding = this.getPadding();
    this._contentSize = {
      width: maxWidth + padding.left + padding.right,
      height: maxHeight + padding.top + padding.bottom
    };
    return this._contentSize;
  }
  containsPoint(x, y) {
    return x >= this._bounds.x && x <= this._bounds.x + this._bounds.width && y >= this._bounds.y && y <= this._bounds.y + this._bounds.height;
  }
  hitTest(x, y) {
    if (!this.visible || !this.containsPoint(x, y)) {
      return null;
    }
    const sortedChildren = [...this.children].sort((a, b) => {
      const aLayer = a.style.renderLayer ?? 0;
      const bLayer = b.style.renderLayer ?? 0;
      if (aLayer !== bLayer) {
        return bLayer - aLayer;
      }
      const aZ = a.style.zIndex ?? 0;
      const bZ = b.style.zIndex ?? 0;
      return bZ - aZ;
    });
    for (const child of sortedChildren) {
      const hit = child.hitTest(x, y);
      if (hit && hit.interactive) {
        return hit;
      }
    }
    return this.interactive ? this : null;
  }
  handlePointerEvent(event) {
    switch (event.type) {
      case "pointerdown":
        this._pressed = true;
        this.onPointerDown?.(event);
        this.bubblePointerDown(event);
        return true;
      case "pointerup":
        if (this._pressed) {
          this._pressed = false;
          this.onPointerUp?.(event);
          if (this.containsPoint(event.x, event.y)) {
            this.onClick?.(event);
            this.bubbleClick(event);
          }
        }
        return true;
      case "pointerenter":
        this._hovered = true;
        this.onPointerEnter?.(event);
        return true;
      case "pointerleave":
        this._hovered = false;
        this._pressed = false;
        this.onPointerLeave?.(event);
        return true;
      case "keydown":
        this.onKeyDown?.(event);
        return true;
    }
    return false;
  }
  bubblePointerDown(event) {
    let current = this.parent;
    while (current) {
      current._pressed = true;
      current.onPointerDown?.(event);
      current = current.parent;
    }
  }
  bubbleClick(event) {
    let current = this.parent;
    while (current) {
      if (current.containsPoint(event.x, event.y) && current.onClick) {
        current.onClick(event);
      }
      current._pressed = false;
      current = current.parent;
    }
  }
  setFocus(focused) {
    if (this._focused !== focused) {
      this._focused = focused;
      if (focused) {
        this.onFocus?.();
      } else {
        this.onBlur?.();
      }
      this.markDirty();
    }
  }
  update(dt) {
    for (const child of this.children) {
      child.update(dt);
    }
  }
  collectRenderData(data, parentZIndex = 0, parentRenderLayer = 0) {
    if (!this.visible)
      return;
    const effectiveZIndex = parentZIndex + (this.style.zIndex ?? 0);
    const effectiveRenderLayer = this.style.renderLayer ?? parentRenderLayer;
    this.getRenderData(data, effectiveZIndex, effectiveRenderLayer);
    for (const child of this.children) {
      child.collectRenderData(data, effectiveZIndex, effectiveRenderLayer);
    }
  }
  destroy() {
    for (const child of this.children) {
      child.destroy();
    }
    this.children = [];
    this.parent = null;
  }
}

// ../../src/core/ui/components/Label.ts
class Label extends UIElement {
  _text = "";
  _lines = [];
  _textWidth = 0;
  _textHeight = 0;
  static metricsCanvas = null;
  static metricsContext = null;
  constructor(text = "", style) {
    super(style);
    this._text = text;
    if (style?.text) {
      this._text = style.text;
    }
    this._interactive = false;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    if (this._text !== value) {
      this._text = value;
      this._lines = [];
      this.markDirty();
    }
  }
  get lines() {
    return this._lines;
  }
  getMetricsContext() {
    if (!Label.metricsCanvas) {
      Label.metricsCanvas = document.createElement("canvas");
      Label.metricsContext = Label.metricsCanvas.getContext("2d");
    }
    return Label.metricsContext;
  }
  resolveFontWeight(weight) {
    if (weight === undefined || weight === "normal")
      return "400";
    if (weight === "medium")
      return "500";
    if (weight === "bold")
      return "700";
    if (typeof weight === "number")
      return String(weight);
    return "400";
  }
  wrapText(text, maxWidth, fontSize, fontFamily, fontWeight) {
    if (!text)
      return [];
    const ctx = this.getMetricsContext();
    const weight = this.resolveFontWeight(fontWeight);
    ctx.font = `${weight} ${fontSize}px ${fontFamily}`;
    const lines = [];
    const paragraphs = text.split(`
`);
    for (const paragraph of paragraphs) {
      const words = paragraph.split(" ");
      let currentLine = "";
      for (const word of words) {
        const testLine = currentLine ? `${currentLine} ${word}` : word;
        const metrics = ctx.measureText(testLine);
        if (metrics.width > maxWidth && currentLine) {
          lines.push(currentLine);
          currentLine = word;
        } else {
          currentLine = testLine;
        }
      }
      if (currentLine) {
        lines.push(currentLine);
      }
    }
    return lines;
  }
  measureContent() {
    const fontSize = this.style.fontSize ?? 16;
    const fontFamily = this.style.fontFamily ?? "sans-serif";
    const fontWeight = this.style.fontWeight;
    const lineHeightMultiplier = this.style.lineHeight ?? 1.4;
    const lineHeight = fontSize * lineHeightMultiplier;
    const wordWrap = this.style.wordWrap ?? false;
    const maxWidth = typeof this.style.width === "number" ? this.style.width : Infinity;
    if (wordWrap && maxWidth < Infinity) {
      this._lines = this.wrapText(this._text, maxWidth, fontSize, fontFamily, fontWeight);
    } else {
      this._lines = this._text.split(`
`);
    }
    const maxLines = this.style.maxLines;
    if (maxLines && this._lines.length > maxLines) {
      this._lines = this._lines.slice(0, maxLines);
      if (this._lines.length > 0) {
        this._lines[this._lines.length - 1] += "...";
      }
    }
    let maxLineWidth = 0;
    const ctx = this.getMetricsContext();
    const weight = this.resolveFontWeight(fontWeight);
    ctx.font = `${weight} ${fontSize}px ${fontFamily}`;
    for (const line of this._lines) {
      const metrics = ctx.measureText(line);
      maxLineWidth = Math.max(maxLineWidth, metrics.width);
    }
    this._textWidth = maxLineWidth;
    this._textHeight = this._lines.length * lineHeight;
    const padding = this.getPadding();
    this._contentSize = {
      width: this._textWidth + padding.left + padding.right,
      height: this._textHeight + padding.top + padding.bottom
    };
    return this._contentSize;
  }
  getRenderData(data, baseZIndex, inheritedRenderLayer = 0) {
    const opacity = this.style.opacity ?? 1;
    const renderLayer = this.style.renderLayer ?? inheritedRenderLayer;
    if (opacity <= 0)
      return;
    if (this.style.backgroundColor) {
      data.push({
        type: "quad",
        bounds: { ...this._bounds },
        zIndex: baseZIndex,
        renderLayer,
        backgroundColor: this.style.backgroundColor,
        backgroundAlpha: (this.style.backgroundAlpha ?? 1) * opacity,
        borderRadius: this.style.borderRadius ?? 0
      });
    }
    if (this._text) {
      const padding = this.getPadding();
      const textBounds = {
        x: this._bounds.x + padding.left,
        y: this._bounds.y + padding.top,
        width: this._bounds.width - padding.left - padding.right,
        height: this._bounds.height - padding.top - padding.bottom
      };
      const displayText = this._lines.length > 0 ? this._lines.join(`
`) : this._text;
      data.push({
        type: "text",
        bounds: textBounds,
        zIndex: baseZIndex + 0.1,
        renderLayer,
        text: displayText,
        color: this.style.color ?? "#ffffff",
        fontSize: this.style.fontSize ?? 16,
        fontFamily: this.style.fontFamily ?? "sans-serif",
        textAlign: this.style.textAlign ?? "left",
        textAlpha: opacity,
        letterSpacing: this.style.letterSpacing,
        lineHeight: this.style.lineHeight,
        fontWeight: this.style.fontWeight,
        labelShadow: this.style.labelShadow,
        labelOutline: this.style.labelOutline
      });
    }
  }
}

// ../../src/core/ui/easing.ts
function linear(t) {
  return t;
}
function ease(t) {
  return cubicBezier(0.25, 0.1, 0.25, 1, t);
}
function easeIn(t) {
  return t * t;
}
function easeOut(t) {
  return 1 - (1 - t) * (1 - t);
}
function easeInOut(t) {
  return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
}
function spring(t) {
  const c4 = 2 * Math.PI / 3;
  if (t === 0)
    return 0;
  if (t === 1)
    return 1;
  return Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
}
function getEasingFunction(type) {
  switch (type) {
    case "linear":
      return linear;
    case "ease":
      return ease;
    case "ease-in":
      return easeIn;
    case "ease-out":
      return easeOut;
    case "ease-in-out":
      return easeInOut;
    case "spring":
      return spring;
    default:
      return linear;
  }
}
function cubicBezier(x1, y1, x2, y2, t) {
  if (t <= 0)
    return 0;
  if (t >= 1)
    return 1;
  const cx = 3 * x1;
  const bx = 3 * (x2 - x1) - cx;
  const ax = 1 - cx - bx;
  const cy = 3 * y1;
  const by = 3 * (y2 - y1) - cy;
  const ay = 1 - cy - by;
  const sampleCurveX = (t2) => ((ax * t2 + bx) * t2 + cx) * t2;
  const sampleCurveY = (t2) => ((ay * t2 + by) * t2 + cy) * t2;
  const sampleCurveDerivativeX = (t2) => (3 * ax * t2 + 2 * bx) * t2 + cx;
  let guessT = t;
  for (let i = 0;i < 8; i++) {
    const currentX = sampleCurveX(guessT) - t;
    if (Math.abs(currentX) < 0.000001)
      break;
    const derivative = sampleCurveDerivativeX(guessT);
    if (Math.abs(derivative) < 0.000001)
      break;
    guessT -= currentX / derivative;
  }
  guessT = Math.max(0, Math.min(1, guessT));
  return sampleCurveY(guessT);
}
function interpolateColor(from, to, t, easing = "linear") {
  const easedT = getEasingFunction(easing)(t);
  const fromRgba = parseColorToRgba(from);
  const toRgba = parseColorToRgba(to);
  const r = Math.round(fromRgba.r + (toRgba.r - fromRgba.r) * easedT);
  const g = Math.round(fromRgba.g + (toRgba.g - fromRgba.g) * easedT);
  const b = Math.round(fromRgba.b + (toRgba.b - fromRgba.b) * easedT);
  const a = fromRgba.a + (toRgba.a - fromRgba.a) * easedT;
  return `rgba(${r}, ${g}, ${b}, ${a.toFixed(3)})`;
}
function parseColorToRgba(color) {
  if (color.startsWith("rgba(")) {
    const match = color.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/);
    if (match) {
      return {
        r: parseInt(match[1]),
        g: parseInt(match[2]),
        b: parseInt(match[3]),
        a: parseFloat(match[4])
      };
    }
  }
  if (color.startsWith("rgb(")) {
    const match = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
    if (match) {
      return {
        r: parseInt(match[1]),
        g: parseInt(match[2]),
        b: parseInt(match[3]),
        a: 1
      };
    }
  }
  if (color.startsWith("#")) {
    let hex = color.slice(1);
    if (hex.length === 3) {
      hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
    } else if (hex.length === 4) {
      hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];
    }
    const r = parseInt(hex.slice(0, 2), 16);
    const g = parseInt(hex.slice(2, 4), 16);
    const b = parseInt(hex.slice(4, 6), 16);
    const a = hex.length === 8 ? parseInt(hex.slice(6, 8), 16) / 255 : 1;
    return { r, g, b, a };
  }
  return { r: 0, g: 0, b: 0, a: 0 };
}

// ../../src/core/ui/UIAnimator.ts
class UIAnimatorClass {
  animations = new Map;
  animatedStyles = new Map;
  frameId = null;
  lastTime = 0;
  autoUpdateRunning = false;
  pulseAnimations = new Map;
  staggerAnimations = new Map;
  animate(element, property, from, to, options) {
    const key = this.getAnimationKey(element, property);
    this.animations.delete(key);
    const animation = {
      element,
      property,
      from,
      to,
      duration: options.duration,
      easing: options.easing ?? "ease-out",
      elapsed: 0,
      delay: options.delay ?? 0,
      onComplete: options.onComplete
    };
    this.animations.set(key, animation);
    this.startAutoUpdate();
  }
  transition(element, property, from, to, transition) {
    if (transition.property !== "all" && transition.property !== property) {
      return;
    }
    if (from === to) {
      return;
    }
    this.animate(element, property, from, to, {
      duration: transition.duration,
      easing: transition.easing ?? "ease-out",
      delay: transition.delay ?? 0
    });
  }
  update(deltaTime) {
    const hasPropertyAnimations = this.animations.size > 0;
    const hasPulseAnimations = this.pulseAnimations.size > 0;
    const hasStaggerAnimations = this.staggerAnimations.size > 0;
    if (!hasPropertyAnimations && !hasPulseAnimations && !hasStaggerAnimations) {
      return;
    }
    if (hasPropertyAnimations) {
      const completedKeys = [];
      for (const [key, anim] of this.animations) {
        if (anim.delay > 0) {
          anim.delay -= deltaTime;
          if (anim.delay > 0) {
            this.updateAnimatedStyle(anim.element, anim.property, anim.from);
            continue;
          }
          anim.elapsed = -anim.delay;
          anim.delay = 0;
        }
        anim.elapsed += deltaTime;
        const progress = Math.min(1, anim.elapsed / anim.duration);
        const easedProgress = getEasingFunction(anim.easing)(progress);
        const currentValue = this.interpolateValue(anim.from, anim.to, easedProgress);
        this.updateAnimatedStyle(anim.element, anim.property, currentValue);
        anim.element.markDirty();
        if (progress >= 1) {
          completedKeys.push(key);
          anim.onComplete?.();
        }
      }
      for (const key of completedKeys) {
        this.animations.delete(key);
      }
    }
    for (const pulse of this.pulseAnimations.values()) {
      if (pulse.active) {
        pulse.elapsed += deltaTime;
      }
    }
    const completedStaggers = [];
    for (const [key, stagger] of this.staggerAnimations) {
      if (stagger.active) {
        stagger.elapsed += deltaTime;
        const totalDuration = (stagger.itemCount - 1) * stagger.options.delay + stagger.options.duration;
        if (stagger.elapsed >= totalDuration) {
          completedStaggers.push(key);
        }
      }
    }
    for (const key of completedStaggers) {
      this.staggerAnimations.delete(key);
    }
    if (this.animations.size === 0 && this.pulseAnimations.size === 0 && this.staggerAnimations.size === 0) {
      this.stopAutoUpdate();
    }
  }
  cancelAll(element) {
    const prefix = `${element.id}_`;
    const keysToRemove = [];
    for (const key of this.animations.keys()) {
      if (key.startsWith(prefix)) {
        keysToRemove.push(key);
      }
    }
    for (const key of keysToRemove) {
      this.animations.delete(key);
    }
    this.animatedStyles.delete(element.id);
  }
  cancel(element, property) {
    const key = this.getAnimationKey(element, property);
    this.animations.delete(key);
  }
  getAnimatedStyle(element) {
    return this.animatedStyles.get(element.id);
  }
  hasActiveAnimations(element) {
    const prefix = `${element.id}_`;
    for (const key of this.animations.keys()) {
      if (key.startsWith(prefix)) {
        return true;
      }
    }
    return false;
  }
  getAnimatedValue(element, property, styleValue) {
    const animStyle = this.animatedStyles.get(element.id);
    if (animStyle && property in animStyle) {
      return animStyle[property];
    }
    return styleValue;
  }
  clearAll() {
    this.animations.clear();
    this.animatedStyles.clear();
    this.pulseAnimations.clear();
    this.staggerAnimations.clear();
    this.stopAutoUpdate();
  }
  startPulse(key, config) {
    this.pulseAnimations.set(key, {
      config,
      elapsed: 0,
      active: true
    });
    this.startAutoUpdate();
  }
  stopPulse(key) {
    this.pulseAnimations.delete(key);
  }
  getPulseValue(key) {
    const pulse = this.pulseAnimations.get(key);
    if (!pulse || !pulse.active) {
      return 0;
    }
    const duration = pulse.config.duration ?? 1000;
    const intensity = pulse.config.intensity ?? 0.5;
    const phase = pulse.elapsed / duration * 2 * Math.PI;
    const oscillation = (Math.sin(phase) + 1) / 2;
    return oscillation * intensity;
  }
  hasPulse(key) {
    return this.pulseAnimations.has(key);
  }
  startStagger(key, itemCount, options) {
    this.staggerAnimations.set(key, {
      options,
      itemCount,
      elapsed: 0,
      active: true
    });
    this.startAutoUpdate();
  }
  stopStagger(key) {
    this.staggerAnimations.delete(key);
  }
  getStaggerItemState(key, index) {
    const stagger = this.staggerAnimations.get(key);
    if (!stagger || !stagger.active) {
      return { opacity: 1, offsetY: 0, scale: 1 };
    }
    const { options, elapsed } = stagger;
    const itemStartTime = index * options.delay;
    const itemElapsed = elapsed - itemStartTime;
    if (itemElapsed < 0) {
      switch (options.animation) {
        case "fade":
          return { opacity: 0, offsetY: 0, scale: 1 };
        case "slide-down":
          return { opacity: 0, offsetY: -20, scale: 1 };
        case "slide-up":
          return { opacity: 0, offsetY: 20, scale: 1 };
        case "scale":
          return { opacity: 0, offsetY: 0, scale: 0.8 };
      }
    }
    const progress = Math.min(1, itemElapsed / options.duration);
    const easing = options.easing ?? "ease-out";
    const easedProgress = getEasingFunction(easing)(progress);
    switch (options.animation) {
      case "fade":
        return { opacity: easedProgress, offsetY: 0, scale: 1 };
      case "slide-down":
        return { opacity: easedProgress, offsetY: -20 * (1 - easedProgress), scale: 1 };
      case "slide-up":
        return { opacity: easedProgress, offsetY: 20 * (1 - easedProgress), scale: 1 };
      case "scale":
        return { opacity: easedProgress, offsetY: 0, scale: 0.8 + 0.2 * easedProgress };
    }
  }
  isStaggerComplete(key) {
    const stagger = this.staggerAnimations.get(key);
    if (!stagger)
      return true;
    const totalDuration = (stagger.itemCount - 1) * stagger.options.delay + stagger.options.duration;
    return stagger.elapsed >= totalDuration;
  }
  getDebugInfo() {
    const elementIds = new Set;
    for (const anim of this.animations.values()) {
      elementIds.add(anim.element.id);
    }
    return {
      count: this.animations.size,
      elements: Array.from(elementIds),
      pulseCount: this.pulseAnimations.size,
      staggerCount: this.staggerAnimations.size
    };
  }
  getAnimationKey(element, property) {
    return `${element.id}_${property}`;
  }
  updateAnimatedStyle(element, property, value) {
    let style = this.animatedStyles.get(element.id);
    if (!style) {
      style = {};
      this.animatedStyles.set(element.id, style);
    }
    style[property] = value;
  }
  interpolateValue(from, to, t) {
    if (typeof from === "number" && typeof to === "number") {
      return from + (to - from) * t;
    }
    if (typeof from === "string" && typeof to === "string") {
      if (this.isColorValue(from) && this.isColorValue(to)) {
        return interpolateColor(from, to, t, "linear");
      }
    }
    return t >= 1 ? to : from;
  }
  isColorValue(value) {
    return value.startsWith("#") || value.startsWith("rgb") || value.startsWith("rgba");
  }
  startAutoUpdate() {
    if (this.autoUpdateRunning)
      return;
    this.autoUpdateRunning = true;
    this.lastTime = performance.now();
    const tick = (currentTime) => {
      if (!this.autoUpdateRunning)
        return;
      const deltaTime = currentTime - this.lastTime;
      this.lastTime = currentTime;
      this.update(deltaTime);
      if (this.autoUpdateRunning) {
        this.frameId = requestAnimationFrame(tick);
      }
    };
    this.frameId = requestAnimationFrame(tick);
  }
  stopAutoUpdate() {
    this.autoUpdateRunning = false;
    if (this.frameId !== null) {
      cancelAnimationFrame(this.frameId);
      this.frameId = null;
    }
  }
}
var UIAnimator = new UIAnimatorClass;

// ../../src/core/ui/components/Button.ts
var DEFAULT_HOVER_TRANSITION = {
  property: "backgroundColor",
  duration: 150,
  easing: "ease-out"
};
var DEFAULT_PRESS_TRANSITION = {
  property: "all",
  duration: 50,
  easing: "ease-out"
};
var DEFAULT_RELEASE_TRANSITION = {
  property: "all",
  duration: 200,
  easing: "spring"
};

class Button extends UIElement {
  _label;
  _disabled = false;
  _icon = null;
  _previousState = "normal";
  _animatedScale = 1;
  static defaultStyle = {
    backgroundColor: "rgba(42, 42, 78, 0.9)",
    color: "#f0f0f0",
    borderColor: "rgba(58, 58, 90, 0.8)",
    borderWidth: 1,
    borderRadius: 6,
    padding: { top: 12, right: 20, bottom: 12, left: 20 },
    fontSize: 14,
    fontFamily: "system-ui, -apple-system, sans-serif",
    textAlign: "center",
    cursor: "pointer",
    hoverBackgroundColor: "rgba(58, 58, 94, 0.95)",
    hoverColor: "#ffffff",
    hoverBorderColor: "rgba(70, 70, 110, 0.9)",
    pressedBackgroundColor: "rgba(26, 26, 62, 0.95)",
    pressedColor: "#d0d0e0",
    pressedBorderColor: "rgba(50, 50, 80, 0.8)",
    disabledBackgroundColor: "rgba(30, 30, 50, 0.5)",
    disabledColor: "rgba(160, 160, 176, 0.5)",
    disabledBorderColor: "rgba(50, 50, 70, 0.3)",
    focusBackgroundColor: "rgba(58, 58, 94, 0.95)",
    focusBorderColor: "rgba(106, 90, 205, 0.9)",
    focusBorderWidth: 2
  };
  constructor(text = "Button", style) {
    const mergedStyle = { ...Button.defaultStyle, ...style };
    super(mergedStyle);
    this._label = new Label(text, {
      color: mergedStyle.color,
      fontSize: mergedStyle.fontSize,
      fontFamily: mergedStyle.fontFamily,
      textAlign: mergedStyle.textAlign
    });
    this._label.interactive = false;
    this._interactive = true;
  }
  get text() {
    return this._label.text;
  }
  set text(value) {
    this._label.text = value;
    this.markDirty();
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
    this._interactive = !value;
    this.markDirty();
  }
  get label() {
    return this._label;
  }
  setIcon(icon) {
    this._icon = icon;
    this.markDirty();
  }
  getVisualState() {
    if (this._disabled)
      return "disabled";
    if (this._pressed)
      return "pressed";
    if (this._hovered)
      return "hover";
    if (this._focused)
      return "focused";
    return "normal";
  }
  getStateStyle() {
    const style = this.style;
    const state = this.getVisualState();
    switch (state) {
      case "hover":
        return {
          backgroundColor: style.hoverBackgroundColor ?? style.backgroundColor ?? "#3a3a5e",
          color: style.hoverColor ?? style.color ?? "#ffffff",
          borderColor: style.hoverBorderColor ?? style.borderColor ?? "#46466e",
          borderWidth: style.borderWidth ?? 1,
          backgroundImage: style.hoverBackgroundImage ?? style.backgroundImage,
          tint: style.hoverTint ?? style.tint
        };
      case "pressed":
        return {
          backgroundColor: style.pressedBackgroundColor ?? style.backgroundColor ?? "#1a1a3e",
          color: style.pressedColor ?? style.color ?? "#d0d0e0",
          borderColor: style.pressedBorderColor ?? style.borderColor ?? "#323250",
          borderWidth: style.borderWidth ?? 1,
          backgroundImage: style.pressedBackgroundImage ?? style.backgroundImage,
          tint: style.pressedTint ?? style.tint
        };
      case "disabled":
        return {
          backgroundColor: style.disabledBackgroundColor ?? style.backgroundColor ?? "#1e1e32",
          color: style.disabledColor ?? style.color ?? "#606070",
          borderColor: style.disabledBorderColor ?? style.borderColor ?? "#323246",
          borderWidth: style.borderWidth ?? 1,
          backgroundImage: style.disabledBackgroundImage ?? style.backgroundImage,
          tint: style.disabledTint ?? style.tint
        };
      case "focused":
        return {
          backgroundColor: style.focusBackgroundColor ?? style.backgroundColor ?? "#3a3a5e",
          color: style.color ?? "#f0f0f0",
          borderColor: style.focusBorderColor ?? "#6a5acd",
          borderWidth: style.focusBorderWidth ?? style.borderWidth ?? 2,
          backgroundImage: style.focusedBackgroundImage ?? style.backgroundImage,
          tint: style.focusedTint ?? style.tint,
          glow: style.focusGlow ?? { blur: 12, color: "#6a5acd", intensity: 0.85 }
        };
      default:
        return {
          backgroundColor: style.backgroundColor ?? "#2a2a4e",
          color: style.color ?? "#f0f0f0",
          borderColor: style.borderColor ?? "#3a3a5a",
          borderWidth: style.borderWidth ?? 1,
          backgroundImage: style.backgroundImage,
          tint: style.tint
        };
    }
  }
  measureContent() {
    const labelSize = this._label.measureContent();
    const padding = this.getPadding();
    let width = labelSize.width;
    let height = labelSize.height;
    if (this._icon) {
      const iconSize = this._icon.measureContent();
      width += iconSize.width + parseGap(this.style.gap ?? 8);
      height = Math.max(height, iconSize.height);
    }
    this._contentSize = {
      width: width + padding.left + padding.right,
      height: height + padding.top + padding.bottom
    };
    return this._contentSize;
  }
  handlePointerEvent(event) {
    if (this._disabled) {
      return false;
    }
    const previousState = this._previousState;
    const result = super.handlePointerEvent(event);
    const currentState = this.getVisualState();
    if (currentState !== previousState) {
      this.triggerStateTransition(previousState, currentState);
      this._previousState = currentState;
    }
    return result;
  }
  update(dt) {
    super.update(dt);
    const currentState = this.getVisualState();
    if (currentState !== this._previousState) {
      this.triggerStateTransition(this._previousState, currentState);
      this._previousState = currentState;
    }
  }
  triggerStateTransition(from, to) {
    const style = this.style;
    if (style.transitionsEnabled === false) {
      return;
    }
    const fromStyle = this.getStyleForState(from);
    const toStyle = this.getStyleForState(to);
    let transition;
    if (to === "pressed") {
      transition = style.pressTransition ?? DEFAULT_PRESS_TRANSITION;
      UIAnimator.animate(this, "scale", this._animatedScale, 0.98, {
        duration: transition.duration,
        easing: transition.easing ?? "ease-out"
      });
    } else if (from === "pressed") {
      transition = DEFAULT_RELEASE_TRANSITION;
      UIAnimator.animate(this, "scale", this._animatedScale, 1, {
        duration: transition.duration,
        easing: "spring"
      });
    } else if (to === "hover" || from === "hover") {
      transition = style.hoverTransition ?? DEFAULT_HOVER_TRANSITION;
    } else {
      transition = DEFAULT_HOVER_TRANSITION;
    }
    UIAnimator.transition(this, "backgroundColor", fromStyle.backgroundColor, toStyle.backgroundColor, transition);
  }
  getStyleForState(state) {
    const style = this.style;
    switch (state) {
      case "hover":
        return {
          backgroundColor: style.hoverBackgroundColor ?? style.backgroundColor ?? "#3a3a5e",
          color: style.hoverColor ?? style.color ?? "#ffffff",
          borderColor: style.hoverBorderColor ?? style.borderColor ?? "#46466e",
          borderWidth: style.borderWidth ?? 1
        };
      case "pressed":
        return {
          backgroundColor: style.pressedBackgroundColor ?? style.backgroundColor ?? "#1a1a3e",
          color: style.pressedColor ?? style.color ?? "#d0d0e0",
          borderColor: style.pressedBorderColor ?? style.borderColor ?? "#323250",
          borderWidth: style.borderWidth ?? 1
        };
      case "disabled":
        return {
          backgroundColor: style.disabledBackgroundColor ?? style.backgroundColor ?? "#1e1e32",
          color: style.disabledColor ?? style.color ?? "#606070",
          borderColor: style.disabledBorderColor ?? style.borderColor ?? "#323246",
          borderWidth: style.borderWidth ?? 1
        };
      case "focused":
        return {
          backgroundColor: style.focusBackgroundColor ?? style.backgroundColor ?? "#3a3a5e",
          color: style.color ?? "#f0f0f0",
          borderColor: style.focusBorderColor ?? "#6a5acd",
          borderWidth: style.focusBorderWidth ?? style.borderWidth ?? 2
        };
      default:
        return {
          backgroundColor: style.backgroundColor ?? "#2a2a4e",
          color: style.color ?? "#f0f0f0",
          borderColor: style.borderColor ?? "#3a3a5a",
          borderWidth: style.borderWidth ?? 1
        };
    }
  }
  getImageBounds(texture) {
    const buttonWidth = this._bounds.width;
    const buttonHeight = this._bounds.height;
    const textureWidth = texture.gpuTexture?.width ?? buttonWidth;
    const textureHeight = texture.gpuTexture?.height ?? buttonHeight;
    const buttonAspect = buttonWidth / buttonHeight;
    const textureAspect = textureWidth / textureHeight;
    let displayWidth;
    let displayHeight;
    if (textureAspect > buttonAspect) {
      displayWidth = buttonWidth;
      displayHeight = buttonWidth / textureAspect;
    } else {
      displayHeight = buttonHeight;
      displayWidth = buttonHeight * textureAspect;
    }
    const x = this._bounds.x + (buttonWidth - displayWidth) / 2;
    const y = this._bounds.y + (buttonHeight - displayHeight) / 2;
    return { x, y, width: displayWidth, height: displayHeight };
  }
  getScaledBounds(scale) {
    if (scale === 1) {
      return this._bounds;
    }
    const centerX = this._bounds.x + this._bounds.width / 2;
    const centerY = this._bounds.y + this._bounds.height / 2;
    const scaledWidth = this._bounds.width * scale;
    const scaledHeight = this._bounds.height * scale;
    return {
      x: centerX - scaledWidth / 2,
      y: centerY - scaledHeight / 2,
      width: scaledWidth,
      height: scaledHeight
    };
  }
  getRenderData(data, baseZIndex, inheritedRenderLayer = 0) {
    const stateStyle = this.getStateStyle();
    const style = this.style;
    const renderLayer = this.style.renderLayer ?? inheritedRenderLayer;
    const opacity = this.style.opacity ?? 1;
    if (opacity <= 0)
      return;
    const animStyle = UIAnimator.getAnimatedStyle(this);
    const animatedBgColor = animStyle?.backgroundColor;
    const animatedScale = animStyle?.scale ?? 1;
    const scaledBounds = this.getScaledBounds(animatedScale);
    const effectiveBgColor = animatedBgColor ?? stateStyle.backgroundColor;
    const bgImage = stateStyle.backgroundImage;
    if (bgImage && bgImage.gpuTexture && bgImage.view) {
      const imageBounds = this.getImageBounds(bgImage);
      const scaledImageContentBounds = {
        x: imageBounds.x + (scaledBounds.x - this._bounds.x),
        y: imageBounds.y + (scaledBounds.y - this._bounds.y),
        width: imageBounds.width * animatedScale,
        height: imageBounds.height * animatedScale
      };
      const imageRenderLayer = style.backgroundImageRenderLayer ?? renderLayer;
      data.push({
        type: "image",
        bounds: scaledImageContentBounds,
        zIndex: baseZIndex,
        renderLayer: imageRenderLayer,
        texture: bgImage.gpuTexture,
        textureView: bgImage.view,
        uvRect: { u0: 0, v0: 0, u1: 1, v1: 1 },
        backgroundAlpha: (this.style.backgroundAlpha ?? 1) * opacity,
        tint: stateStyle.tint,
        glow: stateStyle.glow,
        scale: animatedScale
      });
      if (stateStyle.borderColor && stateStyle.borderWidth > 0) {
        data.push({
          type: "quad",
          bounds: scaledBounds,
          zIndex: baseZIndex + 0.05,
          renderLayer,
          borderColor: stateStyle.borderColor,
          borderWidth: stateStyle.borderWidth,
          borderRadius: (style.borderRadius ?? 4) * animatedScale,
          scale: animatedScale
        });
      }
    } else {
      data.push({
        type: "quad",
        bounds: scaledBounds,
        zIndex: baseZIndex,
        renderLayer,
        backgroundColor: effectiveBgColor,
        backgroundAlpha: (this.style.backgroundAlpha ?? 1) * opacity,
        borderRadius: (style.borderRadius ?? 4) * animatedScale,
        tint: stateStyle.tint,
        glow: stateStyle.glow,
        shadow: this.style.shadow,
        scale: animatedScale
      });
      if (stateStyle.borderColor && stateStyle.borderWidth > 0) {
        data.push({
          type: "quad",
          bounds: scaledBounds,
          zIndex: baseZIndex + 0.01,
          renderLayer,
          borderColor: stateStyle.borderColor,
          borderWidth: stateStyle.borderWidth,
          borderRadius: (style.borderRadius ?? 4) * animatedScale,
          scale: animatedScale
        });
      }
    }
    const padding = this.getPadding();
    const textBounds = {
      x: scaledBounds.x + padding.left * animatedScale,
      y: scaledBounds.y + padding.top * animatedScale,
      width: scaledBounds.width - (padding.left + padding.right) * animatedScale,
      height: scaledBounds.height - (padding.top + padding.bottom) * animatedScale
    };
    data.push({
      type: "text",
      bounds: textBounds,
      zIndex: baseZIndex + 0.1,
      renderLayer,
      text: this._label.text,
      color: stateStyle.color,
      fontSize: (style.fontSize ?? 14) * animatedScale,
      fontFamily: style.fontFamily ?? "sans-serif",
      textAlign: style.textAlign ?? "center",
      labelShadow: this.style.labelShadow,
      labelOutline: this.style.labelOutline,
      scale: animatedScale
    });
    if (this._icon) {
      this._icon.collectRenderData(data, baseZIndex);
    }
  }
  destroy() {
    UIAnimator.cancelAll(this);
    this._label.destroy();
    if (this._icon) {
      this._icon.destroy();
    }
    super.destroy();
  }
}

// ../../src/core/ui/components/Image.ts
class Image2 extends UIElement {
  _texture = null;
  _gpuTexture = null;
  _textureView = null;
  _uvRect = { u0: 0, v0: 0, u1: 1, v1: 1 };
  _sourceWidth = 0;
  _sourceHeight = 0;
  constructor(texture, style) {
    super(style);
    if (texture) {
      this.setTexture(texture);
    }
    this._interactive = false;
  }
  setTexture(texture) {
    this._texture = texture;
    if (texture && texture.gpuTexture) {
      this._gpuTexture = texture.gpuTexture;
      this._textureView = texture.view;
      this._sourceWidth = texture.gpuTexture.width;
      this._sourceHeight = texture.gpuTexture.height;
    } else {
      this._gpuTexture = null;
      this._textureView = null;
      this._sourceWidth = 0;
      this._sourceHeight = 0;
    }
    this.markDirty();
  }
  setGPUTexture(texture, width, height) {
    this._texture = null;
    this._gpuTexture = texture;
    this._textureView = texture?.createView() ?? null;
    this._sourceWidth = width ?? texture?.width ?? 0;
    this._sourceHeight = height ?? texture?.height ?? 0;
    this.markDirty();
  }
  setUVRect(u0, v0, u1, v1) {
    this._uvRect = { u0, v0, u1, v1 };
    this.markDirty();
  }
  setSpriteFrame(x, y, width, height, atlasWidth, atlasHeight) {
    this._uvRect = {
      u0: x / atlasWidth,
      v0: y / atlasHeight,
      u1: (x + width) / atlasWidth,
      v1: (y + height) / atlasHeight
    };
    this._sourceWidth = width;
    this._sourceHeight = height;
    this.markDirty();
  }
  get texture() {
    return this._texture;
  }
  get gpuTexture() {
    return this._gpuTexture;
  }
  get textureView() {
    return this._textureView;
  }
  get sourceWidth() {
    return this._sourceWidth;
  }
  get sourceHeight() {
    return this._sourceHeight;
  }
  measureContent() {
    if (typeof this.style.width === "number" && typeof this.style.height === "number") {
      this._contentSize = {
        width: this.style.width,
        height: this.style.height
      };
      return this._contentSize;
    }
    let width = this._sourceWidth;
    let height = this._sourceHeight;
    width *= this._uvRect.u1 - this._uvRect.u0;
    height *= this._uvRect.v1 - this._uvRect.v0;
    if (typeof this.style.width === "number") {
      const scale = this.style.width / width;
      width = this.style.width;
      height *= scale;
    } else if (typeof this.style.height === "number") {
      const scale = this.style.height / height;
      height = this.style.height;
      width *= scale;
    }
    const padding = this.getPadding();
    this._contentSize = {
      width: width + padding.left + padding.right,
      height: height + padding.top + padding.bottom
    };
    return this._contentSize;
  }
  getDisplayBounds() {
    const style = this.style;
    const scaleMode = style.scaleMode ?? "stretch";
    const padding = this.getPadding();
    const contentX = this._bounds.x + padding.left;
    const contentY = this._bounds.y + padding.top;
    const contentWidth = this._bounds.width - padding.left - padding.right;
    const contentHeight = this._bounds.height - padding.top - padding.bottom;
    if (scaleMode === "stretch" || this._sourceWidth === 0 || this._sourceHeight === 0) {
      return { x: contentX, y: contentY, width: contentWidth, height: contentHeight };
    }
    const sourceAspect = this._sourceWidth / this._sourceHeight;
    const containerAspect = contentWidth / contentHeight;
    let displayWidth;
    let displayHeight;
    switch (scaleMode) {
      case "contain":
        if (sourceAspect > containerAspect) {
          displayWidth = contentWidth;
          displayHeight = contentWidth / sourceAspect;
        } else {
          displayHeight = contentHeight;
          displayWidth = contentHeight * sourceAspect;
        }
        break;
      case "cover":
        if (sourceAspect > containerAspect) {
          displayHeight = contentHeight;
          displayWidth = contentHeight * sourceAspect;
        } else {
          displayWidth = contentWidth;
          displayHeight = contentWidth / sourceAspect;
        }
        break;
      case "none":
      default:
        displayWidth = this._sourceWidth;
        displayHeight = this._sourceHeight;
        break;
    }
    let displayX = contentX;
    let displayY = contentY;
    const alignX = style.alignX ?? "center";
    const alignY = style.alignY ?? "center";
    switch (alignX) {
      case "center":
        displayX = contentX + (contentWidth - displayWidth) / 2;
        break;
      case "right":
        displayX = contentX + contentWidth - displayWidth;
        break;
    }
    switch (alignY) {
      case "center":
        displayY = contentY + (contentHeight - displayHeight) / 2;
        break;
      case "bottom":
        displayY = contentY + contentHeight - displayHeight;
        break;
    }
    return { x: displayX, y: displayY, width: displayWidth, height: displayHeight };
  }
  getRenderData(data, baseZIndex, inheritedRenderLayer = 0) {
    const style = this.style;
    const renderLayer = this.style.renderLayer ?? inheritedRenderLayer;
    const opacity = this.style.opacity ?? 1;
    if (opacity <= 0)
      return;
    if (this.style.backgroundColor) {
      data.push({
        type: "quad",
        bounds: { ...this._bounds },
        zIndex: baseZIndex,
        renderLayer,
        backgroundColor: this.style.backgroundColor,
        backgroundAlpha: (this.style.backgroundAlpha ?? 1) * opacity,
        borderRadius: style.borderRadius ?? 0
      });
    }
    if (this._gpuTexture && this._textureView) {
      const displayBounds = this.getDisplayBounds();
      const renderType = style.nineSlice ? "nine-slice" : "image";
      data.push({
        type: renderType,
        bounds: displayBounds,
        zIndex: baseZIndex + 0.1,
        renderLayer,
        texture: this._gpuTexture,
        textureView: this._textureView,
        uvRect: this._uvRect,
        color: style.tint,
        backgroundAlpha: (style.tintAlpha ?? 1) * opacity,
        nineSlice: style.nineSlice,
        sourceWidth: this._sourceWidth,
        sourceHeight: this._sourceHeight
      });
    }
    if (style.borderColor && style.borderWidth) {
      data.push({
        type: "quad",
        bounds: { ...this._bounds },
        zIndex: baseZIndex + 0.2,
        renderLayer,
        borderColor: style.borderColor,
        borderWidth: style.borderWidth,
        borderRadius: style.borderRadius ?? 0
      });
    }
  }
}

// ../../src/core/debug/utils/codeGenerator.ts
function formatVector3(v, format, precision = 2) {
  const x = v.x.toFixed(precision);
  const y = v.y.toFixed(precision);
  const z = v.z.toFixed(precision);
  switch (format) {
    case "jsx":
      return `[${x}, ${y}, ${z}]`;
    case "yaml":
      return `[${x}, ${y}, ${z}]`;
    case "typescript":
      return `new Vector3(${x}, ${y}, ${z})`;
  }
}
function formatQuaternion(q, format, precision = 4) {
  const x = q.x.toFixed(precision);
  const y = q.y.toFixed(precision);
  const z = q.z.toFixed(precision);
  const w = q.w.toFixed(precision);
  switch (format) {
    case "jsx":
      return `[${x}, ${y}, ${z}, ${w}]`;
    case "yaml":
      return `[${x}, ${y}, ${z}, ${w}]`;
    case "typescript":
      return `new Quaternion(${x}, ${y}, ${z}, ${w})`;
  }
}
function formatEuler(euler, format, precision = 1) {
  const x = euler.x.toFixed(precision);
  const y = euler.y.toFixed(precision);
  const z = euler.z.toFixed(precision);
  switch (format) {
    case "jsx":
      return `[${x}, ${y}, ${z}]`;
    case "yaml":
      return `[${x}, ${y}, ${z}]`;
    case "typescript":
      return `Quaternion.fromEuler(new Vector3(${x}, ${y}, ${z}))`;
  }
}
function generateCameraCode(camera, format) {
  const pos = camera.transform.position;
  const rot = camera.transform.rotation;
  const euler = rot.toEulerDegrees();
  switch (format) {
    case "jsx":
      return `<PerspectiveCamera
  position={${formatVector3(pos, "jsx")}}
  rotation={${formatEuler(euler, "jsx")}}
  fov={${camera.fov.toFixed(1)}}
  near={${camera.near}}
  far={${camera.far}}
/>`;
    case "yaml":
      return `camera:
  position: ${formatVector3(pos, "yaml")}
  rotation: ${formatEuler(euler, "yaml")}
  fov: ${camera.fov.toFixed(1)}
  near: ${camera.near}
  far: ${camera.far}`;
    case "typescript":
      return `camera.transform.position = ${formatVector3(pos, "typescript")};
camera.transform.rotation = ${formatQuaternion(rot, "typescript")};
camera.fov = ${camera.fov.toFixed(1)};`;
  }
}
function generateNodeCode(node, format) {
  const pos = node.transform.position;
  const rot = node.transform.rotation;
  const euler = rot.toEulerDegrees();
  const scale = node.transform.scale;
  const name = node.name || "unnamed";
  let componentType = "Node";
  if (node instanceof Mesh) {
    componentType = "Mesh";
  } else if (node instanceof Light) {
    const light = node;
    switch (light.type) {
      case 0 /* Directional */:
        componentType = "DirectionalLight";
        break;
      case 1 /* Point */:
        componentType = "PointLight";
        break;
      case 2 /* Spot */:
        componentType = "SpotLight";
        break;
    }
  }
  switch (format) {
    case "jsx":
      return `<${componentType}
  name="${name}"
  position={${formatVector3(pos, "jsx")}}
  rotation={${formatEuler(euler, "jsx")}}
  scale={${formatVector3(scale, "jsx")}}
/>`;
    case "yaml":
      return `- name: ${name}
  type: ${componentType.toLowerCase()}
  position: ${formatVector3(pos, "yaml")}
  rotation: ${formatEuler(euler, "yaml")}
  scale: ${formatVector3(scale, "yaml")}`;
    case "typescript":
      return `${name}.transform.position = ${formatVector3(pos, "typescript")};
${name}.transform.rotation = ${formatQuaternion(rot, "typescript")};
${name}.transform.scale = ${formatVector3(scale, "typescript")};`;
  }
}
function generateLightCode(light, format) {
  const pos = light.transform.position;
  const rot = light.transform.rotation;
  const color = light.color;
  const castShadow = light.shadow.castShadow;
  let typeName = "Light";
  switch (light.type) {
    case 0 /* Directional */:
      typeName = "DirectionalLight";
      break;
    case 1 /* Point */:
      typeName = "PointLight";
      break;
    case 2 /* Spot */:
      typeName = "SpotLight";
      break;
  }
  const euler = rot.toEulerDegrees();
  switch (format) {
    case "jsx":
      if (light.type === 0 /* Directional */) {
        return `<${typeName}
  rotation={${formatEuler(euler, "jsx")}}
  color={${formatVector3(color, "jsx")}}
  intensity={${light.intensity.toFixed(2)}}
  castShadow={${castShadow}}
/>`;
      } else {
        return `<${typeName}
  position={${formatVector3(pos, "jsx")}}
  color={${formatVector3(color, "jsx")}}
  intensity={${light.intensity.toFixed(2)}}
  castShadow={${castShadow}}
/>`;
      }
    case "yaml":
      if (light.type === 0 /* Directional */) {
        return `- type: ${typeName.toLowerCase()}
  rotation: ${formatEuler(euler, "yaml")}
  color: ${formatVector3(color, "yaml")}
  intensity: ${light.intensity.toFixed(2)}
  castShadow: ${castShadow}`;
      } else {
        return `- type: ${typeName.toLowerCase()}
  position: ${formatVector3(pos, "yaml")}
  color: ${formatVector3(color, "yaml")}
  intensity: ${light.intensity.toFixed(2)}
  castShadow: ${castShadow}`;
      }
    case "typescript":
      return `const ${light.name || "light"} = new ${typeName}();
${light.name || "light"}.color = ${formatVector3(color, "typescript")};
${light.name || "light"}.intensity = ${light.intensity.toFixed(2)};
${light.name || "light"}.shadow.castShadow = ${castShadow};`;
  }
}
function generateUIElementCode(element, format) {
  const name = element.name || element.id || "element";
  const x = element.style.x ?? 0;
  const y = element.style.y ?? 0;
  const width = element.style.width;
  const height = element.style.height;
  const visible = element.visible;
  const opacity = element.style.opacity ?? 1;
  let componentType = "UIElement";
  let extraProps = {};
  if (element instanceof Button) {
    componentType = "UIButton";
    extraProps.text = `"${element.text}"`;
  } else if (element instanceof Label) {
    componentType = "UILabel";
    extraProps.text = `"${element.text}"`;
    if (element.style.color) {
      extraProps.color = `"${element.style.color}"`;
    }
    if (element.style.fontSize) {
      extraProps.fontSize = element.style.fontSize.toString();
    }
  } else if (element instanceof Image2) {
    componentType = "UIImage";
    if (element.sourceWidth && element.sourceHeight) {
      extraProps["// sourceSize"] = `${element.sourceWidth}x${element.sourceHeight}`;
    }
  } else {
    componentType = element.constructor.name || "UIElement";
  }
  switch (format) {
    case "jsx":
      let jsxProps = `
  x={${formatStyleValue(x)}}
  y={${formatStyleValue(y)}}`;
      if (width !== undefined) {
        jsxProps += `
  width={${formatStyleValue(width)}}`;
      }
      if (height !== undefined) {
        jsxProps += `
  height={${formatStyleValue(height)}}`;
      }
      if (!visible) {
        jsxProps += `
  visible={false}`;
      }
      if (opacity !== 1) {
        jsxProps += `
  opacity={${opacity.toFixed(2)}}`;
      }
      for (const [key, value] of Object.entries(extraProps)) {
        if (!key.startsWith("//")) {
          jsxProps += `
  ${key}={${value}}`;
        }
      }
      return `<${componentType}${jsxProps}
/>`;
    case "yaml":
      let yamlContent = `- type: ${componentType.toLowerCase()}
  x: ${formatStyleValue(x)}
  y: ${formatStyleValue(y)}`;
      if (width !== undefined) {
        yamlContent += `
  width: ${formatStyleValue(width)}`;
      }
      if (height !== undefined) {
        yamlContent += `
  height: ${formatStyleValue(height)}`;
      }
      if (!visible) {
        yamlContent += `
  visible: false`;
      }
      if (opacity !== 1) {
        yamlContent += `
  opacity: ${opacity.toFixed(2)}`;
      }
      for (const [key, value] of Object.entries(extraProps)) {
        if (!key.startsWith("//")) {
          const yamlValue = value.replace(/^"|"$/g, "");
          yamlContent += `
  ${key}: ${yamlValue}`;
        }
      }
      return yamlContent;
    case "typescript":
      let tsCode = `const ${sanitizeVarName(name)} = new ${componentType}();
`;
      tsCode += `${sanitizeVarName(name)}.style.x = ${formatStyleValue(x)};
`;
      tsCode += `${sanitizeVarName(name)}.style.y = ${formatStyleValue(y)};`;
      if (width !== undefined) {
        tsCode += `
${sanitizeVarName(name)}.style.width = ${formatStyleValue(width)};`;
      }
      if (height !== undefined) {
        tsCode += `
${sanitizeVarName(name)}.style.height = ${formatStyleValue(height)};`;
      }
      if (!visible) {
        tsCode += `
${sanitizeVarName(name)}.visible = false;`;
      }
      if (opacity !== 1) {
        tsCode += `
${sanitizeVarName(name)}.style.opacity = ${opacity.toFixed(2)};`;
      }
      if (element instanceof Button) {
        tsCode += `
${sanitizeVarName(name)}.text = "${element.text}";`;
      } else if (element instanceof Label) {
        tsCode += `
${sanitizeVarName(name)}.text = "${element.text}";`;
      }
      return tsCode;
  }
}
function formatStyleValue(value) {
  if (value === undefined)
    return "0";
  if (typeof value === "number")
    return value.toString();
  if (typeof value === "string")
    return `"${value}"`;
  return "0";
}
function sanitizeVarName(name) {
  let sanitized = name.replace(/[^a-zA-Z0-9_]/g, "_");
  if (/^[0-9]/.test(sanitized)) {
    sanitized = "_" + sanitized;
  }
  return sanitized || "element";
}

// ../../src/core/debug/panels/CameraPanel.ts
class CameraPanel extends Panel {
  camera = null;
  positionInput = null;
  rotationDisplay;
  fovInput = null;
  codeFormatSelect;
  currentFormat = "jsx";
  constructor() {
    super("Camera", { defaultOpen: false });
    const posSection = document.createElement("div");
    posSection.style.marginBottom = "8px";
    const posLabel = document.createElement("div");
    posLabel.innerText = "Position:";
    posLabel.style.fontWeight = "bold";
    posLabel.style.marginBottom = "4px";
    posLabel.style.fontSize = "10px";
    posSection.appendChild(posLabel);
    const posInputContainer = document.createElement("div");
    posInputContainer.id = "camera-pos-input";
    posSection.appendChild(posInputContainer);
    this.content.appendChild(posSection);
    const rotSection = document.createElement("div");
    rotSection.style.marginBottom = "8px";
    const rotLabel = document.createElement("div");
    rotLabel.innerText = "Rotation (degrees):";
    rotLabel.style.fontWeight = "bold";
    rotLabel.style.marginBottom = "4px";
    rotLabel.style.fontSize = "10px";
    rotSection.appendChild(rotLabel);
    this.rotationDisplay = document.createElement("div");
    this.rotationDisplay.style.fontSize = "10px";
    this.rotationDisplay.style.color = "#aaa";
    rotSection.appendChild(this.rotationDisplay);
    this.content.appendChild(rotSection);
    const fovSection = document.createElement("div");
    fovSection.style.marginBottom = "8px";
    fovSection.style.display = "flex";
    fovSection.style.alignItems = "center";
    fovSection.style.gap = "8px";
    const fovLabel = document.createElement("span");
    fovLabel.innerText = "FOV:";
    fovLabel.style.fontWeight = "bold";
    fovLabel.style.fontSize = "10px";
    fovSection.appendChild(fovLabel);
    const fovInputContainer = document.createElement("div");
    fovInputContainer.id = "camera-fov-input";
    fovSection.appendChild(fovInputContainer);
    this.content.appendChild(fovSection);
    const divider = document.createElement("div");
    divider.style.borderTop = "1px solid #444";
    divider.style.margin = "8px 0";
    this.content.appendChild(divider);
    const formatSection = document.createElement("div");
    formatSection.style.marginBottom = "8px";
    formatSection.style.display = "flex";
    formatSection.style.alignItems = "center";
    formatSection.style.gap = "8px";
    const formatLabel = document.createElement("span");
    formatLabel.innerText = "Format:";
    formatLabel.style.fontSize = "10px";
    formatSection.appendChild(formatLabel);
    this.codeFormatSelect = document.createElement("select");
    this.codeFormatSelect.style.fontSize = "10px";
    this.codeFormatSelect.style.padding = "2px 4px";
    this.codeFormatSelect.style.backgroundColor = "#222";
    this.codeFormatSelect.style.color = "#fff";
    this.codeFormatSelect.style.border = "1px solid #555";
    this.codeFormatSelect.style.borderRadius = "3px";
    const formats = [
      { value: "jsx", label: "JSX" },
      { value: "yaml", label: "YAML" },
      { value: "typescript", label: "TypeScript" }
    ];
    formats.forEach(({ value, label }) => {
      const option = document.createElement("option");
      option.value = value;
      option.innerText = label;
      this.codeFormatSelect.appendChild(option);
    });
    this.codeFormatSelect.onchange = () => {
      this.currentFormat = this.codeFormatSelect.value;
    };
    formatSection.appendChild(this.codeFormatSelect);
    this.content.appendChild(formatSection);
    const buttonsDiv = document.createElement("div");
    buttonsDiv.style.display = "flex";
    buttonsDiv.style.flexWrap = "wrap";
    buttonsDiv.style.gap = "4px";
    buttonsDiv.style.marginBottom = "6px";
    buttonsDiv.appendChild(createCopyButton("Position", () => {
      if (!this.camera)
        return "";
      return formatVector3(this.camera.transform.position, this.currentFormat);
    }));
    buttonsDiv.appendChild(createCopyButton("Rotation", () => {
      if (!this.camera)
        return "";
      return formatQuaternion(this.camera.transform.rotation, this.currentFormat);
    }));
    buttonsDiv.appendChild(createCopyButton("Euler", () => {
      if (!this.camera)
        return "";
      const euler = this.camera.transform.rotation.toEuler();
      return formatVector3(euler, this.currentFormat);
    }));
    this.content.appendChild(buttonsDiv);
    const copyAllBtn = createCopyButton("Copy Camera Code", () => {
      if (!this.camera)
        return "";
      return generateCameraCode(this.camera, this.currentFormat);
    }, { fullWidth: true });
    copyAllBtn.style.marginTop = "4px";
    this.content.appendChild(copyAllBtn);
  }
  setCamera(camera) {
    this.camera = camera;
    const posContainer = this.content.querySelector("#camera-pos-input");
    if (posContainer && !this.positionInput) {
      this.positionInput = createVector3Input(camera.transform.position, {
        precision: 2,
        step: 0.5,
        onChange: (v) => {
          if (this.camera) {
            this.camera.transform.position.x = v.x;
            this.camera.transform.position.y = v.y;
            this.camera.transform.position.z = v.z;
          }
        }
      });
      posContainer.appendChild(this.positionInput.element);
    }
    const fovContainer = this.content.querySelector("#camera-fov-input");
    if (fovContainer && !this.fovInput) {
      this.fovInput = createNumberInput(camera.fov, {
        min: 10,
        max: 120,
        step: 1,
        precision: 0,
        width: "50px",
        onChange: (v) => {
          if (this.camera) {
            this.camera.fov = v;
          }
        }
      });
      fovContainer.appendChild(this.fovInput.element);
    }
  }
  update() {
    if (!this.camera || !this.isOpen)
      return;
    if (this.positionInput) {
      const pos = this.camera.transform.position;
      this.positionInput.setValue(pos);
    }
    const euler = this.camera.transform.rotation.toEulerDegrees();
    this.rotationDisplay.innerHTML = `
      <span style="color: #ff6666;">P: ${euler.x.toFixed(1)}°</span>
      <span style="color: #66ff66; margin-left: 8px;">Y: ${euler.y.toFixed(1)}°</span>
      <span style="color: #6666ff; margin-left: 8px;">R: ${euler.z.toFixed(1)}°</span>
    `;
    if (this.fovInput) {
      this.fovInput.setValue(this.camera.fov);
    }
  }
}

// ../../src/core/Atmosphere.ts
var DEFAULT_ATMOSPHERE_CONFIG = {
  enabled: false,
  bottomRadius: 6360000,
  topRadius: 6460000,
  rayleighScattering: new Vector3(0.005802, 0.013558, 0.0331).divide(1000),
  rayleighDensityExpScale: -1 / 8000,
  mieScattering: new Vector3(0.003996, 0.003996, 0.003996).divide(1000),
  mieExtinction: new Vector3(0.00444, 0.00444, 0.00444).divide(1000),
  mieAbsorption: new Vector3(0.000444, 0.000444, 0.000444).divide(1000),
  mieDensityExpScale: -1 / 1200,
  miePhaseG: 0.8,
  absorptionExtinction: new Vector3(0.00065, 0.001881, 0.000085).divide(1000),
  absorptionDensity0LayerWidth: 25000,
  absorptionDensity0ConstantTerm: -0.666666,
  absorptionDensity0LinearTerm: 0.066666 / 1000,
  absorptionDensity1ConstantTerm: 2.666666,
  absorptionDensity1LinearTerm: -0.066666 / 1000,
  sunDirection: new Vector3(0, -1, 0),
  sunIlluminance: new Vector3(10, 10, 10),
  sunDiskHalfAngle: 0.00935,
  groundAlbedo: new Vector3(0.3, 0.3, 0.3),
  sunDiskEnabled: true,
  sunDiskScale: 2.5,
  moonEnabled: true,
  moonDirection: new Vector3(0, 1, 0),
  moonPhase: 0.5,
  moonScale: 1.8,
  moonAngularRadius: 0.009,
  moonColor: new Vector3(0.9, 0.9, 1),
  starsEnabled: true,
  starsIntensity: 1,
  starsTwinkle: 0.3,
  useCustomSkybox: false,
  customSkyboxBlend: 0,
  cloudsEnabled: false,
  cloudQuality: "high",
  cloudCoverage: 0.6,
  cloudDensity: 1.5,
  cloudColor: new Vector3(1, 1, 1),
  cloudAltitude: 3000,
  cloudHeight: 1500,
  cloudSpeed: 20,
  cloudWindDirection: new Vector3(1, 0, 0)
};

// ../../src/core/SubScene.ts
class SubScene extends Node {
  activeCamera = null;
  lights = [];
  enabled = true;
  atmosphere = null;
  priority = 0;
  constructor(name = "SubScene") {
    super(name);
  }
  setActiveCamera(camera) {
    this.activeCamera = camera;
  }
  addLight(light) {
    this.addChild(light);
    if (!this.lights.includes(light)) {
      this.lights.push(light);
    }
  }
  removeLight(light) {
    this.removeChild(light);
    const index = this.lights.indexOf(light);
    if (index > -1) {
      this.lights.splice(index, 1);
    }
  }
  getClosestLights(position, maxLights) {
    const visibleLights = this.lights.filter((l) => l.visible);
    const directional = visibleLights.filter((l) => l.type === 0 /* Directional */);
    const positional = visibleLights.filter((l) => l.type !== 0 /* Directional */);
    positional.sort((a, b) => {
      const distA = Math.max(0.01, a.transform.position.distanceTo(position));
      const distB = Math.max(0.01, b.transform.position.distanceTo(position));
      const scoreA = a.intensity / (distA * distA);
      const scoreB = b.intensity / (distB * distB);
      return scoreB - scoreA;
    });
    const result = [...directional, ...positional];
    return result.slice(0, maxLights);
  }
  isActive() {
    return this.visible && this.enabled && this.activeCamera !== null;
  }
  getEffectiveAtmosphere() {
    return this.atmosphere ?? { ...DEFAULT_ATMOSPHERE_CONFIG };
  }
}

// ../../src/math/Vector2.ts
class Vector2 {
  x;
  y;
  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
  }
  static get zero() {
    return new Vector2(0, 0);
  }
  static get one() {
    return new Vector2(1, 1);
  }
  clone() {
    return new Vector2(this.x, this.y);
  }
  set(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  }
}

// ../../src/core/Camera.ts
class Camera extends Node {
  projectionMatrix;
  viewMatrix;
  projectionJitter = new Vector2(0, 0);
  previousViewMatrix;
  previousProjectionMatrix;
  projectionType = "perspective";
  fov;
  aspect;
  near;
  far;
  orthographic = {
    left: -1,
    right: 1,
    top: 1,
    bottom: -1,
    zoom: 1
  };
  physicalCamera = {
    aperture: 2.8,
    focalLength: 50,
    focusDistance: 10,
    sensorSize: 36,
    shutterSpeed: 250,
    iso: 400
  };
  depthOfField = {
    enabled: false,
    intensity: 1,
    maxBlur: 8,
    samples: 32,
    bokehShape: "circle"
  };
  motionBlur = {
    enabled: false,
    intensity: 1,
    samples: 16,
    maxBlur: 32
  };
  lensEffects = {
    distortionEnabled: false,
    distortionAmount: 0,
    chromaticAberrationEnabled: false,
    chromaticAberrationIntensity: 0.005,
    vignetteEnabled: false,
    vignetteIntensity: 0.3,
    vignetteSmoothness: 0.5
  };
  tiltShift = {
    enabled: false,
    focusPosition: 0.5,
    focusWidth: 0.2,
    blurAmount: 4,
    gradientSize: 0.3,
    direction: "horizontal"
  };
  constructor(fov = 45, aspect = 1, near = 0.1, far = 1000) {
    super("Camera");
    this.fov = fov * (Math.PI / 180);
    this.aspect = aspect;
    this.near = near;
    this.far = far;
    this.projectionMatrix = new Matrix4;
    this.viewMatrix = new Matrix4;
    this.previousViewMatrix = new Matrix4;
    this.previousProjectionMatrix = new Matrix4;
    this.updateProjectionMatrix();
    this.updateViewMatrix();
    this.updatePreviousMatrices();
  }
  getCoCScale() {
    const { aperture, focalLength, focusDistance, sensorSize } = this.physicalCamera;
    const cocScale = focalLength * focalLength / (aperture * focusDistance * sensorSize);
    return cocScale * 0.001;
  }
  getMotionBlurScale() {
    return 60 / this.physicalCamera.shutterSpeed;
  }
  getFovFromPhysical() {
    const { focalLength, sensorSize } = this.physicalCamera;
    return 2 * Math.atan(sensorSize / (2 * focalLength));
  }
  usePhysicalFov() {
    this.fov = this.getFovFromPhysical();
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    if (this.projectionType === "orthographic") {
      const zoom = this.orthographic.zoom;
      const left = this.orthographic.left / zoom;
      const right = this.orthographic.right / zoom;
      const top = this.orthographic.top / zoom;
      const bottom = this.orthographic.bottom / zoom;
      this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
    } else {
      this.projectionMatrix.makePerspective(this.fov, this.aspect, this.near, this.far);
    }
    if (this.projectionJitter.x !== 0 || this.projectionJitter.y !== 0) {
      if (this.projectionType === "orthographic") {
        this.projectionMatrix.elements[12] += this.projectionJitter.x;
        this.projectionMatrix.elements[13] += this.projectionJitter.y;
      } else {
        this.projectionMatrix.elements[8] += this.projectionJitter.x;
        this.projectionMatrix.elements[9] += this.projectionJitter.y;
      }
    }
  }
  setPerspective(fov, aspect) {
    this.projectionType = "perspective";
    if (fov !== undefined)
      this.fov = fov * (Math.PI / 180);
    if (aspect !== undefined)
      this.aspect = aspect;
    this.updateProjectionMatrix();
  }
  setOrthographic(size, aspect) {
    this.projectionType = "orthographic";
    if (aspect !== undefined)
      this.aspect = aspect;
    if (size !== undefined) {
      const halfWidth = size * this.aspect;
      const halfHeight = size;
      this.orthographic.left = -halfWidth;
      this.orthographic.right = halfWidth;
      this.orthographic.top = halfHeight;
      this.orthographic.bottom = -halfHeight;
    }
    this.updateProjectionMatrix();
  }
  setOrthographicBounds(left, right, top, bottom) {
    this.projectionType = "orthographic";
    this.orthographic.left = left;
    this.orthographic.right = right;
    this.orthographic.top = top;
    this.orthographic.bottom = bottom;
    this.updateProjectionMatrix();
  }
  updateOrthographicAspect(aspect) {
    if (this.projectionType !== "orthographic")
      return;
    const halfHeight = (this.orthographic.top - this.orthographic.bottom) / 2;
    this.aspect = aspect;
    this.orthographic.left = -halfHeight * aspect;
    this.orthographic.right = halfHeight * aspect;
    this.updateProjectionMatrix();
  }
  get isOrthographic() {
    return this.projectionType === "orthographic";
  }
  get isPerspective() {
    return this.projectionType === "perspective";
  }
  get viewMatrixInverse() {
    return this.transform.worldMatrix;
  }
  updatePreviousMatrices() {
    this.previousViewMatrix.copy(this.viewMatrix);
    this.previousProjectionMatrix.copy(this.projectionMatrix);
  }
  updateViewMatrix() {
    const eye = this.transform.position;
    const target = this.transform.position.clone().add(this.transform.getForwardVector());
    const up = this.transform.getUpVector();
    this.viewMatrix = new Matrix4().lookAt(eye, target, up);
  }
}

// ../../src/core/ScenePresets.ts
var FOG_PRESETS = {
  none: {
    enabled: false,
    density: 0,
    skyFalloff: 0
  },
  subtle: {
    enabled: true,
    type: "EXP2",
    density: 0.0015,
    skyFalloff: 0.15,
    color: { r: 0.5, g: 0.65, b: 0.85 }
  },
  atmospheric: {
    enabled: true,
    type: "EXP2",
    density: 0.003,
    skyFalloff: 0.25,
    color: { r: 0.5, g: 0.6, b: 0.8 }
  },
  forest: {
    enabled: true,
    type: "EXP2",
    density: 0.0015,
    skyFalloff: 0.2,
    color: { r: 0.45, g: 0.55, b: 0.45 }
  },
  heavy: {
    enabled: true,
    type: "EXP2",
    density: 0.01,
    skyFalloff: 0.4,
    color: { r: 0.6, g: 0.6, b: 0.65 }
  },
  night: {
    enabled: true,
    type: "EXP2",
    density: 0.005,
    skyFalloff: 0.3,
    color: { r: 0.1, g: 0.08, b: 0.15 }
  }
};
var SCENE_PRESETS = {
  "outdoor-day": {
    name: "Outdoor Day",
    description: "Sunny daytime scene with blue sky and subtle fog",
    atmosphere: {
      enabled: true,
      sunDirection: { x: 0.5, y: 0.8, z: 0.3 },
      sunIlluminance: { x: 10, y: 10, z: 9.5 },
      sunDiskEnabled: true,
      sunDiskScale: 1,
      cloudsEnabled: true,
      cloudCoverage: 0.3,
      cloudSpeed: 10
    },
    fog: {
      enabled: true,
      type: "EXP2",
      density: 0.0015,
      color: { r: 0.5, g: 0.65, b: 0.85 },
      skyFalloff: 0.2
    },
    cloudShadows: {
      enabled: true,
      intensity: 0.4,
      scale: 0.02
    },
    postProcessing: {
      bloom: { enabled: true, threshold: 1.5, intensity: 0.6 },
      ssao: { enabled: true, radius: 1.5, bias: 0.025 },
      aa: { enabled: true }
    },
    recommendedLighting: {
      sunIntensity: 4,
      sunColor: { r: 1, g: 0.95, b: 0.9 },
      ambientIntensity: 0.3
    }
  },
  "outdoor-sunset": {
    name: "Outdoor Sunset",
    description: "Golden hour lighting with warm orange tones",
    atmosphere: {
      enabled: true,
      sunDirection: { x: 0.8, y: 0.15, z: 0.3 },
      sunIlluminance: { x: 12, y: 8, z: 5 },
      sunDiskEnabled: true,
      sunDiskScale: 1.5,
      cloudsEnabled: true,
      cloudCoverage: 0.4,
      cloudSpeed: 8
    },
    fog: {
      enabled: true,
      type: "EXP2",
      density: 0.003,
      color: { r: 0.8, g: 0.5, b: 0.4 },
      skyFalloff: 0.35
    },
    cloudShadows: {
      enabled: true,
      intensity: 0.3,
      scale: 0.025
    },
    postProcessing: {
      bloom: { enabled: true, threshold: 1, intensity: 0.8 },
      ssao: { enabled: true },
      aa: { enabled: true }
    },
    recommendedLighting: {
      sunIntensity: 3,
      sunColor: { r: 1, g: 0.7, b: 0.4 },
      ambientIntensity: 0.4
    }
  },
  "outdoor-night": {
    name: "Outdoor Night",
    description: "Moonlit night scene with stars and deep blue fog",
    atmosphere: {
      enabled: true,
      sunDirection: { x: 0, y: -0.3, z: 0.5 },
      sunIlluminance: { x: 0.1, y: 0.1, z: 0.15 },
      sunDiskEnabled: false,
      cloudsEnabled: true,
      cloudCoverage: 0.5,
      cloudSpeed: 5,
      starsEnabled: true,
      moonEnabled: true
    },
    fog: {
      enabled: true,
      type: "EXP2",
      density: 0.005,
      color: { r: 0.1, g: 0.08, b: 0.15 },
      skyFalloff: 0.3
    },
    cloudShadows: {
      enabled: false,
      intensity: 0,
      scale: 0.02
    },
    postProcessing: {
      bloom: { enabled: true, threshold: 0.5, intensity: 1 },
      ssao: { enabled: true },
      aa: { enabled: true }
    },
    recommendedLighting: {
      sunIntensity: 0.5,
      sunColor: { r: 0.7, g: 0.8, b: 1 },
      ambientIntensity: 0.15
    }
  },
  forest: {
    name: "Forest",
    description: "Forest scene with light fog and billboard clouds (performant)",
    atmosphere: {
      enabled: true,
      sunDirection: { x: 0.4, y: 0.6, z: 0.4 },
      sunIlluminance: { x: 8, y: 8, z: 7 },
      sunDiskEnabled: true,
      sunDiskScale: 0.8,
      cloudsEnabled: false,
      cloudCoverage: 0.4,
      cloudSpeed: 12
    },
    fog: {
      enabled: true,
      type: "EXP2",
      density: 0.0015,
      color: { r: 0.45, g: 0.55, b: 0.75 },
      skyFalloff: 0.4
    },
    cloudShadows: {
      enabled: true,
      intensity: 0.4,
      scale: 0.015
    },
    postProcessing: {
      bloom: { enabled: true, threshold: 1.5, intensity: 0.4 },
      ssao: { enabled: true, radius: 2, bias: 0.03 },
      aa: { enabled: false }
    },
    recommendedLighting: {
      sunIntensity: 4,
      sunColor: { r: 1, g: 0.95, b: 0.85 },
      ambientIntensity: 0.4
    }
  },
  "indoor-dungeon": {
    name: "Indoor Dungeon",
    description: "Dark interior with torch lighting and no atmosphere",
    atmosphere: {
      enabled: false,
      sunDirection: { x: 0, y: 1, z: 0 }
    },
    fog: {
      enabled: true,
      type: "EXP2",
      density: 0.008,
      color: { r: 0.15, g: 0.12, b: 0.1 },
      skyFalloff: 0
    },
    cloudShadows: {
      enabled: false,
      intensity: 0,
      scale: 0.02
    },
    postProcessing: {
      bloom: { enabled: true, threshold: 0.8, intensity: 1.2 },
      ssao: { enabled: true, radius: 1, bias: 0.02 },
      aa: { enabled: true }
    },
    recommendedLighting: {
      sunIntensity: 0,
      sunColor: { r: 1, g: 0.8, b: 0.6 },
      ambientIntensity: 0.1
    }
  },
  underwater: {
    name: "Underwater",
    description: "Aquatic scene with caustics and cyan fog",
    atmosphere: {
      enabled: false,
      sunDirection: { x: 0, y: 1, z: 0 }
    },
    fog: {
      enabled: true,
      type: "EXP2",
      density: 0.015,
      color: { r: 0.1, g: 0.3, b: 0.4 },
      skyFalloff: 0.5
    },
    cloudShadows: {
      enabled: false,
      intensity: 0,
      scale: 0.02
    },
    postProcessing: {
      bloom: { enabled: true, threshold: 1.2, intensity: 0.8 },
      ssao: { enabled: true },
      aa: { enabled: true }
    },
    recommendedLighting: {
      sunIntensity: 2,
      sunColor: { r: 0.6, g: 0.8, b: 1 },
      ambientIntensity: 0.4
    }
  }
};
function getScenePresetNames() {
  return Object.keys(SCENE_PRESETS);
}
function getFogPresetNames() {
  return Object.keys(FOG_PRESETS);
}

// ../../src/core/Scene.ts
class Scene extends Node {
  backgroundColor = { r: 0, g: 0, b: 0, a: 1 };
  lights = [];
  _lightScratchGlobal = [];
  _lightScratchPositional = [];
  _lightScratchResult = [];
  shadows = {
    enabled: true,
    resolution: 2048,
    bias: 0.005,
    maxLights: 1
  };
  postProcessing = {
    aa: { enabled: true },
    fxaa: { enabled: false },
    ssr: { enabled: false },
    ssao: { enabled: true, radius: 1.5, bias: 0.025 },
    bloom: { enabled: false, threshold: 0.9, intensity: 1 },
    tonemapping: { enabled: true, exposure: 1 },
    godRays: {
      enabled: false,
      intensity: 0.2,
      decay: 0.97,
      density: 0.5,
      weight: 0.1,
      exposure: 0.3,
      samples: 80,
      maxDistance: 1.5
    }
  };
  globalIllumination = {
    enabled: true,
    intensity: 0.1,
    spatialDenoise: true,
    temporalDenoise: true
  };
  atmosphere = { ...DEFAULT_ATMOSPHERE_CONFIG };
  cloudShadows = {
    enabled: false,
    intensity: 0.5,
    scale: 0.005,
    speed: 1,
    coverage: 0.5,
    softness: 0.3,
    windDirection: 45
  };
  fog = {
    enabled: false,
    type: "EXP2",
    color: new Vector3(0.5, 0.65, 0.85),
    near: 1,
    far: 1000,
    density: 0.002,
    skyFalloff: 0.15
  };
  render = {
    indirectDraw: true,
    frustumCulling: true,
    occlusionCulling: false
  };
  environmentMap = null;
  environmentIntensity = 1;
  constructor() {
    super("Scene");
  }
  get totalTriangleCount() {
    let count = 0;
    this.traverse((node) => {
      if (node instanceof Mesh && node.geometry) {
        count += node.geometry.triangleCount;
      }
    });
    return count;
  }
  addLight(light) {
    this.addChild(light);
    this.lights.push(light);
  }
  removeLight(light) {
    this.removeChild(light);
    const index = this.lights.indexOf(light);
    if (index > -1) {
      this.lights.splice(index, 1);
    }
  }
  getClosestLights(position, maxLights) {
    this._lightScratchGlobal.length = 0;
    this._lightScratchPositional.length = 0;
    this._lightScratchResult.length = 0;
    for (const light of this.lights) {
      if (!light.visible)
        continue;
      if (light.type === 0 /* Directional */ || light.type === 3 /* Ambient */ || light.type === 4 /* Hemisphere */) {
        this._lightScratchGlobal.push(light);
      } else if (light.type === 1 /* Point */ || light.type === 2 /* Spot */) {
        this._lightScratchPositional.push(light);
      }
    }
    this._lightScratchPositional.sort((a, b) => {
      const distA = Math.max(0.01, a.transform.position.distanceTo(position));
      const distB = Math.max(0.01, b.transform.position.distanceTo(position));
      const scoreA = a.intensity / (distA * distA);
      const scoreB = b.intensity / (distB * distB);
      return scoreB - scoreA;
    });
    let count = 0;
    for (const light of this._lightScratchGlobal) {
      if (count >= maxLights)
        break;
      this._lightScratchResult.push(light);
      count++;
    }
    for (const light of this._lightScratchPositional) {
      if (count >= maxLights)
        break;
      this._lightScratchResult.push(light);
      count++;
    }
    return this._lightScratchResult;
  }
  updatePreviousFrame() {
    this.traverse((node) => {
      if (node instanceof Mesh) {
        node.previousWorldMatrix.copy(node.transform.worldMatrix);
      }
    });
  }
  findActiveSubScene() {
    let activeSubScene = null;
    let highestPriority = -Infinity;
    this.traverse((node) => {
      if (node instanceof SubScene && node.isActive()) {
        if (node.priority > highestPriority) {
          highestPriority = node.priority;
          activeSubScene = node;
        }
      }
      return true;
    });
    return activeSubScene;
  }
  getEffectiveCamera() {
    const activeSubScene = this.findActiveSubScene();
    return activeSubScene?.activeCamera ?? null;
  }
  getEffectiveLights() {
    const activeSubScene = this.findActiveSubScene();
    return activeSubScene?.lights ?? this.lights;
  }
  getEffectiveAtmosphere() {
    const activeSubScene = this.findActiveSubScene();
    if (activeSubScene?.atmosphere) {
      return activeSubScene.atmosphere;
    }
    return this.atmosphere;
  }
  usePreset(presetName) {
    const preset = SCENE_PRESETS[presetName];
    if (!preset) {
      const available = getScenePresetNames().join(", ");
      console.warn(`Scene preset '${presetName}' not found. Available presets: ${available}`);
      return;
    }
    this.atmosphere.enabled = preset.atmosphere.enabled;
    if (preset.atmosphere.sunDirection) {
      this.atmosphere.sunDirection.set(preset.atmosphere.sunDirection.x, preset.atmosphere.sunDirection.y, preset.atmosphere.sunDirection.z);
    }
    if (preset.atmosphere.sunIlluminance) {
      this.atmosphere.sunIlluminance.set(preset.atmosphere.sunIlluminance.x, preset.atmosphere.sunIlluminance.y, preset.atmosphere.sunIlluminance.z);
    }
    if (preset.atmosphere.sunDiskEnabled !== undefined) {
      this.atmosphere.sunDiskEnabled = preset.atmosphere.sunDiskEnabled;
    }
    if (preset.atmosphere.sunDiskScale !== undefined) {
      this.atmosphere.sunDiskScale = preset.atmosphere.sunDiskScale;
    }
    if (preset.atmosphere.cloudsEnabled !== undefined) {
      this.atmosphere.cloudsEnabled = preset.atmosphere.cloudsEnabled;
    }
    if (preset.atmosphere.cloudCoverage !== undefined) {
      this.atmosphere.cloudCoverage = preset.atmosphere.cloudCoverage;
    }
    if (preset.atmosphere.cloudSpeed !== undefined) {
      this.atmosphere.cloudSpeed = preset.atmosphere.cloudSpeed;
    }
    if (preset.atmosphere.starsEnabled !== undefined) {
      this.atmosphere.starsEnabled = preset.atmosphere.starsEnabled;
    }
    if (preset.atmosphere.moonEnabled !== undefined) {
      this.atmosphere.moonEnabled = preset.atmosphere.moonEnabled;
    }
    this.fog.enabled = preset.fog.enabled;
    this.fog.type = preset.fog.type;
    this.fog.density = preset.fog.density;
    this.fog.color.set(preset.fog.color.r, preset.fog.color.g, preset.fog.color.b);
    this.fog.skyFalloff = preset.fog.skyFalloff;
    this.cloudShadows.enabled = preset.cloudShadows.enabled;
    this.cloudShadows.intensity = preset.cloudShadows.intensity;
    this.cloudShadows.scale = preset.cloudShadows.scale;
    if (preset.postProcessing.bloom) {
      this.postProcessing.bloom.enabled = preset.postProcessing.bloom.enabled;
      this.postProcessing.bloom.threshold = preset.postProcessing.bloom.threshold;
      this.postProcessing.bloom.intensity = preset.postProcessing.bloom.intensity;
    }
    if (preset.postProcessing.ssr !== undefined) {
      this.postProcessing.ssr.enabled = preset.postProcessing.ssr.enabled;
    }
    if (preset.postProcessing.ssao) {
      this.postProcessing.ssao.enabled = preset.postProcessing.ssao.enabled;
      if (preset.postProcessing.ssao.radius !== undefined) {
        this.postProcessing.ssao.radius = preset.postProcessing.ssao.radius;
      }
      if (preset.postProcessing.ssao.bias !== undefined) {
        this.postProcessing.ssao.bias = preset.postProcessing.ssao.bias;
      }
    }
    if (preset.postProcessing.aa !== undefined) {
      this.postProcessing.aa.enabled = preset.postProcessing.aa.enabled;
    }
    console.log(`Scene: Applied preset '${presetName}' (${preset.description})`);
  }
  useFogPreset(presetName) {
    const preset = FOG_PRESETS[presetName];
    if (!preset) {
      const available = getFogPresetNames().join(", ");
      console.warn(`Fog preset '${presetName}' not found. Available presets: ${available}`);
      return;
    }
    this.fog.enabled = preset.enabled;
    if ("density" in preset) {
      this.fog.density = preset.density;
    }
    if ("skyFalloff" in preset) {
      this.fog.skyFalloff = preset.skyFalloff;
    }
    if ("type" in preset) {
      this.fog.type = preset.type;
    }
    if ("color" in preset && preset.color) {
      this.fog.color.set(preset.color.r, preset.color.g, preset.color.b);
    }
  }
  setFogDensity(density) {
    if (density > 0.02) {
      console.warn(`Fog density ${density} is very high. Typical range: 0.001-0.01. ` + `Did you mean ${(density / 100).toFixed(4)}?`);
    } else if (density < 0 || density > 1) {
      console.warn(`Fog density ${density} is outside valid range. Typical range: 0.001-0.01.`);
    }
    this.fog.density = density;
  }
  static getPresetNames() {
    return getScenePresetNames();
  }
  static getFogPresetNames() {
    return getFogPresetNames();
  }
  static fromPreset(presetName, options) {
    const preset = SCENE_PRESETS[presetName];
    if (!preset) {
      const available = getScenePresetNames().join(", ");
      throw new Error(`Scene preset '${presetName}' not found. Available presets: ${available}`);
    }
    const scene = new Scene;
    scene.usePreset(presetName);
    const sunColor = new Vector3(preset.recommendedLighting.sunColor.r, preset.recommendedLighting.sunColor.g, preset.recommendedLighting.sunColor.b);
    const sun = new DirectionalLight(sunColor, preset.recommendedLighting.sunIntensity);
    sun.shadow.castShadow = true;
    const sunDir = preset.atmosphere.sunDirection;
    sun.transform.position.set(sunDir.x * 100, sunDir.y * 100, sunDir.z * 100);
    const ambient = new AmbientLight(new Vector3(1, 1, 1), preset.recommendedLighting.ambientIntensity);
    scene.addLight(sun);
    scene.addLight(ambient);
    const camera = new Camera(60, 16 / 9, 0.1, 2000);
    if (options?.cameraPosition) {
      camera.transform.position.copy(options.cameraPosition);
    } else {
      if (presetName === "indoor-dungeon") {
        camera.transform.position.set(0, 2, 5);
      } else {
        camera.transform.position.set(50, 15, 50);
      }
    }
    if (options?.cameraTarget) {
      camera.transform.lookAt(options.cameraTarget);
    } else {
      camera.transform.lookAt(new Vector3(0, 0, 0));
    }
    console.log(`Scene.fromPreset('${presetName}'): Created scene with sun, ambient light, and camera`);
    return { scene, sun, ambient, camera };
  }
}

// ../../src/core/debug/panels/ScenePanel.ts
class ScenePanel extends Panel {
  scene = null;
  treeContainer;
  selectedNode = null;
  callbacks;
  nodeElements = new Map;
  constructor(callbacks = {}) {
    super("Scene Graph", { showRefresh: true, onRefresh: () => this.refresh() });
    this.callbacks = callbacks;
    this.treeContainer = document.createElement("div");
    this.treeContainer.style.maxHeight = "200px";
    this.treeContainer.style.overflowY = "auto";
    this.treeContainer.style.fontSize = "11px";
    this.content.appendChild(this.treeContainer);
  }
  onToggle(isOpen) {
    if (isOpen && this.treeContainer.childElementCount === 0) {
      this.refresh();
    }
  }
  setScene(scene) {
    this.scene = scene;
  }
  refresh() {
    if (!this.scene) {
      this.treeContainer.innerHTML = '<i style="color: #888;">No scene registered</i>';
      return;
    }
    this.treeContainer.innerHTML = "";
    this.nodeElements.clear();
    this.treeContainer.appendChild(this.buildNodeTree(this.scene));
  }
  selectNode(node, triggerCallback = true) {
    if (this.selectedNode === node)
      return;
    if (this.selectedNode) {
      const prevEl = this.nodeElements.get(this.selectedNode);
      if (prevEl) {
        prevEl.style.backgroundColor = "transparent";
      }
    }
    this.selectedNode = node;
    if (node) {
      const el = this.nodeElements.get(node);
      if (el) {
        el.style.backgroundColor = "rgba(100, 150, 255, 0.2)";
      }
    }
    if (triggerCallback) {
      this.callbacks.onSelectNode?.(node);
    }
  }
  getSelectedNode() {
    return this.selectedNode;
  }
  buildNodeTree(node, depth = 0) {
    const container = document.createElement("div");
    container.style.marginLeft = `${depth * 12}px`;
    const row = document.createElement("div");
    row.style.display = "flex";
    row.style.alignItems = "center";
    row.style.marginBottom = "2px";
    row.style.padding = "2px 4px";
    row.style.borderRadius = "3px";
    row.style.cursor = "pointer";
    this.nodeElements.set(node, row);
    row.onmouseenter = () => {
      if (node !== this.selectedNode) {
        row.style.backgroundColor = "rgba(255, 255, 255, 0.05)";
      }
    };
    row.onmouseleave = () => {
      if (node !== this.selectedNode) {
        row.style.backgroundColor = "transparent";
      }
    };
    row.onclick = (e) => {
      e.stopPropagation();
      this.selectNode(node);
    };
    row.ondblclick = (e) => {
      e.stopPropagation();
      this.callbacks.onFocusNode?.(node);
    };
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.checked = node.visible;
    checkbox.style.marginRight = "5px";
    checkbox.style.cursor = "pointer";
    checkbox.onclick = (e) => e.stopPropagation();
    checkbox.onchange = () => {
      node.visible = checkbox.checked;
    };
    row.appendChild(checkbox);
    const { typeName, typeColor } = this.getNodeTypeInfo(node);
    const typeSpan = document.createElement("span");
    typeSpan.innerText = `[${typeName}]`;
    typeSpan.style.color = typeColor;
    typeSpan.style.marginRight = "6px";
    typeSpan.style.fontSize = "9px";
    typeSpan.style.fontWeight = "bold";
    row.appendChild(typeSpan);
    const nameSpan = document.createElement("span");
    nameSpan.innerText = node.name || "Unnamed";
    nameSpan.style.flex = "1";
    nameSpan.style.overflow = "hidden";
    nameSpan.style.textOverflow = "ellipsis";
    nameSpan.style.whiteSpace = "nowrap";
    row.appendChild(nameSpan);
    container.appendChild(row);
    if (node.children.length > 0) {
      const childrenContainer = document.createElement("div");
      for (const child of node.children) {
        childrenContainer.appendChild(this.buildNodeTree(child, depth + 1));
      }
      container.appendChild(childrenContainer);
    }
    return container;
  }
  getNodeTypeInfo(node) {
    if (node instanceof Mesh) {
      return { typeName: "Mesh", typeColor: "#aaf" };
    } else if (node instanceof Scene) {
      return { typeName: "Scene", typeColor: "#fff" };
    } else if (node instanceof Light) {
      const light = node;
      switch (light.type) {
        case 0 /* Directional */:
          return { typeName: "Dir", typeColor: "#ffa" };
        case 1 /* Point */:
          return { typeName: "Pt", typeColor: "#aff" };
        case 2 /* Spot */:
          return { typeName: "Spot", typeColor: "#faf" };
        default:
          return { typeName: "Light", typeColor: "#ff8" };
      }
    }
    return { typeName: "Node", typeColor: "#888" };
  }
}

// ../../src/core/debug/panels/InspectorPanel.ts
class InspectorPanel extends Panel {
  selectedNode = null;
  positionInput = null;
  rotationInput = null;
  scaleInput = null;
  contentContainer;
  codeFormatSelect;
  currentFormat = "jsx";
  constructor() {
    super("Inspector", { defaultOpen: false });
    const formatSection = document.createElement("div");
    formatSection.style.marginBottom = "8px";
    formatSection.style.display = "flex";
    formatSection.style.alignItems = "center";
    formatSection.style.gap = "8px";
    const formatLabel = document.createElement("span");
    formatLabel.innerText = "Format:";
    formatLabel.style.fontSize = "10px";
    formatSection.appendChild(formatLabel);
    this.codeFormatSelect = document.createElement("select");
    this.codeFormatSelect.style.fontSize = "10px";
    this.codeFormatSelect.style.padding = "2px 4px";
    this.codeFormatSelect.style.backgroundColor = "#222";
    this.codeFormatSelect.style.color = "#fff";
    this.codeFormatSelect.style.border = "1px solid #555";
    this.codeFormatSelect.style.borderRadius = "3px";
    const formats = [
      { value: "jsx", label: "JSX" },
      { value: "yaml", label: "YAML" },
      { value: "typescript", label: "TypeScript" }
    ];
    formats.forEach(({ value, label }) => {
      const option = document.createElement("option");
      option.value = value;
      option.innerText = label;
      this.codeFormatSelect.appendChild(option);
    });
    this.codeFormatSelect.onchange = () => {
      this.currentFormat = this.codeFormatSelect.value;
    };
    formatSection.appendChild(this.codeFormatSelect);
    this.content.appendChild(formatSection);
    this.contentContainer = document.createElement("div");
    this.content.appendChild(this.contentContainer);
  }
  setSelectedNode(node) {
    this.selectedNode = node;
    this.positionInput = null;
    this.rotationInput = null;
    this.scaleInput = null;
    this.rebuildContent();
  }
  rebuildContent() {
    this.contentContainer.innerHTML = "";
    if (!this.selectedNode) {
      const emptyMsg = document.createElement("div");
      emptyMsg.innerHTML = '<i style="color: #888;">No object selected</i>';
      emptyMsg.style.fontSize = "10px";
      this.contentContainer.appendChild(emptyMsg);
      return;
    }
    const node = this.selectedNode;
    const nameHeader = document.createElement("div");
    nameHeader.style.fontWeight = "bold";
    nameHeader.style.marginBottom = "8px";
    nameHeader.style.padding = "4px";
    nameHeader.style.backgroundColor = "rgba(255, 255, 255, 0.05)";
    nameHeader.style.borderRadius = "3px";
    nameHeader.innerText = node.name || "Unnamed Object";
    this.contentContainer.appendChild(nameHeader);
    this.createSection("Position", () => {
      this.positionInput = createVector3Input(node.transform.position, {
        precision: 2,
        step: 0.5,
        onChange: (v) => {
          if (this.selectedNode) {
            this.selectedNode.transform.position = new Vector3(v.x, v.y, v.z);
          }
        }
      });
      return this.positionInput.element;
    });
    this.createSection("Rotation (degrees)", () => {
      const euler = node.transform.rotation.toEulerDegrees();
      this.rotationInput = createVector3Input(euler, {
        precision: 1,
        step: 5,
        labels: { x: "P", y: "Y", z: "R" },
        colors: { x: "#ff6666", y: "#66ff66", z: "#6666ff" },
        onChange: (v) => {
          if (this.selectedNode) {
            const deg2rad = Math.PI / 180;
            const eulerRad = new Vector3(v.x * deg2rad, v.y * deg2rad, v.z * deg2rad);
            this.selectedNode.transform.rotation = Quaternion.fromEuler(eulerRad, "YXZ");
          }
        }
      });
      return this.rotationInput.element;
    });
    this.createSection("Scale", () => {
      this.scaleInput = createVector3Input(node.transform.scale, {
        precision: 2,
        step: 0.1,
        labels: { x: "X", y: "Y", z: "Z" },
        colors: { x: "#ff9966", y: "#99ff66", z: "#6699ff" },
        onChange: (v) => {
          if (this.selectedNode) {
            this.selectedNode.transform.scale = new Vector3(v.x, v.y, v.z);
          }
        }
      });
      return this.scaleInput.element;
    });
    this.createSection("Visibility", () => {
      const visRow = document.createElement("div");
      visRow.style.display = "flex";
      visRow.style.alignItems = "center";
      visRow.style.gap = "8px";
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.checked = node.visible;
      checkbox.onchange = () => {
        if (this.selectedNode) {
          this.selectedNode.visible = checkbox.checked;
        }
      };
      visRow.appendChild(checkbox);
      const label = document.createElement("span");
      label.innerText = "Visible";
      label.style.fontSize = "10px";
      visRow.appendChild(label);
      return visRow;
    });
    if (node instanceof Light) {
      this.createLightSection(node);
    }
    const divider = document.createElement("div");
    divider.style.borderTop = "1px solid #444";
    divider.style.margin = "8px 0";
    this.contentContainer.appendChild(divider);
    const copyBtn = createCopyButton("Copy Object Code", () => {
      if (!this.selectedNode)
        return "";
      if (this.selectedNode instanceof Light) {
        return generateLightCode(this.selectedNode, this.currentFormat);
      }
      return generateNodeCode(this.selectedNode, this.currentFormat);
    }, { fullWidth: true });
    this.contentContainer.appendChild(copyBtn);
  }
  createSection(title, buildContent) {
    const section = document.createElement("div");
    section.style.marginBottom = "8px";
    const label = document.createElement("div");
    label.innerText = title;
    label.style.fontWeight = "bold";
    label.style.marginBottom = "4px";
    label.style.fontSize = "10px";
    label.style.color = "#aaa";
    section.appendChild(label);
    section.appendChild(buildContent());
    this.contentContainer.appendChild(section);
  }
  createLightSection(light) {
    this.createSection("Light Type", () => {
      const typeDisplay = document.createElement("span");
      typeDisplay.style.fontSize = "10px";
      switch (light.type) {
        case 0 /* Directional */:
          typeDisplay.innerText = "Directional";
          typeDisplay.style.color = "#ffa";
          break;
        case 1 /* Point */:
          typeDisplay.innerText = "Point";
          typeDisplay.style.color = "#aff";
          break;
        case 2 /* Spot */:
          typeDisplay.innerText = "Spot";
          typeDisplay.style.color = "#faf";
          break;
      }
      return typeDisplay;
    });
    this.createSection("Intensity", () => {
      const intensityRow = document.createElement("div");
      intensityRow.style.display = "flex";
      intensityRow.style.alignItems = "center";
      intensityRow.style.gap = "8px";
      const slider = document.createElement("input");
      slider.type = "range";
      slider.min = "0";
      slider.max = "10";
      slider.step = "0.1";
      slider.value = light.intensity.toString();
      slider.style.width = "80px";
      const valueDisplay = document.createElement("span");
      valueDisplay.innerText = light.intensity.toFixed(1);
      valueDisplay.style.fontSize = "10px";
      valueDisplay.style.minWidth = "30px";
      slider.oninput = () => {
        const val = parseFloat(slider.value);
        light.intensity = val;
        valueDisplay.innerText = val.toFixed(1);
      };
      intensityRow.appendChild(slider);
      intensityRow.appendChild(valueDisplay);
      return intensityRow;
    });
    this.createSection("Shadows", () => {
      const shadowRow = document.createElement("div");
      shadowRow.style.display = "flex";
      shadowRow.style.alignItems = "center";
      shadowRow.style.gap = "8px";
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.checked = light.shadow.castShadow;
      checkbox.onchange = () => {
        light.shadow.castShadow = checkbox.checked;
      };
      shadowRow.appendChild(checkbox);
      const label = document.createElement("span");
      label.innerText = "Cast Shadow";
      label.style.fontSize = "10px";
      shadowRow.appendChild(label);
      return shadowRow;
    });
  }
  update() {
    if (!this.selectedNode || !this.isOpen)
      return;
    if (this.positionInput) {
      this.positionInput.setValue(this.selectedNode.transform.position);
    }
    if (this.rotationInput) {
      const euler = this.selectedNode.transform.rotation.toEulerDegrees();
      this.rotationInput.setValue(euler);
    }
    if (this.scaleInput) {
      this.scaleInput.setValue(this.selectedNode.transform.scale);
    }
  }
}

// ../../src/core/debug/panels/RenderSettingsPanel.ts
class RenderSettingsPanel extends Panel {
  scene = null;
  settingsContainer;
  toggleRows = new Map;
  sliderRows = new Map;
  constructor() {
    super("Render Settings", { defaultOpen: false });
    this.settingsContainer = document.createElement("div");
    this.settingsContainer.style.fontSize = "11px";
    this.content.appendChild(this.settingsContainer);
    this.buildSettings();
  }
  setScene(scene) {
    this.scene = scene;
    this.syncFromScene();
  }
  buildSettings() {
    this.createSectionHeader("Post Processing");
    this.createToggle("taa", "TAA", true, (checked) => {
      if (this.scene)
        this.scene.postProcessing.aa.enabled = checked;
    });
    this.createToggle("fxaa", "FXAA", false, (checked) => {
      if (this.scene)
        this.scene.postProcessing.fxaa.enabled = checked;
    });
    this.createToggle("ssao", "SSAO", true, (checked) => {
      if (this.scene)
        this.scene.postProcessing.ssao.enabled = checked;
    });
    this.createSlider("ssaoRadius", "SSAO Radius", 0.1, 5, 0.5, 0.1, (val) => {
      if (this.scene)
        this.scene.postProcessing.ssao.radius = val;
    });
    this.createSlider("ssaoBias", "SSAO Bias", 0.001, 0.1, 0.025, 0.001, (val) => {
      if (this.scene)
        this.scene.postProcessing.ssao.bias = val;
    });
    this.createSectionHeader("Global Illumination");
    this.createToggle("ssgi", "SSGI (Alpha)", true, (checked) => {
      if (this.scene)
        this.scene.globalIllumination.enabled = checked;
    });
    this.createSlider("ssgiIntensity", "SSGI Intensity", 0, 3, 0.1, 0.1, (val) => {
      if (this.scene)
        this.scene.globalIllumination.intensity = val;
    });
    this.createToggle("ssgiSpatial", "SSGI Spatial Denoise", false, (checked) => {
      if (this.scene)
        this.scene.globalIllumination.spatialDenoise = checked;
    });
    this.createToggle("ssgiTemporal", "SSGI Temporal Denoise", true, (checked) => {
      if (this.scene)
        this.scene.globalIllumination.temporalDenoise = checked;
    });
    this.createSectionHeader("Culling & Draw");
    this.createToggle("indirect", "Indirect Draw", true, (checked) => {
      if (this.scene)
        this.scene.render.indirectDraw = checked;
    });
    this.createToggle("frustum", "Frustum Culling", true, (checked) => {
      if (this.scene)
        this.scene.render.frustumCulling = checked;
    });
    this.createToggle("occlusion", "Occlusion Culling", true, (checked) => {
      if (this.scene)
        this.scene.render.occlusionCulling = checked;
    });
  }
  createSectionHeader(title) {
    const header = document.createElement("div");
    header.innerText = title;
    header.style.fontWeight = "bold";
    header.style.marginTop = "8px";
    header.style.marginBottom = "4px";
    header.style.fontSize = "10px";
    header.style.color = "#aaa";
    header.style.borderBottom = "1px solid #444";
    header.style.paddingBottom = "2px";
    this.settingsContainer.appendChild(header);
  }
  createToggle(id, label, defaultValue, onChange) {
    const row = document.createElement("div");
    row.style.display = "flex";
    row.style.alignItems = "center";
    row.style.marginBottom = "3px";
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.checked = defaultValue;
    checkbox.style.marginRight = "6px";
    checkbox.onchange = () => onChange(checkbox.checked);
    row.appendChild(checkbox);
    this.toggleRows.set(id, checkbox);
    const labelSpan = document.createElement("span");
    labelSpan.innerText = label;
    labelSpan.style.fontSize = "10px";
    row.appendChild(labelSpan);
    this.settingsContainer.appendChild(row);
  }
  createSlider(id, label, min, max, defaultValue, step, onChange) {
    const row = document.createElement("div");
    row.style.display = "flex";
    row.style.alignItems = "center";
    row.style.marginBottom = "3px";
    row.style.fontSize = "10px";
    const labelSpan = document.createElement("span");
    labelSpan.innerText = label + ": ";
    labelSpan.style.marginRight = "5px";
    labelSpan.style.minWidth = "80px";
    labelSpan.style.color = "#aaa";
    row.appendChild(labelSpan);
    const slider = document.createElement("input");
    slider.type = "range";
    slider.min = min.toString();
    slider.max = max.toString();
    slider.step = step.toString();
    slider.value = defaultValue.toString();
    slider.style.width = "60px";
    const valueSpan = document.createElement("span");
    valueSpan.innerText = defaultValue.toFixed(3);
    valueSpan.style.marginLeft = "5px";
    valueSpan.style.minWidth = "40px";
    slider.oninput = () => {
      const val = parseFloat(slider.value);
      valueSpan.innerText = val.toFixed(3);
      onChange(val);
    };
    this.sliderRows.set(id, { slider, value: valueSpan });
    row.appendChild(slider);
    row.appendChild(valueSpan);
    this.settingsContainer.appendChild(row);
  }
  syncFromScene() {
    if (!this.scene)
      return;
    this.toggleRows.get("taa").checked = this.scene.postProcessing.aa.enabled;
    this.toggleRows.get("fxaa").checked = this.scene.postProcessing.fxaa.enabled;
    this.toggleRows.get("ssao").checked = this.scene.postProcessing.ssao.enabled;
    this.toggleRows.get("ssgi").checked = this.scene.globalIllumination.enabled;
    this.toggleRows.get("ssgiSpatial").checked = this.scene.globalIllumination.spatialDenoise;
    this.toggleRows.get("ssgiTemporal").checked = this.scene.globalIllumination.temporalDenoise;
    this.toggleRows.get("indirect").checked = this.scene.render.indirectDraw;
    this.toggleRows.get("frustum").checked = this.scene.render.frustumCulling;
    this.toggleRows.get("occlusion").checked = this.scene.render.occlusionCulling;
    const ssaoRadius = this.sliderRows.get("ssaoRadius");
    if (ssaoRadius) {
      ssaoRadius.slider.value = this.scene.postProcessing.ssao.radius.toString();
      ssaoRadius.value.innerText = this.scene.postProcessing.ssao.radius.toFixed(3);
    }
    const ssaoBias = this.sliderRows.get("ssaoBias");
    if (ssaoBias) {
      ssaoBias.slider.value = this.scene.postProcessing.ssao.bias.toString();
      ssaoBias.value.innerText = this.scene.postProcessing.ssao.bias.toFixed(3);
    }
    const ssgiIntensity = this.sliderRows.get("ssgiIntensity");
    if (ssgiIntensity) {
      ssgiIntensity.slider.value = this.scene.globalIllumination.intensity.toString();
      ssgiIntensity.value.innerText = this.scene.globalIllumination.intensity.toFixed(3);
    }
  }
}

// ../../src/core/debug/panels/LightsPanel.ts
class LightsPanel extends Panel {
  scene = null;
  lightsContainer;
  callbacks;
  constructor(callbacks = {}) {
    super("Lights", { showRefresh: true, onRefresh: () => this.refresh() });
    this.callbacks = callbacks;
    this.lightsContainer = document.createElement("div");
    this.lightsContainer.style.maxHeight = "150px";
    this.lightsContainer.style.overflowY = "auto";
    this.lightsContainer.style.fontSize = "11px";
    this.content.appendChild(this.lightsContainer);
  }
  onToggle(isOpen) {
    if (isOpen) {
      this.refresh();
    }
  }
  setScene(scene) {
    this.scene = scene;
  }
  refresh() {
    if (!this.scene) {
      this.lightsContainer.innerHTML = '<i style="color: #888;">No scene registered</i>';
      return;
    }
    this.lightsContainer.innerHTML = "";
    if (this.scene.lights.length === 0) {
      this.lightsContainer.innerHTML = '<i style="color: #888;">No lights in scene</i>';
      return;
    }
    for (const light of this.scene.lights) {
      this.lightsContainer.appendChild(this.createLightRow(light));
    }
  }
  createLightRow(light) {
    const row = document.createElement("div");
    row.style.display = "flex";
    row.style.alignItems = "center";
    row.style.marginBottom = "3px";
    row.style.padding = "3px";
    row.style.backgroundColor = "rgba(255, 255, 255, 0.05)";
    row.style.borderRadius = "3px";
    row.style.cursor = "pointer";
    row.onmouseenter = () => {
      row.style.backgroundColor = "rgba(255, 255, 255, 0.1)";
    };
    row.onmouseleave = () => {
      row.style.backgroundColor = "rgba(255, 255, 255, 0.05)";
    };
    row.onclick = () => {
      this.callbacks.onSelectLight?.(light);
    };
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.checked = light.visible;
    checkbox.style.marginRight = "6px";
    checkbox.onclick = (e) => e.stopPropagation();
    checkbox.onchange = () => {
      light.visible = checkbox.checked;
    };
    row.appendChild(checkbox);
    const { typeLabel, typeColor } = this.getLightTypeInfo(light);
    const typeSpan = document.createElement("span");
    typeSpan.innerText = `[${typeLabel}]`;
    typeSpan.style.color = typeColor;
    typeSpan.style.marginRight = "6px";
    typeSpan.style.fontSize = "9px";
    typeSpan.style.fontWeight = "bold";
    row.appendChild(typeSpan);
    const nameSpan = document.createElement("span");
    nameSpan.innerText = light.name || "Unnamed";
    nameSpan.style.flex = "1";
    nameSpan.style.overflow = "hidden";
    nameSpan.style.textOverflow = "ellipsis";
    nameSpan.style.whiteSpace = "nowrap";
    row.appendChild(nameSpan);
    const intensitySpan = document.createElement("span");
    intensitySpan.innerText = `${light.intensity.toFixed(1)}`;
    intensitySpan.style.color = "#888";
    intensitySpan.style.fontSize = "9px";
    intensitySpan.style.marginLeft = "4px";
    intensitySpan.title = "Intensity";
    row.appendChild(intensitySpan);
    if (light.shadow.castShadow) {
      const shadowIcon = document.createElement("span");
      shadowIcon.innerText = "\uD83C\uDF11";
      shadowIcon.style.marginLeft = "4px";
      shadowIcon.style.fontSize = "10px";
      shadowIcon.title = "Casts Shadow";
      row.appendChild(shadowIcon);
    }
    return row;
  }
  getLightTypeInfo(light) {
    switch (light.type) {
      case 0 /* Directional */:
        return { typeLabel: "Dir", typeColor: "#ffa" };
      case 1 /* Point */:
        return { typeLabel: "Pt", typeColor: "#aff" };
      case 2 /* Spot */:
        return { typeLabel: "Spot", typeColor: "#faf" };
      default:
        return { typeLabel: "Light", typeColor: "#ff8" };
    }
  }
}

// ../../src/core/debug/panels/UIHierarchyPanel.ts
class UIHierarchyPanel extends Panel {
  uiManager = null;
  treeContainer;
  selectedElement = null;
  callbacks;
  elementNodes = new Map;
  constructor(callbacks = {}) {
    super("UI Hierarchy", { showRefresh: true, onRefresh: () => this.refresh() });
    this.callbacks = callbacks;
    this.treeContainer = document.createElement("div");
    this.treeContainer.style.maxHeight = "200px";
    this.treeContainer.style.overflowY = "auto";
    this.treeContainer.style.fontSize = "11px";
    this.content.appendChild(this.treeContainer);
  }
  onToggle(isOpen) {
    if (isOpen && this.treeContainer.childElementCount === 0) {
      this.refresh();
    }
  }
  setUIManager(uiManager) {
    this.uiManager = uiManager;
    this.treeContainer.innerHTML = "";
    this.elementNodes.clear();
  }
  refresh() {
    this.selectElement(null);
    if (!this.uiManager) {
      this.treeContainer.innerHTML = '<i style="color: #888;">No UI Manager registered</i>';
      return;
    }
    const root = this.uiManager.getRoot();
    if (!root) {
      this.treeContainer.innerHTML = '<i style="color: #888;">No UI root element</i>';
      return;
    }
    this.treeContainer.innerHTML = "";
    this.elementNodes.clear();
    this.treeContainer.appendChild(this.buildElementTree(root));
  }
  selectElement(element, triggerCallback = true) {
    if (this.selectedElement === element)
      return;
    if (this.selectedElement) {
      const prevEl = this.elementNodes.get(this.selectedElement);
      if (prevEl) {
        prevEl.style.backgroundColor = "transparent";
      }
    }
    this.selectedElement = element;
    if (element) {
      const el = this.elementNodes.get(element);
      if (el) {
        el.style.backgroundColor = "rgba(255, 100, 100, 0.2)";
      }
    }
    if (triggerCallback) {
      this.callbacks.onSelectElement?.(element);
    }
  }
  getSelectedElement() {
    return this.selectedElement;
  }
  buildElementTree(element, depth = 0) {
    const container = document.createElement("div");
    container.style.marginLeft = `${depth * 12}px`;
    const row = document.createElement("div");
    row.style.display = "flex";
    row.style.alignItems = "center";
    row.style.marginBottom = "2px";
    row.style.padding = "2px 4px";
    row.style.borderRadius = "3px";
    row.style.cursor = "pointer";
    this.elementNodes.set(element, row);
    row.onmouseenter = () => {
      if (element !== this.selectedElement) {
        row.style.backgroundColor = "rgba(255, 255, 255, 0.05)";
      }
    };
    row.onmouseleave = () => {
      if (element !== this.selectedElement) {
        row.style.backgroundColor = "transparent";
      }
    };
    row.onclick = (e) => {
      e.stopPropagation();
      if (this.selectedElement === element) {
        this.selectElement(null);
      } else {
        this.selectElement(element);
      }
    };
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.checked = element.visible;
    checkbox.style.marginRight = "5px";
    checkbox.style.cursor = "pointer";
    checkbox.onclick = (e) => e.stopPropagation();
    checkbox.onchange = () => {
      element.visible = checkbox.checked;
    };
    row.appendChild(checkbox);
    const { typeName, typeColor } = this.getElementTypeInfo(element);
    const typeSpan = document.createElement("span");
    typeSpan.innerText = `[${typeName}]`;
    typeSpan.style.color = typeColor;
    typeSpan.style.marginRight = "6px";
    typeSpan.style.fontSize = "9px";
    typeSpan.style.fontWeight = "bold";
    row.appendChild(typeSpan);
    const nameSpan = document.createElement("span");
    nameSpan.innerText = element.name || element.id || "Unnamed";
    nameSpan.style.flex = "1";
    nameSpan.style.overflow = "hidden";
    nameSpan.style.textOverflow = "ellipsis";
    nameSpan.style.whiteSpace = "nowrap";
    row.appendChild(nameSpan);
    container.appendChild(row);
    if (element.children.length > 0) {
      const childrenContainer = document.createElement("div");
      for (const child of element.children) {
        childrenContainer.appendChild(this.buildElementTree(child, depth + 1));
      }
      container.appendChild(childrenContainer);
    }
    return container;
  }
  getElementTypeInfo(element) {
    if (element instanceof Button) {
      return { typeName: "Btn", typeColor: "#ffaa66" };
    } else if (element instanceof Label) {
      return { typeName: "Lbl", typeColor: "#aaffaa" };
    } else if (element instanceof Image2) {
      return { typeName: "Img", typeColor: "#aaaaff" };
    }
    const constructorName = element.constructor.name;
    switch (constructorName) {
      case "Panel":
        return { typeName: "Pnl", typeColor: "#ffaaff" };
      case "Toggle":
        return { typeName: "Tgl", typeColor: "#aaffff" };
      case "Slider":
        return { typeName: "Sld", typeColor: "#ffffaa" };
      case "TypewriterBox":
        return { typeName: "Txt", typeColor: "#ff88ff" };
      case "DialogueBox":
        return { typeName: "Dlg", typeColor: "#88ffff" };
      case "CharacterDisplay":
        return { typeName: "Chr", typeColor: "#ffff88" };
      default:
        return { typeName: "UI", typeColor: "#888888" };
    }
  }
}

// ../../src/debug/ErrorOverlay.ts
class ErrorOverlay {
  static instance;
  element;
  content;
  header;
  errorList;
  isVisible = false;
  errorCount = 0;
  static MAX_ERRORS = 50;
  constructor() {
    this.element = document.createElement("div");
    this.element.style.position = "fixed";
    this.element.style.top = "50%";
    this.element.style.left = "50%";
    this.element.style.transform = "translate(-50%, -50%)";
    this.element.style.width = "80%";
    this.element.style.maxWidth = "800px";
    this.element.style.maxHeight = "80vh";
    this.element.style.backgroundColor = "rgba(20, 20, 20, 0.95)";
    this.element.style.border = "1px solid #ff4444";
    this.element.style.boxShadow = "0 0 20px rgba(0, 0, 0, 0.8)";
    this.element.style.color = "#fff";
    this.element.style.fontFamily = "monospace";
    this.element.style.zIndex = "10000";
    this.element.style.display = "none";
    this.element.style.flexDirection = "column";
    this.element.style.borderRadius = "8px";
    this.header = document.createElement("div");
    this.header.style.padding = "10px 15px";
    this.header.style.backgroundColor = "#331111";
    this.header.style.borderBottom = "1px solid #552222";
    this.header.style.display = "flex";
    this.header.style.justifyContent = "space-between";
    this.header.style.alignItems = "center";
    this.header.style.borderTopLeftRadius = "8px";
    this.header.style.borderTopRightRadius = "8px";
    const titleContainer = document.createElement("div");
    titleContainer.style.display = "flex";
    titleContainer.style.alignItems = "center";
    titleContainer.style.gap = "10px";
    const title = document.createElement("span");
    title.innerText = "⚠️ Engine Errors";
    title.style.fontWeight = "bold";
    title.style.color = "#ff6666";
    titleContainer.appendChild(title);
    this.header.appendChild(titleContainer);
    const controls = document.createElement("div");
    controls.style.display = "flex";
    controls.style.gap = "10px";
    const copyFirstBtn = document.createElement("button");
    copyFirstBtn.innerText = "Copy first";
    copyFirstBtn.style.background = "#444";
    copyFirstBtn.style.border = "1px solid #666";
    copyFirstBtn.style.color = "#fff";
    copyFirstBtn.style.cursor = "pointer";
    copyFirstBtn.style.fontSize = "12px";
    copyFirstBtn.style.padding = "2px 8px";
    copyFirstBtn.style.borderRadius = "4px";
    copyFirstBtn.onclick = () => this.copyToClipboard(1, copyFirstBtn);
    controls.appendChild(copyFirstBtn);
    const copyFirst3Btn = document.createElement("button");
    copyFirst3Btn.innerText = "Copy first 3";
    copyFirst3Btn.style.background = "#444";
    copyFirst3Btn.style.border = "1px solid #666";
    copyFirst3Btn.style.color = "#fff";
    copyFirst3Btn.style.cursor = "pointer";
    copyFirst3Btn.style.fontSize = "12px";
    copyFirst3Btn.style.padding = "2px 8px";
    copyFirst3Btn.style.borderRadius = "4px";
    copyFirst3Btn.onclick = () => this.copyToClipboard(3, copyFirst3Btn);
    controls.appendChild(copyFirst3Btn);
    const copyBtn = document.createElement("button");
    copyBtn.innerText = "Copy All";
    copyBtn.style.background = "#444";
    copyBtn.style.border = "1px solid #666";
    copyBtn.style.color = "#fff";
    copyBtn.style.cursor = "pointer";
    copyBtn.style.fontSize = "12px";
    copyBtn.style.padding = "2px 8px";
    copyBtn.style.borderRadius = "4px";
    copyBtn.onclick = () => this.copyToClipboard(undefined, copyBtn);
    controls.appendChild(copyBtn);
    const closeBtn = document.createElement("button");
    closeBtn.innerText = "✕";
    closeBtn.style.background = "none";
    closeBtn.style.border = "none";
    closeBtn.style.color = "#fff";
    closeBtn.style.cursor = "pointer";
    closeBtn.style.fontSize = "16px";
    closeBtn.onclick = () => this.hide();
    controls.appendChild(closeBtn);
    this.header.appendChild(controls);
    this.element.appendChild(this.header);
    this.content = document.createElement("div");
    this.content.style.padding = "0";
    this.content.style.overflowY = "auto";
    this.content.style.flex = "1";
    this.element.appendChild(this.content);
    this.errorList = document.createElement("div");
    this.content.appendChild(this.errorList);
    document.body.appendChild(this.element);
  }
  static getInstance() {
    if (!ErrorOverlay.instance) {
      ErrorOverlay.instance = new ErrorOverlay;
    }
    return ErrorOverlay.instance;
  }
  show() {
    if (!this.isVisible) {
      this.element.style.display = "flex";
      this.isVisible = true;
    }
  }
  hide() {
    this.element.style.display = "none";
    this.isVisible = false;
  }
  clear() {
    this.errorList.innerHTML = "";
    this.errorCount = 0;
  }
  reportError(message, source = "General") {
    if (this.errorCount >= ErrorOverlay.MAX_ERRORS)
      return;
    this.show();
    const item = this.createErrorItem(source, message, "error");
    this.errorList.appendChild(item);
    this.errorCount++;
    if (this.errorCount >= ErrorOverlay.MAX_ERRORS) {
      this.addLimitMessage();
    }
  }
  reportWarning(message, source = "General") {
    if (this.errorCount >= ErrorOverlay.MAX_ERRORS)
      return;
    const item = this.createErrorItem(source, message, "warning");
    this.errorList.appendChild(item);
    this.errorCount++;
    if (this.errorCount >= ErrorOverlay.MAX_ERRORS) {
      this.addLimitMessage();
    }
  }
  reportShaderIssues(label, code, messages) {
    if (this.errorCount >= ErrorOverlay.MAX_ERRORS)
      return;
    let hasError = false;
    const messageContainer = document.createElement("div");
    messageContainer.style.padding = "10px";
    messageContainer.style.borderBottom = "1px solid #444";
    const header = document.createElement("div");
    header.innerText = `Shader Compilation: ${label}`;
    header.style.fontWeight = "bold";
    header.style.marginBottom = "5px";
    header.style.color = "#aaa";
    messageContainer.appendChild(header);
    const codeLines = code.split(`
`);
    for (const msg of messages) {
      if (msg.type === "error")
        hasError = true;
      const msgDiv = document.createElement("div");
      msgDiv.style.marginBottom = "8px";
      msgDiv.style.padding = "5px";
      msgDiv.style.backgroundColor = msg.type === "error" ? "rgba(255, 0, 0, 0.1)" : "rgba(255, 255, 0, 0.1)";
      msgDiv.style.borderLeft = `3px solid ${msg.type === "error" ? "#f44" : "#fa0"}`;
      const text = document.createElement("div");
      text.innerText = `[${msg.type.toUpperCase()}] Line ${msg.lineNum}:${msg.linePos} - ${msg.message}`;
      text.style.color = msg.type === "error" ? "#f88" : "#fe8";
      msgDiv.appendChild(text);
      if (msg.lineNum && msg.lineNum <= codeLines.length) {
        const context = document.createElement("pre");
        context.style.margin = "4px 0 0 0";
        context.style.fontSize = "11px";
        context.style.color = "#888";
        context.style.overflowX = "auto";
        const startLine = Math.max(0, msg.lineNum - 2);
        const endLine = Math.min(codeLines.length - 1, msg.lineNum + 2);
        let contextStr = "";
        for (let i = startLine;i <= endLine; i++) {
          const prefix = i + 1 === msg.lineNum ? "> " : "  ";
          contextStr += `${prefix}${i + 1}: ${codeLines[i]}
`;
        }
        context.innerText = contextStr;
        msgDiv.appendChild(context);
      }
      messageContainer.appendChild(msgDiv);
    }
    this.errorList.appendChild(messageContainer);
    this.errorCount++;
    if (hasError) {
      this.show();
    }
    if (this.errorCount >= ErrorOverlay.MAX_ERRORS) {
      this.addLimitMessage();
    }
  }
  addLimitMessage() {
    const div = document.createElement("div");
    div.style.padding = "10px";
    div.style.textAlign = "center";
    div.style.color = "#888";
    div.style.fontStyle = "italic";
    div.innerText = `Error limit reached (${ErrorOverlay.MAX_ERRORS}). Further errors suppressed.`;
    this.errorList.appendChild(div);
  }
  copyToClipboard(count, button) {
    let text;
    if (count === undefined) {
      text = this.errorList.innerText;
    } else {
      const children = this.errorList.children;
      const parts = [];
      for (let i = 0;i < Math.min(count, children.length); i++) {
        parts.push(children[i].innerText);
      }
      text = parts.join(`

`);
    }
    navigator.clipboard.writeText(text).then(() => {
      if (button) {
        const originalText = button.innerText;
        button.innerText = "✓";
        setTimeout(() => {
          button.innerText = originalText;
        }, 2000);
      }
    }).catch((err) => {
      console.error("Failed to copy errors: ", err);
    });
  }
  createErrorItem(source, message, type) {
    const div = document.createElement("div");
    div.style.padding = "10px";
    div.style.borderBottom = "1px solid #444";
    div.style.backgroundColor = type === "error" ? "rgba(50, 0, 0, 0.3)" : "rgba(50, 50, 0, 0.2)";
    const meta = document.createElement("div");
    meta.style.fontSize = "11px";
    meta.style.color = "#aaa";
    meta.style.marginBottom = "4px";
    meta.innerText = `[${type.toUpperCase()}] ${source} - ${new Date().toLocaleTimeString()}`;
    div.appendChild(meta);
    const msg = document.createElement("div");
    msg.innerText = message;
    msg.style.whiteSpace = "pre-wrap";
    msg.style.color = type === "error" ? "#f66" : "#fd8";
    div.appendChild(msg);
    return div;
  }
}

// ../../src/core/renderer/RendererCapabilities.ts
var DEFAULT_SOFTWARE_RENDERING_CONFIG = {
  forceSoftwareMode: false,
  disableSSGI: true,
  disableSSR: true,
  disableSSAO: false,
  disableTAA: false,
  disableBloom: false,
  disableDoF: true,
  disableMotionBlur: true,
  disableAtmosphere: false,
  simpleShadows: true,
  reduceTextureQuality: true
};
var cachedCapabilities = null;
async function detectRendererCapabilities(adapter) {
  if (cachedCapabilities) {
    return cachedCapabilities;
  }
  let info = {
    vendor: "",
    architecture: "",
    device: "",
    description: ""
  };
  const adapterAny = adapter;
  if (typeof adapterAny.requestAdapterInfo === "function") {
    try {
      info = await adapterAny.requestAdapterInfo();
    } catch {
      info = adapterAny.info ?? info;
    }
  } else if (adapterAny.info) {
    info = adapterAny.info;
  }
  const vendor = info.vendor?.toLowerCase() ?? "";
  const architecture = info.architecture?.toLowerCase() ?? "";
  const device = info.device?.toLowerCase() ?? "";
  const description = info.description?.toLowerCase() ?? "";
  const isSoftwareRenderer = vendor.includes("google") && (architecture.includes("swiftshader") || device.includes("swiftshader")) || description.includes("swiftshader") || description.includes("llvmpipe") || description.includes("software") || vendor.includes("mesa") && description.includes("llvmpipe") || description.includes("angle") && description.includes("swiftshader");
  const supportsMappedAtCreation = !isSoftwareRenderer;
  const supportsCompute = true;
  const maxTextureSize = isSoftwareRenderer ? 2048 : adapter.limits.maxTextureDimension2D;
  cachedCapabilities = {
    isSoftwareRenderer,
    vendor: info.vendor ?? "unknown",
    architecture: info.architecture ?? "unknown",
    device: info.device ?? "unknown",
    description: info.description ?? "unknown",
    supportsMappedAtCreation,
    supportsCompute,
    maxTextureSize,
    useReducedQuality: isSoftwareRenderer
  };
  if (isSoftwareRenderer) {
    console.warn("RendererCapabilities: Software renderer detected. Some features will be disabled for compatibility.");
    console.log("RendererCapabilities: Adapter info:", {
      vendor: cachedCapabilities.vendor,
      device: cachedCapabilities.device,
      description: cachedCapabilities.description
    });
  }
  return cachedCapabilities;
}
function getRendererCapabilities() {
  return cachedCapabilities;
}
function isSoftwareRenderingMode(config) {
  if (config?.forceSoftwareMode) {
    return true;
  }
  return cachedCapabilities?.isSoftwareRenderer ?? false;
}
function getEffectiveSoftwareConfig(userConfig) {
  const isSoftware = isSoftwareRenderingMode(userConfig);
  if (!isSoftware) {
    return {};
  }
  return {
    ...DEFAULT_SOFTWARE_RENDERING_CONFIG,
    ...userConfig
  };
}
function createBufferWithData(device, data, usage, label) {
  const capabilities = getRendererCapabilities();
  const alignedSize = Math.ceil(data.byteLength / 4) * 4;
  if (capabilities?.isSoftwareRenderer) {
    const buffer = device.createBuffer({
      label,
      size: alignedSize,
      usage: usage | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(buffer, 0, data.buffer, data.byteOffset, data.byteLength);
    return buffer;
  } else {
    const buffer = device.createBuffer({
      label,
      size: alignedSize,
      usage,
      mappedAtCreation: true
    });
    if (data instanceof Float32Array) {
      new Float32Array(buffer.getMappedRange()).set(data);
    } else if (data instanceof Uint32Array) {
      new Uint32Array(buffer.getMappedRange()).set(data);
    } else if (data instanceof Int32Array) {
      new Int32Array(buffer.getMappedRange()).set(data);
    } else if (data instanceof Uint16Array) {
      new Uint16Array(buffer.getMappedRange()).set(data);
    }
    buffer.unmap();
    return buffer;
  }
}

// ../../src/core/utils/WebGPUUtils.ts
function createShaderModuleSafe(device, descriptor) {
  const module = device.createShaderModule(descriptor);
  const capabilities = getRendererCapabilities();
  if (capabilities?.isSoftwareRenderer) {
    return module;
  }
  if (module.getCompilationInfo) {
    module.getCompilationInfo().then((info) => {
      if (info.messages.length > 0) {
        const errors = info.messages.filter((m) => m.type === "error");
        const warnings = info.messages.filter((m) => m.type === "warning");
        if (errors.length > 0 || warnings.length > 0) {
          ErrorOverlay.getInstance().reportShaderIssues(descriptor.label || "Unknown Shader", descriptor.code, info.messages);
        }
      }
    }).catch((err) => {
      console.error("Failed to get shader compilation info:", err);
      ErrorOverlay.getInstance().reportError("Failed to get shader compilation info: " + err.message, "Internal Error");
    });
  }
  return module;
}

// ../../src/core/Texture.ts
class Texture {
  gpuTexture = null;
  view = null;
  sampler = null;
  label;
  srgb = false;
  premultiplyAlpha = false;
  constructor(label = "Texture", options) {
    this.label = label;
    if (options) {
      this.srgb = options.srgb ?? false;
      this.premultiplyAlpha = options.premultiplyAlpha ?? false;
    }
  }
  async load(device, url) {
    try {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`Failed to fetch texture: ${response.status} ${response.statusText}`);
      }
      const blob = await response.blob();
      const imgBitmap = await createImageBitmap(blob);
      this.createFromImageBitmap(device, imgBitmap);
    } catch (e) {
      console.error(`Failed to load texture: ${url}`, e);
      throw e;
    }
  }
  static fromGPUTexture(device, gpuTexture, label = "GPU Texture") {
    const texture = new Texture(label);
    texture.gpuTexture = gpuTexture;
    texture.view = gpuTexture.createView();
    texture.sampler = device.createSampler({
      magFilter: "linear",
      minFilter: "linear",
      addressModeU: "repeat",
      addressModeV: "repeat"
    });
    return texture;
  }
  createFromImageBitmap(device, imgBitmap) {
    const mipLevelCount = Math.floor(Math.log2(Math.max(imgBitmap.width, imgBitmap.height))) + 1;
    const format = this.srgb ? "rgba8unorm-srgb" : "rgba8unorm";
    this.gpuTexture = device.createTexture({
      label: this.label,
      size: [imgBitmap.width, imgBitmap.height, 1],
      format,
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,
      mipLevelCount
    });
    device.queue.copyExternalImageToTexture({ source: imgBitmap, flipY: false }, { texture: this.gpuTexture, premultipliedAlpha: this.premultiplyAlpha }, [imgBitmap.width, imgBitmap.height]);
    if (mipLevelCount > 1) {
      Texture.generateMipmaps(device, this.gpuTexture, mipLevelCount);
    }
    this.view = this.gpuTexture.createView();
    this.sampler = device.createSampler({
      magFilter: "linear",
      minFilter: "linear",
      mipmapFilter: "linear",
      addressModeU: "repeat",
      addressModeV: "repeat",
      maxAnisotropy: 4
    });
  }
  static generateMipmaps(device, texture, mipLevelCount) {
    const pipeline = Texture.getMipmapPipeline(device, texture.format);
    const commandEncoder = device.createCommandEncoder({ label: "Mipmap Gen" });
    let width = texture.width;
    let height = texture.height;
    for (let i = 1;i < mipLevelCount; i++) {
      const dstWidth = Math.max(1, Math.floor(width / 2));
      const dstHeight = Math.max(1, Math.floor(height / 2));
      const bindGroup = device.createBindGroup({
        layout: pipeline.getBindGroupLayout(0),
        entries: [
          { binding: 0, resource: device.createSampler({ minFilter: "linear" }) },
          { binding: 1, resource: texture.createView({ baseMipLevel: i - 1, mipLevelCount: 1 }) }
        ]
      });
      const pass = commandEncoder.beginRenderPass({
        colorAttachments: [{
          view: texture.createView({ baseMipLevel: i, mipLevelCount: 1 }),
          loadOp: "clear",
          storeOp: "store"
        }]
      });
      pass.setPipeline(pipeline);
      pass.setBindGroup(0, bindGroup);
      pass.draw(3);
      pass.end();
      width = dstWidth;
      height = dstHeight;
    }
    device.queue.submit([commandEncoder.finish()]);
  }
  static mipmapPipelineCache = new WeakMap;
  static getMipmapPipeline(device, format) {
    let deviceCache = this.mipmapPipelineCache.get(device);
    if (!deviceCache) {
      deviceCache = new Map;
      this.mipmapPipelineCache.set(device, deviceCache);
    }
    if (deviceCache.has(format)) {
      return deviceCache.get(format);
    }
    const module2 = createShaderModuleSafe(device, {
      code: `
            struct VertexOutput {
                @builtin(position) position : vec4f,
                @location(0) uv : vec2f,
            }

            @vertex
            fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                var output : VertexOutput;
                let pos = array(
                  vec2f(-1.0, -1.0),
                  vec2f( 3.0, -1.0),
                  vec2f(-1.0,  3.0)
                );
                let p = pos[vertexIndex];
                output.position = vec4f(p, 0.0, 1.0);
                output.uv = p * 0.5 + 0.5;
                output.uv.y = 1.0 - output.uv.y; 
                return output;
            }

            @group(0) @binding(0) var samp : sampler;
            @group(0) @binding(1) var img : texture_2d<f32>;

            @fragment
            fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {
                return textureSample(img, samp, uv);
            }
          `
    });
    const pipeline = device.createRenderPipeline({
      layout: "auto",
      vertex: {
        module: module2,
        entryPoint: "vs_main"
      },
      fragment: {
        module: module2,
        entryPoint: "fs_main",
        targets: [{ format }]
      },
      primitive: { topology: "triangle-list" }
    });
    deviceCache.set(format, pipeline);
    return pipeline;
  }
  static _defaultTextures = new WeakMap;
  static getDefault(device) {
    if (!Texture._defaultTextures.has(device)) {
      const texture = new Texture("Default White Texture");
      texture.gpuTexture = device.createTexture({
        label: "Default White Texture",
        size: [1, 1, 1],
        format: "rgba8unorm",
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
      });
      const data = new Uint8Array([255, 255, 255, 255]);
      device.queue.writeTexture({ texture: texture.gpuTexture }, data, { bytesPerRow: 4, rowsPerImage: 1 }, [1, 1, 1]);
      texture.view = texture.gpuTexture.createView();
      texture.sampler = device.createSampler({
        magFilter: "linear",
        minFilter: "linear"
      });
      Texture._defaultTextures.set(device, texture);
    }
    return Texture._defaultTextures.get(device);
  }
}

// ../../src/core/debug/panels/UIInspectorPanel.ts
class UIInspectorPanel extends Panel {
  selectedElement = null;
  contentContainer;
  codeFormatSelect;
  currentFormat = "jsx";
  device = null;
  constructor() {
    super("UI Inspector", { defaultOpen: false });
    const formatSection = document.createElement("div");
    formatSection.style.marginBottom = "8px";
    formatSection.style.display = "flex";
    formatSection.style.alignItems = "center";
    formatSection.style.gap = "8px";
    const formatLabel = document.createElement("span");
    formatLabel.innerText = "Format:";
    formatLabel.style.fontSize = "10px";
    formatSection.appendChild(formatLabel);
    this.codeFormatSelect = document.createElement("select");
    this.codeFormatSelect.style.fontSize = "10px";
    this.codeFormatSelect.style.padding = "2px 4px";
    this.codeFormatSelect.style.backgroundColor = "#222";
    this.codeFormatSelect.style.color = "#fff";
    this.codeFormatSelect.style.border = "1px solid #555";
    this.codeFormatSelect.style.borderRadius = "3px";
    const formats = [
      { value: "jsx", label: "JSX" },
      { value: "yaml", label: "YAML" },
      { value: "typescript", label: "TypeScript" }
    ];
    formats.forEach(({ value, label }) => {
      const option = document.createElement("option");
      option.value = value;
      option.innerText = label;
      this.codeFormatSelect.appendChild(option);
    });
    this.codeFormatSelect.onchange = () => {
      this.currentFormat = this.codeFormatSelect.value;
    };
    formatSection.appendChild(this.codeFormatSelect);
    this.content.appendChild(formatSection);
    this.contentContainer = document.createElement("div");
    this.content.appendChild(this.contentContainer);
  }
  setDevice(device) {
    this.device = device;
  }
  setSelectedElement(element) {
    this.selectedElement = element;
    this.rebuildContent();
  }
  rebuildContent() {
    this.contentContainer.innerHTML = "";
    if (!this.selectedElement) {
      const emptyMsg = document.createElement("div");
      emptyMsg.innerHTML = '<i style="color: #888;">No UI element selected</i>';
      emptyMsg.style.fontSize = "10px";
      this.contentContainer.appendChild(emptyMsg);
      return;
    }
    const element = this.selectedElement;
    const nameHeader = document.createElement("div");
    nameHeader.style.fontWeight = "bold";
    nameHeader.style.marginBottom = "8px";
    nameHeader.style.padding = "4px";
    nameHeader.style.backgroundColor = "rgba(255, 100, 100, 0.1)";
    nameHeader.style.borderRadius = "3px";
    nameHeader.style.border = "1px solid rgba(255, 100, 100, 0.3)";
    nameHeader.innerText = element.name || element.id || "Unnamed Element";
    this.contentContainer.appendChild(nameHeader);
    this.createSection("Type", () => {
      const typeSpan = document.createElement("span");
      typeSpan.style.fontSize = "10px";
      typeSpan.style.color = "#aaa";
      typeSpan.innerText = element.constructor.name;
      return typeSpan;
    });
    this.createSection("Position", () => {
      const container = document.createElement("div");
      container.style.display = "flex";
      container.style.gap = "8px";
      container.style.alignItems = "center";
      const xLabel = document.createElement("span");
      xLabel.innerText = "X:";
      xLabel.style.color = "#ff6666";
      xLabel.style.fontSize = "10px";
      container.appendChild(xLabel);
      const xInput = this.createNumberInput(this.parseStyleValue(element.style.x), (v) => {
        element.style.x = v;
        element.markDirty();
      });
      container.appendChild(xInput);
      const yLabel = document.createElement("span");
      yLabel.innerText = "Y:";
      yLabel.style.color = "#66ff66";
      yLabel.style.fontSize = "10px";
      container.appendChild(yLabel);
      const yInput = this.createNumberInput(this.parseStyleValue(element.style.y), (v) => {
        element.style.y = v;
        element.markDirty();
      });
      container.appendChild(yInput);
      return container;
    });
    this.createSection("Size", () => {
      const container = document.createElement("div");
      container.style.display = "flex";
      container.style.gap = "8px";
      container.style.alignItems = "center";
      const wLabel = document.createElement("span");
      wLabel.innerText = "W:";
      wLabel.style.color = "#6666ff";
      wLabel.style.fontSize = "10px";
      container.appendChild(wLabel);
      const wInput = this.createNumberInput(this.parseStyleValue(element.style.width), (v) => {
        element.style.width = v;
        element.markDirty();
      });
      container.appendChild(wInput);
      const hLabel = document.createElement("span");
      hLabel.innerText = "H:";
      hLabel.style.color = "#ff66ff";
      hLabel.style.fontSize = "10px";
      container.appendChild(hLabel);
      const hInput = this.createNumberInput(this.parseStyleValue(element.style.height), (v) => {
        element.style.height = v;
        element.markDirty();
      });
      container.appendChild(hInput);
      return container;
    });
    this.createSection("Computed Bounds", () => {
      const bounds = element.bounds;
      const span = document.createElement("span");
      span.style.fontSize = "10px";
      span.style.color = "#888";
      span.innerText = `x: ${bounds.x.toFixed(0)}, y: ${bounds.y.toFixed(0)}, w: ${bounds.width.toFixed(0)}, h: ${bounds.height.toFixed(0)}`;
      return span;
    });
    this.createSection("Visibility", () => {
      const visRow = document.createElement("div");
      visRow.style.display = "flex";
      visRow.style.alignItems = "center";
      visRow.style.gap = "8px";
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.checked = element.visible;
      checkbox.onchange = () => {
        element.visible = checkbox.checked;
      };
      visRow.appendChild(checkbox);
      const label = document.createElement("span");
      label.innerText = "Visible";
      label.style.fontSize = "10px";
      visRow.appendChild(label);
      return visRow;
    });
    this.createSection("Opacity", () => {
      const container = document.createElement("div");
      container.style.display = "flex";
      container.style.alignItems = "center";
      container.style.gap = "8px";
      const slider = document.createElement("input");
      slider.type = "range";
      slider.min = "0";
      slider.max = "1";
      slider.step = "0.05";
      slider.value = (element.style.opacity ?? 1).toString();
      slider.style.width = "80px";
      const valueDisplay = document.createElement("span");
      valueDisplay.innerText = (element.style.opacity ?? 1).toFixed(2);
      valueDisplay.style.fontSize = "10px";
      valueDisplay.style.minWidth = "30px";
      slider.oninput = () => {
        const val = parseFloat(slider.value);
        element.style.opacity = val;
        valueDisplay.innerText = val.toFixed(2);
        element.markDirty();
      };
      container.appendChild(slider);
      container.appendChild(valueDisplay);
      return container;
    });
    if (element instanceof Button) {
      this.createButtonSection(element);
    }
    if (element instanceof Label) {
      this.createLabelSection(element);
    }
    if (element instanceof Image2) {
      this.createImageSection(element);
    }
    if (element instanceof Button && element.style.backgroundImage) {
      this.createButtonImageSection(element);
    }
    const divider = document.createElement("div");
    divider.style.borderTop = "1px solid #444";
    divider.style.margin = "8px 0";
    this.contentContainer.appendChild(divider);
    const copyBtn = createCopyButton("Copy UI Element Code", () => {
      if (!this.selectedElement)
        return "";
      return generateUIElementCode(this.selectedElement, this.currentFormat);
    }, { fullWidth: true });
    this.contentContainer.appendChild(copyBtn);
  }
  createSection(title, buildContent) {
    const section = document.createElement("div");
    section.style.marginBottom = "8px";
    const label = document.createElement("div");
    label.innerText = title;
    label.style.fontWeight = "bold";
    label.style.marginBottom = "4px";
    label.style.fontSize = "10px";
    label.style.color = "#aaa";
    section.appendChild(label);
    section.appendChild(buildContent());
    this.contentContainer.appendChild(section);
  }
  createNumberInput(value, onChange) {
    const input = document.createElement("input");
    input.type = "number";
    input.value = value.toString();
    input.style.width = "50px";
    input.style.fontSize = "10px";
    input.style.padding = "2px 4px";
    input.style.backgroundColor = "#222";
    input.style.color = "#fff";
    input.style.border = "1px solid #555";
    input.style.borderRadius = "3px";
    input.onchange = () => {
      const val = parseFloat(input.value) || 0;
      onChange(val);
    };
    return input;
  }
  parseStyleValue(value) {
    if (value === undefined)
      return 0;
    if (typeof value === "number")
      return value;
    if (typeof value === "string" && value.endsWith("%")) {
      return parseFloat(value) || 0;
    }
    return 0;
  }
  createButtonSection(button) {
    this.createSection("Button Text", () => {
      const container = document.createElement("div");
      const textInput = document.createElement("input");
      textInput.type = "text";
      textInput.value = button.text;
      textInput.style.width = "100%";
      textInput.style.fontSize = "10px";
      textInput.style.padding = "4px";
      textInput.style.backgroundColor = "#222";
      textInput.style.color = "#fff";
      textInput.style.border = "1px solid #555";
      textInput.style.borderRadius = "3px";
      textInput.style.boxSizing = "border-box";
      textInput.oninput = () => {
        button.text = textInput.value;
      };
      container.appendChild(textInput);
      return container;
    });
  }
  createLabelSection(label) {
    this.createSection("Label Text", () => {
      const container = document.createElement("div");
      const textArea = document.createElement("textarea");
      textArea.value = label.text;
      textArea.style.width = "100%";
      textArea.style.height = "60px";
      textArea.style.fontSize = "10px";
      textArea.style.padding = "4px";
      textArea.style.backgroundColor = "#222";
      textArea.style.color = "#fff";
      textArea.style.border = "1px solid #555";
      textArea.style.borderRadius = "3px";
      textArea.style.boxSizing = "border-box";
      textArea.style.resize = "vertical";
      textArea.oninput = () => {
        label.text = textArea.value;
      };
      container.appendChild(textArea);
      return container;
    });
    this.createSection("Font Size", () => {
      const container = document.createElement("div");
      container.style.display = "flex";
      container.style.alignItems = "center";
      container.style.gap = "8px";
      const input = this.createNumberInput(label.style.fontSize ?? 16, (v) => {
        label.style.fontSize = v;
        label.markDirty();
      });
      input.style.width = "60px";
      container.appendChild(input);
      const px = document.createElement("span");
      px.innerText = "px";
      px.style.fontSize = "10px";
      px.style.color = "#888";
      container.appendChild(px);
      return container;
    });
    this.createSection("Color", () => {
      const container = document.createElement("div");
      container.style.display = "flex";
      container.style.alignItems = "center";
      container.style.gap = "8px";
      const colorInput = document.createElement("input");
      colorInput.type = "color";
      colorInput.value = label.style.color || "#ffffff";
      colorInput.style.width = "40px";
      colorInput.style.height = "25px";
      colorInput.style.border = "none";
      colorInput.style.cursor = "pointer";
      colorInput.oninput = () => {
        label.style.color = colorInput.value;
        label.markDirty();
      };
      container.appendChild(colorInput);
      const hexDisplay = document.createElement("span");
      hexDisplay.innerText = colorInput.value;
      hexDisplay.style.fontSize = "10px";
      hexDisplay.style.color = "#888";
      container.appendChild(hexDisplay);
      colorInput.oninput = () => {
        label.style.color = colorInput.value;
        hexDisplay.innerText = colorInput.value;
        label.markDirty();
      };
      return container;
    });
  }
  createImageSection(image) {
    this.createSection("Image Source", () => {
      const container = document.createElement("div");
      const info = document.createElement("div");
      info.style.fontSize = "10px";
      info.style.color = "#888";
      info.style.marginBottom = "4px";
      if (image.gpuTexture) {
        info.innerText = `${image.sourceWidth} x ${image.sourceHeight}`;
      } else {
        info.innerText = "No texture loaded";
      }
      container.appendChild(info);
      const fileLabel = document.createElement("label");
      fileLabel.style.display = "inline-block";
      fileLabel.style.padding = "4px 8px";
      fileLabel.style.backgroundColor = "#333";
      fileLabel.style.color = "#fff";
      fileLabel.style.fontSize = "10px";
      fileLabel.style.borderRadius = "3px";
      fileLabel.style.cursor = "pointer";
      fileLabel.style.border = "1px solid #555";
      fileLabel.innerText = "Load Image...";
      const fileInput = document.createElement("input");
      fileInput.type = "file";
      fileInput.accept = "image/*";
      fileInput.style.display = "none";
      fileInput.onchange = async () => {
        if (fileInput.files && fileInput.files[0]) {
          const file = fileInput.files[0];
          await this.loadImageFromFile(file, image);
          info.innerText = `${image.sourceWidth} x ${image.sourceHeight}`;
        }
      };
      fileLabel.appendChild(fileInput);
      container.appendChild(fileLabel);
      return container;
    });
    this.createSection("Scale Mode", () => {
      const select = document.createElement("select");
      select.style.fontSize = "10px";
      select.style.padding = "2px 4px";
      select.style.backgroundColor = "#222";
      select.style.color = "#fff";
      select.style.border = "1px solid #555";
      select.style.borderRadius = "3px";
      const modes = ["stretch", "contain", "cover", "none"];
      modes.forEach((mode) => {
        const option = document.createElement("option");
        option.value = mode;
        option.innerText = mode;
        option.selected = image.style.scaleMode === mode;
        select.appendChild(option);
      });
      select.onchange = () => {
        image.style.scaleMode = select.value;
        image.markDirty();
      };
      return select;
    });
  }
  createButtonImageSection(button) {
    this.createSection("Background Image", () => {
      const container = document.createElement("div");
      const currentTexture = button.style.backgroundImage;
      const info = document.createElement("div");
      info.style.fontSize = "10px";
      info.style.color = "#888";
      info.style.marginBottom = "4px";
      if (currentTexture?.gpuTexture) {
        info.innerText = `${currentTexture.gpuTexture.width} x ${currentTexture.gpuTexture.height}`;
      } else {
        info.innerText = "No background image";
      }
      container.appendChild(info);
      const fileLabel = document.createElement("label");
      fileLabel.style.display = "inline-block";
      fileLabel.style.padding = "4px 8px";
      fileLabel.style.backgroundColor = "#333";
      fileLabel.style.color = "#fff";
      fileLabel.style.fontSize = "10px";
      fileLabel.style.borderRadius = "3px";
      fileLabel.style.cursor = "pointer";
      fileLabel.style.border = "1px solid #555";
      fileLabel.innerText = "Load Background...";
      const fileInput = document.createElement("input");
      fileInput.type = "file";
      fileInput.accept = "image/*";
      fileInput.style.display = "none";
      fileInput.onchange = async () => {
        if (fileInput.files && fileInput.files[0] && this.device) {
          const file = fileInput.files[0];
          const texture = await this.loadTextureFromFile(file);
          if (texture) {
            button.style.backgroundImage = texture;
            info.innerText = `${texture.gpuTexture?.width ?? 0} x ${texture.gpuTexture?.height ?? 0}`;
            button.markDirty();
          }
        }
      };
      fileLabel.appendChild(fileInput);
      container.appendChild(fileLabel);
      return container;
    });
  }
  async loadImageFromFile(file, image) {
    if (!this.device)
      return;
    const texture = await this.loadTextureFromFile(file);
    if (texture) {
      image.setTexture(texture);
    }
  }
  async loadTextureFromFile(file) {
    if (!this.device)
      return null;
    try {
      const blob = new Blob([await file.arrayBuffer()], { type: file.type });
      const imgBitmap = await createImageBitmap(blob);
      const texture = new Texture(file.name);
      texture.createFromImageBitmap(this.device, imgBitmap);
      return texture;
    } catch (e) {
      console.error("Failed to load texture from file:", e);
      return null;
    }
  }
  update() {}
}

// ../../src/core/debug/UISelectionRenderer.ts
class UISelectionRenderer {
  overlayElement = null;
  selectedElement = null;
  canvas = null;
  constructor() {}
  init(canvas) {
    this.canvas = canvas;
    this.overlayElement = document.createElement("div");
    this.overlayElement.style.position = "absolute";
    this.overlayElement.style.pointerEvents = "none";
    this.overlayElement.style.border = "2px solid #ff4444";
    this.overlayElement.style.boxShadow = "0 0 4px rgba(255, 68, 68, 0.5), inset 0 0 4px rgba(255, 68, 68, 0.3)";
    this.overlayElement.style.backgroundColor = "rgba(255, 68, 68, 0.1)";
    this.overlayElement.style.display = "none";
    this.overlayElement.style.zIndex = "999";
    const label = document.createElement("div");
    label.className = "ui-selection-label";
    label.style.position = "absolute";
    label.style.top = "-20px";
    label.style.left = "0";
    label.style.backgroundColor = "#ff4444";
    label.style.color = "white";
    label.style.padding = "2px 6px";
    label.style.fontSize = "10px";
    label.style.fontFamily = "monospace";
    label.style.whiteSpace = "nowrap";
    label.style.borderRadius = "2px 2px 0 0";
    this.overlayElement.appendChild(label);
    if (canvas.parentElement) {
      canvas.parentElement.style.position = "relative";
      canvas.parentElement.appendChild(this.overlayElement);
    }
  }
  setSelectedElement(element) {
    this.selectedElement = element;
    this.updateOverlay();
  }
  getSelectedElement() {
    return this.selectedElement;
  }
  update() {
    this.updateOverlay();
  }
  updateOverlay() {
    if (!this.overlayElement || !this.canvas)
      return;
    if (!this.selectedElement || !this.selectedElement.visible) {
      this.overlayElement.style.display = "none";
      return;
    }
    const bounds = this.selectedElement.bounds;
    const canvasRect = this.canvas.getBoundingClientRect();
    const scaleX = canvasRect.width / this.canvas.width;
    const scaleY = canvasRect.height / this.canvas.height;
    this.overlayElement.style.display = "block";
    this.overlayElement.style.left = `${bounds.x * scaleX}px`;
    this.overlayElement.style.top = `${bounds.y * scaleY}px`;
    this.overlayElement.style.width = `${bounds.width * scaleX}px`;
    this.overlayElement.style.height = `${bounds.height * scaleY}px`;
    const label = this.overlayElement.querySelector(".ui-selection-label");
    if (label) {
      const typeName = this.selectedElement.constructor.name;
      const name = this.selectedElement.name || this.selectedElement.id || "unnamed";
      label.innerText = `${typeName}: ${name}`;
    }
  }
  cleanup() {
    if (this.overlayElement && this.overlayElement.parentElement) {
      this.overlayElement.parentElement.removeChild(this.overlayElement);
    }
    this.overlayElement = null;
    this.selectedElement = null;
    this.canvas = null;
  }
}

// ../../src/core/debug/utils/cameraFocus.ts
var currentAnimation = null;
function calculateFocusPosition(node, camera) {
  let center = node.transform.position.clone();
  let size = 2;
  if (node instanceof Mesh && node.geometry?.aabb) {
    const aabb = node.geometry.aabb;
    const worldMatrix = node.transform.worldMatrix;
    const corners = [
      new Vector3(aabb.min.x, aabb.min.y, aabb.min.z),
      new Vector3(aabb.max.x, aabb.min.y, aabb.min.z),
      new Vector3(aabb.min.x, aabb.max.y, aabb.min.z),
      new Vector3(aabb.max.x, aabb.max.y, aabb.min.z),
      new Vector3(aabb.min.x, aabb.min.y, aabb.max.z),
      new Vector3(aabb.max.x, aabb.min.y, aabb.max.z),
      new Vector3(aabb.min.x, aabb.max.y, aabb.max.z),
      new Vector3(aabb.max.x, aabb.max.y, aabb.max.z)
    ];
    const worldMin = new Vector3(Infinity, Infinity, Infinity);
    const worldMax = new Vector3(-Infinity, -Infinity, -Infinity);
    for (const corner of corners) {
      const worldCorner = worldMatrix.transformVector(corner);
      worldMin.x = Math.min(worldMin.x, worldCorner.x);
      worldMin.y = Math.min(worldMin.y, worldCorner.y);
      worldMin.z = Math.min(worldMin.z, worldCorner.z);
      worldMax.x = Math.max(worldMax.x, worldCorner.x);
      worldMax.y = Math.max(worldMax.y, worldCorner.y);
      worldMax.z = Math.max(worldMax.z, worldCorner.z);
    }
    center = new Vector3((worldMin.x + worldMax.x) / 2, (worldMin.y + worldMax.y) / 2, (worldMin.z + worldMax.z) / 2);
    size = Math.max(worldMax.x - worldMin.x, worldMax.y - worldMin.y, worldMax.z - worldMin.z);
  }
  const fovRad = camera.fov;
  const screenFraction = 0.4;
  const distance = size / (2 * Math.tan(fovRad / 2) * screenFraction);
  const minDistance = size * 1.5;
  const finalDistance = Math.max(distance, minDistance);
  const elevationAngle = 30 * Math.PI / 180;
  const azimuthAngle = 45 * Math.PI / 180;
  const offsetX = finalDistance * Math.cos(elevationAngle) * Math.cos(azimuthAngle);
  const offsetY = finalDistance * Math.sin(elevationAngle);
  const offsetZ = finalDistance * Math.cos(elevationAngle) * Math.sin(azimuthAngle);
  const targetPosition = new Vector3(center.x + offsetX, center.y + offsetY, center.z + offsetZ);
  return { position: targetPosition, lookAt: center };
}
function focusOnNode(node, camera, duration = 400) {
  const { position: targetPosition, lookAt } = calculateFocusPosition(node, camera);
  currentAnimation = {
    isAnimating: true,
    startPosition: camera.transform.position.clone(),
    targetPosition,
    lookAtTarget: lookAt,
    startTime: performance.now(),
    duration
  };
}
function updateCameraFocus(camera) {
  if (!currentAnimation || !currentAnimation.isAnimating) {
    return false;
  }
  const elapsed = performance.now() - currentAnimation.startTime;
  let t = Math.min(elapsed / currentAnimation.duration, 1);
  t = 1 - Math.pow(1 - t, 3);
  const newPos = currentAnimation.startPosition.lerp(currentAnimation.targetPosition, t);
  camera.transform.position.x = newPos.x;
  camera.transform.position.y = newPos.y;
  camera.transform.position.z = newPos.z;
  const up = new Vector3(0, 1, 0);
  camera.viewMatrix = new Matrix4().lookAt(newPos, currentAnimation.lookAtTarget, up);
  if (t >= 1) {
    currentAnimation.isAnimating = false;
    currentAnimation = null;
    return false;
  }
  return true;
}
function cancelCameraFocus() {
  if (currentAnimation) {
    currentAnimation.isAnimating = false;
    currentAnimation = null;
  }
}

// ../../src/core/debug/Debugger.ts
class Debugger {
  element;
  header;
  content;
  performancePanel;
  cameraPanel;
  scenePanel;
  inspectorPanel;
  renderSettingsPanel;
  lightsPanel;
  uiHierarchyPanel;
  uiInspectorPanel;
  uiSelectionRenderer;
  expanded = false;
  visible = true;
  camera = null;
  selectedNode = null;
  selectedUIElement = null;
  _uiManager = null;
  lastTime = 0;
  frames = 0;
  fps = 0;
  keydownHandler;
  constructor(parent = null, options = {}) {
    const {
      defaultOpen = false,
      position = "top-right",
      panels = ["performance", "camera", "scene", "inspector", "lights", "renderSettings", "uiHierarchy", "uiInspector"],
      visible
    } = options;
    this.expanded = defaultOpen;
    const hideViaEnv = typeof ({ env: {}, url: "" }) !== "undefined" && ({ env: {}, url: "" }).env?.VITE_HIDE_DEBUG_OVERLAY === "true";
    this.visible = visible !== undefined ? visible : !hideViaEnv;
    this.element = document.createElement("div");
    this.element.style.position = "absolute";
    this.element.style.color = "white";
    this.element.style.backgroundColor = "rgba(0, 0, 0, 0.85)";
    this.element.style.padding = "6px";
    this.element.style.fontFamily = "monospace";
    this.element.style.fontSize = "12px";
    this.element.style.zIndex = "1000";
    this.element.style.borderRadius = "6px";
    this.element.style.minWidth = "160px";
    this.element.style.maxWidth = "280px";
    this.element.style.userSelect = "none";
    this.element.style.maxHeight = "90vh";
    this.element.style.overflowY = "auto";
    this.element.style.boxShadow = "0 2px 10px rgba(0, 0, 0, 0.5)";
    this.element.style.display = this.visible ? "block" : "none";
    this.setPosition(position);
    this.header = document.createElement("div");
    this.header.style.cursor = "pointer";
    this.header.style.display = "flex";
    this.header.style.justifyContent = "space-between";
    this.header.style.alignItems = "center";
    this.header.style.padding = "2px 0";
    this.header.onclick = () => this.toggle();
    this.element.appendChild(this.header);
    this.content = document.createElement("div");
    this.content.style.display = defaultOpen ? "block" : "none";
    this.content.style.marginTop = "5px";
    this.element.appendChild(this.content);
    this.performancePanel = new PerformancePanel;
    this.cameraPanel = new CameraPanel;
    this.scenePanel = new ScenePanel({
      onSelectNode: (node) => this.handleNodeSelection(node),
      onFocusNode: (node) => this.handleFocusNode(node)
    });
    this.inspectorPanel = new InspectorPanel;
    this.renderSettingsPanel = new RenderSettingsPanel;
    this.lightsPanel = new LightsPanel({
      onSelectLight: (light) => this.handleNodeSelection(light)
    });
    this.uiHierarchyPanel = new UIHierarchyPanel({
      onSelectElement: (element) => this.handleUIElementSelection(element)
    });
    this.uiInspectorPanel = new UIInspectorPanel;
    this.uiSelectionRenderer = new UISelectionRenderer;
    if (panels.includes("performance")) {
      this.content.appendChild(this.performancePanel.getElement());
    }
    if (panels.includes("camera")) {
      this.content.appendChild(this.cameraPanel.getElement());
    }
    if (panels.includes("scene")) {
      this.content.appendChild(this.scenePanel.getElement());
    }
    if (panels.includes("inspector")) {
      this.content.appendChild(this.inspectorPanel.getElement());
    }
    if (panels.includes("lights")) {
      this.content.appendChild(this.lightsPanel.getElement());
    }
    if (panels.includes("renderSettings")) {
      this.content.appendChild(this.renderSettingsPanel.getElement());
    }
    if (panels.includes("uiHierarchy")) {
      this.content.appendChild(this.uiHierarchyPanel.getElement());
    }
    if (panels.includes("uiInspector")) {
      this.content.appendChild(this.uiInspectorPanel.getElement());
    }
    const hint = document.createElement("div");
    hint.style.fontSize = "9px";
    hint.style.color = "#666";
    hint.style.marginTop = "8px";
    hint.style.textAlign = "center";
    hint.innerText = "Press ` or F3 to toggle";
    this.content.appendChild(hint);
    if (parent) {
      parent.appendChild(this.element);
    } else {
      document.body.appendChild(this.element);
    }
    this.keydownHandler = (e) => {
      if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) {
        return;
      }
      if (e.key === "`" || e.key === "F3") {
        e.preventDefault();
        this.toggle();
      }
    };
    document.addEventListener("keydown", this.keydownHandler);
    this.updateHeader();
  }
  setPosition(position) {
    this.element.style.top = "";
    this.element.style.bottom = "";
    this.element.style.left = "";
    this.element.style.right = "";
    switch (position) {
      case "top-right":
        this.element.style.top = "10px";
        this.element.style.right = "10px";
        break;
      case "top-left":
        this.element.style.top = "10px";
        this.element.style.left = "10px";
        break;
      case "bottom-right":
        this.element.style.bottom = "10px";
        this.element.style.right = "10px";
        break;
      case "bottom-left":
        this.element.style.bottom = "10px";
        this.element.style.left = "10px";
        break;
    }
  }
  toggle() {
    this.expanded = !this.expanded;
    this.content.style.display = this.expanded ? "block" : "none";
    this.updateHeader();
  }
  setOpen(open) {
    this.expanded = open;
    this.content.style.display = open ? "block" : "none";
    this.updateHeader();
  }
  isOpen() {
    return this.expanded;
  }
  setVisible(visible) {
    this.visible = visible;
    this.element.style.display = visible ? "block" : "none";
  }
  isVisible() {
    return this.visible;
  }
  registerScene(scene) {
    this.scenePanel.setScene(scene);
    this.lightsPanel.setScene(scene);
    this.renderSettingsPanel.setScene(scene);
  }
  registerCamera(camera) {
    this.camera = camera;
    this.cameraPanel.setCamera(camera);
  }
  registerUIManager(uiManager) {
    this.handleUIElementSelection(null);
    this._uiManager = uiManager;
    this.uiHierarchyPanel.setUIManager(uiManager);
  }
  registerCanvas(canvas, device) {
    this.uiSelectionRenderer.init(canvas);
    if (device) {
      this.uiInspectorPanel.setDevice(device);
    }
  }
  setGpuStats(draws, triangles) {
    this.performancePanel.setGpuStats(draws, triangles);
  }
  setFrameTriangles(count) {
    this.performancePanel.setFrameTriangles(count);
  }
  setSceneTriangles(count) {
    this.performancePanel.setSceneTriangles(count);
  }
  update(time) {
    this.frames++;
    if (time >= this.lastTime + 1000) {
      this.fps = Math.round(this.frames * 1000 / (time - this.lastTime));
      this.lastTime = time;
      this.frames = 0;
      this.performancePanel.setFps(this.fps);
      this.updateHeader();
    }
    if (this.camera) {
      updateCameraFocus(this.camera);
    }
    if (this.expanded) {
      this.performancePanel.update();
      this.cameraPanel.update();
      this.inspectorPanel.update();
      this.uiInspectorPanel.update();
    }
    this.uiSelectionRenderer.update();
  }
  updateHeader() {
    const fpsColor = this.fps < 30 ? "#f44" : this.fps < 50 ? "#fa0" : "#4f4";
    this.header.innerHTML = `
      <span>FPS: <span style="color: ${fpsColor}; font-weight: bold;">${this.fps}</span></span>
      <span style="font-size: 10px; color: #888;">${this.expanded ? "▼" : "▶"}</span>
    `;
  }
  handleNodeSelection(node) {
    this.selectedNode = node;
    this.scenePanel.selectNode(node, false);
    this.inspectorPanel.setSelectedNode(node);
    if (node) {
      this.inspectorPanel.setOpen(true);
    }
  }
  handleFocusNode(node) {
    if (!this.camera)
      return;
    cancelCameraFocus();
    focusOnNode(node, this.camera, 400);
  }
  handleUIElementSelection(element) {
    this.selectedUIElement = element;
    this.uiHierarchyPanel.selectElement(element, false);
    this.uiInspectorPanel.setSelectedElement(element);
    this.uiSelectionRenderer.setSelectedElement(element);
    if (element) {
      this.uiInspectorPanel.setOpen(true);
    }
  }
  getSelectedNode() {
    return this.selectedNode;
  }
  getSelectedUIElement() {
    return this.selectedUIElement;
  }
  getUIManager() {
    return this._uiManager;
  }
  addSection(title, content) {
    const details = document.createElement("details");
    details.style.marginTop = "8px";
    details.style.borderTop = "1px solid #555";
    details.style.paddingTop = "4px";
    const summary = document.createElement("summary");
    summary.innerText = title;
    summary.style.cursor = "pointer";
    summary.style.fontWeight = "bold";
    summary.style.marginBottom = "4px";
    summary.style.outline = "none";
    details.appendChild(summary);
    details.appendChild(content);
    const hint = this.content.lastElementChild;
    if (hint) {
      this.content.insertBefore(details, hint);
    } else {
      this.content.appendChild(details);
    }
  }
  cleanup() {
    document.removeEventListener("keydown", this.keydownHandler);
    this.uiSelectionRenderer.cleanup();
    if (this.element && this.element.parentNode) {
      this.element.parentNode.removeChild(this.element);
    }
  }
}
// ../../src/core/debug/SelectionRenderer.ts
class SelectionRenderer {
  device = null;
  pipeline = null;
  vertexBuffer = null;
  uniformBuffer = null;
  bindGroup = null;
  bindGroupLayout = null;
  selectedNode = null;
  static BOX_VERTICES = new Float32Array([
    -1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    -1,
    1,
    1,
    -1,
    1,
    1,
    1,
    1,
    1,
    1,
    -1,
    1,
    1,
    -1,
    1,
    1,
    -1,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    1
  ]);
  shaderCode = `
    struct Uniforms {
      mvp: mat4x4<f32>,
      color: vec4<f32>,
    }

    @group(0) @binding(0) var<uniform> uniforms: Uniforms;

    struct VertexOutput {
      @builtin(position) position: vec4<f32>,
    }

    @vertex
    fn vs_main(@location(0) position: vec3<f32>) -> VertexOutput {
      var output: VertexOutput;
      output.position = uniforms.mvp * vec4<f32>(position, 1.0);
      return output;
    }

    @fragment
    fn fs_main() -> @location(0) vec4<f32> {
      return uniforms.color;
    }
  `;
  init(device) {
    this.device = device;
    this.vertexBuffer = device.createBuffer({
      size: SelectionRenderer.BOX_VERTICES.byteLength,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(this.vertexBuffer, 0, SelectionRenderer.BOX_VERTICES);
    this.uniformBuffer = device.createBuffer({
      size: 256,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.bindGroupLayout = device.createBindGroupLayout({
      entries: [
        {
          binding: 0,
          visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
          buffer: { type: "uniform" }
        }
      ]
    });
    this.bindGroup = device.createBindGroup({
      layout: this.bindGroupLayout,
      entries: [
        { binding: 0, resource: { buffer: this.uniformBuffer } }
      ]
    });
    const shaderModule = device.createShaderModule({
      code: this.shaderCode
    });
    this.pipeline = device.createRenderPipeline({
      layout: device.createPipelineLayout({
        bindGroupLayouts: [this.bindGroupLayout]
      }),
      vertex: {
        module: shaderModule,
        entryPoint: "vs_main",
        buffers: [
          {
            arrayStride: 12,
            attributes: [
              { shaderLocation: 0, offset: 0, format: "float32x3" }
            ]
          }
        ]
      },
      fragment: {
        module: shaderModule,
        entryPoint: "fs_main",
        targets: [{ format: navigator.gpu.getPreferredCanvasFormat() }]
      },
      primitive: {
        topology: "line-list"
      },
      depthStencil: {
        format: "depth24plus",
        depthWriteEnabled: false,
        depthCompare: "less-equal"
      }
    });
  }
  setSelectedNode(node) {
    this.selectedNode = node;
  }
  getSelectedNode() {
    return this.selectedNode;
  }
  render(encoder, colorView, depthView, camera) {
    if (!this.device || !this.pipeline || !this.selectedNode || !this.uniformBuffer || !this.bindGroup) {
      return;
    }
    const localBounds = this.getLocalBounds(this.selectedNode);
    if (!localBounds)
      return;
    const { min, max } = localBounds;
    const localCenter = new Vector3((min.x + max.x) / 2, (min.y + max.y) / 2, (min.z + max.z) / 2);
    const halfExtents = new Vector3((max.x - min.x) / 2, (max.y - min.y) / 2, (max.z - min.z) / 2);
    const localModel = new Matrix4().compose(localCenter, Matrix4.identity, halfExtents);
    const model = this.selectedNode.transform.worldMatrix.clone().multiply(localModel);
    const view = camera.viewMatrix;
    const proj = camera.projectionMatrix;
    const mvp = proj.multiply(view).multiply(model);
    const uniformData = new Float32Array(20);
    uniformData.set(mvp.elements, 0);
    uniformData[16] = 0.2;
    uniformData[17] = 0.8;
    uniformData[18] = 1;
    uniformData[19] = 1;
    this.device.queue.writeBuffer(this.uniformBuffer, 0, uniformData);
    const passEncoder = encoder.beginRenderPass({
      colorAttachments: [
        {
          view: colorView,
          loadOp: "load",
          storeOp: "store"
        }
      ],
      depthStencilAttachment: {
        view: depthView,
        depthLoadOp: "load",
        depthStoreOp: "store"
      }
    });
    passEncoder.setPipeline(this.pipeline);
    passEncoder.setBindGroup(0, this.bindGroup);
    passEncoder.setVertexBuffer(0, this.vertexBuffer);
    passEncoder.draw(24);
    passEncoder.end();
  }
  getLocalBounds(node) {
    if (node instanceof Mesh && node.geometry) {
      const aabb = node.geometry.aabb;
      if (aabb) {
        return {
          min: new Vector3(aabb.min.x, aabb.min.y, aabb.min.z),
          max: new Vector3(aabb.max.x, aabb.max.y, aabb.max.z)
        };
      }
    }
    const size = 0.5;
    return {
      min: new Vector3(-size, -size, -size),
      max: new Vector3(size, size, size)
    };
  }
  cleanup() {
    this.vertexBuffer?.destroy();
    this.uniformBuffer?.destroy();
    this.vertexBuffer = null;
    this.uniformBuffer = null;
    this.pipeline = null;
    this.bindGroup = null;
    this.device = null;
  }
}
// ../../src/core/ui/UIRenderPass.ts
class UIRenderPass {
  device = null;
  context = null;
  presentationFormat = null;
  uiManager;
  width = 0;
  height = 0;
  quadPipeline = null;
  _textPipeline = null;
  vertexBuffer = null;
  uniformBuffer = null;
  maxQuads = 4096;
  vertexData;
  uniformBindGroupLayout = null;
  textureBindGroupLayout = null;
  uniformBindGroup = null;
  whiteTexture = null;
  whiteTextureView = null;
  defaultBindGroup = null;
  sampler = null;
  textureBindGroupCache = new Map;
  textCanvas = null;
  textContext = null;
  textTexture = null;
  textTextureView = null;
  textBindGroup = null;
  constructor(uiManager) {
    this.uiManager = uiManager;
    this.vertexData = new Float32Array(this.maxQuads * 6 * 8);
  }
  getUIManager() {
    return this.uiManager;
  }
  getTextPipeline() {
    return this._textPipeline;
  }
  init(device, context, presentationFormat) {
    this.device = device;
    this.context = context;
    this.presentationFormat = presentationFormat;
    const canvas = context.canvas;
    this.width = canvas.width;
    this.height = canvas.height;
    this.createResources();
    this.createPipelines();
    this.createTextCanvas();
  }
  resize(width, height) {
    this.width = width;
    this.height = height;
    this.uiManager.resize(width, height);
    this.updateUniformBuffer();
    this.resizeTextCanvas();
  }
  createResources() {
    if (!this.device)
      return;
    this.vertexBuffer = this.device.createBuffer({
      label: "UI Vertex Buffer",
      size: this.vertexData.byteLength,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
    });
    this.uniformBuffer = this.device.createBuffer({
      label: "UI Uniform Buffer",
      size: 80,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.sampler = this.device.createSampler({
      label: "UI Sampler",
      magFilter: "linear",
      minFilter: "linear",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    });
    this.whiteTexture = this.device.createTexture({
      label: "UI White Texture",
      size: [1, 1],
      format: "rgba8unorm",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
    });
    this.device.queue.writeTexture({ texture: this.whiteTexture }, new Uint8Array([255, 255, 255, 255]), { bytesPerRow: 4 }, [1, 1]);
    this.whiteTextureView = this.whiteTexture.createView();
    this.uniformBindGroupLayout = this.device.createBindGroupLayout({
      label: "UI Uniform Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.VERTEX, buffer: { type: "uniform" } }
      ]
    });
    this.textureBindGroupLayout = this.device.createBindGroupLayout({
      label: "UI Texture Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "filtering" } },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "float" } }
      ]
    });
    this.uniformBindGroup = this.device.createBindGroup({
      label: "UI Uniform Bind Group",
      layout: this.uniformBindGroupLayout,
      entries: [
        { binding: 0, resource: { buffer: this.uniformBuffer } }
      ]
    });
    this.defaultBindGroup = this.device.createBindGroup({
      label: "UI Default Texture Bind Group",
      layout: this.textureBindGroupLayout,
      entries: [
        { binding: 0, resource: this.sampler },
        { binding: 1, resource: this.whiteTextureView }
      ]
    });
    this.updateUniformBuffer();
  }
  createPipelines() {
    if (!this.device || !this.presentationFormat)
      return;
    const shaderCode = `
      struct Uniforms {
        projection: mat4x4<f32>,
        screenSize: vec2<f32>,
        _pad: vec2<f32>,
      }

      @group(0) @binding(0) var<uniform> uniforms: Uniforms;
      @group(1) @binding(0) var texSampler: sampler;
      @group(1) @binding(1) var tex: texture_2d<f32>;

      struct VertexInput {
        @location(0) position: vec2<f32>,
        @location(1) uv: vec2<f32>,
        @location(2) color: vec4<f32>,
      }

      struct VertexOutput {
        @builtin(position) position: vec4<f32>,
        @location(0) uv: vec2<f32>,
        @location(1) color: vec4<f32>,
      }

      @vertex
      fn vs_main(input: VertexInput) -> VertexOutput {
        var output: VertexOutput;
        output.position = uniforms.projection * vec4<f32>(input.position, 0.0, 1.0);
        output.uv = input.uv;
        output.color = input.color;
        return output;
      }

      @fragment
      fn fs_quad(input: VertexOutput) -> @location(0) vec4<f32> {
        let texColor = textureSample(tex, texSampler, input.uv);
        return input.color * texColor;
      }

      @fragment
      fn fs_text(input: VertexOutput) -> @location(0) vec4<f32> {
        let texColor = textureSample(tex, texSampler, input.uv);
        // Use texture alpha for text, color for tint
        return vec4<f32>(input.color.rgb, input.color.a * texColor.a);
      }
    `;
    const shaderModule = createShaderModuleSafe(this.device, {
      label: "UI Shader",
      code: shaderCode
    });
    const pipelineLayout = this.device.createPipelineLayout({
      label: "UI Pipeline Layout",
      bindGroupLayouts: [this.uniformBindGroupLayout, this.textureBindGroupLayout]
    });
    const vertexBufferLayout = {
      arrayStride: 8 * 4,
      attributes: [
        { shaderLocation: 0, offset: 0, format: "float32x2" },
        { shaderLocation: 1, offset: 8, format: "float32x2" },
        { shaderLocation: 2, offset: 16, format: "float32x4" }
      ]
    };
    this.quadPipeline = this.device.createRenderPipeline({
      label: "UI Quad Pipeline",
      layout: pipelineLayout,
      vertex: {
        module: shaderModule,
        entryPoint: "vs_main",
        buffers: [vertexBufferLayout]
      },
      fragment: {
        module: shaderModule,
        entryPoint: "fs_quad",
        targets: [{
          format: this.presentationFormat,
          blend: {
            color: { srcFactor: "src-alpha", dstFactor: "one-minus-src-alpha", operation: "add" },
            alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }
          }
        }]
      },
      primitive: {
        topology: "triangle-list"
      }
    });
    this._textPipeline = this.device.createRenderPipeline({
      label: "UI Text Pipeline",
      layout: pipelineLayout,
      vertex: {
        module: shaderModule,
        entryPoint: "vs_main",
        buffers: [vertexBufferLayout]
      },
      fragment: {
        module: shaderModule,
        entryPoint: "fs_text",
        targets: [{
          format: this.presentationFormat,
          blend: {
            color: { srcFactor: "src-alpha", dstFactor: "one-minus-src-alpha", operation: "add" },
            alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" }
          }
        }]
      },
      primitive: {
        topology: "triangle-list"
      }
    });
  }
  createTextCanvas() {
    this.textCanvas = document.createElement("canvas");
    this.textCanvas.width = this.width || 800;
    this.textCanvas.height = this.height || 600;
    this.textContext = this.textCanvas.getContext("2d", { willReadFrequently: true });
    this.createTextTexture();
  }
  resizeTextCanvas() {
    if (this.textCanvas && this.width > 0 && this.height > 0) {
      this.textCanvas.width = this.width;
      this.textCanvas.height = this.height;
      this.createTextTexture();
    }
  }
  createTextTexture() {
    if (!this.device || !this.textCanvas)
      return;
    if (this.textTexture) {
      this.textTexture.destroy();
    }
    this.textTexture = this.device.createTexture({
      label: "UI Text Texture",
      size: [this.textCanvas.width, this.textCanvas.height],
      format: "rgba8unorm",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
    });
    this.textTextureView = this.textTexture.createView();
    const transparentData = new Uint8Array(this.textCanvas.width * this.textCanvas.height * 4);
    this.device.queue.writeTexture({ texture: this.textTexture }, transparentData, { bytesPerRow: this.textCanvas.width * 4, rowsPerImage: this.textCanvas.height }, [this.textCanvas.width, this.textCanvas.height]);
    this.textBindGroup = this.device.createBindGroup({
      label: "UI Text Bind Group",
      layout: this.textureBindGroupLayout,
      entries: [
        { binding: 0, resource: this.sampler },
        { binding: 1, resource: this.textTextureView }
      ]
    });
  }
  updateUniformBuffer() {
    if (!this.device || !this.uniformBuffer)
      return;
    const projection = new Float32Array([
      2 / this.width,
      0,
      0,
      0,
      0,
      -2 / this.height,
      0,
      0,
      0,
      0,
      1,
      0,
      -1,
      1,
      0,
      1
    ]);
    const uniforms = new Float32Array(20);
    uniforms.set(projection, 0);
    uniforms[16] = this.width;
    uniforms[17] = this.height;
    this.device.queue.writeBuffer(this.uniformBuffer, 0, uniforms);
  }
  getTextureBindGroup(texture, textureView) {
    if (!this.device || !this.textureBindGroupLayout || !this.sampler) {
      throw new Error("UIRenderPass not initialized");
    }
    let bindGroup = this.textureBindGroupCache.get(texture);
    if (!bindGroup) {
      bindGroup = this.device.createBindGroup({
        label: "UI Image Bind Group",
        layout: this.textureBindGroupLayout,
        entries: [
          { binding: 0, resource: this.sampler },
          { binding: 1, resource: textureView }
        ]
      });
      this.textureBindGroupCache.set(texture, bindGroup);
    }
    return bindGroup;
  }
  parseColor(color, alpha = 1) {
    if (!color)
      return [1, 1, 1, alpha];
    if (color === "transparent") {
      return [0, 0, 0, 0];
    }
    if (color.startsWith("#")) {
      const hex = color.slice(1);
      if (hex.length === 3) {
        const r = parseInt(hex[0] + hex[0], 16) / 255;
        const g = parseInt(hex[1] + hex[1], 16) / 255;
        const b = parseInt(hex[2] + hex[2], 16) / 255;
        return [r, g, b, alpha];
      } else if (hex.length === 6) {
        const r = parseInt(hex.slice(0, 2), 16) / 255;
        const g = parseInt(hex.slice(2, 4), 16) / 255;
        const b = parseInt(hex.slice(4, 6), 16) / 255;
        return [r, g, b, alpha];
      } else if (hex.length === 8) {
        const r = parseInt(hex.slice(0, 2), 16) / 255;
        const g = parseInt(hex.slice(2, 4), 16) / 255;
        const b = parseInt(hex.slice(4, 6), 16) / 255;
        const a = parseInt(hex.slice(6, 8), 16) / 255;
        return [r, g, b, a * alpha];
      }
    }
    const rgbMatch = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
    if (rgbMatch) {
      const r = parseInt(rgbMatch[1]) / 255;
      const g = parseInt(rgbMatch[2]) / 255;
      const b = parseInt(rgbMatch[3]) / 255;
      const a = rgbMatch[4] ? parseFloat(rgbMatch[4]) : 1;
      return [r, g, b, a * alpha];
    }
    return [1, 1, 1, alpha];
  }
  applyTint(color, tint) {
    if (!tint)
      return color;
    const [tr, tg, tb] = this.parseColor(tint, 1);
    return [
      color[0] * tr,
      color[1] * tg,
      color[2] * tb,
      color[3]
    ];
  }
  addQuad(vertexOffset, x, y, w, h, u0, v0, u1, v1, r, g, b, a) {
    const v = this.vertexData;
    const o = vertexOffset;
    v[o + 0] = x;
    v[o + 1] = y;
    v[o + 2] = u0;
    v[o + 3] = v0;
    v[o + 4] = r;
    v[o + 5] = g;
    v[o + 6] = b;
    v[o + 7] = a;
    v[o + 8] = x + w;
    v[o + 9] = y;
    v[o + 10] = u1;
    v[o + 11] = v0;
    v[o + 12] = r;
    v[o + 13] = g;
    v[o + 14] = b;
    v[o + 15] = a;
    v[o + 16] = x;
    v[o + 17] = y + h;
    v[o + 18] = u0;
    v[o + 19] = v1;
    v[o + 20] = r;
    v[o + 21] = g;
    v[o + 22] = b;
    v[o + 23] = a;
    v[o + 24] = x + w;
    v[o + 25] = y;
    v[o + 26] = u1;
    v[o + 27] = v0;
    v[o + 28] = r;
    v[o + 29] = g;
    v[o + 30] = b;
    v[o + 31] = a;
    v[o + 32] = x + w;
    v[o + 33] = y + h;
    v[o + 34] = u1;
    v[o + 35] = v1;
    v[o + 36] = r;
    v[o + 37] = g;
    v[o + 38] = b;
    v[o + 39] = a;
    v[o + 40] = x;
    v[o + 41] = y + h;
    v[o + 42] = u0;
    v[o + 43] = v1;
    v[o + 44] = r;
    v[o + 45] = g;
    v[o + 46] = b;
    v[o + 47] = a;
    return 48;
  }
  addNineSliceQuads(vertexOffset, bounds, nineSlice, sourceWidth, sourceHeight, uvRect, r, g, b, a) {
    let offset = vertexOffset;
    const { left: sliceL, right: sliceR, top: sliceT, bottom: sliceB } = nineSlice;
    const { x, y, width, height } = bounds;
    const { u0, v0, u1, v1 } = uvRect;
    const uvWidth = u1 - u0;
    const uvHeight = v1 - v0;
    const uvLeft = u0 + sliceL / sourceWidth * uvWidth;
    const uvRight = u1 - sliceR / sourceWidth * uvWidth;
    const uvTop = v0 + sliceT / sourceHeight * uvHeight;
    const uvBottom = v1 - sliceB / sourceHeight * uvHeight;
    const screenLeft = x + sliceL;
    const screenRight = x + width - sliceR;
    const screenTop = y + sliceT;
    const screenBottom = y + height - sliceB;
    const centerWidth = Math.max(0, screenRight - screenLeft);
    const centerHeight = Math.max(0, screenBottom - screenTop);
    offset += this.addQuad(offset, x, y, sliceL, sliceT, u0, v0, uvLeft, uvTop, r, g, b, a);
    if (centerWidth > 0) {
      offset += this.addQuad(offset, screenLeft, y, centerWidth, sliceT, uvLeft, v0, uvRight, uvTop, r, g, b, a);
    }
    offset += this.addQuad(offset, screenRight, y, sliceR, sliceT, uvRight, v0, u1, uvTop, r, g, b, a);
    if (centerHeight > 0) {
      offset += this.addQuad(offset, x, screenTop, sliceL, centerHeight, u0, uvTop, uvLeft, uvBottom, r, g, b, a);
    }
    if (centerWidth > 0 && centerHeight > 0) {
      offset += this.addQuad(offset, screenLeft, screenTop, centerWidth, centerHeight, uvLeft, uvTop, uvRight, uvBottom, r, g, b, a);
    }
    if (centerHeight > 0) {
      offset += this.addQuad(offset, screenRight, screenTop, sliceR, centerHeight, uvRight, uvTop, u1, uvBottom, r, g, b, a);
    }
    offset += this.addQuad(offset, x, screenBottom, sliceL, sliceB, u0, uvBottom, uvLeft, v1, r, g, b, a);
    if (centerWidth > 0) {
      offset += this.addQuad(offset, screenLeft, screenBottom, centerWidth, sliceB, uvLeft, uvBottom, uvRight, v1, r, g, b, a);
    }
    offset += this.addQuad(offset, screenRight, screenBottom, sliceR, sliceB, uvRight, uvBottom, u1, v1, r, g, b, a);
    return offset - vertexOffset;
  }
  execute(commandEncoder, context, globalResources) {
    if (!this.device || !this.context || !this.quadPipeline || !this.vertexBuffer || !this.uniformBindGroup) {
      return;
    }
    const renderData = this.uiManager.getRenderData();
    if (renderData.length === 0)
      return;
    const dataByLayer = new Map;
    for (const data of renderData) {
      const layer = data.renderLayer ?? 0;
      if (!dataByLayer.has(layer)) {
        dataByLayer.set(layer, []);
      }
      dataByLayer.get(layer).push(data);
    }
    const sortedLayers = Array.from(dataByLayer.keys()).sort((a, b) => a - b);
    let currentTexture;
    try {
      currentTexture = this.context.getCurrentTexture();
    } catch (e) {
      if (this.device && this.presentationFormat) {
        try {
          console.warn("[UIRenderPass] Canvas context not configured, attempting to reconfigure...");
          this.context.configure({
            device: this.device,
            format: this.presentationFormat,
            alphaMode: "opaque"
          });
          currentTexture = this.context.getCurrentTexture();
          console.log("[UIRenderPass] Successfully reconfigured canvas context");
        } catch (reconfigureError) {
          console.warn("[UIRenderPass] Failed to reconfigure canvas context, skipping render");
          return;
        }
      } else {
        console.warn("[UIRenderPass] Cannot reconfigure - missing device or format, skipping render");
        return;
      }
    }
    const textureView = currentTexture.createView();
    let globalVertexOffset = 0;
    const layerRenderInfos = new Map;
    for (const layer of sortedLayers) {
      const layerData = dataByLayer.get(layer);
      const backgroundQuads = [];
      const overlayQuads = [];
      const images = [];
      const texts = [];
      const roundedQuads = [];
      for (const data of layerData) {
        if (data.type === "text") {
          texts.push(data);
        } else if ((data.type === "image" || data.type === "nine-slice") && data.texture && data.textureView) {
          images.push(data);
        } else if (data.gradient) {
          roundedQuads.push(data);
        } else if (data.backgroundColor) {
          const alpha = data.backgroundAlpha ?? 1;
          const colorHasAlpha = data.backgroundColor.includes("rgba") && !data.backgroundColor.endsWith(", 1)") && !data.backgroundColor.endsWith(",1)");
          const isSemiTransparent = alpha < 1 || colorHasAlpha;
          const hasGlow = data.glow && data.glow.blur > 0;
          const hasShadow = !!data.shadow;
          if (data.borderRadius && data.borderRadius > 0 || isSemiTransparent || hasGlow || hasShadow) {
            roundedQuads.push(data);
          } else {
            backgroundQuads.push(data);
          }
        } else if (data.borderColor && data.borderWidth && data.borderWidth > 0) {
          const hasGlow = data.glow && data.glow.blur > 0;
          const hasShadow = !!data.shadow;
          if (data.borderRadius && data.borderRadius > 0 || hasGlow || hasShadow) {
            roundedQuads.push(data);
          } else {
            overlayQuads.push(data);
          }
        }
      }
      const layerInfo = {
        backgroundQuadStart: globalVertexOffset / 48,
        backgroundQuadCount: 0,
        images: new Map,
        overlayQuadStart: 0,
        overlayQuadCount: 0,
        texts,
        roundedQuads,
        canvasOverlayVertexStart: 0
      };
      for (const data of backgroundQuads) {
        if (layerInfo.backgroundQuadCount >= this.maxQuads)
          break;
        let color = this.parseColor(data.backgroundColor, data.backgroundAlpha ?? 1);
        color = this.applyTint(color, data.tint);
        const [r, g, b, a] = color;
        const bounds = data.bounds;
        globalVertexOffset += this.addQuad(globalVertexOffset, bounds.x, bounds.y, bounds.width, bounds.height, 0, 0, 1, 1, r, g, b, a);
        layerInfo.backgroundQuadCount++;
        if (data.borderColor && data.borderWidth && data.borderWidth > 0) {
          overlayQuads.push(data);
        }
      }
      for (const data of images) {
        if (!data.texture)
          continue;
        const bounds = data.bounds;
        const uvRect = data.uvRect ?? { u0: 0, v0: 0, u1: 1, v1: 1 };
        let color = this.parseColor(data.color ?? "#ffffff", data.backgroundAlpha ?? 1);
        color = this.applyTint(color, data.tint);
        const [r, g, b, a] = color;
        const vertexStart = globalVertexOffset / 48;
        let vertexFloats;
        if (data.type === "nine-slice" && data.nineSlice && data.sourceWidth && data.sourceHeight) {
          vertexFloats = this.addNineSliceQuads(globalVertexOffset, bounds, data.nineSlice, data.sourceWidth, data.sourceHeight, uvRect, r, g, b, a);
        } else {
          vertexFloats = this.addQuad(globalVertexOffset, bounds.x, bounds.y, bounds.width, bounds.height, uvRect.u0, uvRect.v0, uvRect.u1, uvRect.v1, r, g, b, a);
        }
        globalVertexOffset += vertexFloats;
        const vertexCount = vertexFloats / 8;
        if (!layerInfo.images.has(data.texture)) {
          layerInfo.images.set(data.texture, []);
        }
        layerInfo.images.get(data.texture).push({ data, vertexStart, vertexCount });
      }
      layerInfo.overlayQuadStart = globalVertexOffset / 48;
      for (const data of overlayQuads) {
        const [br, bg, bb, ba] = this.parseColor(data.borderColor, 1);
        const bw = data.borderWidth;
        const bounds = data.bounds;
        globalVertexOffset += this.addQuad(globalVertexOffset, bounds.x, bounds.y, bounds.width, bw, 0, 0, 1, 1, br, bg, bb, ba);
        layerInfo.overlayQuadCount++;
        globalVertexOffset += this.addQuad(globalVertexOffset, bounds.x, bounds.y + bounds.height - bw, bounds.width, bw, 0, 0, 1, 1, br, bg, bb, ba);
        layerInfo.overlayQuadCount++;
        globalVertexOffset += this.addQuad(globalVertexOffset, bounds.x, bounds.y + bw, bw, bounds.height - bw * 2, 0, 0, 1, 1, br, bg, bb, ba);
        layerInfo.overlayQuadCount++;
        globalVertexOffset += this.addQuad(globalVertexOffset, bounds.x + bounds.width - bw, bounds.y + bw, bw, bounds.height - bw * 2, 0, 0, 1, 1, br, bg, bb, ba);
        layerInfo.overlayQuadCount++;
      }
      const hasCanvasContent = (texts.length > 0 || roundedQuads.length > 0) && this.textTexture;
      if (hasCanvasContent) {
        layerInfo.canvasOverlayVertexStart = globalVertexOffset / 48;
        globalVertexOffset += this.addQuad(globalVertexOffset, 0, 0, this.width, this.height, 0, 0, 1, 1, 1, 1, 1, 1);
      }
      layerRenderInfos.set(layer, layerInfo);
    }
    if (globalVertexOffset > 0) {
      this.device.queue.writeBuffer(this.vertexBuffer, 0, this.vertexData.buffer, 0, globalVertexOffset * 4);
    }
    for (const layer of sortedLayers) {
      const layerInfo = layerRenderInfos.get(layer);
      if (!layerInfo)
        continue;
      const hasGPUContent = layerInfo.backgroundQuadCount > 0 || layerInfo.images.size > 0 || layerInfo.overlayQuadCount > 0;
      if (hasGPUContent) {
        const renderPassDescriptor = {
          colorAttachments: [{
            view: textureView,
            loadOp: "load",
            storeOp: "store"
          }]
        };
        const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
        passEncoder.setVertexBuffer(0, this.vertexBuffer);
        if (layerInfo.backgroundQuadCount > 0) {
          passEncoder.setPipeline(this.quadPipeline);
          passEncoder.setBindGroup(0, this.uniformBindGroup);
          passEncoder.setBindGroup(1, this.defaultBindGroup);
          passEncoder.draw(layerInfo.backgroundQuadCount * 6, 1, layerInfo.backgroundQuadStart * 6, 0);
        }
        for (const [texture, imageList] of layerInfo.images) {
          const firstImage = imageList[0];
          if (!firstImage.data.textureView)
            continue;
          const bindGroup = this.getTextureBindGroup(texture, firstImage.data.textureView);
          passEncoder.setPipeline(this.quadPipeline);
          passEncoder.setBindGroup(0, this.uniformBindGroup);
          passEncoder.setBindGroup(1, bindGroup);
          for (const img of imageList) {
            passEncoder.draw(img.vertexCount, 1, img.vertexStart * 6, 0);
          }
        }
        if (layerInfo.overlayQuadCount > 0) {
          passEncoder.setPipeline(this.quadPipeline);
          passEncoder.setBindGroup(0, this.uniformBindGroup);
          passEncoder.setBindGroup(1, this.defaultBindGroup);
          passEncoder.draw(layerInfo.overlayQuadCount * 6, 1, layerInfo.overlayQuadStart * 6, 0);
        }
        passEncoder.end();
      }
      const hasCanvasContent = (layerInfo.texts.length > 0 || layerInfo.roundedQuads.length > 0) && this.textTexture;
      if (hasCanvasContent) {
        this.renderTextToCanvas(layerInfo.texts, layerInfo.roundedQuads);
        const renderPassDescriptor = {
          colorAttachments: [{
            view: textureView,
            loadOp: "load",
            storeOp: "store"
          }]
        };
        const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
        passEncoder.setVertexBuffer(0, this.vertexBuffer);
        passEncoder.setPipeline(this.quadPipeline);
        passEncoder.setBindGroup(0, this.uniformBindGroup);
        passEncoder.setBindGroup(1, this.textBindGroup);
        passEncoder.draw(6, 1, layerInfo.canvasOverlayVertexStart * 6, 0);
        passEncoder.end();
      }
    }
  }
  renderTextToCanvas(texts, roundedQuads = []) {
    if (!this.textContext || !this.textCanvas || !this.device || !this.textTexture)
      return;
    this.textContext.clearRect(0, 0, this.textCanvas.width, this.textCanvas.height);
    this.textContext.globalAlpha = 1;
    this.textContext.globalCompositeOperation = "source-over";
    const time = performance.now() / 1000;
    const allCanvasContent = [];
    for (const data of roundedQuads) {
      allCanvasContent.push({ data, isText: false });
    }
    for (const data of texts) {
      allCanvasContent.push({ data, isText: true });
    }
    allCanvasContent.sort((a, b) => {
      const layerA = a.data.renderLayer ?? 0;
      const layerB = b.data.renderLayer ?? 0;
      if (layerA !== layerB)
        return layerA - layerB;
      const zIndexA = a.data.zIndex ?? 0;
      const zIndexB = b.data.zIndex ?? 0;
      if (zIndexA !== zIndexB)
        return zIndexA - zIndexB;
      if (a.isText !== b.isText)
        return a.isText ? 1 : -1;
      return 0;
    });
    for (const { data, isText } of allCanvasContent) {
      this.textContext.save();
      if (isText) {
        if (data.richTextSegments && data.richTextSegments.length > 0) {
          this.renderRichText(data, time);
        } else if (data.text) {
          this.renderPlainText(data);
        }
      } else {
        this.renderRoundedQuad(data);
      }
      this.textContext.restore();
    }
    const imageData = this.textContext.getImageData(0, 0, this.textCanvas.width, this.textCanvas.height);
    this.device.queue.writeTexture({ texture: this.textTexture }, imageData.data, { bytesPerRow: this.textCanvas.width * 4, rowsPerImage: this.textCanvas.height }, [this.textCanvas.width, this.textCanvas.height]);
  }
  renderRoundedQuad(data) {
    if (!this.textContext)
      return;
    const bounds = data.bounds;
    const radius = data.borderRadius ?? 0;
    const bgColor = data.backgroundColor;
    const bgAlpha = data.backgroundAlpha ?? 1;
    const borderColor = data.borderColor;
    const borderWidth = data.borderWidth ?? 0;
    const gradient = data.gradient;
    const glow = data.glow;
    const hasGlow = glow && glow.blur > 0 && (bgColor || gradient);
    if (hasGlow) {
      const [gr, gg, gb] = this.parseColor(glow.color, 1);
      const glowIntensity = glow.intensity ?? 1;
      this.textContext.shadowColor = `rgba(${Math.round(gr * 255)}, ${Math.round(gg * 255)}, ${Math.round(gb * 255)}, ${glowIntensity})`;
      this.textContext.shadowBlur = glow.blur;
      this.textContext.shadowOffsetX = 0;
      this.textContext.shadowOffsetY = 0;
    }
    if (data.shadow) {
      this.renderShadows(data);
    }
    if (gradient || bgColor) {
      if (gradient) {
        this.textContext.fillStyle = this.createCanvasGradient(gradient, bounds, bgAlpha);
      } else if (bgColor) {
        const [r, g, b, a] = this.parseColor(bgColor, bgAlpha);
        this.textContext.fillStyle = `rgba(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)}, ${a})`;
      }
      this.textContext.beginPath();
      this.roundRect(bounds.x, bounds.y, bounds.width, bounds.height, radius);
      this.textContext.fill();
    }
    if (hasGlow) {
      this.textContext.shadowColor = "transparent";
      this.textContext.shadowBlur = 0;
    }
    if (borderColor && borderWidth > 0) {
      const [r, g, b, a] = this.parseColor(borderColor, 1);
      this.textContext.strokeStyle = `rgba(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)}, ${a})`;
      this.textContext.lineWidth = borderWidth;
      this.textContext.beginPath();
      const inset = borderWidth / 2;
      this.roundRect(bounds.x + inset, bounds.y + inset, bounds.width - borderWidth, bounds.height - borderWidth, Math.max(0, radius - inset));
      this.textContext.stroke();
    }
  }
  createCanvasGradient(gradient, bounds, alpha) {
    if (!this.textContext) {
      throw new Error("Text context not available");
    }
    let canvasGradient;
    if (gradient.type === "linear") {
      const angle = (gradient.angle ?? 0) * (Math.PI / 180);
      const centerX = bounds.x + bounds.width / 2;
      const centerY = bounds.y + bounds.height / 2;
      const diag = Math.sqrt(bounds.width * bounds.width + bounds.height * bounds.height) / 2;
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      const x0 = centerX - cos * diag;
      const y0 = centerY - sin * diag;
      const x1 = centerX + cos * diag;
      const y1 = centerY + sin * diag;
      canvasGradient = this.textContext.createLinearGradient(x0, y0, x1, y1);
    } else {
      const centerX = bounds.x + bounds.width * (gradient.centerX ?? 0.5);
      const centerY = bounds.y + bounds.height * (gradient.centerY ?? 0.5);
      const baseRadius = Math.min(bounds.width, bounds.height) * (gradient.radius ?? 0.5);
      canvasGradient = this.textContext.createRadialGradient(centerX, centerY, 0, centerX, centerY, baseRadius);
    }
    for (const stop of gradient.stops) {
      const [r, g, b, a] = this.parseColor(stop.color, alpha);
      canvasGradient.addColorStop(Math.max(0, Math.min(1, stop.position)), `rgba(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)}, ${a})`);
    }
    return canvasGradient;
  }
  renderShadows(data) {
    if (!this.textContext || !data.shadow)
      return;
    const bounds = data.bounds;
    const radius = data.borderRadius ?? 0;
    const shadows = Array.isArray(data.shadow) ? data.shadow : [data.shadow];
    for (let i = shadows.length - 1;i >= 0; i--) {
      const shadow = shadows[i];
      const offsetX = shadow.offsetX ?? 0;
      const offsetY = shadow.offsetY ?? 0;
      const blur = shadow.blur;
      const spread = shadow.spread ?? 0;
      const [r, g, b, a] = this.parseColor(shadow.color, 1);
      if (shadow.inset) {
        this.renderInsetShadow(bounds, radius, offsetX, offsetY, blur, spread, r, g, b, a);
      } else {
        this.textContext.save();
        this.textContext.shadowColor = `rgba(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)}, ${a})`;
        this.textContext.shadowBlur = blur;
        this.textContext.shadowOffsetX = offsetX;
        this.textContext.shadowOffsetY = offsetY;
        this.textContext.fillStyle = "rgba(0, 0, 0, 1)";
        this.textContext.beginPath();
        this.roundRect(bounds.x - spread, bounds.y - spread, bounds.width + spread * 2, bounds.height + spread * 2, Math.max(0, radius + spread));
        this.textContext.fill();
        this.textContext.shadowColor = "transparent";
        this.textContext.globalCompositeOperation = "destination-out";
        this.textContext.beginPath();
        this.roundRect(bounds.x, bounds.y, bounds.width, bounds.height, radius);
        this.textContext.fill();
        this.textContext.restore();
      }
    }
  }
  renderInsetShadow(bounds, radius, offsetX, offsetY, blur, spread, r, g, b, a) {
    if (!this.textContext)
      return;
    this.textContext.save();
    this.textContext.beginPath();
    this.roundRect(bounds.x, bounds.y, bounds.width, bounds.height, radius);
    this.textContext.clip();
    this.textContext.shadowColor = `rgba(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)}, ${a})`;
    this.textContext.shadowBlur = blur;
    this.textContext.shadowOffsetX = offsetX;
    this.textContext.shadowOffsetY = offsetY;
    const margin = blur + Math.abs(offsetX) + Math.abs(offsetY) + spread + 100;
    this.textContext.fillStyle = "rgba(0, 0, 0, 1)";
    this.textContext.beginPath();
    this.textContext.rect(bounds.x - margin, bounds.y - margin, bounds.width + margin * 2, bounds.height + margin * 2);
    const innerX = bounds.x + spread;
    const innerY = bounds.y + spread;
    const innerW = bounds.width - spread * 2;
    const innerH = bounds.height - spread * 2;
    const innerR = Math.max(0, radius - spread);
    this.textContext.moveTo(innerX + innerR, innerY);
    this.textContext.lineTo(innerX + innerW - innerR, innerY);
    this.textContext.quadraticCurveTo(innerX + innerW, innerY, innerX + innerW, innerY + innerR);
    this.textContext.lineTo(innerX + innerW, innerY + innerH - innerR);
    this.textContext.quadraticCurveTo(innerX + innerW, innerY + innerH, innerX + innerW - innerR, innerY + innerH);
    this.textContext.lineTo(innerX + innerR, innerY + innerH);
    this.textContext.quadraticCurveTo(innerX, innerY + innerH, innerX, innerY + innerH - innerR);
    this.textContext.lineTo(innerX, innerY + innerR);
    this.textContext.quadraticCurveTo(innerX, innerY, innerX + innerR, innerY);
    this.textContext.fill("evenodd");
    this.textContext.restore();
  }
  roundRect(x, y, w, h, r) {
    if (!this.textContext)
      return;
    r = Math.min(r, w / 2, h / 2);
    this.textContext.moveTo(x + r, y);
    this.textContext.lineTo(x + w - r, y);
    this.textContext.quadraticCurveTo(x + w, y, x + w, y + r);
    this.textContext.lineTo(x + w, y + h - r);
    this.textContext.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    this.textContext.lineTo(x + r, y + h);
    this.textContext.quadraticCurveTo(x, y + h, x, y + h - r);
    this.textContext.lineTo(x, y + r);
    this.textContext.quadraticCurveTo(x, y, x + r, y);
    this.textContext.closePath();
  }
  renderPlainText(data) {
    if (!this.textContext || !data.text)
      return;
    const bounds = data.bounds;
    const fontSize = data.fontSize ?? 16;
    const fontFamily = data.fontFamily ?? "sans-serif";
    const textAlign = data.textAlign ?? "left";
    const color = data.color ?? "#ffffff";
    const alpha = data.textAlpha ?? 1;
    const letterSpacing = data.letterSpacing ?? 0;
    const lineHeightMultiplier = data.lineHeight ?? 1.4;
    const fontWeight = this.resolveFontWeight(data.fontWeight);
    this.textContext.font = `${fontWeight} ${fontSize}px ${fontFamily}`;
    this.textContext.globalAlpha = alpha;
    this.textContext.fillStyle = color;
    this.textContext.textBaseline = "middle";
    this.textContext.letterSpacing = `${letterSpacing}px`;
    let x;
    switch (textAlign) {
      case "center":
        this.textContext.textAlign = "center";
        x = bounds.x + bounds.width / 2;
        break;
      case "right":
        this.textContext.textAlign = "right";
        x = bounds.x + bounds.width;
        break;
      default:
        this.textContext.textAlign = "left";
        x = bounds.x;
    }
    const y = bounds.y + bounds.height / 2;
    const lines = data.text.split(`
`);
    const lineHeight = fontSize * lineHeightMultiplier;
    const totalHeight = lines.length * lineHeight;
    const startY = y - totalHeight / 2 + lineHeight / 2;
    const shadow = data.labelShadow;
    if (shadow) {
      this.textContext.shadowColor = shadow.color;
      this.textContext.shadowBlur = shadow.blur ?? 0;
      this.textContext.shadowOffsetX = shadow.offsetX ?? 0;
      this.textContext.shadowOffsetY = shadow.offsetY ?? 0;
    }
    const outline = data.labelOutline;
    if (outline) {
      this.textContext.strokeStyle = outline.color;
      this.textContext.lineWidth = outline.width;
      this.textContext.lineJoin = "round";
      this.textContext.miterLimit = 2;
      for (let i = 0;i < lines.length; i++) {
        this.textContext.strokeText(lines[i], x, startY + i * lineHeight);
      }
      if (shadow) {
        this.textContext.shadowColor = "transparent";
        this.textContext.shadowBlur = 0;
        this.textContext.shadowOffsetX = 0;
        this.textContext.shadowOffsetY = 0;
      }
    }
    for (let i = 0;i < lines.length; i++) {
      this.textContext.fillText(lines[i], x, startY + i * lineHeight);
    }
    if (shadow && !outline) {
      this.textContext.shadowColor = "transparent";
      this.textContext.shadowBlur = 0;
      this.textContext.shadowOffsetX = 0;
      this.textContext.shadowOffsetY = 0;
    }
    this.textContext.letterSpacing = "0px";
  }
  resolveFontWeight(weight) {
    if (weight === undefined || weight === "normal")
      return "400";
    if (weight === "medium")
      return "500";
    if (weight === "bold")
      return "700";
    if (typeof weight === "number")
      return String(weight);
    return "400";
  }
  renderRichText(data, time) {
    if (!this.textContext || !data.richTextSegments)
      return;
    const bounds = data.bounds;
    const baseFontSize = data.fontSize ?? 16;
    const fontFamily = data.fontFamily ?? "sans-serif";
    const baseColor = data.color ?? "#ffffff";
    const letterSpacing = data.letterSpacing ?? 0;
    const lineHeightMultiplier = data.lineHeight ?? 1.4;
    const baseFontWeight = this.resolveFontWeight(data.fontWeight);
    const lineHeight = baseFontSize * lineHeightMultiplier;
    this.textContext.letterSpacing = `${letterSpacing}px`;
    this.textContext.textAlign = "left";
    this.textContext.textBaseline = "middle";
    const shadow = data.labelShadow;
    if (shadow) {
      this.textContext.shadowColor = shadow.color;
      this.textContext.shadowBlur = shadow.blur ?? 0;
      this.textContext.shadowOffsetX = shadow.offsetX ?? 0;
      this.textContext.shadowOffsetY = shadow.offsetY ?? 0;
    }
    const outline = data.labelOutline;
    if (outline) {
      this.textContext.lineJoin = "round";
      this.textContext.miterLimit = 2;
    }
    let x = bounds.x;
    let y = bounds.y + lineHeight / 2;
    let charIndex = 0;
    const passes = outline ? ["stroke", "fill"] : ["fill"];
    for (const pass of passes) {
      x = bounds.x;
      y = bounds.y + lineHeight / 2;
      charIndex = 0;
      if (pass === "fill" && outline && shadow) {
        this.textContext.shadowColor = "transparent";
        this.textContext.shadowBlur = 0;
        this.textContext.shadowOffsetX = 0;
        this.textContext.shadowOffsetY = 0;
      }
      for (const segment of data.richTextSegments) {
        if (!segment.text)
          continue;
        const fontSize = segment.fontSize ?? baseFontSize;
        const color = segment.color ?? baseColor;
        const bold = segment.bold ?? false;
        const italic = segment.italic ?? false;
        const weight = bold ? "bold" : baseFontWeight;
        const fontStyle = `${italic ? "italic " : ""}${weight} ${fontSize}px ${fontFamily}`;
        this.textContext.font = fontStyle;
        if (pass === "stroke" && outline) {
          this.textContext.strokeStyle = outline.color;
          this.textContext.lineWidth = outline.width;
        } else {
          this.textContext.fillStyle = color;
        }
        for (const char of segment.text) {
          if (char === `
`) {
            x = bounds.x;
            y += lineHeight;
            charIndex++;
            continue;
          }
          let offsetX = 0;
          let offsetY = 0;
          if (segment.shake) {
            const shakeTime = Math.floor(time * 20);
            offsetX = (Math.sin(charIndex * 123.456 + shakeTime) * 0.5 - 0.25) * 6;
            offsetY = (Math.cos(charIndex * 789.123 + shakeTime) * 0.5 - 0.25) * 6;
          }
          if (segment.wave) {
            offsetY += Math.sin(time * 4 + charIndex * 0.3) * 3;
          }
          if (pass === "stroke" && outline) {
            this.textContext.strokeText(char, x + offsetX, y + offsetY);
          } else {
            this.textContext.fillText(char, x + offsetX, y + offsetY);
          }
          const charWidth = this.textContext.measureText(char).width;
          x += charWidth;
          if (x > bounds.x + bounds.width && char === " ") {
            x = bounds.x;
            y += lineHeight;
          }
          charIndex++;
        }
      }
    }
    if (shadow) {
      this.textContext.shadowColor = "transparent";
      this.textContext.shadowBlur = 0;
      this.textContext.shadowOffsetX = 0;
      this.textContext.shadowOffsetY = 0;
    }
    this.textContext.letterSpacing = "0px";
  }
  destroy() {
    this.vertexBuffer?.destroy();
    this.uniformBuffer?.destroy();
    this.whiteTexture?.destroy();
    this.textTexture?.destroy();
  }
}

// ../../src/core/renderer/ShadowUtils.ts
class ShadowUtils {
  static getShadowViewProj(light, camera) {
    const lightDir = light.transform.getForwardVector().normalize();
    let up = Vector3.up;
    if (Math.abs(lightDir.dot(up)) > 0.99) {
      up = new Vector3(0, 0, 1);
    }
    const shadowDistance = 300;
    const lightPos = camera.transform.position.clone().subtract(lightDir.multiply(shadowDistance));
    const lightTarget = camera.transform.position.clone();
    const lightView = new Matrix4().lookAt(lightPos, lightTarget, up);
    const lightProj = new Matrix4().makeOrthographic(-250, 250, 250, -250, 1, 800);
    return lightProj.multiply(lightView);
  }
  static getSpotLightShadowViewProj(light) {
    const lightPos = light.transform.position;
    const lightDir = light.transform.getForwardVector().normalize();
    const target = lightPos.clone().add(lightDir);
    let up = Vector3.up;
    if (Math.abs(lightDir.dot(up)) > 0.99) {
      up = new Vector3(0, 0, 1);
    }
    const lightView = new Matrix4().lookAt(lightPos, target, up);
    const fov = light.outerAngle * 2;
    const aspect = 1;
    const near = 0.1;
    const far = 100;
    const lightProj = new Matrix4().makePerspective(fov, aspect, near, far);
    return lightProj.multiply(lightView);
  }
  static getLightShadowViewProj(light, camera) {
    if (light.type === 2 /* Spot */) {
      return this.getSpotLightShadowViewProj(light);
    }
    return this.getShadowViewProj(light, camera);
  }
}

// ../../src/core/renderer/SceneUniforms.ts
class SceneUniforms {
  device;
  buffer;
  debugMode = 0;
  static hasLoggedLights = false;
  static hasLoggedMatrices = false;
  static MAX_LIGHTS = 8;
  static BUFFER_SIZE = 480 + 8 * 96;
  uniformData = new ArrayBuffer(SceneUniforms.BUFFER_SIZE);
  uniformFloatView = new Float32Array(this.uniformData);
  uniformUintView = new Uint32Array(this.uniformData);
  tempMatrix = new Matrix4;
  tempMatrix2 = new Matrix4;
  constructor(device) {
    this.device = device;
    this.buffer = device.createBuffer({
      label: "Scene Uniform Buffer",
      size: SceneUniforms.BUFFER_SIZE,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
  }
  update(camera, scene) {
    const floatView = this.uniformFloatView;
    const uintView = this.uniformUintView;
    let offset = 0;
    floatView.set(camera.viewMatrix.elements, offset);
    offset += 16;
    floatView.set(camera.projectionMatrix.elements, offset);
    offset += 16;
    const light = scene.lights.find((l) => l.type === 0 /* Directional */);
    if (light && scene.shadows.enabled) {
      const lightViewProj = ShadowUtils.getShadowViewProj(light, camera);
      floatView.set(lightViewProj.elements, offset);
    } else {
      floatView.set(Matrix4.identity.elements, offset);
    }
    offset += 16;
    this.tempMatrix.copy(camera.previousProjectionMatrix).multiply(camera.previousViewMatrix);
    floatView.set(this.tempMatrix.elements, offset);
    offset += 16;
    this.tempMatrix2.copy(camera.projectionMatrix).invert();
    floatView.set(this.tempMatrix2.elements, offset);
    offset += 16;
    const pos = camera.transform.position;
    floatView[offset++] = pos.x;
    floatView[offset++] = pos.y;
    floatView[offset++] = pos.z;
    floatView[offset++] = performance.now() / 1000;
    const position = pos;
    const activeLights = scene.getClosestLights(position, SceneUniforms.MAX_LIGHTS);
    if (!SceneUniforms.hasLoggedLights) {
      console.log("SceneUniforms: Lights", {
        lightCount: activeLights.length,
        lights: activeLights.map((l) => ({ type: l.type, intensity: l.intensity, color: [l.color.x, l.color.y, l.color.z], shadowAtlasIndex: l.shadowAtlasIndex }))
      });
      SceneUniforms.hasLoggedLights = true;
    }
    uintView[offset++] = activeLights.length;
    uintView[offset++] = this.debugMode;
    let flags = 0;
    if (scene.shadows.enabled)
      flags |= 1;
    if (scene.render.frustumCulling)
      flags |= 2;
    if (scene.render.occlusionCulling)
      flags |= 4;
    uintView[offset++] = flags;
    floatView[offset++] = scene.environmentIntensity;
    floatView[offset++] = 0;
    floatView[offset++] = 0;
    floatView[offset++] = 0;
    floatView[offset++] = 0;
    floatView[offset++] = 0;
    floatView[offset++] = 0;
    floatView[offset++] = 0;
    floatView[offset++] = 0;
    uintView[offset++] = 0;
    uintView[offset++] = 0;
    uintView[offset++] = 0;
    uintView[offset++] = 0;
    floatView[offset++] = scene.cloudShadows.enabled ? 1 : 0;
    floatView[offset++] = scene.cloudShadows.intensity;
    floatView[offset++] = scene.cloudShadows.scale;
    floatView[offset++] = scene.cloudShadows.speed;
    const windRad = scene.cloudShadows.windDirection * Math.PI / 180;
    floatView[offset++] = scene.cloudShadows.coverage;
    floatView[offset++] = scene.cloudShadows.softness;
    floatView[offset++] = Math.cos(windRad);
    floatView[offset++] = Math.sin(windRad);
    floatView[offset++] = scene.fog.color.x;
    floatView[offset++] = scene.fog.color.y;
    floatView[offset++] = scene.fog.color.z;
    floatView[offset++] = scene.fog.density;
    floatView[offset++] = scene.fog.near;
    floatView[offset++] = scene.fog.far;
    floatView[offset++] = scene.fog.type === "LINEAR" ? 0 : 1;
    floatView[offset++] = scene.fog.enabled ? 1 : 0;
    floatView[offset++] = scene.fog.skyFalloff;
    floatView[offset++] = 0;
    floatView[offset++] = 0;
    floatView[offset++] = 0;
    for (const light2 of activeLights) {
      const lPos = light2.transform.position;
      floatView[offset++] = lPos.x;
      floatView[offset++] = lPos.y;
      floatView[offset++] = lPos.z;
      floatView[offset++] = 0;
      let lDir;
      if (light2.type === 4 /* Hemisphere */) {
        lDir = light2.direction;
      } else {
        lDir = light2.transform.getForwardVector();
      }
      floatView[offset++] = lDir.x;
      floatView[offset++] = lDir.y;
      floatView[offset++] = lDir.z;
      floatView[offset++] = 0;
      floatView[offset++] = light2.color.x;
      floatView[offset++] = light2.color.y;
      floatView[offset++] = light2.color.z;
      floatView[offset++] = light2.intensity;
      if (light2.type === 1 /* Point */) {
        const pointLight = light2;
        floatView[offset++] = pointLight.distance;
        floatView[offset++] = pointLight.decay;
        floatView[offset++] = 0;
      } else if (light2.type === 2 /* Spot */) {
        const spotLight = light2;
        floatView[offset++] = spotLight.distance;
        floatView[offset++] = spotLight.decay;
        floatView[offset++] = 0;
      } else if (light2.type === 4 /* Hemisphere */) {
        const hemiLight = light2;
        floatView[offset++] = hemiLight.groundColor.x;
        floatView[offset++] = hemiLight.groundColor.y;
        floatView[offset++] = hemiLight.groundColor.z;
      } else {
        floatView[offset++] = 0;
        floatView[offset++] = 0;
        floatView[offset++] = 0;
      }
      uintView[offset++] = light2.type;
      if (light2.type === 2 /* Spot */) {
        const spot = light2;
        floatView[offset++] = spot.innerAngle || 0;
        floatView[offset++] = spot.outerAngle || 0;
      } else {
        floatView[offset++] = 0;
        floatView[offset++] = 0;
      }
      const shadowIdx = light2.shadow.castShadow ? light2.shadowAtlasIndex : -1;
      uintView[offset++] = shadowIdx >>> 0;
      floatView[offset++] = light2.shadow.radius;
      floatView[offset++] = light2.shadow.intensity;
      floatView[offset++] = 0;
      floatView[offset++] = 0;
      floatView[offset++] = 0;
    }
    if (!SceneUniforms.hasLoggedMatrices) {
      SceneUniforms.hasLoggedMatrices = true;
      console.log(`[SceneUniforms] View matrix diagonal: [${floatView[0].toFixed(3)}, ${floatView[5].toFixed(3)}, ${floatView[10].toFixed(3)}, ${floatView[15].toFixed(3)}]`);
      console.log(`[SceneUniforms] View matrix translation column: [${floatView[12].toFixed(3)}, ${floatView[13].toFixed(3)}, ${floatView[14].toFixed(3)}]`);
      console.log(`[SceneUniforms] Projection matrix diagonal: [${floatView[16].toFixed(3)}, ${floatView[21].toFixed(3)}, ${floatView[26].toFixed(3)}, ${floatView[31].toFixed(3)}]`);
      console.log(`[SceneUniforms] Camera position: [${floatView[80].toFixed(3)}, ${floatView[81].toFixed(3)}, ${floatView[82].toFixed(3)}]`);
    }
    this.device.queue.writeBuffer(this.buffer, 0, this.uniformData);
  }
}

// ../../src/core/renderer/ObjectBuffer.ts
class ObjectBuffer {
  device;
  buffer;
  capacity;
  count = 0;
  static hasLogged = false;
  _wasResized = false;
  static ELEMENT_SIZE = 256;
  constructor(device, initialCapacity = 100) {
    this.device = device;
    this.capacity = initialCapacity;
    this.buffer = this.createBuffer(this.capacity);
  }
  createBuffer(count) {
    return this.device.createBuffer({
      label: "Global Object Buffer",
      size: count * ObjectBuffer.ELEMENT_SIZE,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
    });
  }
  get objectCount() {
    return this.count;
  }
  checkAndClearResized() {
    const wasResized = this._wasResized;
    this._wasResized = false;
    return wasResized;
  }
  update(meshes) {
    const prevCount = this.count;
    this.count = meshes.length;
    if (Math.abs(this.count - prevCount) > 10 || this.count === 0) {
      console.log(`[ObjectBuffer] update: ${prevCount} -> ${this.count} meshes`);
    }
    if (this.count > this.capacity) {
      console.log(`[ObjectBuffer] RESIZING: capacity ${this.capacity} -> ${Math.max(this.count, this.capacity * 2)}, destroying old buffer`);
      this.capacity = Math.max(this.count, this.capacity * 2);
      this.buffer.destroy();
      this.buffer = this.createBuffer(this.capacity);
      this._wasResized = true;
      console.log(`[ObjectBuffer] New buffer created`);
    }
    const arrayBuffer = new ArrayBuffer(this.count * ObjectBuffer.ELEMENT_SIZE);
    const floatView = new Float32Array(arrayBuffer);
    const uintView = new Uint32Array(arrayBuffer);
    for (let i = 0;i < this.count; i++) {
      const mesh = meshes[i];
      mesh.renderIndex = i;
      const offset = i * (ObjectBuffer.ELEMENT_SIZE / 4);
      const worldMatrixElements = mesh.transform.worldMatrix.elements;
      if (worldMatrixElements.some((v) => isNaN(v))) {
        console.error("NaN detected in worldMatrix for mesh:", mesh);
      }
      floatView.set(worldMatrixElements, offset);
      const normalMatrix = mesh.transform.worldMatrix.clone().inverse().transpose();
      if (normalMatrix.elements.some((v) => isNaN(v))) {
        console.error("NaN detected in normalMatrix for mesh:", mesh, "worldMatrix:", mesh.transform.worldMatrix.elements);
        floatView.set([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], offset + 16);
      } else {
        floatView.set(normalMatrix.elements, offset + 16);
      }
      floatView[offset + 32] = mesh.worldBounds.min.x;
      floatView[offset + 33] = mesh.worldBounds.min.y;
      floatView[offset + 34] = mesh.worldBounds.min.z;
      uintView[offset + 35] = mesh.geometry.triangleCount;
      floatView[offset + 36] = mesh.worldBounds.max.x;
      floatView[offset + 37] = mesh.worldBounds.max.y;
      floatView[offset + 38] = mesh.worldBounds.max.z;
      floatView[offset + 39] = 0;
      floatView.set(mesh.previousWorldMatrix.elements, offset + 40);
    }
    this.device.queue.writeBuffer(this.buffer, 0, arrayBuffer);
    if (!ObjectBuffer.hasLogged && this.count > 0) {
      ObjectBuffer.hasLogged = true;
      const firstMesh = meshes[0];
      console.log(`[ObjectBuffer] First mesh: ${firstMesh.name || "unnamed"}`);
      console.log(`[ObjectBuffer] Model matrix diagonal: [${floatView[0].toFixed(3)}, ${floatView[5].toFixed(3)}, ${floatView[10].toFixed(3)}, ${floatView[15].toFixed(3)}]`);
      console.log(`[ObjectBuffer] Model matrix translation: [${floatView[12].toFixed(3)}, ${floatView[13].toFixed(3)}, ${floatView[14].toFixed(3)}]`);
    }
  }
}

// ../../src/core/renderer/HiZBuffer.ts
class HiZBuffer {
  texture = null;
  width = 0;
  height = 0;
  mipLevels = 1;
  device;
  constructor(device, width, height) {
    this.device = device;
    this.resize(width, height);
  }
  resize(width, height) {
    if (width <= 0 || height <= 0)
      return;
    if (this.width === width && this.height === height)
      return;
    this.width = width;
    this.height = height;
    this.mipLevels = Math.floor(Math.log2(Math.max(width, height))) + 1;
    if (this.texture)
      this.texture.destroy();
    this.texture = this.device.createTexture({
      label: "Hi-Z Buffer",
      size: { width, height, depthOrArrayLayers: 1 },
      mipLevelCount: this.mipLevels,
      format: "r32float",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.COPY_DST
    });
    let mipWidth = width;
    let mipHeight = height;
    for (let mip = 0;mip < this.mipLevels; mip++) {
      const size = mipWidth * mipHeight;
      const data = new Float32Array(size);
      data.fill(1);
      this.device.queue.writeTexture({ texture: this.texture, mipLevel: mip }, data, { bytesPerRow: mipWidth * 4 }, { width: mipWidth, height: mipHeight });
      mipWidth = Math.max(1, Math.floor(mipWidth / 2));
      mipHeight = Math.max(1, Math.floor(mipHeight / 2));
    }
  }
}

// ../../src/core/renderer/IndirectDrawBuffer.ts
class IndirectDrawBuffer {
  device;
  buffer;
  capacity;
  count = 0;
  static hasLogged = false;
  static STRIDE = 20;
  constructor(device, initialCapacity = 100) {
    this.device = device;
    this.capacity = initialCapacity;
    this.buffer = this.createBuffer(this.capacity);
  }
  createBuffer(count) {
    return this.device.createBuffer({
      label: "Indirect Draw Buffer",
      size: count * IndirectDrawBuffer.STRIDE,
      usage: GPUBufferUsage.INDIRECT | GPUBufferUsage.COPY_DST | GPUBufferUsage.STORAGE
    });
  }
  update(meshes) {
    this.count = meshes.length;
    if (this.count === 0)
      return;
    if (this.count > this.capacity) {
      this.capacity = Math.max(this.count, this.capacity * 2);
      this.buffer.destroy();
      this.buffer = this.createBuffer(this.capacity);
    }
    const data = new Uint32Array(this.count * 5);
    for (let i = 0;i < this.count; i++) {
      const mesh = meshes[i];
      const offset = i * 5;
      if (mesh.geometry.indices) {
        data[offset + 0] = mesh.geometry.indexCount;
        data[offset + 1] = 1;
        data[offset + 2] = 0;
        data[offset + 3] = 0;
        data[offset + 4] = i;
      } else {
        data[offset + 0] = mesh.geometry.vertexCount;
        data[offset + 1] = 1;
        data[offset + 2] = 0;
        data[offset + 3] = i;
        data[offset + 4] = 0;
      }
    }
    if (!IndirectDrawBuffer.hasLogged) {
      IndirectDrawBuffer.hasLogged = true;
    }
    this.device.queue.writeBuffer(this.buffer, 0, data);
  }
  getBufferForMesh(_renderIndex) {
    return this.buffer;
  }
}

// ../../src/core/CubeTexture.ts
class CubeTexture extends Texture {
  constructor(label = "CubeTexture") {
    super(label);
  }
  async loadCube(device, urls) {
    try {
      const promises = urls.map((url) => fetch(url).then((res) => res.blob()).then((blob) => createImageBitmap(blob)));
      const bitmaps = await Promise.all(promises);
      this.createFromImageBitmaps(device, bitmaps);
    } catch (e) {
      console.error(`Failed to load cube texture`, e);
    }
  }
  createFromImageBitmaps(device, bitmaps) {
    if (bitmaps.length !== 6) {
      throw new Error("CubeTexture requires 6 images");
    }
    const width = bitmaps[0].width;
    const height = bitmaps[0].height;
    this.gpuTexture = device.createTexture({
      label: this.label,
      size: [width, height, 6],
      format: "rgba8unorm",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
      viewFormats: ["rgba8unorm"]
    });
    for (let i = 0;i < 6; i++) {
      device.queue.copyExternalImageToTexture({ source: bitmaps[i] }, { texture: this.gpuTexture, origin: [0, 0, i] }, [width, height]);
    }
    this.view = this.gpuTexture.createView({
      dimension: "cube"
    });
    this.sampler = device.createSampler({
      magFilter: "linear",
      minFilter: "linear",
      mipmapFilter: "linear",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge",
      addressModeW: "clamp-to-edge"
    });
  }
  static _defaultCubeTextures = new WeakMap;
  static getDefault(device) {
    if (!CubeTexture._defaultCubeTextures.has(device)) {
      const texture = new CubeTexture("Default Cube Texture");
      texture.gpuTexture = device.createTexture({
        label: "Default Cube Texture",
        size: [1, 1, 6],
        format: "rgba8unorm",
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
      });
      const data = new Uint8Array([0, 0, 0, 255]);
      for (let i = 0;i < 6; i++) {
        device.queue.writeTexture({ texture: texture.gpuTexture, origin: [0, 0, i] }, data, { bytesPerRow: 4, rowsPerImage: 1 }, [1, 1, 1]);
      }
      texture.view = texture.gpuTexture.createView({
        dimension: "cube"
      });
      texture.sampler = device.createSampler({
        magFilter: "linear",
        minFilter: "linear"
      });
      CubeTexture._defaultCubeTextures.set(device, texture);
    }
    return CubeTexture._defaultCubeTextures.get(device);
  }
  static createFromColors(device, px, nx, py, ny, pz, nz) {
    const texture = new CubeTexture("Procedural Cube Texture");
    texture.gpuTexture = device.createTexture({
      label: "Procedural Cube Texture",
      size: [1, 1, 6],
      format: "rgba8unorm",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
    });
    const faces = [px, nx, py, ny, pz, nz];
    for (let i = 0;i < 6; i++) {
      const color = faces[i];
      const data = new Uint8Array([color[0] * 255, color[1] * 255, color[2] * 255, 255]);
      device.queue.writeTexture({ texture: texture.gpuTexture, origin: [0, 0, i] }, data, { bytesPerRow: 4, rowsPerImage: 1 }, [1, 1, 1]);
    }
    texture.view = texture.gpuTexture.createView({
      dimension: "cube"
    });
    texture.sampler = device.createSampler({
      magFilter: "linear",
      minFilter: "linear"
    });
    return texture;
  }
}

// ../../src/core/renderer/GlobalResources.ts
var MAX_SHADOW_LIGHTS = 4;
var activeShadowLayers = 1;
var SHADOW_UNIFORMS_SIZE = 336;
var CASCADE_COUNT = 4;
var CASCADE_UNIFORMS_SIZE = 288;

class GlobalResources {
  sceneUniforms;
  objectBuffer;
  hiZBuffer;
  indirectDrawBuffer;
  lightStorageBuffer;
  statsBuffer;
  cullingDebugBuffer;
  shadowAtlas = null;
  shadowSampler = null;
  shadowUniformsBuffer = null;
  cascadeUniformsBuffer = null;
  pointShadowAtlas = null;
  pointShadowSampler = null;
  environmentMap = null;
  static MAX_STORAGE_LIGHTS = 1024;
  static LIGHT_BUFFER_SIZE = 16 + GlobalResources.MAX_STORAGE_LIGHTS * 96;
  lightBufferData = new ArrayBuffer(GlobalResources.LIGHT_BUFFER_SIZE);
  lightBufferFloatView = new Float32Array(this.lightBufferData);
  lightBufferUintView = new Uint32Array(this.lightBufferData);
  shadowUniformsData = new ArrayBuffer(SHADOW_UNIFORMS_SIZE);
  shadowUniformsFloatView = new Float32Array(this.shadowUniformsData);
  shadowUniformsUintView = new Uint32Array(this.shadowUniformsData);
  cascadeUniformsData = new Float32Array(CASCADE_UNIFORMS_SIZE / 4);
  nearestSampler = null;
  linearSampler = null;
  transmittanceLUT = null;
  scatteringLUT = null;
  irradianceLUT = null;
  skyViewLUT = null;
  cloudNoiseLUT = null;
  atmosphereUniformsBuffer = null;
  atmosphereBindGroup = null;
  atmosphereBindGroupLayout = null;
  computeBindGroup = null;
  computeBindGroupLayout = null;
  renderBindGroup = null;
  renderBindGroupLayout = null;
  get bindGroup() {
    return this.computeBindGroup;
  }
  get bindGroupLayout() {
    return this.computeBindGroupLayout;
  }
  _bindGroupsDirty = true;
  _lastEnvironmentMap = null;
  markBindGroupsDirty() {
    this._bindGroupsDirty = true;
  }
  updateBindGroupsIfNeeded(device) {
    if (this.objectBuffer.checkAndClearResized()) {
      console.log("[GlobalResources] ObjectBuffer was resized, marking bind groups dirty");
      this._bindGroupsDirty = true;
    }
    if (this.environmentMap !== this._lastEnvironmentMap) {
      console.log("[GlobalResources] Environment map changed, marking bind groups dirty");
      this._bindGroupsDirty = true;
      this._lastEnvironmentMap = this.environmentMap;
    }
    if (this._bindGroupsDirty) {
      console.log("[GlobalResources] Recreating bind groups");
      this.createBindGroup(device);
      this._bindGroupsDirty = false;
    }
  }
  _shadowsInitialized = false;
  constructor(device) {
    this.sceneUniforms = new SceneUniforms(device);
    this.objectBuffer = new ObjectBuffer(device);
    this.hiZBuffer = new HiZBuffer(device, 1, 1);
    this.indirectDrawBuffer = new IndirectDrawBuffer(device);
    this.lightStorageBuffer = device.createBuffer({
      label: "Light Storage Buffer",
      size: 16 + 1024 * 96,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
    });
    this.statsBuffer = device.createBuffer({
      label: "Render Stats Buffer",
      size: 16,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST
    });
    this.cullingDebugBuffer = device.createBuffer({
      label: "Culling Debug Buffer",
      size: 64,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST
    });
    this.shadowAtlas = device.createTexture({
      label: "Shadow Atlas Placeholder",
      size: [1, 1, 1],
      format: "depth32float",
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
    });
    this.pointShadowAtlas = device.createTexture({
      label: "Point Shadow Atlas Placeholder",
      size: [1, 1, 1],
      format: "r32float",
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
    });
    this._shadowsInitialized = false;
    this.shadowSampler = device.createSampler({
      compare: "less",
      magFilter: "linear",
      minFilter: "linear"
    });
    this.shadowUniformsBuffer = device.createBuffer({
      label: "Shadow Uniforms Buffer",
      size: SHADOW_UNIFORMS_SIZE,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.cascadeUniformsBuffer = device.createBuffer({
      label: "Cascade Uniforms Buffer",
      size: CASCADE_UNIFORMS_SIZE,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.pointShadowSampler = device.createSampler({
      label: "Point Shadow Sampler",
      magFilter: "nearest",
      minFilter: "nearest"
    });
  }
  get shadowsInitialized() {
    return this._shadowsInitialized;
  }
  resize(width, height) {
    this.hiZBuffer.resize(width, height);
    this._bindGroupsDirty = true;
  }
  resizeShadows(resolution, maxLights, device, pointShadowResolution, shadowsEnabled = true) {
    if (!shadowsEnabled) {
      return;
    }
    const pointRes = pointShadowResolution ?? 1024;
    let needsBindGroupRecreate = false;
    const spotLightLayers = Math.max(0, Math.min(MAX_SHADOW_LIGHTS, maxLights));
    const layers = CASCADE_COUNT + spotLightLayers;
    if (this.shadowAtlas && (this.shadowAtlas.width !== resolution || this.shadowAtlas.depthOrArrayLayers !== layers)) {
      this.shadowAtlas.destroy();
      activeShadowLayers = layers;
      const isFirstInit = !this._shadowsInitialized;
      console.log(`GlobalResources: ${isFirstInit ? "Creating" : "Resizing"} shadow atlas to ${resolution}x${resolution}x${layers} (${(resolution * resolution * layers * 4 / 1024 / 1024).toFixed(1)} MB)`);
      this.shadowAtlas = device.createTexture({
        label: "Shadow Atlas (Array)",
        size: [resolution, resolution, layers],
        format: "depth32float",
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
      });
      needsBindGroupRecreate = true;
    }
    const pointLayers = MAX_SHADOW_LIGHTS * 6;
    if (this.pointShadowAtlas && this.pointShadowAtlas.width !== pointRes) {
      this.pointShadowAtlas.destroy();
      const isFirstInit = !this._shadowsInitialized;
      console.log(`GlobalResources: ${isFirstInit ? "Creating" : "Resizing"} point shadow atlas to ${pointRes}x${pointRes}x${pointLayers} (${(pointRes * pointRes * pointLayers * 4 / 1024 / 1024).toFixed(1)} MB)`);
      this.pointShadowAtlas = device.createTexture({
        label: "Point Shadow Atlas (Cube Array)",
        size: [pointRes, pointRes, pointLayers],
        format: "r32float",
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
      });
      needsBindGroupRecreate = true;
    }
    if (needsBindGroupRecreate) {
      this._shadowsInitialized = true;
      this.createBindGroup(device);
    }
  }
  getShadowAtlasLayers() {
    return this.shadowAtlas?.depthOrArrayLayers ?? activeShadowLayers;
  }
  setAtmosphereLUTs(transmittance, scattering, irradiance, skyView, cloudNoise = null) {
    this.transmittanceLUT = transmittance;
    this.scatteringLUT = scattering;
    this.irradianceLUT = irradiance;
    this.skyViewLUT = skyView;
    this.cloudNoiseLUT = cloudNoise;
  }
  hasLoggedShadowUniforms = false;
  updateShadowUniforms(device, shadowLights, atlasResolution) {
    if (!this.shadowUniformsBuffer)
      return;
    if (!this.hasLoggedShadowUniforms && shadowLights.length > 0) {
      console.log("GlobalResources.updateShadowUniforms:", {
        numLights: shadowLights.length,
        lights: shadowLights.map((l, i) => ({
          index: i,
          atlasLayer: l.atlasLayer,
          bias: l.bias,
          viewProjDiag: [l.viewProj[0], l.viewProj[5], l.viewProj[10], l.viewProj[15]]
        }))
      });
      this.hasLoggedShadowUniforms = true;
    }
    const floatView = this.shadowUniformsFloatView;
    const uintView = this.shadowUniformsUintView;
    let offset = 0;
    for (let i = 0;i < MAX_SHADOW_LIGHTS; i++) {
      const light = shadowLights[i];
      if (light) {
        floatView.set(light.viewProj, offset);
        offset += 16;
        uintView[offset++] = light.atlasLayer;
        floatView[offset++] = light.bias;
        floatView[offset++] = light.normalBias;
        uintView[offset++] = 0;
      } else {
        offset += 20;
      }
    }
    uintView[offset++] = Math.min(shadowLights.length, MAX_SHADOW_LIGHTS);
    floatView[offset++] = atlasResolution;
    offset += 2;
    device.queue.writeBuffer(this.shadowUniformsBuffer, 0, this.shadowUniformsData);
  }
  updateCascadeUniforms(device, cascadeViewProjs, splits, biases) {
    if (!this.cascadeUniformsBuffer)
      return;
    const data = this.cascadeUniformsData;
    let offset = 0;
    for (let i = 0;i < CASCADE_COUNT; i++) {
      if (cascadeViewProjs[i]) {
        data.set(cascadeViewProjs[i], offset);
      }
      offset += 16;
    }
    data.set(splits, offset);
    offset += 4;
    data.set(biases, offset);
    device.queue.writeBuffer(this.cascadeUniformsBuffer, 0, data);
  }
  updateLightBuffer(device, scene, camera) {
    const activeLights = scene.getClosestLights(camera.transform.position, GlobalResources.MAX_STORAGE_LIGHTS);
    let spotShadowIndex = 0;
    let pointShadowLayerIndex = 0;
    for (const light of activeLights) {
      if (light.shadow.castShadow) {
        if (light.type === 0) {
          light.shadowAtlasIndex = 0;
        } else if (light.type === 2) {
          light.shadowAtlasIndex = spotShadowIndex++;
        } else if (light.type === 1) {
          light.shadowAtlasIndex = pointShadowLayerIndex++;
        } else {
          light.shadowAtlasIndex = -1;
        }
      } else {
        light.shadowAtlasIndex = -1;
      }
    }
    const floatView = this.lightBufferFloatView;
    const uintView = this.lightBufferUintView;
    uintView[0] = activeLights.length;
    let offset = 4;
    for (let i = 0;i < activeLights.length; i++) {
      const light = activeLights[i];
      const lPos = light.transform.position;
      floatView[offset++] = lPos.x;
      floatView[offset++] = lPos.y;
      floatView[offset++] = lPos.z;
      floatView[offset++] = 0;
      let lDir;
      if (light.type === 4 /* Hemisphere */) {
        lDir = light.direction;
      } else {
        lDir = light.transform.getForwardVector();
      }
      floatView[offset++] = lDir.x;
      floatView[offset++] = lDir.y;
      floatView[offset++] = lDir.z;
      floatView[offset++] = 0;
      floatView[offset++] = light.color.x;
      floatView[offset++] = light.color.y;
      floatView[offset++] = light.color.z;
      floatView[offset++] = light.intensity;
      if (light.type === 1 /* Point */) {
        const pointLight = light;
        floatView[offset++] = pointLight.distance;
        floatView[offset++] = pointLight.decay;
        floatView[offset++] = 0;
      } else if (light.type === 2 /* Spot */) {
        const spotLight = light;
        floatView[offset++] = spotLight.distance;
        floatView[offset++] = spotLight.decay;
        floatView[offset++] = 0;
      } else if (light.type === 4 /* Hemisphere */) {
        const hemiLight = light;
        floatView[offset++] = hemiLight.groundColor.x;
        floatView[offset++] = hemiLight.groundColor.y;
        floatView[offset++] = hemiLight.groundColor.z;
      } else {
        floatView[offset++] = 0;
        floatView[offset++] = 0;
        floatView[offset++] = 0;
      }
      uintView[offset++] = light.type;
      if (light.type === 2 /* Spot */) {
        const spot = light;
        floatView[offset++] = spot.innerAngle || 0;
        floatView[offset++] = spot.outerAngle || 0;
      } else {
        floatView[offset++] = 0;
        floatView[offset++] = 0;
      }
      const shadowIdx = light.shadow.castShadow ? light.shadowAtlasIndex : -1;
      uintView[offset++] = shadowIdx >>> 0;
      floatView[offset++] = light.shadow.radius;
      floatView[offset++] = light.shadow.intensity;
      floatView[offset++] = 0;
      floatView[offset++] = 0;
      floatView[offset++] = 0;
    }
    device.queue.writeBuffer(this.lightStorageBuffer, 0, this.lightBufferData);
  }
  createBindGroup(device) {
    const defaultEnv = CubeTexture.getDefault(device);
    const envMap = this.environmentMap || defaultEnv;
    if (!this.computeBindGroupLayout) {
      this.computeBindGroupLayout = device.createBindGroupLayout({
        label: "Global Compute Bind Group Layout",
        entries: [
          { binding: 0, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE, buffer: { type: "uniform" } },
          { binding: 1, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE, buffer: { type: "read-only-storage" } },
          { binding: 2, visibility: GPUShaderStage.COMPUTE, texture: { sampleType: "unfilterable-float", viewDimension: "2d" } },
          { binding: 3, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT | GPUShaderStage.COMPUTE, buffer: { type: "read-only-storage" } },
          { binding: 4, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "depth", viewDimension: "2d-array" } },
          { binding: 5, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "comparison" } },
          { binding: 6, visibility: GPUShaderStage.FRAGMENT, texture: { viewDimension: "cube" } },
          { binding: 7, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "filtering" } },
          { binding: 8, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
          { binding: 9, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "unfilterable-float", viewDimension: "2d-array" } },
          { binding: 10, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "non-filtering" } },
          { binding: 11, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } }
        ]
      });
    }
    this.computeBindGroup = device.createBindGroup({
      label: "Global Compute Bind Group",
      layout: this.computeBindGroupLayout,
      entries: [
        { binding: 0, resource: { buffer: this.sceneUniforms.buffer } },
        { binding: 1, resource: { buffer: this.objectBuffer.buffer } },
        { binding: 2, resource: this.hiZBuffer.texture ? this.hiZBuffer.texture.createView() : undefined },
        { binding: 3, resource: { buffer: this.lightStorageBuffer } },
        { binding: 4, resource: this.shadowAtlas.createView({ dimension: "2d-array" }) },
        { binding: 5, resource: this.shadowSampler },
        { binding: 6, resource: envMap.view },
        { binding: 7, resource: envMap.sampler },
        { binding: 8, resource: { buffer: this.shadowUniformsBuffer } },
        { binding: 9, resource: this.pointShadowAtlas.createView({ dimension: "2d-array" }) },
        { binding: 10, resource: this.pointShadowSampler },
        { binding: 11, resource: { buffer: this.cascadeUniformsBuffer } }
      ]
    });
    if (!this.renderBindGroupLayout) {
      this.renderBindGroupLayout = device.createBindGroupLayout({
        label: "Global Render Bind Group Layout",
        entries: [
          { binding: 0, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
          { binding: 1, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: "read-only-storage" } },
          { binding: 3, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: "read-only-storage" } },
          { binding: 4, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "depth", viewDimension: "2d-array" } },
          { binding: 5, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "comparison" } },
          { binding: 6, visibility: GPUShaderStage.FRAGMENT, texture: { viewDimension: "cube" } },
          { binding: 7, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "filtering" } },
          { binding: 8, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
          { binding: 9, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "unfilterable-float", viewDimension: "2d-array" } },
          { binding: 10, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "non-filtering" } },
          { binding: 11, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } }
        ]
      });
    }
    this.renderBindGroup = device.createBindGroup({
      label: "Global Render Bind Group",
      layout: this.renderBindGroupLayout,
      entries: [
        { binding: 0, resource: { buffer: this.sceneUniforms.buffer } },
        { binding: 1, resource: { buffer: this.objectBuffer.buffer } },
        { binding: 3, resource: { buffer: this.lightStorageBuffer } },
        { binding: 4, resource: this.shadowAtlas.createView({ dimension: "2d-array" }) },
        { binding: 5, resource: this.shadowSampler },
        { binding: 6, resource: envMap.view },
        { binding: 7, resource: envMap.sampler },
        { binding: 8, resource: { buffer: this.shadowUniformsBuffer } },
        { binding: 9, resource: this.pointShadowAtlas.createView({ dimension: "2d-array" }) },
        { binding: 10, resource: this.pointShadowSampler },
        { binding: 11, resource: { buffer: this.cascadeUniformsBuffer } }
      ]
    });
    if (this.transmittanceLUT && this.skyViewLUT) {
      if (!this.nearestSampler) {
        this.nearestSampler = device.createSampler({
          minFilter: "nearest",
          magFilter: "nearest"
        });
      }
      if (!this.linearSampler) {
        this.linearSampler = device.createSampler({
          minFilter: "linear",
          magFilter: "linear",
          mipmapFilter: "linear",
          addressModeU: "repeat",
          addressModeV: "repeat",
          addressModeW: "repeat"
        });
      }
      if (!this.atmosphereUniformsBuffer) {
        this.atmosphereUniformsBuffer = device.createBuffer({
          label: "Atmosphere Uniforms Buffer",
          size: 512,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        });
      }
      if (!this.atmosphereBindGroupLayout) {
        this.atmosphereBindGroupLayout = device.createBindGroupLayout({
          label: "Atmosphere Bind Group Layout (SkyboxPass)",
          entries: [
            { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "unfilterable-float", viewDimension: "2d" } },
            { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "unfilterable-float", viewDimension: "2d" } },
            { binding: 2, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
            { binding: 3, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "non-filtering" } },
            { binding: 4, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "float", viewDimension: "3d" } },
            { binding: 5, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "filtering" } }
          ]
        });
      }
      const noiseView = this.cloudNoiseLUT ? this.cloudNoiseLUT.createView() : this.transmittanceLUT.createView();
      this.atmosphereBindGroup = device.createBindGroup({
        label: "Atmosphere Bind Group (SkyboxPass)",
        layout: this.atmosphereBindGroupLayout,
        entries: [
          { binding: 0, resource: this.transmittanceLUT.createView() },
          { binding: 1, resource: this.skyViewLUT.createView() },
          { binding: 2, resource: { buffer: this.atmosphereUniformsBuffer } },
          { binding: 3, resource: this.nearestSampler },
          { binding: 4, resource: noiseView },
          { binding: 5, resource: this.linearSampler }
        ]
      });
    }
  }
}

// ../../src/core/procedural/water/WaterMaterial.ts
var DEFAULT_WATER_MATERIAL_CONFIG = {
  shallowColor: new Vector3(0, 0.5, 0.8),
  deepColor: new Vector3(0, 0.1, 0.25),
  opacity: 0.95,
  roughness: 0.05,
  fresnelPower: 5,
  fresnelBias: 0.02,
  skyReflectionBlend: 0.3,
  refractionStrength: 0.05,
  chromaticAberration: true,
  chromaticAberrationStrength: 0.01,
  depthFadeDistance: 10,
  foamEnabled: false,
  foamIntensity: 0.5,
  foamColor: new Vector3(1, 1, 1),
  foamSpeed: 1,
  causticsEnabled: true,
  causticsIntensity: 0.15,
  causticsScale: 8,
  causticsOctaves: 4,
  scatterColor: new Vector3(0, 0.7, 0.6),
  scatterIntensity: 0.4,
  waveHeightMultiplier: 1,
  ssrEnabled: false,
  ssrStrength: 0.5,
  refractionEnabled: false
};
var MAX_LIGHTS = 8;

class WaterMaterial extends Material {
  config;
  alphaMode = "BLEND";
  opacity = 0.8;
  displacementTexture = null;
  waveNormalTexture = null;
  depthTexture = null;
  ssrTexture = null;
  sceneColorTexture = null;
  normalMap = null;
  foamTexture = null;
  time = 0;
  worldSize = { width: 100, depth: 100 };
  screenWidth = 1920;
  screenHeight = 1080;
  constructor(config = {}) {
    super();
    this.config = { ...DEFAULT_WATER_MATERIAL_CONFIG, ...config };
    this.opacity = this.config.opacity;
    this.initShaders();
  }
  initShaders() {
    const commonDefines = `
      struct Light {
        position: vec3f,
        _pad1: f32,
        direction: vec3f,
        _pad2: f32,
        color: vec3f,
        intensity: f32,
        attenuation: vec3f,
        lightType: u32,
        coneAngles: vec2f,
        shadowIndex: i32,
        shadowRadius: f32,
        shadowIntensity: f32,
        _pad3: f32,
        _pad4: f32,
        _pad5: f32,
      }

      struct SceneUniforms {
        viewMatrix : mat4x4<f32>,
        projectionMatrix : mat4x4<f32>,
        lightViewProj : mat4x4<f32>,
        prevViewProj : mat4x4<f32>,
        inverseProjectionMatrix : mat4x4<f32>,
        cameraPosition : vec3f,
        time : f32,
        lightCount : u32,
        debugMode : u32,
        flags : u32,
        environmentIntensity : f32,
        fogColor: vec3f,
        fogDensity: f32,
        fogParams: vec4f,
        fogSettings: vec4u,
        lights : array<Light, ${MAX_LIGHTS}>,
      }

      struct ObjectData {
        modelMatrix : mat4x4<f32>,
        normalMatrix : mat4x4<f32>,
        aabbMin : vec3f,
        _pad1 : f32,
        aabbMax : vec3f,
        _pad2 : f32,
        prevModelMatrix : mat4x4<f32>,
        _pad3 : vec4<f32>,
        _pad4 : vec4<f32>,
      }

      struct WaterUniforms {
        shallowColor: vec3f,
        opacity: f32,
        deepColor: vec3f,
        roughness: f32,
        fresnelPower: f32,
        fresnelBias: f32,
        skyReflectionBlend: f32,
        refractionStrength: f32,
        depthFadeDistance: f32,
        foamEnabled: u32,
        foamIntensity: f32,
        causticsEnabled: u32,
        foamColor: vec3f,
        causticsIntensity: f32,
        scatterColor: vec3f,
        scatterIntensity: f32,
        causticsScale: f32,
        waveHeightMultiplier: f32,
        time: f32,
        worldWidth: f32,
        worldDepth: f32,
        screenWidth: f32,
        screenHeight: f32,
        nearPlane: f32,
        farPlane: f32,
        // New uniforms for improved water
        ssrEnabled: u32,
        ssrStrength: f32,
        refractionEnabled: u32,
        chromaticAberration: u32,
        chromaticAberrationStrength: f32,
        foamSpeed: f32,
        causticsOctaves: u32,
        _pad: f32,
      }

      @group(0) @binding(0) var<uniform> scene : SceneUniforms;
      @group(0) @binding(1) var<storage, read> objects : array<ObjectData>;

      @group(1) @binding(0) var<uniform> water : WaterUniforms;
      @group(1) @binding(1) var linearSampler : sampler;
      @group(1) @binding(2) var displacementTex : texture_2d<f32>;
      @group(1) @binding(3) var waveNormalTex : texture_2d<f32>;
      @group(1) @binding(4) var sceneDepthTex : texture_depth_2d;
      @group(1) @binding(5) var depthSampler : sampler;
      @group(1) @binding(6) var ssrTex : texture_2d<f32>;
      @group(1) @binding(7) var sceneColorTex : texture_2d<f32>;
      @group(1) @binding(8) var foamTex : texture_2d<f32>;

      struct VertexInput {
        @location(0) position : vec3<f32>,
        @location(1) normal : vec3<f32>,
        @location(2) uv : vec2<f32>,
      }

      struct VertexOutput {
        @builtin(position) position : vec4<f32>,
        @location(0) worldNormal : vec3<f32>,
        @location(1) uv : vec2<f32>,
        @location(2) worldPosition : vec3<f32>,
        @location(3) foam : f32,
        @location(4) clipPosition : vec4<f32>,
      }
    `;
    this.vertexShaderCode = `
      ${commonDefines}

      @vertex
      fn vs_main(input : VertexInput, @builtin(instance_index) instanceIndex : u32) -> VertexOutput {
        var output : VertexOutput;

        let modelMatrix = objects[instanceIndex].modelMatrix;
        let normalMatrix = objects[instanceIndex].normalMatrix;

        // Calculate UV for wave sampling (based on world position)
        let localWorldPos = (modelMatrix * vec4<f32>(input.position, 1.0)).xyz;
        let waveUV = vec2f(
          (localWorldPos.x / water.worldWidth) + 0.5,
          (localWorldPos.z / water.worldDepth) + 0.5
        );

        // Sample displacement texture
        let displacement = textureSampleLevel(displacementTex, linearSampler, waveUV, 0.0);

        // Apply wave displacement
        var displacedPosition = input.position;
        displacedPosition.x += displacement.x * water.waveHeightMultiplier;
        displacedPosition.y += displacement.y * water.waveHeightMultiplier;
        displacedPosition.z += displacement.z * water.waveHeightMultiplier;

        let worldPos = modelMatrix * vec4<f32>(displacedPosition, 1.0);
        output.worldPosition = worldPos.xyz;

        let clipPos = scene.projectionMatrix * scene.viewMatrix * worldPos;
        output.position = clipPos;

        // Pass clip position to fragment shader for depth sampling
        output.clipPosition = clipPos;

        // Sample wave normal
        let waveNormal = textureSampleLevel(waveNormalTex, linearSampler, waveUV, 0.0).xyz * 2.0 - 1.0;

        // Transform normal to world space
        let baseNormal = normalize((normalMatrix * vec4<f32>(input.normal, 0.0)).xyz);

        // Blend base normal with wave normal
        let tangent = normalize(cross(baseNormal, vec3f(0.0, 0.0, 1.0)));
        let bitangent = normalize(cross(baseNormal, tangent));
        let TBN = mat3x3f(tangent, bitangent, baseNormal);
        output.worldNormal = normalize(TBN * waveNormal);

        output.uv = input.uv;
        output.foam = displacement.w;

        return output;
      }
    `;
    this.fragmentShaderCode = `
      ${commonDefines}

      const PI = 3.14159265359;

      // Hash functions for procedural noise
      fn hash21(p: vec2f) -> f32 {
        var p3 = fract(vec3f(p.xyx) * 0.1031);
        p3 += dot(p3, p3.yzx + 33.33);
        return fract((p3.x + p3.y) * p3.z);
      }

      fn hash22(p: vec2f) -> vec2f {
        let n = sin(dot(p, vec2f(41.0, 289.0)));
        return fract(vec2f(262144.0, 32768.0) * n) * 2.0 - 1.0;
      }

      // Smooth noise for caustics and foam
      fn noise2D(p: vec2f) -> f32 {
        let i = floor(p);
        let f = fract(p);
        let u = f * f * (3.0 - 2.0 * f);

        return mix(
          mix(hash21(i + vec2f(0.0, 0.0)), hash21(i + vec2f(1.0, 0.0)), u.x),
          mix(hash21(i + vec2f(0.0, 1.0)), hash21(i + vec2f(1.0, 1.0)), u.x),
          u.y
        );
      }

      // FBM noise for more detailed foam
      fn fbm(p: vec2f, octaves: i32) -> f32 {
        var value = 0.0;
        var amplitude = 0.5;
        var frequency = 1.0;
        var pp = p;

        for (var i = 0; i < octaves; i++) {
          value += amplitude * noise2D(pp * frequency);
          amplitude *= 0.5;
          frequency *= 2.0;
        }
        return value;
      }

      // Enhanced Voronoi-based caustics pattern with configurable octaves
      fn caustics(uv: vec2f, time: f32, octaves: u32) -> f32 {
        var c = 0.0;
        let numLayers = min(i32(octaves), 5);

        // Multiple layers for complex pattern
        for (var i = 0; i < numLayers; i++) {
          let scale = 1.0 + f32(i) * 0.4;
          let speed = 0.5 + f32(i) * 0.15;
          let weight = 1.0 / (f32(i) + 1.0);

          // Offset each layer slightly for more variation
          let offset = vec2f(f32(i) * 17.3, f32(i) * 31.7);
          let p = uv * scale + offset + vec2f(time * speed * 0.1, time * speed * 0.07);

          // Voronoi-like pattern
          let ip = floor(p);
          let fp = fract(p);

          var minDist = 1.0;
          var secondMinDist = 1.0;

          for (var y = -1; y <= 1; y++) {
            for (var x = -1; x <= 1; x++) {
              let neighbor = vec2f(f32(x), f32(y));
              let point = hash22(ip + neighbor) * 0.5 + 0.5;
              // More complex animation with multiple frequencies
              let animPoint = point + 0.25 * sin(time * 0.5 + 6.28 * point)
                                     + 0.1 * sin(time * 1.3 + 3.14 * point.yx);
              let diff = neighbor + animPoint - fp;
              let dist = length(diff);

              if (dist < minDist) {
                secondMinDist = minDist;
                minDist = dist;
              } else if (dist < secondMinDist) {
                secondMinDist = dist;
              }
            }
          }

          // Use edge distance for more caustic-like pattern
          let edge = secondMinDist - minDist;
          c += pow(1.0 - edge * 2.0, 2.0) * weight;
        }

        // Apply power curve for sharper, more realistic caustics
        return pow(clamp(c * 0.4, 0.0, 1.0), 1.5);
      }

      // Fresnel calculation
      fn fresnel(viewDir: vec3f, normal: vec3f, power: f32, bias: f32) -> f32 {
        let NdotV = max(dot(normal, viewDir), 0.0);
        return bias + (1.0 - bias) * pow(1.0 - NdotV, power);
      }

      // GGX distribution
      fn distributionGGX(N: vec3f, H: vec3f, roughness: f32) -> f32 {
        let a = roughness * roughness;
        let a2 = a * a;
        let NdotH = max(dot(N, H), 0.0);
        let NdotH2 = NdotH * NdotH;
        let num = a2;
        let denom = (NdotH2 * (a2 - 1.0) + 1.0);
        return num / (PI * denom * denom);
      }

      // Detail normal from procedural noise
      fn getDetailNormal(worldPos: vec3f, time: f32) -> vec3f {
        let scale1 = 0.5;
        let scale2 = 1.5;

        let uv1 = worldPos.xz * scale1 + vec2f(time * 0.02, time * 0.015);
        let uv2 = worldPos.xz * scale2 + vec2f(-time * 0.03, time * 0.02);

        let h1 = noise2D(uv1);
        let h2 = noise2D(uv2) * 0.5;

        // Calculate normal from height
        let eps = 0.1;
        let h1x = noise2D(uv1 + vec2f(eps, 0.0)) + noise2D(uv2 + vec2f(eps, 0.0)) * 0.5;
        let h1z = noise2D(uv1 + vec2f(0.0, eps)) + noise2D(uv2 + vec2f(0.0, eps)) * 0.5;

        let dx = (h1x - h1 - h2) / eps;
        let dz = (h1z - h1 - h2) / eps;

        return normalize(vec3f(-dx * 0.3, 1.0, -dz * 0.3));
      }

      // Linearize depth from [0,1] non-linear to linear view-space depth
      fn linearizeDepth(depth: f32, near: f32, far: f32) -> f32 {
        return near * far / (far - depth * (far - near));
      }

      // Sample scene color with chromatic aberration for refraction
      fn sampleRefractionColor(baseUV: vec2f, offset: vec2f, chromaticStrength: f32, chromaticEnabled: bool) -> vec3f {
        if (chromaticEnabled && chromaticStrength > 0.0) {
          // Sample R, G, B at slightly different offsets for chromatic aberration
          let rOffset = offset * (1.0 + chromaticStrength);
          let gOffset = offset;
          let bOffset = offset * (1.0 - chromaticStrength);

          let rUV = clamp(baseUV + rOffset, vec2f(0.001), vec2f(0.999));
          let gUV = clamp(baseUV + gOffset, vec2f(0.001), vec2f(0.999));
          let bUV = clamp(baseUV + bOffset, vec2f(0.001), vec2f(0.999));

          let r = textureSample(sceneColorTex, linearSampler, rUV).r;
          let g = textureSample(sceneColorTex, linearSampler, gUV).g;
          let b = textureSample(sceneColorTex, linearSampler, bUV).b;

          return vec3f(r, g, b);
        } else {
          let refractUV = clamp(baseUV + offset, vec2f(0.001), vec2f(0.999));
          return textureSample(sceneColorTex, linearSampler, refractUV).rgb;
        }
      }

      @fragment
      fn fs_main(
        @builtin(position) fragCoord : vec4f,
        @location(0) worldNormal : vec3f,
        @location(1) uv : vec2f,
        @location(2) worldPosition : vec3f,
        @location(3) foam : f32,
        @location(4) clipPosition : vec4f
      ) -> @location(0) vec4f {
        // Calculate screen UV from fragment position
        let screenUV = vec2f(fragCoord.x / water.screenWidth, fragCoord.y / water.screenHeight);

        // Sample scene depth to calculate water depth
        let sceneDepthRaw = textureSample(sceneDepthTex, depthSampler, screenUV);
        let sceneDepthLinear = linearizeDepth(sceneDepthRaw, water.nearPlane, water.farPlane);

        // Water surface depth (from clip position)
        let waterDepthLinear = linearizeDepth(fragCoord.z, water.nearPlane, water.farPlane);

        // Calculate actual water depth (distance from surface to scene geometry behind)
        let waterDepth = max(0.0, sceneDepthLinear - waterDepthLinear);

        // Depth factor for color and opacity (0 = surface, 1 = deep)
        let depthFactor = clamp(waterDepth / water.depthFadeDistance, 0.0, 1.0);

        // Add detail normal for micro-ripples
        let detailNormal = getDetailNormal(worldPosition, water.time);
        let N = normalize(mix(worldNormal, detailNormal, 0.3));

        let V = normalize(scene.cameraPosition - worldPosition);
        let NdotV = max(dot(N, V), 0.0);

        // Fresnel term - high at glancing angles (more reflection), low when looking down (more see-through)
        let fresnelTerm = fresnel(V, N, water.fresnelPower, water.fresnelBias);

        // Water color based on actual depth - shallow to deep gradient
        let waterColor = mix(water.shallowColor, water.deepColor, depthFactor);

        // === REFRACTION - Sample scene color behind water ===
        var refractionColor = vec3f(0.0);
        if (water.refractionEnabled == 1u) {
          // Calculate refraction offset based on wave normal
          let refractionOffset = N.xz * water.refractionStrength * (1.0 - depthFactor * 0.5);
          let chromaticEnabled = water.chromaticAberration == 1u;
          refractionColor = sampleRefractionColor(screenUV, refractionOffset, water.chromaticAberrationStrength, chromaticEnabled);

          // Tint refracted color with water color based on depth
          refractionColor = mix(refractionColor, refractionColor * waterColor * 2.0, depthFactor * 0.7);
        }

        // === SKY REFLECTION ===
        let reflectDir = reflect(-V, N);
        let skyT = clamp(reflectDir.y * 0.5 + 0.5, 0.0, 1.0);
        let horizonColor = vec3f(0.7, 0.8, 0.9);
        let zenithColor = vec3f(0.3, 0.5, 0.85);
        var reflectionColor = mix(horizonColor, zenithColor, skyT);

        // === SSR INTEGRATION - Sample screen-space reflections ===
        if (water.ssrEnabled == 1u) {
          let ssrSample = textureSample(ssrTex, linearSampler, screenUV);
          let ssrColor = ssrSample.rgb;
          let ssrAlpha = ssrSample.a;

          // Blend SSR with sky reflection - SSR takes priority when available
          if (ssrAlpha > 0.01) {
            reflectionColor = mix(reflectionColor, ssrColor, ssrAlpha * water.ssrStrength);
          }
        }

        // Subsurface scattering - stronger in shallow water where light penetrates
        var sss = vec3f(0.0);
        let sssDepthFactor = 1.0 - depthFactor; // More SSS in shallow water
        for (var i = 0u; i < scene.lightCount; i++) {
          let light = scene.lights[i];
          var L = vec3f(0.0);

          if (light.lightType == 0u) {
            L = normalize(-light.direction);
          } else {
            L = normalize(light.position - worldPosition);
          }

          let LdotV = max(dot(L, -V), 0.0);
          let scatter = pow(LdotV, 3.0) * NdotV * sssDepthFactor;
          sss += water.scatterColor * scatter * light.color * light.intensity * water.scatterIntensity;
        }

        // === ENHANCED CAUSTICS - more visible in shallow water ===
        var causticsColor = vec3f(0.0);
        if (water.causticsEnabled == 1u) {
          let causticsUV = worldPosition.xz * water.causticsScale * 0.01;
          let causticsValue = caustics(causticsUV, water.time, water.causticsOctaves);
          let causticsStrength = (1.0 - fresnelTerm) * (1.0 - depthFactor * 0.7);

          // Use slightly warm tint for caustics (sunlight through water)
          let causticsTint = vec3f(1.0, 0.98, 0.9);
          causticsColor = causticsTint * causticsValue * water.causticsIntensity * causticsStrength;
        }

        // === COMPOSE FINAL COLOR ===
        // Start with base color: blend between refraction and water color
        var finalColor = waterColor;
        if (water.refractionEnabled == 1u) {
          // Blend refraction with water color based on fresnel and depth
          // When depthFactor is very high (>0.95), there's likely no geometry behind the water
          // (we're seeing the sky/background), so reduce refraction to avoid washed-out look
          let hasGeometryBehind = smoothstep(0.95, 0.8, depthFactor); // 1.0 when geometry present, 0.0 when sky
          let refractionBlend = (1.0 - fresnelTerm) * (1.0 - depthFactor * 0.3) * hasGeometryBehind;
          finalColor = mix(waterColor, refractionColor, refractionBlend * 0.8);
        }

        // Add subsurface scattering and caustics
        finalColor += sss + causticsColor;

        // Add reflection based on fresnel
        finalColor = mix(finalColor, reflectionColor, fresnelTerm * water.skyReflectionBlend);

        // Specular highlights from lights
        for (var i = 0u; i < scene.lightCount; i++) {
          let light = scene.lights[i];
          var L = vec3f(0.0);
          var attenuation = 1.0;

          if (light.lightType == 0u) {
            L = normalize(-light.direction);
          } else {
            let lightVec = light.position - worldPosition;
            let dist = length(lightVec);
            L = normalize(lightVec);
            attenuation = 1.0 / (1.0 + 0.09 * dist + 0.032 * dist * dist);
          }

          let H = normalize(V + L);
          let NdotL = max(dot(N, L), 0.0);

          // Specular (sun glitter)
          let D = distributionGGX(N, H, water.roughness);
          let specular = D * fresnelTerm;

          finalColor += specular * light.color * light.intensity * attenuation * NdotL * 0.3;
        }

        // === ENHANCED FOAM ===
        if (water.foamEnabled == 1u && water.foamIntensity > 0.0) {
          let timeOffset = water.time * water.foamSpeed;

          // Sample foam texture if available, otherwise use procedural
          let foamUV = worldPosition.xz * 0.1;
          var foamSample = textureSample(foamTex, linearSampler, foamUV).r;

          // Fallback to procedural foam if texture is placeholder (all 1s)
          if (foamSample > 0.99) {
            // Animated procedural foam pattern
            let foamPattern1 = fbm(worldPosition.xz * 2.0 + vec2f(timeOffset * 0.1, 0.0), 3);
            let foamPattern2 = fbm(worldPosition.xz * 4.0 + vec2f(0.0, timeOffset * 0.15) + vec2f(100.0, 50.0), 2);
            let foamPattern3 = noise2D(worldPosition.xz * 8.0 - vec2f(timeOffset * 0.2, timeOffset * 0.1));
            foamSample = foamPattern1 * 0.5 + foamPattern2 * 0.35 + foamPattern3 * 0.15;
          }

          // Edge foam where water is very shallow (main foam source)
          let edgeThreshold = 0.4;
          let shallowFactor = 1.0 - smoothstep(0.0, edgeThreshold, depthFactor);
          let edgeFoam = shallowFactor * foamSample;

          // Dynamic foam at wave crests - use foam input from vertex shader
          let crestFoam = foam * 0.5 * foamSample;

          // Wave intersection foam (where waves meet)
          let waveIntersection = pow(max(0.0, 1.0 - abs(N.y)), 3.0) * 0.3 * foamSample;

          // Combine all foam sources
          let totalFoam = clamp((edgeFoam + crestFoam + waveIntersection) * water.foamIntensity, 0.0, 0.9);

          if (totalFoam > 0.03) {
            // Add subtle animation to foam color
            let foamBrightness = 1.0 + 0.1 * sin(water.time * 2.0 + worldPosition.x * 0.5);
            let animatedFoamColor = water.foamColor * foamBrightness;
            finalColor = mix(finalColor, animatedFoamColor, totalFoam);
          }
        }

        // Opacity: shallow water = more transparent, deep water = more opaque
        // Also factor in fresnel: glancing angles = more opaque (reflection)
        // The opacity setting now properly scales the entire opacity range
        var finalOpacity = water.opacity;
        if (water.refractionEnabled == 1u) {
          // With refraction, use mostly high opacity so refraction shows through alpha blend
          let depthOpacity = water.opacity * mix(0.5, 1.0, depthFactor);
          finalOpacity = depthOpacity + fresnelTerm * (1.0 - depthOpacity) * 0.4;
        } else {
          // Scale opacity by depth: shallow = 30% of opacity, deep = 100% of opacity
          let depthOpacity = water.opacity * mix(0.3, 1.0, depthFactor);
          finalOpacity = depthOpacity + fresnelTerm * (1.0 - depthOpacity) * 0.5;
        }

        return vec4f(finalColor, clamp(finalOpacity, 0.0, 1.0));
      }
    `;
  }
  getRenderingPath() {
    return "forward";
  }
  getVertexShader(_pass) {
    return this.vertexShaderCode;
  }
  getFragmentShader(_pass) {
    return this.fragmentShaderCode;
  }
  getUniformBufferSize() {
    return 176;
  }
  updateUniforms(device, buffer, _offset, _context) {
    const arrayBuffer = new ArrayBuffer(this.getUniformBufferSize());
    const floatView = new Float32Array(arrayBuffer);
    const uintView = new Uint32Array(arrayBuffer);
    let i = 0;
    floatView[i++] = this.config.shallowColor.x;
    floatView[i++] = this.config.shallowColor.y;
    floatView[i++] = this.config.shallowColor.z;
    floatView[i++] = this.config.opacity;
    floatView[i++] = this.config.deepColor.x;
    floatView[i++] = this.config.deepColor.y;
    floatView[i++] = this.config.deepColor.z;
    floatView[i++] = this.config.roughness;
    floatView[i++] = this.config.fresnelPower;
    floatView[i++] = this.config.fresnelBias;
    floatView[i++] = this.config.skyReflectionBlend;
    floatView[i++] = this.config.refractionStrength;
    floatView[i++] = this.config.depthFadeDistance;
    uintView[i++] = this.config.foamEnabled ? 1 : 0;
    floatView[i++] = this.config.foamIntensity;
    uintView[i++] = this.config.causticsEnabled ? 1 : 0;
    floatView[i++] = this.config.foamColor.x;
    floatView[i++] = this.config.foamColor.y;
    floatView[i++] = this.config.foamColor.z;
    floatView[i++] = this.config.causticsIntensity;
    floatView[i++] = this.config.scatterColor.x;
    floatView[i++] = this.config.scatterColor.y;
    floatView[i++] = this.config.scatterColor.z;
    floatView[i++] = this.config.scatterIntensity;
    floatView[i++] = this.config.causticsScale;
    floatView[i++] = this.config.waveHeightMultiplier;
    floatView[i++] = this.time;
    floatView[i++] = this.worldSize.width;
    floatView[i++] = this.worldSize.depth;
    floatView[i++] = this.screenWidth;
    floatView[i++] = this.screenHeight;
    floatView[i++] = _context?.camera?.near ?? 0.1;
    floatView[i++] = _context?.camera?.far ?? 1000;
    uintView[i++] = this.config.ssrEnabled ? 1 : 0;
    floatView[i++] = this.config.ssrStrength;
    uintView[i++] = this.config.refractionEnabled ? 1 : 0;
    uintView[i++] = this.config.chromaticAberration ? 1 : 0;
    floatView[i++] = this.config.chromaticAberrationStrength;
    floatView[i++] = this.config.foamSpeed;
    uintView[i++] = this.config.causticsOctaves;
    floatView[i++] = 0;
    floatView[i++] = 0;
    floatView[i++] = 0;
    floatView[i++] = 0;
    device.queue.writeBuffer(buffer, 0, arrayBuffer);
  }
  getBindGroupEntries(device, uniformBuffer) {
    const defaultTex = Texture.getDefault(device);
    const linearSampler = device.createSampler({
      magFilter: "linear",
      minFilter: "linear",
      mipmapFilter: "linear",
      addressModeU: "repeat",
      addressModeV: "repeat"
    });
    const depthSampler = device.createSampler({
      magFilter: "nearest",
      minFilter: "nearest"
    });
    const displacementView = this.displacementTexture?.createView() ?? defaultTex.view;
    const normalView = this.waveNormalTexture?.createView() ?? defaultTex.view;
    let depthView;
    if (this.depthTexture) {
      depthView = this.depthTexture.createView();
    } else {
      const dummyDepth = device.createTexture({
        size: [1, 1],
        format: "depth32float",
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT
      });
      depthView = dummyDepth.createView();
    }
    const ssrView = this.ssrTexture ? this.ssrTexture.createView() : defaultTex.view;
    const sceneColorView = this.sceneColorTexture ? this.sceneColorTexture.createView() : defaultTex.view;
    const foamView = this.foamTexture ? this.foamTexture.view : defaultTex.view;
    return [
      { binding: 0, resource: { buffer: uniformBuffer } },
      { binding: 1, resource: linearSampler },
      { binding: 2, resource: displacementView },
      { binding: 3, resource: normalView },
      { binding: 4, resource: depthView },
      { binding: 5, resource: depthSampler },
      { binding: 6, resource: ssrView },
      { binding: 7, resource: sceneColorView },
      { binding: 8, resource: foamView }
    ];
  }
  createBindGroupLayout(device) {
    return device.createBindGroupLayout({
      label: "WaterMaterial Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
        { binding: 1, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, sampler: { type: "filtering" } },
        { binding: 2, visibility: GPUShaderStage.VERTEX, texture: { sampleType: "float" } },
        { binding: 3, visibility: GPUShaderStage.VERTEX, texture: {} },
        { binding: 4, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "depth" } },
        { binding: 5, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "non-filtering" } },
        { binding: 6, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "float" } },
        { binding: 7, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "float" } },
        { binding: 8, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "float" } }
      ]
    });
  }
  setShallowColor(color) {
    this.config.shallowColor = color;
  }
  setDeepColor(color) {
    this.config.deepColor = color;
  }
  setOpacity(opacity) {
    this.config.opacity = Math.max(0, Math.min(1, opacity));
    this.opacity = this.config.opacity;
  }
  getConfig() {
    return { ...this.config };
  }
  setConfig(config) {
    if (config.shallowColor)
      this.config.shallowColor = config.shallowColor;
    if (config.deepColor)
      this.config.deepColor = config.deepColor;
    if (config.opacity !== undefined)
      this.config.opacity = config.opacity;
    if (config.roughness !== undefined)
      this.config.roughness = config.roughness;
    if (config.fresnelPower !== undefined)
      this.config.fresnelPower = config.fresnelPower;
    if (config.fresnelBias !== undefined)
      this.config.fresnelBias = config.fresnelBias;
    if (config.skyReflectionBlend !== undefined)
      this.config.skyReflectionBlend = config.skyReflectionBlend;
    if (config.refractionStrength !== undefined)
      this.config.refractionStrength = config.refractionStrength;
    if (config.chromaticAberration !== undefined)
      this.config.chromaticAberration = config.chromaticAberration;
    if (config.chromaticAberrationStrength !== undefined)
      this.config.chromaticAberrationStrength = config.chromaticAberrationStrength;
    if (config.depthFadeDistance !== undefined)
      this.config.depthFadeDistance = config.depthFadeDistance;
    if (config.foamEnabled !== undefined)
      this.config.foamEnabled = config.foamEnabled;
    if (config.foamIntensity !== undefined)
      this.config.foamIntensity = config.foamIntensity;
    if (config.foamColor)
      this.config.foamColor = config.foamColor;
    if (config.foamSpeed !== undefined)
      this.config.foamSpeed = config.foamSpeed;
    if (config.causticsEnabled !== undefined)
      this.config.causticsEnabled = config.causticsEnabled;
    if (config.causticsIntensity !== undefined)
      this.config.causticsIntensity = config.causticsIntensity;
    if (config.causticsScale !== undefined)
      this.config.causticsScale = config.causticsScale;
    if (config.causticsOctaves !== undefined)
      this.config.causticsOctaves = config.causticsOctaves;
    if (config.scatterColor)
      this.config.scatterColor = config.scatterColor;
    if (config.scatterIntensity !== undefined)
      this.config.scatterIntensity = config.scatterIntensity;
    if (config.waveHeightMultiplier !== undefined)
      this.config.waveHeightMultiplier = config.waveHeightMultiplier;
    if (config.ssrEnabled !== undefined)
      this.config.ssrEnabled = config.ssrEnabled;
    if (config.ssrStrength !== undefined)
      this.config.ssrStrength = config.ssrStrength;
    if (config.refractionEnabled !== undefined)
      this.config.refractionEnabled = config.refractionEnabled;
  }
}

// ../../src/core/procedural/water/WaveGenerator.ts
var DEFAULT_WAVE_CONFIG = {
  waveType: "gerstner",
  resolution: 256,
  worldSize: { width: 100, depth: 100 },
  waves: [
    { direction: new Vector2(1, 0), steepness: 0.5, wavelength: 10, speed: 1 },
    { direction: new Vector2(0.7, 0.7), steepness: 0.3, wavelength: 5, speed: 1.2 },
    { direction: new Vector2(-0.3, 0.9), steepness: 0.2, wavelength: 3, speed: 0.8 },
    { direction: new Vector2(0.5, -0.8), steepness: 0.15, wavelength: 2, speed: 1.5 }
  ]
};
var MAX_WAVES = 8;

class WaveGenerator {
  config;
  _device = null;
  initialized = false;
  displacementTexture = null;
  normalTexture = null;
  computePipeline = null;
  bindGroup = null;
  uniformBuffer = null;
  waveBuffer = null;
  constructor(config = {}) {
    this.config = { ...DEFAULT_WAVE_CONFIG, ...config };
  }
  init(device) {
    this._device = device;
    const resolution = this.config.resolution;
    this.displacementTexture = device.createTexture({
      label: "Wave Displacement Texture",
      size: [resolution, resolution],
      format: "rgba16float",
      usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING
    });
    this.normalTexture = device.createTexture({
      label: "Wave Normal Texture",
      size: [resolution, resolution],
      format: "rgba8unorm",
      usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING
    });
    this.uniformBuffer = device.createBuffer({
      label: "Wave Uniforms",
      size: 48,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.waveBuffer = device.createBuffer({
      label: "Wave Parameters",
      size: MAX_WAVES * 32,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
    });
    const shaderModule = device.createShaderModule({
      label: "Wave Compute Shader",
      code: this.getComputeShaderCode()
    });
    const bindGroupLayout = device.createBindGroupLayout({
      label: "Wave Bind Group Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: "uniform" } },
        { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: "read-only-storage" } },
        { binding: 2, visibility: GPUShaderStage.COMPUTE, storageTexture: { access: "write-only", format: "rgba16float" } },
        { binding: 3, visibility: GPUShaderStage.COMPUTE, storageTexture: { access: "write-only", format: "rgba8unorm" } }
      ]
    });
    const pipelineLayout = device.createPipelineLayout({
      label: "Wave Pipeline Layout",
      bindGroupLayouts: [bindGroupLayout]
    });
    this.computePipeline = device.createComputePipeline({
      label: "Wave Compute Pipeline",
      layout: pipelineLayout,
      compute: {
        module: shaderModule,
        entryPoint: "main"
      }
    });
    this.bindGroup = device.createBindGroup({
      label: "Wave Bind Group",
      layout: bindGroupLayout,
      entries: [
        { binding: 0, resource: { buffer: this.uniformBuffer } },
        { binding: 1, resource: { buffer: this.waveBuffer } },
        { binding: 2, resource: this.displacementTexture.createView() },
        { binding: 3, resource: this.normalTexture.createView() }
      ]
    });
    this.uploadWaveParameters();
    this.initialized = true;
    console.log("WaveGenerator: Initialized with resolution", resolution);
  }
  uploadWaveParameters() {
    if (!this._device || !this.waveBuffer)
      return;
    const waves = this.config.waves || [];
    const waveData = new Float32Array(MAX_WAVES * 8);
    for (let i = 0;i < Math.min(waves.length, MAX_WAVES); i++) {
      const wave = waves[i];
      const offset = i * 8;
      const dirLen = Math.sqrt(wave.direction.x * wave.direction.x + wave.direction.y * wave.direction.y);
      const dirX = dirLen > 0 ? wave.direction.x / dirLen : 1;
      const dirY = dirLen > 0 ? wave.direction.y / dirLen : 0;
      waveData[offset + 0] = dirX;
      waveData[offset + 1] = dirY;
      waveData[offset + 2] = wave.steepness;
      waveData[offset + 3] = wave.wavelength;
      waveData[offset + 4] = wave.speed;
      waveData[offset + 5] = 0;
      waveData[offset + 6] = 0;
      waveData[offset + 7] = 0;
    }
    this._device.queue.writeBuffer(this.waveBuffer, 0, waveData);
  }
  generate(time, commandEncoder) {
    if (!this.initialized || !this._device || !this.computePipeline || !this.bindGroup || !this.uniformBuffer) {
      return;
    }
    const waveCount = Math.min(this.config.waves?.length || 0, MAX_WAVES);
    const uniformData = new Float32Array([
      time,
      this.config.resolution,
      this.config.worldSize.width,
      this.config.worldSize.depth,
      waveCount,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    this._device.queue.writeBuffer(this.uniformBuffer, 0, uniformData);
    const computePass = commandEncoder.beginComputePass({
      label: "Wave Compute Pass"
    });
    computePass.setPipeline(this.computePipeline);
    computePass.setBindGroup(0, this.bindGroup);
    const workgroupSize = 8;
    const workgroupCountX = Math.ceil(this.config.resolution / workgroupSize);
    const workgroupCountY = Math.ceil(this.config.resolution / workgroupSize);
    computePass.dispatchWorkgroups(workgroupCountX, workgroupCountY);
    computePass.end();
  }
  getComputeShaderCode() {
    return `
      struct Uniforms {
        time: f32,
        resolution: f32,
        worldWidth: f32,
        worldDepth: f32,
        waveCount: f32,
        _pad: vec3f,
      }

      struct Wave {
        direction: vec2f,
        steepness: f32,
        wavelength: f32,
        speed: f32,
        _pad: vec3f,
      }

      @group(0) @binding(0) var<uniform> uniforms: Uniforms;
      @group(0) @binding(1) var<storage, read> waves: array<Wave>;
      @group(0) @binding(2) var outputDisplacement: texture_storage_2d<rgba16float, write>;
      @group(0) @binding(3) var outputNormal: texture_storage_2d<rgba8unorm, write>;

      const PI: f32 = 3.14159265359;
      const GRAVITY: f32 = 9.81;

      // Gerstner wave displacement calculation
      fn gerstnerWave(worldPos: vec2f, time: f32, wave: Wave) -> vec4f {
        let k = 2.0 * PI / wave.wavelength;
        let c = sqrt(GRAVITY / k); // Wave speed from dispersion relation
        let d = wave.direction;
        let f = k * dot(d, worldPos) - c * time * wave.speed;
        let a = wave.steepness / k;

        // Displacement (horizontal X, vertical Y, horizontal Z)
        let dx = d.x * a * cos(f);
        let dy = a * sin(f);
        let dz = d.y * a * cos(f);

        // Foam based on wave peaks (when sin(f) > threshold)
        let foam = max(0.0, sin(f) - 0.7) * 3.0;

        return vec4f(dx, dy, dz, foam);
      }

      // Calculate partial derivatives for normal computation
      fn gerstnerDerivatives(worldPos: vec2f, time: f32, wave: Wave) -> vec4f {
        let k = 2.0 * PI / wave.wavelength;
        let c = sqrt(GRAVITY / k);
        let d = wave.direction;
        let f = k * dot(d, worldPos) - c * time * wave.speed;
        let a = wave.steepness / k;

        // Partial derivatives of height with respect to x and z
        let dhdx = k * d.x * a * cos(f);
        let dhdz = k * d.y * a * cos(f);

        // Also compute horizontal displacement derivatives for Gerstner normal
        let ddxdx = -k * d.x * d.x * a * sin(f);
        let ddzdz = -k * d.y * d.y * a * sin(f);

        return vec4f(dhdx, dhdz, ddxdx, ddzdz);
      }

      @compute @workgroup_size(8, 8)
      fn main(@builtin(global_invocation_id) globalId: vec3u) {
        let resolution = u32(uniforms.resolution);

        if (globalId.x >= resolution || globalId.y >= resolution) {
          return;
        }

        let uv = vec2f(f32(globalId.x), f32(globalId.y)) / uniforms.resolution;

        // Convert UV to world position
        let worldPos = vec2f(
          (uv.x - 0.5) * uniforms.worldWidth,
          (uv.y - 0.5) * uniforms.worldDepth
        );

        var totalDisplacement = vec3f(0.0);
        var totalFoam = 0.0;
        var totalDhdx = 0.0;
        var totalDhdz = 0.0;

        let waveCount = u32(uniforms.waveCount);

        for (var i = 0u; i < waveCount; i++) {
          let wave = waves[i];
          let result = gerstnerWave(worldPos, uniforms.time, wave);
          totalDisplacement += result.xyz;
          totalFoam += result.w;

          let derivatives = gerstnerDerivatives(worldPos, uniforms.time, wave);
          totalDhdx += derivatives.x;
          totalDhdz += derivatives.y;
        }

        // Clamp foam
        totalFoam = clamp(totalFoam, 0.0, 1.0);

        // Write displacement
        textureStore(outputDisplacement, vec2i(globalId.xy), vec4f(totalDisplacement, totalFoam));

        // Calculate normal from derivatives
        // For Gerstner waves: N = normalize(vec3(-dhdx, 1, -dhdz))
        let normal = normalize(vec3f(-totalDhdx, 1.0, -totalDhdz));

        // Encode normal to 0-1 range for storage
        let encodedNormal = normal * 0.5 + 0.5;

        textureStore(outputNormal, vec2i(globalId.xy), vec4f(encodedNormal, 1.0));
      }
    `;
  }
  getDisplacementTexture() {
    return this.displacementTexture;
  }
  getNormalTexture() {
    return this.normalTexture;
  }
  getHeightAt(x, z, time) {
    if (this.config.waveType !== "gerstner" || !this.config.waves) {
      return 0;
    }
    let height = 0;
    for (const wave of this.config.waves) {
      const k = 2 * Math.PI / wave.wavelength;
      const c = Math.sqrt(9.81 / k);
      const d = wave.direction;
      const dirLen = Math.sqrt(d.x * d.x + d.y * d.y);
      const dirX = dirLen > 0 ? d.x / dirLen : 1;
      const dirY = dirLen > 0 ? d.y / dirLen : 0;
      const f = k * (dirX * x + dirY * z) - c * time * wave.speed;
      const a = wave.steepness / k;
      height += a * Math.sin(f);
    }
    return height;
  }
  setConfig(config) {
    const oldResolution = this.config.resolution;
    this.config = { ...this.config, ...config };
    if (config.resolution && config.resolution !== oldResolution && this._device) {
      this.destroy();
      this.init(this._device);
    } else if (config.waves) {
      this.uploadWaveParameters();
    }
  }
  getConfig() {
    return { ...this.config };
  }
  addWave(wave) {
    if (!this.config.waves) {
      this.config.waves = [];
    }
    if (this.config.waves.length < MAX_WAVES) {
      this.config.waves.push(wave);
      this.uploadWaveParameters();
    } else {
      console.warn("WaveGenerator: Maximum wave count reached");
    }
  }
  clearWaves() {
    this.config.waves = [];
    this.uploadWaveParameters();
  }
  static getGerstnerWGSL() {
    return `
      // Gerstner wave function
      // Returns: vec4f(displacement.xyz, foam)
      fn gerstnerWave(
        worldPos: vec2f,
        time: f32,
        direction: vec2f,
        steepness: f32,
        wavelength: f32,
        speed: f32
      ) -> vec4f {
        let k = 2.0 * 3.14159 / wavelength;
        let c = sqrt(9.81 / k);
        let d = normalize(direction);
        let f = k * dot(d, worldPos) - c * time * speed;
        let a = steepness / k;

        // Displacement
        let dx = d.x * a * cos(f);
        let dy = a * sin(f);
        let dz = d.y * a * cos(f);

        // Foam based on wave peaks
        let foam = max(0.0, sin(f) - 0.8) * 5.0;

        return vec4f(dx, dy, dz, foam);
      }

      // Sum multiple Gerstner waves
      fn sumGerstnerWaves(
        worldPos: vec2f,
        time: f32,
        waves: array<vec4f, 8>,  // direction.xy, steepness, wavelength
        speeds: array<f32, 8>,
        waveCount: u32
      ) -> vec4f {
        var result = vec4f(0.0);

        for (var i = 0u; i < waveCount; i++) {
          let wave = waves[i];
          result += gerstnerWave(
            worldPos,
            time,
            wave.xy,
            wave.z,
            wave.w,
            speeds[i]
          );
        }

        return result;
      }
    `;
  }
  destroy() {
    this.displacementTexture?.destroy();
    this.normalTexture?.destroy();
    this.uniformBuffer?.destroy();
    this.waveBuffer?.destroy();
    this.displacementTexture = null;
    this.normalTexture = null;
    this.computePipeline = null;
    this.bindGroup = null;
    this.uniformBuffer = null;
    this.waveBuffer = null;
    this._device = null;
    this.initialized = false;
  }
}

// ../../src/core/procedural/water/Water.ts
var DEFAULT_WATER_CONFIG = {
  segments: { x: 64, z: 64 },
  deepColor: new Vector3(0, 0.1, 0.25),
  roughness: 0.05,
  wavesEnabled: true,
  waveCount: 4,
  fresnelPower: 5,
  fresnelBias: 0.02,
  skyReflectionBlend: 0.3,
  refractionStrength: 0.05,
  chromaticAberration: true,
  chromaticAberrationStrength: 0.01,
  foamEnabled: false,
  foamIntensity: 0.5,
  foamColor: new Vector3(1, 1, 1),
  foamSpeed: 1,
  causticsEnabled: true,
  causticsIntensity: 0.15,
  causticsScale: 8,
  causticsOctaves: 4,
  scatterColor: new Vector3(0, 0.7, 0.6),
  scatterIntensity: 0.4,
  ssrEnabled: false,
  ssrStrength: 0.5,
  refractionEnabled: false,
  depthFadeDistance: 10,
  waveResolution: 256
};

class Water extends Node {
  config;
  _device = null;
  initialized = false;
  mesh = null;
  material = null;
  waveGenerator = null;
  geometry = null;
  _totalTime = 0;
  constructor(config) {
    super("Water");
    this.config = { ...DEFAULT_WATER_CONFIG, ...config };
    this._initState = "pending";
    this._needsUpdate = true;
  }
  async onInit(device) {
    await this.init(device);
  }
  onUpdate(deltaTime) {
    this._totalTime += deltaTime;
    if (this.material) {
      this.material.time = this._totalTime;
      if (this.mesh) {
        this.mesh.bindGroup = null;
      }
    }
  }
  async init(device) {
    this._device = device;
    this.geometry = this.createWaterGeometry();
    if (this.config.wavesEnabled !== false) {
      const waves = this.config.customWaves || this.generateDefaultWaves();
      this.waveGenerator = new WaveGenerator({
        waveType: "gerstner",
        resolution: this.config.waveResolution || 256,
        worldSize: { width: this.config.size.width, depth: this.config.size.depth },
        waves
      });
      this.waveGenerator.init(device);
    }
    this.material = new WaterMaterial({
      shallowColor: this.config.shallowColor,
      deepColor: this.config.deepColor || new Vector3(0, 0.15, 0.3),
      opacity: this.config.opacity,
      roughness: this.config.roughness ?? 0.05,
      fresnelPower: this.config.fresnelPower ?? 5,
      fresnelBias: this.config.fresnelBias ?? 0.02,
      skyReflectionBlend: this.config.skyReflectionBlend ?? 0.3,
      refractionStrength: this.config.refractionStrength ?? 0.05,
      chromaticAberration: this.config.chromaticAberration ?? true,
      chromaticAberrationStrength: this.config.chromaticAberrationStrength ?? 0.01,
      depthFadeDistance: this.config.depthFadeDistance ?? 10,
      foamEnabled: this.config.foamEnabled ?? true,
      foamIntensity: this.config.foamIntensity ?? 0.5,
      foamColor: this.config.foamColor || new Vector3(1, 1, 1),
      foamSpeed: this.config.foamSpeed ?? 1,
      causticsEnabled: this.config.causticsEnabled ?? true,
      causticsIntensity: this.config.causticsIntensity ?? 0.3,
      causticsScale: this.config.causticsScale ?? 8,
      causticsOctaves: this.config.causticsOctaves ?? 4,
      scatterColor: this.config.scatterColor || new Vector3(0, 0.7, 0.6),
      scatterIntensity: this.config.scatterIntensity ?? 0.4,
      waveHeightMultiplier: this.config.waveHeight,
      ssrEnabled: this.config.ssrEnabled ?? true,
      ssrStrength: this.config.ssrStrength ?? 0.5,
      refractionEnabled: this.config.refractionEnabled ?? true
    });
    if (this.waveGenerator) {
      this.material.displacementTexture = this.waveGenerator.getDisplacementTexture();
      this.material.waveNormalTexture = this.waveGenerator.getNormalTexture();
    }
    this.material.worldSize = { width: this.config.size.width, depth: this.config.size.depth };
    this.mesh = new Mesh(this.geometry, this.material);
    this.addChild(this.mesh);
    this.setWaterLevel(this.config.waterLevel);
    this.initialized = true;
    this._initState = "ready";
    console.log(`Water: Initialized ${this.config.size.width}x${this.config.size.depth} with ${this.config.segments?.x}x${this.config.segments?.z} segments`);
  }
  generateDefaultWaves() {
    const waveCount = this.config.waveCount ?? 4;
    const baseSpeed = this.config.waveSpeed;
    const baseHeight = this.config.waveHeight;
    const waves = [];
    for (let i = 0;i < waveCount; i++) {
      const angle = i / waveCount * Math.PI * 2 + Math.random() * 0.5;
      const wavelength = 10 / (i + 1) + Math.random() * 2;
      const steepness = 0.5 / (i + 1) * baseHeight;
      waves.push({
        direction: new Vector2(Math.cos(angle), Math.sin(angle)),
        steepness: Math.max(0.05, steepness),
        wavelength: Math.max(1, wavelength),
        speed: baseSpeed * (0.8 + Math.random() * 0.4)
      });
    }
    return waves;
  }
  createWaterGeometry() {
    const geometry = new Geometry;
    const segmentsX = this.config.segments?.x ?? 64;
    const segmentsZ = this.config.segments?.z ?? 64;
    const width = this.config.size.width;
    const depth = this.config.size.depth;
    const vertexCount = (segmentsX + 1) * (segmentsZ + 1);
    const positions = new Float32Array(vertexCount * 3);
    const normals = new Float32Array(vertexCount * 3);
    const uvs = new Float32Array(vertexCount * 2);
    let vi = 0;
    let ni = 0;
    let ui = 0;
    for (let z = 0;z <= segmentsZ; z++) {
      for (let x = 0;x <= segmentsX; x++) {
        const u = x / segmentsX;
        const v = z / segmentsZ;
        positions[vi++] = (u - 0.5) * width;
        positions[vi++] = 0;
        positions[vi++] = (v - 0.5) * depth;
        normals[ni++] = 0;
        normals[ni++] = 1;
        normals[ni++] = 0;
        uvs[ui++] = u;
        uvs[ui++] = v;
      }
    }
    const indexCount = segmentsX * segmentsZ * 6;
    const useUint32 = vertexCount > 65535;
    const indices = useUint32 ? new Uint32Array(indexCount) : new Uint16Array(indexCount);
    let ii = 0;
    for (let z = 0;z < segmentsZ; z++) {
      for (let x = 0;x < segmentsX; x++) {
        const a = z * (segmentsX + 1) + x;
        const b = a + 1;
        const c = a + (segmentsX + 1);
        const d = c + 1;
        indices[ii++] = a;
        indices[ii++] = c;
        indices[ii++] = b;
        indices[ii++] = b;
        indices[ii++] = c;
        indices[ii++] = d;
      }
    }
    geometry.setAttribute("position", positions);
    geometry.setAttribute("normal", normals);
    geometry.setAttribute("uv", uvs);
    geometry.setIndices(indices);
    return geometry;
  }
  update(time, commandEncoder) {
    if (!this.initialized)
      return;
    if (this.waveGenerator && commandEncoder) {
      this.waveGenerator.generate(time * this.config.waveSpeed, commandEncoder);
    }
    if (this.material) {
      this.material.time = time;
      if (this.waveGenerator) {
        this.material.displacementTexture = this.waveGenerator.getDisplacementTexture();
        this.material.waveNormalTexture = this.waveGenerator.getNormalTexture();
      }
      if (this.mesh) {
        this.mesh.bindGroup = null;
      }
    }
  }
  setWaterLevel(level) {
    this.config.waterLevel = level;
    const pos = this.transform.position;
    this.transform.position = new Vector3(pos.x, level, pos.z);
  }
  setConfig(config) {
    if (config.size) {
      const needsGeometryUpdate = config.size.width !== this.config.size.width || config.size.depth !== this.config.size.depth;
      this.config.size = config.size;
      if (needsGeometryUpdate && this._device) {
        this.geometry = this.createWaterGeometry();
        if (this.mesh && this.material) {
          this.removeChild(this.mesh);
          this.mesh = new Mesh(this.geometry, this.material);
          this.addChild(this.mesh);
        }
        if (this.waveGenerator) {
          this.waveGenerator.setConfig({
            worldSize: { width: config.size.width, depth: config.size.depth }
          });
        }
        if (this.material) {
          this.material.worldSize = { width: config.size.width, depth: config.size.depth };
        }
      }
    }
    if (config.segments && this._device) {
      this.config.segments = config.segments;
      this.geometry = this.createWaterGeometry();
      if (this.mesh && this.material) {
        this.removeChild(this.mesh);
        this.mesh = new Mesh(this.geometry, this.material);
        this.addChild(this.mesh);
      }
    }
    if (config.waterLevel !== undefined) {
      this.setWaterLevel(config.waterLevel);
    }
    if (config.shallowColor && this.material) {
      this.config.shallowColor = config.shallowColor;
      this.material.setConfig({ shallowColor: config.shallowColor });
    }
    if (config.deepColor && this.material) {
      this.config.deepColor = config.deepColor;
      this.material.setConfig({ deepColor: config.deepColor });
    }
    if (config.opacity !== undefined && this.material) {
      this.config.opacity = config.opacity;
      this.material.setOpacity(config.opacity);
    }
    if (config.roughness !== undefined && this.material) {
      this.config.roughness = config.roughness;
      this.material.setConfig({ roughness: config.roughness });
    }
    if (config.waveHeight !== undefined) {
      this.config.waveHeight = config.waveHeight;
      if (this.material) {
        this.material.setConfig({ waveHeightMultiplier: config.waveHeight });
      }
    }
    if (config.waveSpeed !== undefined) {
      this.config.waveSpeed = config.waveSpeed;
    }
    if (config.waveCount !== undefined && this.waveGenerator && this._device) {
      this.config.waveCount = config.waveCount;
      const waves = this.generateDefaultWaves();
      this.waveGenerator.setConfig({ waves });
    }
    if (config.customWaves && this.waveGenerator) {
      this.waveGenerator.setConfig({ waves: config.customWaves });
    }
    if (config.fresnelPower !== undefined && this.material) {
      this.config.fresnelPower = config.fresnelPower;
      this.material.setConfig({ fresnelPower: config.fresnelPower });
    }
    if (config.fresnelBias !== undefined && this.material) {
      this.config.fresnelBias = config.fresnelBias;
      this.material.setConfig({ fresnelBias: config.fresnelBias });
    }
    if (config.skyReflectionBlend !== undefined && this.material) {
      this.config.skyReflectionBlend = config.skyReflectionBlend;
      this.material.setConfig({ skyReflectionBlend: config.skyReflectionBlend });
    }
    if (config.refractionStrength !== undefined && this.material) {
      this.config.refractionStrength = config.refractionStrength;
      this.material.setConfig({ refractionStrength: config.refractionStrength });
    }
    if (config.foamEnabled !== undefined && this.material) {
      this.config.foamEnabled = config.foamEnabled;
      this.material.setConfig({ foamEnabled: config.foamEnabled });
    }
    if (config.foamIntensity !== undefined && this.material) {
      this.config.foamIntensity = config.foamIntensity;
      this.material.setConfig({ foamIntensity: config.foamIntensity });
    }
    if (config.foamColor && this.material) {
      this.config.foamColor = config.foamColor;
      this.material.setConfig({ foamColor: config.foamColor });
    }
    if (config.causticsEnabled !== undefined && this.material) {
      this.config.causticsEnabled = config.causticsEnabled;
      this.material.setConfig({ causticsEnabled: config.causticsEnabled });
    }
    if (config.causticsIntensity !== undefined && this.material) {
      this.config.causticsIntensity = config.causticsIntensity;
      this.material.setConfig({ causticsIntensity: config.causticsIntensity });
    }
    if (config.causticsScale !== undefined && this.material) {
      this.config.causticsScale = config.causticsScale;
      this.material.setConfig({ causticsScale: config.causticsScale });
    }
    if (config.scatterColor && this.material) {
      this.config.scatterColor = config.scatterColor;
      this.material.setConfig({ scatterColor: config.scatterColor });
    }
    if (config.scatterIntensity !== undefined && this.material) {
      this.config.scatterIntensity = config.scatterIntensity;
      this.material.setConfig({ scatterIntensity: config.scatterIntensity });
    }
    if (config.depthFadeDistance !== undefined && this.material) {
      this.config.depthFadeDistance = config.depthFadeDistance;
      this.material.setConfig({ depthFadeDistance: config.depthFadeDistance });
    }
    if (config.chromaticAberration !== undefined && this.material) {
      this.config.chromaticAberration = config.chromaticAberration;
      this.material.setConfig({ chromaticAberration: config.chromaticAberration });
    }
    if (config.chromaticAberrationStrength !== undefined && this.material) {
      this.config.chromaticAberrationStrength = config.chromaticAberrationStrength;
      this.material.setConfig({ chromaticAberrationStrength: config.chromaticAberrationStrength });
    }
    if (config.foamSpeed !== undefined && this.material) {
      this.config.foamSpeed = config.foamSpeed;
      this.material.setConfig({ foamSpeed: config.foamSpeed });
    }
    if (config.causticsOctaves !== undefined && this.material) {
      this.config.causticsOctaves = config.causticsOctaves;
      this.material.setConfig({ causticsOctaves: config.causticsOctaves });
    }
    if (config.ssrEnabled !== undefined && this.material) {
      this.config.ssrEnabled = config.ssrEnabled;
      this.material.setConfig({ ssrEnabled: config.ssrEnabled });
    }
    if (config.ssrStrength !== undefined && this.material) {
      this.config.ssrStrength = config.ssrStrength;
      this.material.setConfig({ ssrStrength: config.ssrStrength });
    }
    if (config.refractionEnabled !== undefined && this.material) {
      this.config.refractionEnabled = config.refractionEnabled;
      this.material.setConfig({ refractionEnabled: config.refractionEnabled });
    }
  }
  getConfig() {
    return { ...this.config };
  }
  isUnderwater(position) {
    const waveHeight = this.getWaveHeightAt(position.x, position.z, this.material?.time ?? 0);
    return position.y < this.config.waterLevel + waveHeight;
  }
  getWaveHeightAt(x, z, time) {
    if (!this.waveGenerator)
      return 0;
    return this.waveGenerator.getHeightAt(x, z, time * this.config.waveSpeed) * this.config.waveHeight;
  }
  getWaveGenerator() {
    return this.waveGenerator;
  }
  getMaterial() {
    return this.material;
  }
  getMesh() {
    return this.mesh;
  }
  exportGeometry() {
    if (!this.geometry)
      return null;
    const positions = this.geometry.attributes["position"];
    const normals = this.geometry.attributes["normal"];
    const uvs = this.geometry.attributes["uv"];
    const indices = this.geometry.indices;
    if (!positions || !normals || !uvs || !indices)
      return null;
    return {
      vertices: new Float32Array(positions),
      normals: new Float32Array(normals),
      uvs: new Float32Array(uvs),
      indices: new Uint32Array(indices)
    };
  }
  destroy() {
    if (this.waveGenerator) {
      this.waveGenerator.destroy();
      this.waveGenerator = null;
    }
    if (this.mesh) {
      this.removeChild(this.mesh);
      this.mesh = null;
    }
    this.geometry = null;
    this.material = null;
    this._device = null;
    this.initialized = false;
    console.log("Water: Destroyed");
  }
}

// ../../src/core/renderer/RenderGraph.ts
class RenderGraph {
  passes = [];
  globalResources = null;
  getPasses() {
    return this.passes;
  }
  addPass(pass) {
    this.passes.push(pass);
  }
  insertPassAt(index, pass) {
    this.passes.splice(index, 0, pass);
  }
  removePass(pass) {
    const index = this.passes.indexOf(pass);
    if (index !== -1) {
      this.passes.splice(index, 1);
      return true;
    }
    return false;
  }
  init(device, context, presentationFormat) {
    this.globalResources = new GlobalResources(device);
    this.globalResources.createBindGroup(device);
    for (const pass of this.passes) {
      pass.init(device, context, presentationFormat);
    }
  }
  resize(width, height) {
    if (width <= 0 || height <= 0) {
      console.warn(`RenderGraph: Skipping resize with invalid dimensions: ${width}x${height}`);
      return;
    }
    if (this.globalResources) {
      this.globalResources.resize(width, height);
    }
    for (const pass of this.passes) {
      pass.resize(width, height);
    }
  }
  setDebugMode(mode) {
    if (this.globalResources) {
      this.globalResources.sceneUniforms.debugMode = mode;
    }
  }
  getGlobalResources() {
    return this.globalResources;
  }
  execute(device, context) {
    if (!this.globalResources)
      return;
    const shadowsEnabled = context.scene.shadows.enabled;
    const shadowRes = context.scene.shadows.resolution;
    const shadowLayers = context.scene.shadows.maxLights ?? 1;
    const pointShadowRes = context.scene.shadows.pointShadowResolution;
    this.globalResources.resizeShadows(shadowRes, shadowLayers, device, pointShadowRes, shadowsEnabled);
    this.globalResources.environmentMap = context.scene.environmentMap;
    this.globalResources.sceneUniforms.update(context.camera, context.scene);
    const meshes = [];
    context.scene.traverse((node) => {
      if (!node.visible)
        return false;
      if (node instanceof Mesh) {
        node.updateWorldBounds();
        meshes.push(node);
      }
    });
    if (meshes.length === 0 && this.globalResources.objectBuffer.objectCount > 0) {
      console.warn("[RenderGraph] Mesh count dropped to 0 from", this.globalResources.objectBuffer.objectCount);
    }
    this.globalResources.objectBuffer.update(meshes);
    this.globalResources.indirectDrawBuffer.update(meshes);
    this.globalResources.updateBindGroupsIfNeeded(device);
    const commandEncoder = device.createCommandEncoder();
    const time = context.time ?? 0;
    context.scene.traverse((node) => {
      if (!node.visible)
        return false;
      if (node instanceof Water) {
        node.update(time, commandEncoder);
      }
    });
    for (const pass of this.passes) {
      pass.execute(commandEncoder, context, this.globalResources);
    }
    device.queue.submit([commandEncoder.finish()]);
  }
}

// ../../src/core/materials/StandardMaterial.ts
class StandardMaterial extends Material {
  albedo;
  roughness;
  metallic;
  emissive;
  opacity = 1;
  alphaMode = "OPAQUE";
  alphaCutoff = 0.5;
  albedoMap = null;
  normalMap = null;
  roughnessMap = null;
  metallicMap = null;
  emissiveMap = null;
  occlusionMap = null;
  displacementMap = null;
  displacementScale = 0.1;
  textureScale = { x: 1, y: 1 };
  receiveShadows = true;
  doubleSided = false;
  ambientIntensity = 1;
  windEnabled = false;
  windStrength = 0.3;
  windSpeed = 1;
  windFrequency = 1.5;
  blendMap2 = null;
  blendNormalMap2 = null;
  blendMode = "none";
  blendNoiseScale = 100;
  blendPatchiness = 0.5;
  useWorldSpaceUV = false;
  worldSpaceUVScale = 30;
  static MAX_LIGHTS = 8;
  forwardFragmentShaderCode;
  constructor(albedo = new Vector3(1, 1, 1), roughness = 0.5, metallic = 0, emissive = new Vector3(0, 0, 0)) {
    super();
    this.albedo = albedo;
    this.roughness = roughness;
    this.metallic = metallic;
    this.emissive = emissive;
    const commonDefines = `
      struct Light {
        position: vec3f,
        _pad1: f32,
        direction: vec3f,
        _pad2: f32,
        color: vec3f,
        intensity: f32,
        attenuation: vec3f,
        lightType: u32,
        coneAngles: vec2f,
        shadowIndex: i32,  // -1 = no shadow, 0-3 = shadow atlas layer
        shadowRadius: f32, // Shadow softness/blur radius (higher = softer)
        shadowIntensity: f32, // How dark shadows get (0=no shadow, 1=fully dark)
        _pad3: f32,
        _pad4: f32,
        _pad5: f32,
      }

      struct SceneUniforms {
        viewMatrix : mat4x4<f32>,
        projectionMatrix : mat4x4<f32>,
        lightViewProj : mat4x4<f32>,
        prevViewProj : mat4x4<f32>,
        inverseProjectionMatrix : mat4x4<f32>,
        cameraPosition : vec3f,
        time : f32,
        lightCount : u32,
        debugMode : u32,
        flags : u32,
        environmentIntensity : f32,
        fogColorLegacy: vec3f,      // Legacy fog (unused)
        fogDensityLegacy: f32,
        fogParamsLegacy: vec4f,
        fogSettingsLegacy: vec4u,
        cloudShadowParams: vec4f,   // x=enabled, y=intensity, z=scale, w=speed
        cloudShadowParams2: vec4f,  // x=coverage, y=softness, z=windDirX, w=windDirZ
        fogColor: vec3f,            // Actual fog color
        fogDensity: f32,            // FogExp2 density
        fogParams: vec4f,           // x=near, y=far, z=type (0=linear,1=exp2), w=enabled
        fogSkyFalloff: f32,
        _fogPad1: f32,
        _fogPad2: f32,
        _fogPad3: f32,
        lights : array<Light, ${StandardMaterial.MAX_LIGHTS}>,
      }

      struct ShadowLight {
        viewProj: mat4x4<f32>,
        atlasLayer: u32,
        bias: f32,
        normalBias: f32,
        _pad: u32,
      }

      struct ShadowUniforms {
        lights: array<ShadowLight, 4>,
        shadowLightCount: u32,
        atlasResolution: f32,
        _pad: vec2<f32>,
      }

      struct ObjectData {
        modelMatrix : mat4x4<f32>,
        normalMatrix : mat4x4<f32>,
        aabbMin : vec3f,
        _pad1 : f32,
        aabbMax : vec3f,
        _pad2 : f32,
        prevModelMatrix : mat4x4<f32>,
        _pad3 : vec4<f32>, // Padding to 256 bytes
        _pad4 : vec4<f32>,
      }

      struct MaterialUniforms {
        albedo : vec3<f32>,
        roughness : f32,
        emissive : vec3<f32>,
        metallic : f32,
        opacity : f32,
        alphaCutoff : f32,
        displacementScale : f32,
        textureFlags : u32,
        alphaMode : u32,
        receiveShadows : f32,
        textureScale : vec2<f32>,  // UV tiling/repeat
        doubleSided : f32,         // Two-sided lighting flag
        ambientIntensity : f32,    // Per-material ambient multiplier (0-1)
        windEnabled : f32,         // Wind animation enabled
        windStrength : f32,        // Wind displacement strength
        windSpeed : f32,           // Wind animation speed
        windFrequency : f32,       // Wind wave frequency
        // Texture blending (for ground/terrain)
        blendMode : u32,           // 0=none, 1=noise
        useWorldSpaceUV : f32,     // Use world XZ for UVs
        worldSpaceUVScale : f32,   // World UV tiling scale
        blendNoiseScale : f32,     // Noise scale for blending
        blendPatchiness : f32,     // Blend threshold
        _blendPad1 : f32,          // Padding for alignment
        _blendPad2 : f32,
        _blendPad3 : f32,
      }

      @group(0) @binding(0) var<uniform> scene : SceneUniforms;
      @group(0) @binding(1) var<storage, read> objects : array<ObjectData>;
      @group(0) @binding(4) var shadowMap: texture_depth_2d_array;
      @group(0) @binding(5) var shadowSampler: sampler_comparison;
      @group(0) @binding(8) var<uniform> shadowUniforms: ShadowUniforms;
      @group(0) @binding(9) var pointShadowTex: texture_2d_array<f32>;
      @group(0) @binding(10) var pointShadowSamp: sampler;

      // Cascade Shadow Map uniforms for directional lights
      struct CascadeUniforms {
        viewProj: array<mat4x4<f32>, 4>,
        splits: vec4<f32>,
        biases: vec4<f32>,
      }
      @group(0) @binding(11) var<uniform> cascadeUniforms: CascadeUniforms;

      @group(1) @binding(0) var<uniform> material : MaterialUniforms;
      @group(1) @binding(1) var samp : sampler;
      @group(1) @binding(2) var albedoTex : texture_2d<f32>;
      @group(1) @binding(3) var normalTex : texture_2d<f32>;
      @group(1) @binding(4) var roughnessTex : texture_2d<f32>;
      @group(1) @binding(5) var metallicTex : texture_2d<f32>;
      @group(1) @binding(6) var emissiveTex : texture_2d<f32>;
      @group(1) @binding(7) var occlusionTex : texture_2d<f32>;
      @group(1) @binding(8) var displacementTex : texture_2d<f32>;
      @group(1) @binding(9) var blendAlbedoTex2 : texture_2d<f32>;   // Secondary albedo for blending
      @group(1) @binding(10) var blendNormalTex2 : texture_2d<f32>; // Secondary normal for blending

      struct VertexInput {
        @location(0) position : vec3<f32>,
        @location(1) normal : vec3<f32>,
        @location(2) uv : vec2<f32>,
      }

      struct VertexOutput {
        @builtin(position) position : vec4<f32>,
        @location(0) worldNormal : vec3<f32>,
        @location(1) uv : vec2<f32>,
        @location(2) worldPosition : vec3<f32>,
        @location(3) currentClip : vec4<f32>,
        @location(4) prevClip : vec4<f32>,
      }

      fn applyFog(color: vec3f, worldPos: vec3f) -> vec3f {
        // fogParams: x=near, y=far, z=type (0=linear, 1=exp2), w=enabled
        let fogEnabled = scene.fogParams.w;
        if (fogEnabled < 0.5) {
            return color;
        }

        // Calculate view-space Z depth (exactly like Three.js)
        // Three.js: vFogDepth = -mvPosition.z where mvPosition = modelViewMatrix * position
        let viewPos = scene.viewMatrix * vec4f(worldPos, 1.0);
        let fogDepth = -viewPos.z;  // Negate because camera looks down -Z in view space

        var fogFactor = 0.0;
        let fogType = scene.fogParams.z;

        if (fogType < 0.5) { // LINEAR (type 0)
            let near = scene.fogParams.x;
            let far = scene.fogParams.y;
            fogFactor = clamp((fogDepth - near) / (far - near), 0.0, 1.0);
        } else { // EXP2 (type 1)
            let density = scene.fogDensity;
            // FogExp2 formula exactly like Three.js
            fogFactor = 1.0 - exp(-density * density * fogDepth * fogDepth);
        }

        return mix(color, scene.fogColor, fogFactor);
      }

      // Get hemisphere light irradiance based on surface normal
      // Interpolates between ground and sky color based on how much the surface faces up
      fn getHemisphereLightIrradiance(skyColor: vec3f, groundColor: vec3f, normal: vec3f, direction: vec3f) -> vec3f {
          let dotNL = dot(normal, direction);
          let hemiDiffuseWeight = dotNL * 0.5 + 0.5;  // Remap [-1,1] to [0,1]
          return mix(groundColor, skyColor, hemiDiffuseWeight);
      }
    `;
    this.vertexShaderCode = `
      ${commonDefines}

      // Wind displacement function for foliage animation
      fn calculateWindDisplacement(worldPos: vec3f, time: f32, strength: f32, speed: f32, frequency: f32) -> vec3f {
        // Use world position for spatial variation
        let phase = worldPos.x * 0.1 + worldPos.z * 0.1;

        // Multi-frequency wind for more natural motion
        let wind1 = sin(time * speed + phase) * strength;
        let wind2 = sin(time * speed * 1.7 + phase * 1.3) * strength * 0.5;
        let wind3 = cos(time * speed * 0.5 + phase * 0.7) * strength * 0.3;

        // Combine into displacement vector (mostly horizontal movement)
        return vec3f(
          (wind1 + wind2) * frequency,
          wind3 * 0.2,  // Less vertical movement
          (wind1 - wind2 * 0.5) * frequency * 0.7
        );
      }

      @vertex
      fn vs_main(input : VertexInput, @builtin(instance_index) instanceIndex : u32) -> VertexOutput {
        var output : VertexOutput;

        let modelMatrix = objects[instanceIndex].modelMatrix;
        let normalMatrix = objects[instanceIndex].normalMatrix;
        let prevModelMatrix = objects[instanceIndex].prevModelMatrix;

        var localPos = input.position;

        // Apply wind displacement for foliage
        if (material.windEnabled > 0.5) {
          // Transform to world space first to get consistent wind across instances
          let tempWorldPos = modelMatrix * vec4<f32>(localPos, 1.0);

          // Height-based wind influence (base anchored, top moves most)
          // Uses localPos.y directly - assumes base at y=0, top at y>0
          let heightFactor = saturate(localPos.y);

          // Calculate wind displacement
          let windDisp = calculateWindDisplacement(
            tempWorldPos.xyz,
            scene.time,
            material.windStrength * heightFactor,
            material.windSpeed,
            material.windFrequency
          );

          // Apply displacement in world space, then transform back
          localPos = localPos + windDisp;
        }

        let worldPos = modelMatrix * vec4<f32>(localPos, 1.0);
        output.worldPosition = worldPos.xyz;

        let clipPos = scene.projectionMatrix * scene.viewMatrix * worldPos;
        output.position = clipPos;
        output.currentClip = clipPos;

        // Previous Frame Position (without wind for stable motion vectors)
        let prevWorldPos = prevModelMatrix * vec4<f32>(input.position, 1.0);
        output.prevClip = scene.prevViewProj * prevWorldPos;

        output.worldNormal = (normalMatrix * vec4<f32>(input.normal, 0.0)).xyz;
        output.uv = input.uv;
        return output;
      }
    `;
    this.fragmentShaderCode = `
      ${commonDefines}

      struct FragmentOutput {
        @location(0) albedo : vec4<f32>,   // RGB = Color, A = Roughness
        @location(1) normal : vec4<f32>,   // RGB = Normal, A = Metalness
        @location(2) position : vec4<f32>, // RGB = World Position, A = Occlusion
        @location(3) emissive : vec4<f32>, // RGB = Emissive, A = Unused
        @location(4) velocity : vec2<f32>, // RG = Velocity
      }

      const HAS_ALBEDO_MAP = 1u;
      const HAS_NORMAL_MAP = 2u;
      const HAS_ROUGHNESS_MAP = 4u;
      const HAS_METALLIC_MAP = 8u;
      const HAS_EMISSIVE_MAP = 16u;
      const HAS_OCCLUSION_MAP = 32u;
      const HAS_DISPLACEMENT_MAP = 64u;
      const HAS_BLEND_MAP_2 = 128u;
      const HAS_BLEND_NORMAL_2 = 256u;

      const BLEND_MODE_NONE = 0u;
      const BLEND_MODE_NOISE = 1u;

      // Simplex noise helper functions
      fn mod289_3(x: vec3f) -> vec3f {
        return x - floor(x * (1.0 / 289.0)) * 289.0;
      }

      fn mod289_2(x: vec2f) -> vec2f {
        return x - floor(x * (1.0 / 289.0)) * 289.0;
      }

      fn permute(x: vec3f) -> vec3f {
        return mod289_3(((x * 34.0) + 1.0) * x);
      }

      fn simplex2d(v: vec2f) -> f32 {
        let C = vec4f(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
        var i = floor(v + dot(v, C.yy));
        let x0 = v - i + dot(i, C.xx);
        var i1: vec2f;
        if (x0.x > x0.y) {
          i1 = vec2f(1.0, 0.0);
        } else {
          i1 = vec2f(0.0, 1.0);
        }
        var x12 = x0.xyxy + C.xxzz;
        x12 = vec4f(x12.xy - i1, x12.zw);

        i = mod289_2(i);
        let p = permute(permute(i.y + vec3f(0.0, i1.y, 1.0)) + i.x + vec3f(0.0, i1.x, 1.0));

        var m = max(vec3f(0.5) - vec3f(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), vec3f(0.0));
        m = m * m;
        m = m * m;

        let x = 2.0 * fract(p * C.www) - 1.0;
        let h = abs(x) - 0.5;
        let ox = floor(x + 0.5);
        let a0 = x - ox;

        m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);

        var g: vec3f;
        g.x = a0.x * x0.x + h.x * x0.y;
        g.y = a0.y * x12.x + h.y * x12.y;
        g.z = a0.z * x12.z + h.z * x12.w;
        return 130.0 * dot(m, g);
      }

      fn parallaxMapping(texCoords: vec2f, viewDir: vec3f) -> vec2f {
         // Parallax Occlusion Mapping (Simplified / Steep Parallax)
         
         // Safety check for grazing angles
         if (abs(viewDir.z) < 0.05) {
             return texCoords;
         }

         // Steep Parallax Mapping
         let numLayers = mix(32.0, 8.0, abs(dot(vec3f(0.0, 0.0, 1.0), viewDir)));
         let layerDepth = 1.0 / numLayers;
         var currentLayerDepth = 0.0;
         let P = viewDir.xy / viewDir.z * material.displacementScale;
         let deltaTexCoords = P / numLayers;
         
         var currentTexCoords = texCoords;
         var currentDepthMapValue = 1.0 - textureSampleLevel(displacementTex, samp, currentTexCoords, 0.0).r;
         
         // Loop limit safety
         var i = 0u;
         while(currentLayerDepth < currentDepthMapValue && i < 64u) {
            currentTexCoords -= deltaTexCoords;
            currentDepthMapValue = 1.0 - textureSampleLevel(displacementTex, samp, currentTexCoords, 0.0).r;
            currentLayerDepth += layerDepth;
            i++;
         }
         
         // Parallax Occlusion (Interpolation)
         let prevTexCoords = currentTexCoords + deltaTexCoords;
         let afterDepth = currentDepthMapValue - currentLayerDepth;
         let beforeDepth = (1.0 - textureSampleLevel(displacementTex, samp, prevTexCoords, 0.0).r) - currentLayerDepth + layerDepth;
         let weight = afterDepth / (afterDepth - beforeDepth);
         let finalTexCoords = prevTexCoords * weight + currentTexCoords * (1.0 - weight);
         
         return finalTexCoords;
      }

      @fragment
      fn fs_main(@location(0) worldNormal : vec3<f32>, @location(1) inUV : vec2<f32>, @location(2) worldPosition : vec3<f32>, @location(3) currentClip : vec4<f32>, @location(4) prevClip : vec4<f32>) -> FragmentOutput {
        var output : FragmentOutput;

        // Safe normalize to prevent NaN from zero-length or degenerate normals
        let normalLen = length(worldNormal);
        var N = select(vec3f(0.0, 1.0, 0.0), worldNormal / normalLen, normalLen > 0.0001);

        // Apply texture scale/tiling (matches THREE.js texture.repeat)
        // Or use world-space UVs for ground/terrain
        var uv: vec2f;
        if (material.useWorldSpaceUV > 0.5) {
          uv = worldPosition.xz / material.worldSpaceUVScale;
        } else {
          uv = inUV * material.textureScale;
        }

        // Velocity Calculation
        // TODO: Handle jitter removal for more accurate TAA
        let currentNDC = currentClip.xy / currentClip.w;
        let prevNDC = prevClip.xy / prevClip.w;
        let velocity = (currentNDC - prevNDC) * 0.5;
        // Invert Y to match Texture UV space (Y down)
        output.velocity = vec2<f32>(velocity.x, -velocity.y);

        // Calculate Tangent Space View Vector for Parallax Mapping
        // We need TBN matrix early if displacement is enabled
        let V_world = normalize(scene.cameraPosition - worldPosition);
        
        if ((material.textureFlags & HAS_DISPLACEMENT_MAP) != 0u) {
            let Q1 = dpdx(worldPosition);
            let Q2 = dpdy(worldPosition);
            let st1 = dpdx(uv);
            let st2 = dpdy(uv);
            let T = normalize(Q1 * st2.y - Q2 * st1.y);
            let B = -normalize(cross(N, T));
            let TBN = mat3x3f(T, B, N);
            
            let V_tangent = normalize(transpose(TBN) * V_world);
            
            // Check if V_tangent.z is positive (looking at surface)
            // If surface is backfacing relative to tangent plane, skip or clamp?
            // Usually not an issue with backface culling.
            
            uv = parallaxMapping(uv, V_tangent);
            
            // Discard if UV is out of bounds?
            if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
                // discard; // Optional: depends on wrapping mode
            }
        }

        var baseColor = material.albedo;
        var roughness = material.roughness;
        var metallic = material.metallic;
        var alpha = material.opacity;
        var emissive = vec3f(0.0);
        var occlusion = 1.0;

        // Calculate blend factor for noise-based texture blending (used for albedo and normal)
        var blendFactor = 0.0;
        if (material.blendMode == BLEND_MODE_NOISE) {
            let noiseVal = simplex2d(worldPosition.xz / material.blendNoiseScale);
            let normalizedNoise = noiseVal * 0.5 + 0.5; // Map from [-1,1] to [0,1]
            blendFactor = smoothstep(
                material.blendPatchiness - 0.1,
                material.blendPatchiness + 0.1,
                normalizedNoise
            );
        }

        // Albedo Map with optional blending
        if ((material.textureFlags & HAS_ALBEDO_MAP) != 0u) {
            let texColor1 = textureSample(albedoTex, samp, uv);
            var finalAlbedo = texColor1.rgb;
            var finalAlpha = texColor1.a;

            // Noise-based texture blending for ground/terrain
            if (material.blendMode == BLEND_MODE_NOISE && (material.textureFlags & HAS_BLEND_MAP_2) != 0u) {
                let texColor2 = textureSample(blendAlbedoTex2, samp, uv);
                finalAlbedo = mix(texColor1.rgb, texColor2.rgb, blendFactor);
                finalAlpha = mix(texColor1.a, texColor2.a, blendFactor);
            }

            baseColor = baseColor * finalAlbedo;
            alpha = alpha * finalAlpha;
        }

        // Alpha Masking
        if (material.alphaCutoff > 0.0 && alpha < material.alphaCutoff) {
            if (material.alphaMode == 1u) { // MASK
                discard;
            }
        }

        // Normal Map with optional blending
        if ((material.textureFlags & HAS_NORMAL_MAP) != 0u) {
          var rawNormal = textureSample(normalTex, samp, uv).xyz * 2.0 - 1.0;

          // Blend with secondary normal map if enabled
          if (material.blendMode == BLEND_MODE_NOISE && (material.textureFlags & HAS_BLEND_NORMAL_2) != 0u) {
              let rawNormal2 = textureSample(blendNormalTex2, samp, uv).xyz * 2.0 - 1.0;
              rawNormal = mix(rawNormal, rawNormal2, blendFactor);
          }

          let mapNormalLength = length(rawNormal);

          // Roughness Bias (Geometric AA)
          // If normal length is short, it means high variance (averaged out).
          // Increase roughness to prevent aliasing.
          let variance = clamp(1.0 - mapNormalLength, 0.0, 1.0);
          roughness = max(roughness, variance * 2.0);

          // Re-normalize for shading
          let mapNormal = rawNormal / max(mapNormalLength, 0.001);

          // Re-calculate TBN for the new UVs (gradients might have changed? strictly speaking yes)
          // But usually we can reuse or just re-compute.
          // Re-computing is safer for correctness with new UVs.
          let Q1 = dpdx(worldPosition);
          let Q2 = dpdy(worldPosition);
          let st1 = dpdx(uv);
          let st2 = dpdy(uv);
          let T = normalize(Q1 * st2.y - Q2 * st1.y);
          let B = -normalize(cross(N, T));
          let TBN = mat3x3f(T, B, N);
          N = normalize(TBN * mapNormal);
        }

        // Roughness Map
        if ((material.textureFlags & HAS_ROUGHNESS_MAP) != 0u) {
            roughness = textureSample(roughnessTex, samp, uv).g;
        }

        // Metallic Map
        if ((material.textureFlags & HAS_METALLIC_MAP) != 0u) {
            metallic = textureSample(metallicTex, samp, uv).b;
        }
        
        // Emissive Map
        if ((material.textureFlags & HAS_EMISSIVE_MAP) != 0u) {
             // Emissive texture is sRGB usually? Assuming linear here if loaded as such.
             // Multiply by emissive factor
             emissive = textureSample(emissiveTex, samp, uv).rgb * material.emissive;
        } else {
             emissive = material.emissive;
        }

        // Occlusion Map
        if ((material.textureFlags & HAS_OCCLUSION_MAP) != 0u) {
            occlusion = textureSample(occlusionTex, samp, uv).r;
        }

        output.albedo = vec4<f32>(baseColor, roughness);
        output.normal = vec4<f32>(N * 0.5 + 0.5, metallic);
        output.position = vec4<f32>(worldPosition, occlusion);
        output.emissive = vec4<f32>(emissive, material.ambientIntensity);  // alpha = ambient intensity multiplier
        output.velocity = vec2<f32>(0.0, 0.0); // Dummy velocity

        return output;
      }
    `;
    this.forwardFragmentShaderCode = `
      ${commonDefines}

      const PI = 3.14159265359;

      const HAS_ALBEDO_MAP = 1u;
      const HAS_NORMAL_MAP = 2u;
      const HAS_ROUGHNESS_MAP = 4u;
      const HAS_METALLIC_MAP = 8u;
      const HAS_EMISSIVE_MAP = 16u;
      const HAS_OCCLUSION_MAP = 32u;
      const HAS_BLEND_MAP_2 = 128u;
      const HAS_BLEND_NORMAL_2 = 256u;

      const BLEND_MODE_NONE = 0u;
      const BLEND_MODE_NOISE = 1u;

      // Simplex noise helper functions for texture blending
      fn mod289_3(x: vec3f) -> vec3f {
        return x - floor(x * (1.0 / 289.0)) * 289.0;
      }

      fn mod289_2(x: vec2f) -> vec2f {
        return x - floor(x * (1.0 / 289.0)) * 289.0;
      }

      fn permute(x: vec3f) -> vec3f {
        return mod289_3(((x * 34.0) + 1.0) * x);
      }

      fn simplex2d(v: vec2f) -> f32 {
        let C = vec4f(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
        var i = floor(v + dot(v, C.yy));
        let x0 = v - i + dot(i, C.xx);
        var i1: vec2f;
        if (x0.x > x0.y) {
          i1 = vec2f(1.0, 0.0);
        } else {
          i1 = vec2f(0.0, 1.0);
        }
        var x12 = x0.xyxy + C.xxzz;
        x12 = vec4f(x12.xy - i1, x12.zw);

        i = mod289_2(i);
        let p = permute(permute(i.y + vec3f(0.0, i1.y, 1.0)) + i.x + vec3f(0.0, i1.x, 1.0));

        var m = max(vec3f(0.5) - vec3f(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), vec3f(0.0));
        m = m * m;
        m = m * m;

        let x = 2.0 * fract(p * C.www) - 1.0;
        let h = abs(x) - 0.5;
        let ox = floor(x + 0.5);
        let a0 = x - ox;

        m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);

        var g: vec3f;
        g.x = a0.x * x0.x + h.x * x0.y;
        g.y = a0.y * x12.x + h.y * x12.y;
        g.z = a0.z * x12.z + h.z * x12.w;
        return 130.0 * dot(m, g);
      }

      // Simple hash-based noise for foliage normal variation
      fn hash31(p: vec3f) -> f32 {
          var p3 = fract(p * 0.1031);
          p3 += dot(p3, p3.yzx + 33.33);
          return fract((p3.x + p3.y) * p3.z);
      }

      fn hash33(p: vec3f) -> vec3f {
          var p3 = fract(p * vec3f(0.1031, 0.1030, 0.0973));
          p3 += dot(p3, p3.yxz + 33.33);
          return fract((p3.xxy + p3.yxx) * p3.zyx);
      }

      // Simple hash function for cloud shadow noise
      fn hash2(p: vec2f) -> f32 {
          let h = dot(p, vec2f(127.1, 311.7));
          return fract(sin(h) * 43758.5453);
      }

      // Value noise for cloud shadows
      fn noise2(p: vec2f) -> f32 {
          let i = floor(p);
          let f = fract(p);
          let u = f * f * (3.0 - 2.0 * f); // Smoothstep

          let a = hash2(i);
          let b = hash2(i + vec2f(1.0, 0.0));
          let c = hash2(i + vec2f(0.0, 1.0));
          let d = hash2(i + vec2f(1.0, 1.0));

          return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
      }

      // FBM (Fractal Brownian Motion) for cloud shadows
      fn fbmCloudShadow(pos: vec2f) -> f32 {
          var p = pos;
          var value = 0.0;
          var amplitude = 0.5;
          var frequency = 1.0;

          for (var i = 0; i < 5; i++) {
              value += amplitude * noise2(p * frequency);
              amplitude *= 0.5;
              frequency *= 2.0;
          }

          return value;
      }

      // Calculate cloud shadow factor based on world position
      fn getCloudShadow(worldPos: vec3f) -> f32 {
          let enabled = scene.cloudShadowParams.x;
          if (enabled < 0.5) {
              return 1.0; // No shadow when disabled
          }

          let intensity = scene.cloudShadowParams.y;
          let scale = scene.cloudShadowParams.z;
          let speed = scene.cloudShadowParams.w;
          let coverage = scene.cloudShadowParams2.x;
          let softness = scene.cloudShadowParams2.y;
          let windDirX = scene.cloudShadowParams2.z;
          let windDirZ = scene.cloudShadowParams2.w;

          // Calculate UV from world XZ position with wind animation
          let windOffset = vec2f(windDirX, windDirZ) * scene.time * speed;
          let uv = worldPos.xz * scale + windOffset;

          // Sample FBM noise
          let noise = fbmCloudShadow(uv);

          // Apply coverage threshold - higher coverage = more shadow
          let threshold = 1.0 - coverage;
          let cloudAmount = smoothstep(threshold - softness * 0.5, threshold + softness * 0.5, noise);

          // Return shadow factor: 1 = no shadow, (1-intensity) = max shadow
          return 1.0 - cloudAmount * intensity;
      }

      // Procedural normal variation for foliage (grass, leaves)
      // Creates subtle normal perturbations based on world position
      fn getFoliageNormalVariation(worldPos: vec3f, baseNormal: vec3f, strength: f32) -> vec3f {
          // Use world position to generate per-blade/leaf variation
          let noise = hash33(worldPos * 2.0) * 2.0 - 1.0;

          // Create tangent vectors for normal perturbation
          var tangent = vec3f(1.0, 0.0, 0.0);
          if (abs(baseNormal.x) > 0.9) {
              tangent = vec3f(0.0, 1.0, 0.0);
          }
          let bitangent = normalize(cross(baseNormal, tangent));
          tangent = normalize(cross(bitangent, baseNormal));

          // Apply noise-based perturbation (stronger horizontal, weaker vertical)
          let perturbedNormal = baseNormal
              + tangent * noise.x * strength * 0.6
              + bitangent * noise.z * strength * 0.6
              + baseNormal * noise.y * strength * 0.2;

          return normalize(perturbedNormal);
      }

      fn distributionGGX(N: vec3f, H: vec3f, roughness: f32) -> f32 {
        let a = roughness * roughness;
        let a2 = a * a;
        let NdotH = max(dot(N, H), 0.0);
        let NdotH2 = NdotH * NdotH;
        let num = a2;
        let denom = (NdotH2 * (a2 - 1.0) + 1.0);
        return num / (PI * denom * denom);
      }

      fn geometrySchlickGGX(NdotV: f32, roughness: f32) -> f32 {
        let r = (roughness + 1.0);
        let k = (r * r) / 8.0;
        let num = NdotV;
        let denom = NdotV * (1.0 - k) + k;
        return num / denom;
      }

      fn geometrySmith(N: vec3f, V: vec3f, L: vec3f, roughness: f32) -> f32 {
        let NdotV = max(dot(N, V), 0.0);
        let NdotL = max(dot(N, L), 0.0);
        let ggx2 = geometrySchlickGGX(NdotV, roughness);
        let ggx1 = geometrySchlickGGX(NdotL, roughness);
        return ggx1 * ggx2;
      }

      fn fresnelSchlick(cosTheta: f32, F0: vec3f) -> vec3f {
        return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
      }
      
      // Convert direction to cube face index and UV coordinates
      // Face order: 0=+X, 1=-X, 2=+Y, 3=-Y, 4=+Z, 5=-Z
      // Derived from lookAt view matrices: ze=eye-target, xe=up×ze, ye=ze×xe
      fn dirToCubeFaceUV(dir: vec3f) -> vec3f {
          let absDir = abs(dir);
          var faceIndex: f32;
          var uv: vec2f;

          if (absDir.x >= absDir.y && absDir.x >= absDir.z) {
              if (dir.x > 0.0) {
                  faceIndex = 0.0; // +X: xe=(0,0,-1), ye=(0,-1,0)
                  uv = vec2f(-dir.z, dir.y) / absDir.x;
              } else {
                  faceIndex = 1.0; // -X: xe=(0,0,1), ye=(0,-1,0)
                  uv = vec2f(dir.z, dir.y) / absDir.x;
              }
          } else if (absDir.y >= absDir.x && absDir.y >= absDir.z) {
              if (dir.y > 0.0) {
                  faceIndex = 2.0; // +Y: xe=(1,0,0), ye=(0,0,1)
                  uv = vec2f(dir.x, -dir.z) / absDir.y;
              } else {
                  faceIndex = 3.0; // -Y: xe=(1,0,0), ye=(0,0,-1)
                  uv = vec2f(dir.x, dir.z) / absDir.y;
              }
          } else {
              if (dir.z > 0.0) {
                  faceIndex = 4.0; // +Z: xe=(1,0,0), ye=(0,-1,0)
                  uv = vec2f(dir.x, dir.y) / absDir.z;
              } else {
                  faceIndex = 5.0; // -Z: xe=(-1,0,0), ye=(0,-1,0)
                  uv = vec2f(-dir.x, dir.y) / absDir.z;
              }
          }
          uv = uv * 0.5 + 0.5;
          return vec3f(uv, faceIndex);
      }

      fn samplePointShadow(shadowIndex: i32, worldPos: vec3f, lightPos: vec3f) -> f32 {
          let shadowsEnabled = (scene.flags & 1u) != 0u;

          let L = worldPos - lightPos;
          let dir = normalize(L);

          let far = 100.0;
          let currentDepth = length(L) / far;

          let faceUV = dirToCubeFaceUV(dir);
          let layerIndex = shadowIndex * 6 + i32(faceUV.z);

          let shadowDepth = textureSampleLevel(pointShadowTex, pointShadowSamp, faceUV.xy, layerIndex, 0.0).r;

          let bias = 0.005;
          let inShadow = select(0.0, 1.0, currentDepth - bias <= shadowDepth);

          return select(1.0, inShadow, shadowsEnabled);
      }

      // Interleaved Gradient Noise for randomizing sampling patterns per pixel
      fn interleavedGradientNoise(position: vec2f) -> f32 {
          return fract(52.9829189 * fract(dot(position, vec2f(0.06711056, 0.00583715))));
      }

      // Vogel disk sampling for uniform circular distribution
      fn vogelDiskSample(sampleIndex: i32, samplesCount: i32, phi: f32) -> vec2f {
          let goldenAngle = 2.399963229728653;
          let r = sqrt((f32(sampleIndex) + 0.5) / f32(samplesCount));
          let theta = f32(sampleIndex) * goldenAngle + phi;
          return vec2f(cos(theta), sin(theta)) * r;
      }

      // Sample shadow for a specific light using its shadow atlas layer
      fn sampleShadowForLight(shadowLightIdx: u32, worldPos: vec3f, N: vec3f, L: vec3f) -> f32 {
          if ((scene.flags & 1u) == 0u) {
              return 1.0;
          }
          if (shadowLightIdx >= shadowUniforms.shadowLightCount) {
              return 1.0;
          }

          let shadowLight = shadowUniforms.lights[shadowLightIdx];

          // Apply normal bias to prevent shadow acne
          let biasedWorldPos = worldPos + N * shadowLight.normalBias;

          // Project to light space
          let lightSpacePos = shadowLight.viewProj * vec4f(biasedWorldPos, 1.0);
          let projCoords = lightSpacePos.xyz / lightSpacePos.w;
          let uv = vec2f(projCoords.x, -projCoords.y) * 0.5 + 0.5;

          // Check bounds
          if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0 || projCoords.z < 0.0 || projCoords.z > 1.0) {
              return 1.0;
          }

          // Dynamic bias based on surface angle
          let angleBias = max(shadowLight.bias * (1.0 - dot(N, L)), shadowLight.bias * 0.1);
          let currentDepth = projCoords.z - angleBias;

          // PCF (Percentage Closer Filtering) with 3x3 kernel
          var visibility = 0.0;
          let oneOverSize = 1.0 / shadowUniforms.atlasResolution;
          let layer = i32(shadowLight.atlasLayer);

          for (var y = -1; y <= 1; y++) {
              for (var x = -1; x <= 1; x++) {
                  let offset = vec2f(f32(x), f32(y)) * oneOverSize;
                  visibility += textureSampleCompareLevel(
                      shadowMap, shadowSampler,
                      uv + offset, layer, currentDepth
                  );
              }
          }
          return visibility / 9.0;
      }

      // Sample a single cascade with noise-based PCF to eliminate moire patterns
      fn sampleCascadeWithNoise(cascade: u32, worldPos: vec3f, N: vec3f, fragCoord: vec2f) -> f32 {
        let viewProj = cascadeUniforms.viewProj[cascade];
        let bias = cascadeUniforms.biases[cascade];

        // Minimal normal bias
        let normalBias = 0.01;
        let biasedWorldPos = worldPos + N * normalBias;
        let lightSpacePos = viewProj * vec4f(biasedWorldPos, 1.0);
        let projCoords = lightSpacePos.xyz / lightSpacePos.w;
        let uv = vec2f(projCoords.x, -projCoords.y) * 0.5 + 0.5;

        if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0 || projCoords.z < 0.0 || projCoords.z > 1.0) {
            return 1.0;
        }

        let currentDepth = projCoords.z - bias;
        var visibility = 0.0;
        let oneOverSize = 1.0 / 2048.0;
        let layer = i32(cascade);

        // Scale filter size by cascade - larger cascades get larger filter
        let filterScale = 1.0 + f32(cascade) * 0.5;
        let filterRadius = oneOverSize * filterScale * 1.5;

        // Use IGN to rotate sampling pattern per pixel - eliminates moire
        let phi = interleavedGradientNoise(fragCoord) * 6.283185307;

        // 12 Vogel disk samples for smooth shadows
        let NUM_SAMPLES = 12;
        for (var i = 0; i < NUM_SAMPLES; i++) {
            let offset2D = vogelDiskSample(i, NUM_SAMPLES, phi) * filterRadius;
            visibility += textureSampleCompareLevel(
                shadowMap, shadowSampler,
                uv + offset2D, layer, currentDepth
            );
        }
        return visibility / f32(NUM_SAMPLES);
      }

      // Cascaded Shadow Map sampling with noise-based PCF and blending
      fn sampleCascadedShadowWithNoise(worldPos: vec3f, N: vec3f, viewMatrix: mat4x4<f32>, fragCoord: vec2f) -> f32 {
        if ((scene.flags & 1u) == 0u) {
            return 1.0;
        }

        let viewPos = viewMatrix * vec4f(worldPos, 1.0);
        let depth = -viewPos.z;

        var cascade = 3u;
        if (depth < cascadeUniforms.splits.x) {
            cascade = 0u;
        } else if (depth < cascadeUniforms.splits.y) {
            cascade = 1u;
        } else if (depth < cascadeUniforms.splits.z) {
            cascade = 2u;
        }

        let shadow1 = sampleCascadeWithNoise(cascade, worldPos, N, fragCoord);

        // Cascade blending at boundaries (last 25% of each cascade)
        if (cascade < 3u) {
            let splits = array<f32, 4>(
                cascadeUniforms.splits.x,
                cascadeUniforms.splits.y,
                cascadeUniforms.splits.z,
                cascadeUniforms.splits.w
            );
            let cascadeEnd = splits[cascade];
            let blendStart = cascadeEnd * 0.75; // Blend in last 25%

            if (depth > blendStart) {
                // Use smoothstep for a more gradual transition
                let t = (depth - blendStart) / (cascadeEnd - blendStart);
                let blendFactor = t * t * (3.0 - 2.0 * t); // smoothstep
                let shadow2 = sampleCascadeWithNoise(cascade + 1u, worldPos, N, fragCoord);
                return mix(shadow1, shadow2, blendFactor);
            }
        }

        return shadow1;
      }

      @fragment
      fn fs_main(@location(0) worldNormal : vec3f, @location(1) inUV : vec2f, @location(2) worldPosition : vec3f, @builtin(front_facing) frontFacing : bool, @builtin(position) fragCoord : vec4f) -> @location(0) vec4f {
        // Safe normalize to prevent NaN from zero-length or degenerate normals
        let normalLen = length(worldNormal);
        var N = select(vec3f(0.0, 1.0, 0.0), worldNormal / normalLen, normalLen > 0.0001);

        // For doubleSided materials: flip normal to face camera (like THREE.js DoubleSide)
        if (material.doubleSided > 0.5 && !frontFacing) {
          N = -N;
        }

        let V = normalize(scene.cameraPosition - worldPosition);

        // Apply texture scale/tiling (matches THREE.js texture.repeat)
        // Or use world-space UVs for ground/terrain
        var uv: vec2f;
        if (material.useWorldSpaceUV > 0.5) {
          uv = worldPosition.xz / material.worldSpaceUVScale;
        } else {
          uv = inUV * material.textureScale;
        }

        var baseColor = material.albedo;
        var alpha = material.opacity;
        var roughness = material.roughness;
        var metallic = material.metallic;
        var emissive = material.emissive;
        var occlusion = 1.0;

        // Calculate blend factor for noise-based texture blending (used for albedo and normal)
        var blendFactor = 0.0;
        if (material.blendMode == BLEND_MODE_NOISE) {
            let noiseVal = simplex2d(worldPosition.xz / material.blendNoiseScale);
            let normalizedNoise = noiseVal * 0.5 + 0.5; // Map from [-1,1] to [0,1]
            blendFactor = smoothstep(
                material.blendPatchiness - 0.1,
                material.blendPatchiness + 0.1,
                normalizedNoise
            );
        }

        // Albedo Map with optional blending
        if ((material.textureFlags & HAS_ALBEDO_MAP) != 0u) {
            let texColor1 = textureSample(albedoTex, samp, uv);
            var finalAlbedo = texColor1.rgb;
            var finalAlpha = texColor1.a;

            // Noise-based texture blending for ground/terrain
            if (material.blendMode == BLEND_MODE_NOISE && (material.textureFlags & HAS_BLEND_MAP_2) != 0u) {
                let texColor2 = textureSample(blendAlbedoTex2, samp, uv);
                finalAlbedo = mix(texColor1.rgb, texColor2.rgb, blendFactor);
                finalAlpha = mix(texColor1.a, texColor2.a, blendFactor);
            }

            baseColor = baseColor * finalAlbedo;
            alpha = alpha * finalAlpha;
        }

        // Normal Map with optional blending
        if ((material.textureFlags & HAS_NORMAL_MAP) != 0u) {
          var mapNormal = textureSample(normalTex, samp, uv).xyz * 2.0 - 1.0;

          // Blend with secondary normal map if enabled
          if (material.blendMode == BLEND_MODE_NOISE && (material.textureFlags & HAS_BLEND_NORMAL_2) != 0u) {
              let mapNormal2 = textureSample(blendNormalTex2, samp, uv).xyz * 2.0 - 1.0;
              mapNormal = mix(mapNormal, mapNormal2, blendFactor);
          }

          let Q1 = dpdx(worldPosition);
          let Q2 = dpdy(worldPosition);
          let st1 = dpdx(uv);
          let st2 = dpdy(uv);
          let T = normalize(Q1 * st2.y - Q2 * st1.y);
          let B = -normalize(cross(N, T));
          let TBN = mat3x3f(T, B, N);
          N = normalize(TBN * mapNormal);
        }

        // Foliage normal variation: Add procedural normal perturbation for wind-enabled materials
        // This creates lighting variation for grass/leaves that lack normal maps
        if (material.windEnabled > 0.5 && (material.textureFlags & HAS_NORMAL_MAP) == 0u) {
          // Strength based on wind strength - more wind = more normal variation
          let variationStrength = 0.3 + material.windStrength * 0.4;
          N = getFoliageNormalVariation(worldPosition, N, variationStrength);
        }

        // Roughness Map
        if ((material.textureFlags & HAS_ROUGHNESS_MAP) != 0u) {
            roughness = textureSample(roughnessTex, samp, uv).g;
        }

        // Metallic Map
        if ((material.textureFlags & HAS_METALLIC_MAP) != 0u) {
            metallic = textureSample(metallicTex, samp, uv).b;
        }

        // Emissive Map
        if ((material.textureFlags & HAS_EMISSIVE_MAP) != 0u) {
            emissive = textureSample(emissiveTex, samp, uv).rgb * material.emissive; // Multiply by factor
        }

        // Occlusion Map
        if ((material.textureFlags & HAS_OCCLUSION_MAP) != 0u) {
            occlusion = textureSample(occlusionTex, samp, uv).r;
        }
        
        // Alpha Test
        if (material.alphaCutoff > 0.0 && alpha < material.alphaCutoff) {
             if (material.alphaMode == 1u) { // MASK
                discard; 
             }
        }
        
        var F0 = vec3f(0.04);
        F0 = mix(F0, baseColor, metallic);

        // ===========================================
        // PHASE 1: Collect Ambient/Hemisphere Light
        // These lights add uniform illumination not based on direction
        // ===========================================
        var ambientIrradiance = vec3f(0.0);
        for (var i = 0u; i < scene.lightCount; i++) {
            let light = scene.lights[i];

            if (light.lightType == 3u) { // Ambient Light
                // Flat ambient - same everywhere regardless of normal
                ambientIrradiance += light.color * light.intensity;
            } else if (light.lightType == 4u) { // Hemisphere Light
                // Sky/ground interpolation based on surface normal
                // light.color = skyColor, light.attenuation = groundColor
                let hemiIrradiance = getHemisphereLightIrradiance(
                    light.color,
                    light.attenuation,  // groundColor stored in attenuation field
                    N,
                    light.direction     // up direction (usually 0,1,0)
                );
                ambientIrradiance += hemiIrradiance * light.intensity;
            }
        }

        // Add a small base ambient if no ambient lights exist
        if (length(ambientIrradiance) < 0.001) {
            ambientIrradiance = vec3f(0.03);  // Minimal fallback ambient
        }

        // ===========================================
        // PHASE 2: Direct Lighting with Shadows
        // Only Directional, Point, and Spot lights
        // ===========================================
        var Lo = vec3f(0.0);

        for (var i = 0u; i < scene.lightCount; i++) {
            let light = scene.lights[i];

            // Skip ambient and hemisphere lights (already processed above)
            if (light.lightType == 3u || light.lightType == 4u) {
                continue;
            }

            var L = vec3f(0.0);
            var attenuation = 1.0;
            var shadow = 1.0;

            if (light.lightType == 0u) { // Directional
                L = normalize(-light.direction);
            } else {
                let lightVec = light.position - worldPosition;
                let dist = length(lightVec);
                L = normalize(lightVec);
                attenuation = 1.0 / (1.0 + 0.09 * dist + 0.032 * dist * dist);
                if (light.lightType == 2u) { // Spot
                   let spotDir = normalize(-light.direction);
                   let angle = acos(dot(L, spotDir));
                   let inner = light.coneAngles.x;
                   let outer = light.coneAngles.y;
                   let spotEffect = 1.0 - smoothstep(inner, outer, angle);
                   attenuation *= spotEffect;
                }
            }

            // Sample shadow if this light has a valid shadow index
            if (light.shadowIndex >= 0) {
                if (light.lightType == 0u) { // Directional - use Cascaded Shadow Maps with noise-based PCF
                    shadow = sampleCascadedShadowWithNoise(worldPosition, N, scene.viewMatrix, fragCoord.xy);
                    // Apply shadow intensity - allows ambient to leak through
                    shadow = mix(1.0, shadow, light.shadowIntensity);
                    // Apply cloud shadows for directional lights
                    shadow *= getCloudShadow(worldPosition);
                } else if (light.lightType == 1u) { // Point
                    shadow = samplePointShadow(light.shadowIndex, worldPosition, light.position);
                    shadow = mix(1.0, shadow, light.shadowIntensity);
                } else { // Spot
                    shadow = sampleShadowForLight(u32(light.shadowIndex), worldPosition, N, L);
                    shadow = mix(1.0, shadow, light.shadowIntensity);
                }
            }

            let H = normalize(V + L);
            let radiance = light.color * light.intensity * attenuation * shadow;

            let NDF = distributionGGX(N, H, roughness);
            let G = geometrySmith(N, V, L, roughness);
            let F = fresnelSchlick(max(dot(H, V), 0.0), F0);

            let numerator = NDF * G * F;

            // Standard NdotV/NdotL - normal was already flipped for back faces if doubleSided
            let NdotV = max(dot(N, V), 0.0);
            let NdotL = max(dot(N, L), 0.0);

            let denominator = 4.0 * NdotV * NdotL + 0.0001;
            let specular = numerator / denominator;

            let kS = F;
            var kD = vec3f(1.0) - kS;
            kD *= 1.0 - metallic;

            Lo += (kD * baseColor / PI + specular) * radiance * NdotL;
        }

        // Combine ambient irradiance with base color, occlusion, and per-material intensity
        let ambient = ambientIrradiance * baseColor * occlusion * material.ambientIntensity;
        var color = ambient + Lo + emissive;

        // Apply Fog
        color = applyFog(color, worldPosition);

        // Output linear color - ToneMappingPass handles gamma correction
        return vec4f(color, alpha);
      }
    `;
  }
  getRenderingPath() {
    if (this.alphaMode === "BLEND" || this.alphaMode === "MASK" || this.doubleSided) {
      return "forward";
    }
    return "deferred";
  }
  getTextureFlags() {
    let flags = 0;
    if (this.albedoMap)
      flags |= 1;
    if (this.normalMap)
      flags |= 2;
    if (this.roughnessMap)
      flags |= 4;
    if (this.metallicMap)
      flags |= 8;
    if (this.emissiveMap)
      flags |= 16;
    if (this.occlusionMap)
      flags |= 32;
    if (this.displacementMap)
      flags |= 64;
    if (this.blendMap2)
      flags |= 128;
    if (this.blendNormalMap2)
      flags |= 256;
    return flags;
  }
  getInstancedVertexShader(pass) {
    return `
      struct Light {
        position: vec3f,
        _pad1: f32,
        direction: vec3f,
        _pad2: f32,
        color: vec3f,
        intensity: f32,
        attenuation: vec3f,
        lightType: u32,
        coneAngles: vec2f,
        shadowIndex: i32,
        shadowRadius: f32,
        shadowIntensity: f32,
        _pad3: f32,
        _pad4: f32,
        _pad5: f32,
      }

      struct SceneUniforms {
        viewMatrix : mat4x4<f32>,
        projectionMatrix : mat4x4<f32>,
        lightViewProj : mat4x4<f32>,
        prevViewProj : mat4x4<f32>,
        inverseProjectionMatrix : mat4x4<f32>,
        cameraPosition : vec3f,
        time : f32,
        lightCount : u32,
        debugMode : u32,
        flags : u32,
        environmentIntensity : f32,
        fogColorLegacy: vec3f,
        fogDensityLegacy: f32,
        fogParamsLegacy: vec4f,
        fogSettingsLegacy: vec4u,
        cloudShadowParams: vec4f,
        cloudShadowParams2: vec4f,
        fogColor: vec3f,
        fogDensity: f32,
        fogParams: vec4f,
        fogSkyFalloff: f32,
        _fogPad1: f32,
        _fogPad2: f32,
        _fogPad3: f32,
        lights : array<Light, ${StandardMaterial.MAX_LIGHTS}>,
      }

      struct MaterialUniforms {
        albedo : vec3<f32>,
        roughness : f32,
        emissive : vec3<f32>,
        metallic : f32,
        opacity : f32,
        alphaCutoff : f32,
        displacementScale : f32,
        textureFlags : u32,
        alphaMode : u32,
        receiveShadows : f32,
        textureScale : vec2<f32>,
        doubleSided : f32,
        ambientIntensity : f32,
        windEnabled : f32,
        windStrength : f32,
        windSpeed : f32,
        windFrequency : f32,
        blendMode : u32,
        useWorldSpaceUV : f32,
        worldSpaceUVScale : f32,
        blendNoiseScale : f32,
        blendPatchiness : f32,
        _blendPad1 : f32,
        _blendPad2 : f32,
        _blendPad3 : f32,
      }

      @group(0) @binding(0) var<uniform> scene : SceneUniforms;
      @group(1) @binding(0) var<uniform> material : MaterialUniforms;

      // Per-vertex attributes
      struct VertexInput {
        @location(0) position : vec3<f32>,
        @location(1) normal : vec3<f32>,
        @location(2) uv : vec2<f32>,
        // Per-instance attributes
        @location(3) instancePosRot : vec4<f32>,  // position.xyz, rotation
        @location(4) instanceScale : vec4<f32>,   // scale.xyz, unused
        @location(5) instanceColor : vec4<f32>,   // color.rgb, unused
      }

      struct VertexOutput {
        @builtin(position) position : vec4<f32>,
        @location(0) worldNormal : vec3<f32>,
        @location(1) uv : vec2<f32>,
        @location(2) worldPosition : vec3<f32>,
        @location(3) instanceColor : vec3<f32>,  // Pass color to fragment shader
      }

      // Wind displacement function for foliage animation
      fn calculateWindDisplacement(worldPos: vec3f, time: f32, strength: f32, speed: f32, frequency: f32) -> vec3f {
        let phase = worldPos.x * 0.1 + worldPos.z * 0.1;
        let wind1 = sin(time * speed + phase) * strength;
        let wind2 = sin(time * speed * 1.7 + phase * 1.3) * strength * 0.5;
        let wind3 = cos(time * speed * 0.5 + phase * 0.7) * strength * 0.3;
        return vec3f(
          (wind1 + wind2) * frequency,
          wind3 * 0.2,
          (wind1 - wind2 * 0.5) * frequency * 0.7
        );
      }

      @vertex
      fn vs_main(input : VertexInput) -> VertexOutput {
        var output : VertexOutput;

        // Extract instance data
        let instancePos = input.instancePosRot.xyz;
        let rotationY = input.instancePosRot.w;
        let scale = input.instanceScale.xyz;
        let color = input.instanceColor.rgb;

        // Build Y-axis rotation matrix
        let cosR = cos(rotationY);
        let sinR = sin(rotationY);
        let rotMat = mat3x3f(
          vec3f(cosR, 0.0, sinR),
          vec3f(0.0, 1.0, 0.0),
          vec3f(-sinR, 0.0, cosR)
        );

        // Apply scale
        var localPos = input.position * scale;

        // Apply wind displacement for foliage (based on local Y position)
        if (material.windEnabled > 0.5) {
          // Use instance position for wind phase variation
          let tempWorldPos = rotMat * localPos + instancePos;
          let heightFactor = saturate(input.position.y * scale.y / max(scale.y, 0.001));

          let windDisp = calculateWindDisplacement(
            tempWorldPos,
            scene.time,
            material.windStrength * heightFactor,
            material.windSpeed,
            material.windFrequency
          );

          localPos = localPos + windDisp;
        }

        // Apply rotation and translation
        let worldPos = rotMat * localPos + instancePos;
        output.worldPosition = worldPos;

        let clipPos = scene.projectionMatrix * scene.viewMatrix * vec4f(worldPos, 1.0);
        output.position = clipPos;

        // Transform normal with rotation
        output.worldNormal = rotMat * input.normal;
        output.uv = input.uv;
        output.instanceColor = color;

        return output;
      }
    `;
  }
  getInstancedFragmentShader(pass) {
    if (pass === "forward") {
      return this.getInstancedForwardFragmentShader();
    }
    return this.getInstancedDeferredFragmentShader();
  }
  getInstancedDeferredFragmentShader() {
    return `
      struct Light {
        position: vec3f,
        _pad1: f32,
        direction: vec3f,
        _pad2: f32,
        color: vec3f,
        intensity: f32,
        attenuation: vec3f,
        lightType: u32,
        coneAngles: vec2f,
        shadowIndex: i32,
        shadowRadius: f32,
        shadowIntensity: f32,
        _pad3: f32,
        _pad4: f32,
        _pad5: f32,
      }

      struct SceneUniforms {
        viewMatrix : mat4x4<f32>,
        projectionMatrix : mat4x4<f32>,
        lightViewProj : mat4x4<f32>,
        prevViewProj : mat4x4<f32>,
        inverseProjectionMatrix : mat4x4<f32>,
        cameraPosition : vec3f,
        time : f32,
        lightCount : u32,
        debugMode : u32,
        flags : u32,
        environmentIntensity : f32,
        fogColorLegacy: vec3f,
        fogDensityLegacy: f32,
        fogParamsLegacy: vec4f,
        fogSettingsLegacy: vec4u,
        cloudShadowParams: vec4f,
        cloudShadowParams2: vec4f,
        fogColor: vec3f,
        fogDensity: f32,
        fogParams: vec4f,
        fogSkyFalloff: f32,
        _fogPad1: f32,
        _fogPad2: f32,
        _fogPad3: f32,
        lights : array<Light, ${StandardMaterial.MAX_LIGHTS}>,
      }

      struct MaterialUniforms {
        albedo : vec3<f32>,
        roughness : f32,
        emissive : vec3<f32>,
        metallic : f32,
        opacity : f32,
        alphaCutoff : f32,
        displacementScale : f32,
        textureFlags : u32,
        alphaMode : u32,
        receiveShadows : f32,
        textureScale : vec2<f32>,
        doubleSided : f32,
        ambientIntensity : f32,
        windEnabled : f32,
        windStrength : f32,
        windSpeed : f32,
        windFrequency : f32,
        blendMode : u32,
        useWorldSpaceUV : f32,
        worldSpaceUVScale : f32,
        blendNoiseScale : f32,
        blendPatchiness : f32,
        _blendPad1 : f32,
        _blendPad2 : f32,
        _blendPad3 : f32,
      }

      @group(0) @binding(0) var<uniform> scene : SceneUniforms;
      @group(1) @binding(0) var<uniform> material : MaterialUniforms;
      @group(1) @binding(1) var samp : sampler;
      @group(1) @binding(2) var albedoTex : texture_2d<f32>;

      struct FragmentOutput {
        @location(0) albedo : vec4<f32>,   // RGB = Color, A = Roughness
        @location(1) normal : vec4<f32>,   // RGB = Normal, A = Metalness
        @location(2) position : vec4<f32>, // RGB = World Position, A = Occlusion
        @location(3) emissive : vec4<f32>, // RGB = Emissive, A = Ambient Intensity
        @location(4) velocity : vec2<f32>, // RG = Velocity (unused for instanced)
      }

      const HAS_ALBEDO_MAP = 1u;

      @fragment
      fn fs_main(
        @builtin(front_facing) frontFacing : bool,
        @location(0) worldNormal : vec3<f32>,
        @location(1) inUV : vec2<f32>,
        @location(2) worldPosition : vec3<f32>,
        @location(3) instanceColor : vec3<f32>
      ) -> FragmentOutput {
        var output : FragmentOutput;

        // Safe normalize
        let normalLen = length(worldNormal);
        var N = select(vec3f(0.0, 1.0, 0.0), worldNormal / normalLen, normalLen > 0.0001);

        // Two-sided lighting: flip normal for back faces
        if (material.doubleSided > 0.5 && !frontFacing) {
          N = -N;
        }

        // Apply texture scale
        var uv: vec2f;
        if (material.useWorldSpaceUV > 0.5) {
          uv = worldPosition.xz / material.worldSpaceUVScale;
        } else {
          uv = inUV * material.textureScale;
        }

        var baseColor = material.albedo;
        var alpha = material.opacity;

        // Sample albedo texture if available
        if ((material.textureFlags & HAS_ALBEDO_MAP) != 0u) {
          let texColor = textureSample(albedoTex, samp, uv);
          baseColor = baseColor * texColor.rgb;
          alpha = alpha * texColor.a;
        }

        // Apply instance color tint
        baseColor = baseColor * instanceColor;

        // Alpha test
        if (material.alphaCutoff > 0.0 && alpha < material.alphaCutoff) {
          if (material.alphaMode == 1u) { // MASK
            discard;
          }
        }

        let roughness = material.roughness;
        let metallic = material.metallic;
        let occlusion = 1.0;
        let emissive = material.emissive;

        output.albedo = vec4f(baseColor, roughness);
        output.normal = vec4f(N * 0.5 + 0.5, metallic);
        output.position = vec4f(worldPosition, occlusion);
        output.emissive = vec4f(emissive, material.ambientIntensity);
        output.velocity = vec2f(0.0, 0.0);

        return output;
      }
    `;
  }
  getInstancedForwardFragmentShader() {
    return `
      struct Light {
        position: vec3f,
        _pad1: f32,
        direction: vec3f,
        _pad2: f32,
        color: vec3f,
        intensity: f32,
        attenuation: vec3f,
        lightType: u32,
        coneAngles: vec2f,
        shadowIndex: i32,
        shadowRadius: f32,
        shadowIntensity: f32,
        _pad3: f32,
        _pad4: f32,
        _pad5: f32,
      }

      struct SceneUniforms {
        viewMatrix : mat4x4<f32>,
        projectionMatrix : mat4x4<f32>,
        lightViewProj : mat4x4<f32>,
        prevViewProj : mat4x4<f32>,
        inverseProjectionMatrix : mat4x4<f32>,
        cameraPosition : vec3f,
        time : f32,
        lightCount : u32,
        debugMode : u32,
        flags : u32,
        environmentIntensity : f32,
        fogColorLegacy: vec3f,
        fogDensityLegacy: f32,
        fogParamsLegacy: vec4f,
        fogSettingsLegacy: vec4u,
        cloudShadowParams: vec4f,
        cloudShadowParams2: vec4f,
        fogColor: vec3f,
        fogDensity: f32,
        fogParams: vec4f,
        fogSkyFalloff: f32,
        _fogPad1: f32,
        _fogPad2: f32,
        _fogPad3: f32,
        lights : array<Light, ${StandardMaterial.MAX_LIGHTS}>,
      }

      struct MaterialUniforms {
        albedo : vec3<f32>,
        roughness : f32,
        emissive : vec3<f32>,
        metallic : f32,
        opacity : f32,
        alphaCutoff : f32,
        displacementScale : f32,
        textureFlags : u32,
        alphaMode : u32,
        receiveShadows : f32,
        textureScale : vec2<f32>,
        doubleSided : f32,
        ambientIntensity : f32,
        windEnabled : f32,
        windStrength : f32,
        windSpeed : f32,
        windFrequency : f32,
        blendMode : u32,
        useWorldSpaceUV : f32,
        worldSpaceUVScale : f32,
        blendNoiseScale : f32,
        blendPatchiness : f32,
        _blendPad1 : f32,
        _blendPad2 : f32,
        _blendPad3 : f32,
      }

      @group(0) @binding(0) var<uniform> scene : SceneUniforms;
      @group(1) @binding(0) var<uniform> material : MaterialUniforms;
      @group(1) @binding(1) var samp : sampler;
      @group(1) @binding(2) var albedoTex : texture_2d<f32>;

      const PI = 3.14159265359;
      const HAS_ALBEDO_MAP = 1u;

      fn applyFog(color: vec3f, worldPos: vec3f) -> vec3f {
        let fogEnabled = scene.fogParams.w;
        if (fogEnabled < 0.5) {
          return color;
        }
        let viewPos = scene.viewMatrix * vec4f(worldPos, 1.0);
        let fogDepth = -viewPos.z;
        var fogFactor = 0.0;
        let fogType = scene.fogParams.z;
        if (fogType < 0.5) {
          let near = scene.fogParams.x;
          let far = scene.fogParams.y;
          fogFactor = clamp((fogDepth - near) / (far - near), 0.0, 1.0);
        } else {
          let density = scene.fogDensity;
          fogFactor = 1.0 - exp(-density * density * fogDepth * fogDepth);
        }
        return mix(color, scene.fogColor, fogFactor);
      }

      fn getHemisphereLightIrradiance(skyColor: vec3f, groundColor: vec3f, normal: vec3f, direction: vec3f) -> vec3f {
        let dotNL = dot(normal, direction);
        let hemiDiffuseWeight = dotNL * 0.5 + 0.5;
        return mix(groundColor, skyColor, hemiDiffuseWeight);
      }

      @fragment
      fn fs_main(
        @builtin(front_facing) frontFacing : bool,
        @location(0) worldNormal : vec3<f32>,
        @location(1) inUV : vec2<f32>,
        @location(2) worldPosition : vec3<f32>,
        @location(3) instanceColor : vec3<f32>
      ) -> @location(0) vec4f {
        // Safe normalize
        let normalLen = length(worldNormal);
        var N = select(vec3f(0.0, 1.0, 0.0), worldNormal / normalLen, normalLen > 0.0001);

        // Two-sided lighting
        if (material.doubleSided > 0.5 && !frontFacing) {
          N = -N;
        }

        let V = normalize(scene.cameraPosition - worldPosition);

        // Apply texture scale
        var uv: vec2f;
        if (material.useWorldSpaceUV > 0.5) {
          uv = worldPosition.xz / material.worldSpaceUVScale;
        } else {
          uv = inUV * material.textureScale;
        }

        var baseColor = material.albedo;
        var alpha = material.opacity;

        // Sample albedo texture
        if ((material.textureFlags & HAS_ALBEDO_MAP) != 0u) {
          let texColor = textureSample(albedoTex, samp, uv);
          baseColor = baseColor * texColor.rgb;
          alpha = alpha * texColor.a;
        }

        // Apply instance color tint
        baseColor = baseColor * instanceColor;

        // Alpha test
        if (material.alphaCutoff > 0.0 && alpha < material.alphaCutoff) {
          if (material.alphaMode == 1u) {
            discard;
          }
        }

        let roughness = material.roughness;
        let metallic = material.metallic;
        let emissive = material.emissive;
        let occlusion = 1.0;

        var F0 = vec3f(0.04);
        F0 = mix(F0, baseColor, metallic);

        // Ambient lighting
        var ambientIrradiance = vec3f(0.0);
        for (var i = 0u; i < scene.lightCount; i++) {
          let light = scene.lights[i];
          if (light.lightType == 3u) { // Ambient
            ambientIrradiance += light.color * light.intensity;
          } else if (light.lightType == 4u) { // Hemisphere
            let hemiIrradiance = getHemisphereLightIrradiance(
              light.color, light.attenuation, N, light.direction
            );
            ambientIrradiance += hemiIrradiance * light.intensity;
          }
        }
        if (length(ambientIrradiance) < 0.001) {
          ambientIrradiance = vec3f(0.03);
        }

        // Direct lighting (simplified - full version has shadow sampling)
        var Lo = vec3f(0.0);
        for (var i = 0u; i < scene.lightCount; i++) {
          let light = scene.lights[i];
          if (light.lightType == 3u || light.lightType == 4u) {
            continue;
          }

          var L = vec3f(0.0);
          var attenuation = 1.0;

          if (light.lightType == 0u) { // Directional
            L = normalize(-light.direction);
          } else {
            let lightVec = light.position - worldPosition;
            let dist = length(lightVec);
            L = normalize(lightVec);
            attenuation = 1.0 / (1.0 + 0.09 * dist + 0.032 * dist * dist);
          }

          let NdotL = max(dot(N, L), 0.0);
          let radiance = light.color * light.intensity * attenuation;

          // Simple Lambertian diffuse
          Lo += baseColor / PI * radiance * NdotL;
        }

        let ambient = ambientIrradiance * baseColor * occlusion * material.ambientIntensity;
        var color = ambient + Lo + emissive;

        color = applyFog(color, worldPosition);

        return vec4f(color, alpha);
      }
    `;
  }
  getVertexShader(pass, options) {
    const includeVelocity = options?.includeVelocity ?? true;
    if (includeVelocity) {
      return this.vertexShaderCode;
    }
    return this.vertexShaderCode.replace("@location(4) prevClip : vec4<f32>,", "").replace(/let prevWorldPos = prevModelMatrix \* vec4<f32>\(input\.position, 1\.0\);\s*output\.prevClip = scene\.prevViewProj \* prevWorldPos;/g, "");
  }
  getFragmentShader(pass, options) {
    if (pass === "forward") {
      return this.forwardFragmentShaderCode;
    }
    const includeVelocity = options?.includeVelocity ?? true;
    if (includeVelocity) {
      return this.fragmentShaderCode;
    }
    return this.fragmentShaderCode.replace("@location(4) velocity : vec2<f32>, // RG = Velocity", "").replace(/, @location\(4\) prevClip : vec4<f32>\)/g, ")").replace(/\/\/ Velocity Calculation[\s\S]*?output\.velocity = vec2<f32>\(velocity\.x, -velocity\.y\);/g, "").replace(/output\.velocity = vec2<f32>\(0\.0, 0\.0\); \/\/ Dummy velocity/g, "");
  }
  getUniformBufferSize() {
    return 128;
  }
  updateUniforms(device, buffer, offset, context) {
    const arrayBuffer = new ArrayBuffer(this.getUniformBufferSize());
    const floatView = new Float32Array(arrayBuffer);
    const uintView = new Uint32Array(arrayBuffer);
    let i = 0;
    floatView[i++] = this.albedo.x;
    floatView[i++] = this.albedo.y;
    floatView[i++] = this.albedo.z;
    floatView[i++] = this.roughness;
    floatView[i++] = this.emissive.x;
    floatView[i++] = this.emissive.y;
    floatView[i++] = this.emissive.z;
    floatView[i++] = this.metallic;
    floatView[i++] = this.opacity;
    floatView[i++] = this.alphaCutoff;
    floatView[i++] = this.displacementScale;
    uintView[i++] = this.getTextureFlags();
    uintView[i++] = this.alphaMode === "OPAQUE" ? 0 : this.alphaMode === "MASK" ? 1 : 2;
    floatView[i++] = this.receiveShadows ? 1 : 0;
    floatView[i++] = this.textureScale.x;
    floatView[i++] = this.textureScale.y;
    floatView[i++] = this.doubleSided ? 1 : 0;
    floatView[i++] = this.ambientIntensity;
    floatView[i++] = this.windEnabled ? 1 : 0;
    floatView[i++] = this.windStrength;
    floatView[i++] = this.windSpeed;
    floatView[i++] = this.windFrequency;
    uintView[i++] = this.blendMode === "none" ? 0 : 1;
    floatView[i++] = this.useWorldSpaceUV ? 1 : 0;
    floatView[i++] = this.worldSpaceUVScale;
    floatView[i++] = this.blendNoiseScale;
    floatView[i++] = this.blendPatchiness;
    floatView[i++] = 0;
    floatView[i++] = 0;
    floatView[i++] = 0;
    device.queue.writeBuffer(buffer, offset, arrayBuffer);
  }
  getBindGroupEntries(device, uniformBuffer) {
    const defaultTex = Texture.getDefault(device);
    return [
      { binding: 0, resource: { buffer: uniformBuffer } },
      { binding: 1, resource: this.albedoMap?.sampler || defaultTex.sampler },
      { binding: 2, resource: this.albedoMap?.view || defaultTex.view },
      { binding: 3, resource: this.normalMap?.view || defaultTex.view },
      { binding: 4, resource: this.roughnessMap?.view || defaultTex.view },
      { binding: 5, resource: this.metallicMap?.view || defaultTex.view },
      { binding: 6, resource: this.emissiveMap?.view || defaultTex.view },
      { binding: 7, resource: this.occlusionMap?.view || defaultTex.view },
      { binding: 8, resource: this.displacementMap?.view || defaultTex.view },
      { binding: 9, resource: this.blendMap2?.view || defaultTex.view },
      { binding: 10, resource: this.blendNormalMap2?.view || defaultTex.view }
    ];
  }
  createBindGroupLayout(device) {
    return device.createBindGroupLayout({
      label: "StandardMaterial Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX, buffer: { type: "uniform" } },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "filtering" } },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 3, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 4, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 5, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 6, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 7, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 8, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 9, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 10, visibility: GPUShaderStage.FRAGMENT, texture: {} }
      ]
    });
  }
}

// ../../src/core/materials/TerrainMaterial.ts
var DEFAULT_TERRAIN_LAYER = {
  albedo: new Vector3(0.5, 0.5, 0.5),
  roughness: 0.8,
  metallic: 0,
  tilingScale: 10,
  displacementScale: 0
};

class TerrainMaterial extends Material {
  splatmap = null;
  layers = [];
  triplanarEnabled = true;
  triplanarSharpness = 4;
  triplanarBlendThreshold = 0.7;
  heightBlendSharpness = 0.5;
  macroVariationScale = 0.02;
  macroVariationStrength = 0.15;
  tilingReductionEnabled = false;
  detailFadeStart = 50;
  detailFadeEnd = 200;
  uvOffsetNoiseScale = 0.05;
  uvOffsetNoiseStrength = 0.1;
  debugMode = 0;
  morphingEnabled = false;
  morphFactor = 0;
  static MAX_LIGHTS = 8;
  forwardFragmentShaderCode;
  constructor() {
    super();
    for (let i = 0;i < 4; i++) {
      this.layers.push({ ...DEFAULT_TERRAIN_LAYER, albedo: DEFAULT_TERRAIN_LAYER.albedo.clone() });
    }
    this.layers[0].albedo = new Vector3(0.15, 0.35, 0.08);
    this.layers[0].roughness = 0.9;
    this.layers[0].tilingScale = 15;
    this.layers[1].albedo = new Vector3(0.45, 0.35, 0.2);
    this.layers[1].roughness = 0.85;
    this.layers[1].tilingScale = 12;
    this.layers[2].albedo = new Vector3(0.35, 0.32, 0.3);
    this.layers[2].roughness = 0.75;
    this.layers[2].tilingScale = 8;
    this.layers[2].displacementScale = 0.05;
    this.layers[3].albedo = new Vector3(0.9, 0.92, 0.95);
    this.layers[3].roughness = 0.6;
    this.layers[3].tilingScale = 20;
    const commonDefines = this.getCommonShaderDefines();
    this.vertexShaderCode = this.buildVertexShader(commonDefines);
    this.fragmentShaderCode = this.buildDeferredFragmentShader(commonDefines);
    this.forwardFragmentShaderCode = this.buildForwardFragmentShader(commonDefines);
  }
  setSplatmap(splatmap, device) {
    if (splatmap instanceof Texture) {
      this.splatmap = splatmap;
    } else if (splatmap && device) {
      this.splatmap = Texture.fromGPUTexture(device, splatmap, "Terrain Splatmap");
    } else if (splatmap) {
      console.warn("TerrainMaterial.setSplatmap: GPUTexture passed without device parameter. Splatmap will not work correctly.");
      this.splatmap = null;
    } else {
      this.splatmap = null;
    }
  }
  setLayer(index, config) {
    if (index < 0 || index >= 4)
      return;
    const layer = this.layers[index];
    if (config.albedoMap !== undefined)
      layer.albedoMap = config.albedoMap;
    if (config.normalMap !== undefined)
      layer.normalMap = config.normalMap;
    if (config.roughnessMap !== undefined)
      layer.roughnessMap = config.roughnessMap;
    if (config.albedo !== undefined)
      layer.albedo = config.albedo;
    if (config.roughness !== undefined)
      layer.roughness = config.roughness;
    if (config.metallic !== undefined)
      layer.metallic = config.metallic;
    if (config.tilingScale !== undefined)
      layer.tilingScale = config.tilingScale;
    if (config.displacementScale !== undefined)
      layer.displacementScale = config.displacementScale;
  }
  getLayer(index) {
    if (index < 0 || index >= 4)
      return null;
    return this.layers[index];
  }
  getRenderingPath() {
    return "deferred";
  }
  getCommonShaderDefines() {
    return `
      struct Light {
        position: vec3f,
        _pad1: f32,
        direction: vec3f,
        _pad2: f32,
        color: vec3f,
        intensity: f32,
        attenuation: vec3f,
        lightType: u32,
        coneAngles: vec2f,
        shadowIndex: i32,
        shadowRadius: f32,
        shadowIntensity: f32,
        _pad3: f32,
        _pad4: f32,
        _pad5: f32,
      }

      struct SceneUniforms {
        viewMatrix : mat4x4<f32>,
        projectionMatrix : mat4x4<f32>,
        lightViewProj : mat4x4<f32>,
        prevViewProj : mat4x4<f32>,
        inverseProjectionMatrix : mat4x4<f32>,
        cameraPosition : vec3f,
        time : f32,
        lightCount : u32,
        debugMode : u32,
        flags : u32,
        environmentIntensity : f32,
        fogColor: vec3f,
        fogDensity: f32,
        fogParams: vec4f,
        fogSettings: vec4u,
        lights : array<Light, ${TerrainMaterial.MAX_LIGHTS}>,
      }

      struct ObjectData {
        modelMatrix : mat4x4<f32>,
        normalMatrix : mat4x4<f32>,
        aabbMin : vec3f,
        _pad1 : f32,
        aabbMax : vec3f,
        _pad2 : f32,
        prevModelMatrix : mat4x4<f32>,
        _pad3 : vec4<f32>,
        _pad4 : vec4<f32>,
      }

      // Terrain material uniforms
      // Layer data: vec4 per layer (tilingScale, displacementScale, roughness, metallic)
      // Plus layer albedo colors, and global settings
      struct TerrainUniforms {
        layer0Props: vec4<f32>,  // tilingScale, displacementScale, roughness, metallic
        layer1Props: vec4<f32>,
        layer2Props: vec4<f32>,
        layer3Props: vec4<f32>,
        layer0Albedo: vec4<f32>, // RGB = albedo, A = unused
        layer1Albedo: vec4<f32>,
        layer2Albedo: vec4<f32>,
        layer3Albedo: vec4<f32>,
        globalSettings: vec4<f32>, // triplanarSharpness, triplanarThreshold, heightBlendSharpness, triplanarEnabled
        macroSettings: vec4<f32>,  // macroScale, macroStrength, textureFlags, debugMode
        distanceSettings: vec4<f32>, // detailFadeStart, detailFadeEnd, uvOffsetScale, uvOffsetStrength
      }

      @group(0) @binding(0) var<uniform> scene : SceneUniforms;
      @group(0) @binding(1) var<storage, read> objects : array<ObjectData>;

      @group(1) @binding(0) var<uniform> terrain : TerrainUniforms;
      @group(1) @binding(1) var splatmapSampler : sampler;  // clamp-to-edge for splatmap
      @group(1) @binding(2) var layerSampler : sampler;     // repeat for layer textures
      @group(1) @binding(3) var splatmapTex : texture_2d<f32>;
      // Layer 0 textures
      @group(1) @binding(4) var layer0AlbedoTex : texture_2d<f32>;
      @group(1) @binding(5) var layer0NormalTex : texture_2d<f32>;
      @group(1) @binding(6) var layer0RoughnessTex : texture_2d<f32>;
      // Layer 1 textures
      @group(1) @binding(7) var layer1AlbedoTex : texture_2d<f32>;
      @group(1) @binding(8) var layer1NormalTex : texture_2d<f32>;
      @group(1) @binding(9) var layer1RoughnessTex : texture_2d<f32>;
      // Layer 2 textures
      @group(1) @binding(10) var layer2AlbedoTex : texture_2d<f32>;
      @group(1) @binding(11) var layer2NormalTex : texture_2d<f32>;
      @group(1) @binding(12) var layer2RoughnessTex : texture_2d<f32>;
      // Layer 3 textures
      @group(1) @binding(13) var layer3AlbedoTex : texture_2d<f32>;
      @group(1) @binding(14) var layer3NormalTex : texture_2d<f32>;
      @group(1) @binding(15) var layer3RoughnessTex : texture_2d<f32>;

      struct VertexInput {
        @location(0) position : vec3<f32>,
        @location(1) normal : vec3<f32>,
        @location(2) uv : vec2<f32>,
      }

      struct VertexOutput {
        @builtin(position) position : vec4<f32>,
        @location(0) worldNormal : vec3<f32>,
        @location(1) uv : vec2<f32>,
        @location(2) worldPosition : vec3<f32>,
        @location(3) currentClip : vec4<f32>,
        @location(4) prevClip : vec4<f32>,
      }

      // Texture flag helpers
      const LAYER0_HAS_ALBEDO = 1u;
      const LAYER0_HAS_NORMAL = 2u;
      const LAYER0_HAS_ROUGHNESS = 4u;
      const LAYER1_HAS_ALBEDO = 8u;
      const LAYER1_HAS_NORMAL = 16u;
      const LAYER1_HAS_ROUGHNESS = 32u;
      const LAYER2_HAS_ALBEDO = 64u;
      const LAYER2_HAS_NORMAL = 128u;
      const LAYER2_HAS_ROUGHNESS = 256u;
      const LAYER3_HAS_ALBEDO = 512u;
      const LAYER3_HAS_NORMAL = 1024u;
      const LAYER3_HAS_ROUGHNESS = 2048u;
      const HAS_SPLATMAP = 4096u;

      // Hash functions for noise generation
      fn hash21(p: vec2f) -> f32 {
        var p3 = fract(p.xyx * vec3f(0.1031, 0.1030, 0.0973));
        p3 += dot(p3, p3.yzx + 33.33);
        return fract((p3.x + p3.y) * p3.z);
      }

      fn hash22(p: vec2f) -> vec2f {
        var p3 = fract(p.xyx * vec3f(0.1031, 0.1030, 0.0973));
        p3 += dot(p3, p3.yzx + 33.33);
        return fract((p3.xx + p3.yz) * p3.zy);
      }

      // Value noise for macro variation
      fn valueNoise(p: vec2f) -> f32 {
        let i = floor(p);
        let f = fract(p);
        // Quintic interpolation for smoother results
        let u = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);
        return mix(
          mix(hash21(i + vec2f(0.0, 0.0)), hash21(i + vec2f(1.0, 0.0)), u.x),
          mix(hash21(i + vec2f(0.0, 1.0)), hash21(i + vec2f(1.0, 1.0)), u.x),
          u.y
        );
      }

      // Fractal Brownian Motion for higher quality noise
      fn fbm(p: vec2f, octaves: u32) -> f32 {
        var value = 0.0;
        var amplitude = 0.5;
        var frequency = 1.0;
        var maxValue = 0.0;
        for (var i = 0u; i < octaves; i++) {
          value += amplitude * valueNoise(p * frequency);
          maxValue += amplitude;
          amplitude *= 0.5;
          frequency *= 2.0;
        }
        return value / maxValue; // Normalize to [0, 1]
      }

      // 2D vector noise for UV offset (returns offset in both directions)
      fn vectorNoise(p: vec2f) -> vec2f {
        let i = floor(p);
        let f = fract(p);
        let u = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);
        return mix(
          mix(hash22(i + vec2f(0.0, 0.0)), hash22(i + vec2f(1.0, 0.0)), u.x),
          mix(hash22(i + vec2f(0.0, 1.0)), hash22(i + vec2f(1.0, 1.0)), u.x),
          u.y
        ) * 2.0 - 1.0; // Map to [-1, 1]
      }

      // FBM-based vector noise for smoother UV distortion
      fn fbmVector(p: vec2f, octaves: u32) -> vec2f {
        var value = vec2f(0.0);
        var amplitude = 0.5;
        var frequency = 1.0;
        var maxValue = 0.0;
        for (var i = 0u; i < octaves; i++) {
          value += amplitude * vectorNoise(p * frequency);
          maxValue += amplitude;
          amplitude *= 0.5;
          frequency *= 2.0;
        }
        return value / maxValue;
      }

      // Triplanar blend weights based on normal
      fn getTriplanarWeights(N: vec3f, sharpness: f32) -> vec3f {
        var weights = abs(N);
        weights = pow(weights, vec3f(sharpness));
        weights = weights / (weights.x + weights.y + weights.z);
        return weights;
      }
    `;
  }
  buildVertexShader(commonDefines) {
    return `
      ${commonDefines}

      @vertex
      fn vs_main(input : VertexInput, @builtin(instance_index) instanceIndex : u32) -> VertexOutput {
        var output : VertexOutput;

        let modelMatrix = objects[instanceIndex].modelMatrix;
        let normalMatrix = objects[instanceIndex].normalMatrix;
        let prevModelMatrix = objects[instanceIndex].prevModelMatrix;

        let worldPos = modelMatrix * vec4<f32>(input.position, 1.0);
        output.worldPosition = worldPos.xyz;

        let clipPos = scene.projectionMatrix * scene.viewMatrix * worldPos;
        output.position = clipPos;
        output.currentClip = clipPos;

        let prevWorldPos = prevModelMatrix * vec4<f32>(input.position, 1.0);
        output.prevClip = scene.prevViewProj * prevWorldPos;

        output.worldNormal = (normalMatrix * vec4<f32>(input.normal, 0.0)).xyz;
        output.uv = input.uv;
        return output;
      }
    `;
  }
  buildDeferredFragmentShader(commonDefines) {
    return `
      ${commonDefines}

      struct FragmentOutput {
        @location(0) albedo : vec4<f32>,
        @location(1) normal : vec4<f32>,
        @location(2) position : vec4<f32>,
        @location(3) emissive : vec4<f32>,
        @location(4) velocity : vec2<f32>,
      }

      // Sample a layer's textures with triplanar blending
      // Note: Using textureSampleLevel with LOD 0 to avoid non-uniform control flow issues
      // triplanarFactor: 0 = pure UV mapping, 1 = pure triplanar mapping
      fn sampleLayerAlbedo(
        layerTex: texture_2d<f32>,
        hasTexture: bool,
        fallbackColor: vec3f,
        uv: vec2f,
        worldPos: vec3f,
        N: vec3f,
        tiling: f32,
        triplanarFactor: f32,
        triWeights: vec3f
      ) -> vec3f {
        if (!hasTexture) {
          return fallbackColor;
        }

        // Sample both paths and blend to avoid non-uniform control flow
        // Triplanar sampling
        let uvX = worldPos.zy * tiling;
        let uvY = worldPos.xz * tiling;
        let uvZ = worldPos.xy * tiling;

        let sampleX = textureSampleLevel(layerTex, layerSampler, uvX, 0.0).rgb;
        let sampleY = textureSampleLevel(layerTex, layerSampler, uvY, 0.0).rgb;
        let sampleZ = textureSampleLevel(layerTex, layerSampler, uvZ, 0.0).rgb;
        let triplanarResult = sampleX * triWeights.x + sampleY * triWeights.y + sampleZ * triWeights.z;

        // Standard UV sampling
        let standardResult = textureSampleLevel(layerTex, layerSampler, uv * tiling, 0.0).rgb;

        // Smooth blend between UV and triplanar based on factor
        return mix(standardResult, triplanarResult, triplanarFactor);
      }

      // Sample layer normal map and return world-space normal
      // For triplanar projection, each plane needs its own TBN matrix
      fn sampleLayerNormalWorldSpace(
        layerTex: texture_2d<f32>,
        hasTexture: bool,
        uv: vec2f,
        worldPos: vec3f,
        geometryNormal: vec3f,
        tiling: f32,
        triplanarFactor: f32,
        triWeights: vec3f,
        uvTBN: mat3x3f
      ) -> vec3f {
        if (!hasTexture) {
          return geometryNormal;
        }

        // Triplanar UVs
        let uvX = worldPos.zy * tiling;
        let uvY = worldPos.xz * tiling;
        let uvZ = worldPos.xy * tiling;

        // Sample normal maps for each projection plane
        let sampleX = textureSampleLevel(layerTex, layerSampler, uvX, 0.0).rgb * 2.0 - 1.0;
        let sampleY = textureSampleLevel(layerTex, layerSampler, uvY, 0.0).rgb * 2.0 - 1.0;
        let sampleZ = textureSampleLevel(layerTex, layerSampler, uvZ, 0.0).rgb * 2.0 - 1.0;

        // Per-plane TBN matrices for triplanar projection
        // XY plane (looking down Z axis): T=(1,0,0), B=(0,1,0), N=(0,0,1)
        let tbnXY = mat3x3f(
          vec3f(1.0, 0.0, 0.0),
          vec3f(0.0, 1.0, 0.0),
          vec3f(0.0, 0.0, sign(geometryNormal.z + 0.0001))
        );
        // XZ plane (looking down Y axis): T=(1,0,0), B=(0,0,1), N=(0,1,0)
        let tbnXZ = mat3x3f(
          vec3f(1.0, 0.0, 0.0),
          vec3f(0.0, 0.0, 1.0),
          vec3f(0.0, sign(geometryNormal.y + 0.0001), 0.0)
        );
        // YZ plane (looking down X axis): T=(0,1,0), B=(0,0,1), N=(1,0,0)
        let tbnYZ = mat3x3f(
          vec3f(0.0, 1.0, 0.0),
          vec3f(0.0, 0.0, 1.0),
          vec3f(sign(geometryNormal.x + 0.0001), 0.0, 0.0)
        );

        // Transform each sample to world space using its plane's TBN
        let worldNormalX = normalize(tbnYZ * sampleX);
        let worldNormalY = normalize(tbnXZ * sampleY);
        let worldNormalZ = normalize(tbnXY * sampleZ);

        // Blend world-space normals using triplanar weights
        let triplanarNormal = normalize(
          worldNormalX * triWeights.x +
          worldNormalY * triWeights.y +
          worldNormalZ * triWeights.z
        );

        // Standard UV sampling with traditional TBN
        let standardSample = textureSampleLevel(layerTex, layerSampler, uv * tiling, 0.0).rgb * 2.0 - 1.0;
        let standardNormal = normalize(uvTBN * standardSample);

        // Smooth blend between UV and triplanar normals
        return normalize(mix(standardNormal, triplanarNormal, triplanarFactor));
      }

      fn sampleLayerRoughness(
        layerTex: texture_2d<f32>,
        hasTexture: bool,
        fallbackRoughness: f32,
        uv: vec2f,
        worldPos: vec3f,
        tiling: f32,
        triplanarFactor: f32,
        triWeights: vec3f
      ) -> f32 {
        if (!hasTexture) {
          return fallbackRoughness;
        }

        // Sample both paths and blend
        let uvX = worldPos.zy * tiling;
        let uvY = worldPos.xz * tiling;
        let uvZ = worldPos.xy * tiling;

        let sampleX = textureSampleLevel(layerTex, layerSampler, uvX, 0.0).g;
        let sampleY = textureSampleLevel(layerTex, layerSampler, uvY, 0.0).g;
        let sampleZ = textureSampleLevel(layerTex, layerSampler, uvZ, 0.0).g;
        let triplanarResult = sampleX * triWeights.x + sampleY * triWeights.y + sampleZ * triWeights.z;

        let standardResult = textureSampleLevel(layerTex, layerSampler, uv * tiling, 0.0).g;

        // Smooth blend between UV and triplanar
        return mix(standardResult, triplanarResult, triplanarFactor);
      }

      @fragment
      fn fs_main(
        @location(0) worldNormal : vec3<f32>,
        @location(1) inUV : vec2<f32>,
        @location(2) worldPosition : vec3<f32>,
        @location(3) currentClip : vec4<f32>,
        @location(4) prevClip : vec4<f32>
      ) -> FragmentOutput {
        var output : FragmentOutput;

        // Normalize surface normal
        let normalLen = length(worldNormal);
        var N = select(vec3f(0.0, 1.0, 0.0), worldNormal / normalLen, normalLen > 0.0001);
        let uv = inUV;

        // Velocity calculation
        let currentNDC = currentClip.xy / currentClip.w;
        let prevNDC = prevClip.xy / prevClip.w;
        let velocity = (currentNDC - prevNDC) * 0.5;
        output.velocity = vec2<f32>(velocity.x, -velocity.y);

        // Get texture flags
        let textureFlags = u32(terrain.macroSettings.z);
        let hasSplatmap = (textureFlags & HAS_SPLATMAP) != 0u;

        // Sample splatmap for blend weights
        var splatWeights = vec4f(1.0, 0.0, 0.0, 0.0); // Default to layer 0
        if (hasSplatmap) {
          splatWeights = textureSampleLevel(splatmapTex, splatmapSampler, uv, 0.0);
        }

        // Triplanar settings
        let triplanarEnabled = terrain.globalSettings.w > 0.5;
        let triplanarSharpness = terrain.globalSettings.x;
        let triplanarThreshold = terrain.globalSettings.y;

        // Calculate slope (1 = vertical, 0 = flat)
        let slope = 1.0 - abs(N.y);

        // Smooth blend factor for triplanar: 0 = pure UV, 1 = pure triplanar
        // Uses smoothstep for gradual transition instead of hard binary switch
        let triplanarFactor = select(
          0.0,
          smoothstep(triplanarThreshold - 0.1, triplanarThreshold + 0.1, slope),
          triplanarEnabled
        );
        let triWeights = getTriplanarWeights(N, triplanarSharpness);

        // Build UV-based TBN matrix for standard normal mapping
        let Q1 = dpdx(worldPosition);
        let Q2 = dpdy(worldPosition);
        let st1 = dpdx(uv);
        let st2 = dpdy(uv);
        let T = normalize(Q1 * st2.y - Q2 * st1.y);
        let B = -normalize(cross(N, T));
        let uvTBN = mat3x3f(T, B, N);

        // Distance-based settings for detail reduction
        let detailFadeStart = terrain.distanceSettings.x;
        let detailFadeEnd = terrain.distanceSettings.y;
        let uvOffsetScale = terrain.distanceSettings.z;
        let uvOffsetStrength = terrain.distanceSettings.w;

        // Calculate distance from camera for LOD-style fading
        let distToCamera = length(worldPosition - scene.cameraPosition);
        let detailFade = smoothstep(detailFadeStart, detailFadeEnd, distToCamera);

        // UV offset noise to break tiling (applied before texture sampling)
        // Use FBM-based vector noise for smoother UV distortion
        let uvOffset = fbmVector(worldPosition.xz * uvOffsetScale, 3u) * uvOffsetStrength;
        // Reduce UV offset at distance (it's less noticeable anyway)
        let adjustedUvOffset = uvOffset * (1.0 - detailFade * 0.7);

        // Macro variation to break tiling - use multi-octave FBM for better quality
        let macroScale = terrain.macroSettings.x;
        let macroStrength = terrain.macroSettings.y;
        // Use FBM with 4 octaves for richer, more natural variation
        let macroNoise = fbm(worldPosition.xz * macroScale, 4u);
        // Add a secondary lower-frequency noise layer for large-scale variation
        let macroNoise2 = fbm(worldPosition.xz * macroScale * 0.3, 3u);
        let combinedMacro = macroNoise * 0.7 + macroNoise2 * 0.3;
        let macroVariation = 1.0 + (combinedMacro - 0.5) * macroStrength * 2.0;

        // Layer properties
        let layer0Tiling = terrain.layer0Props.x;
        let layer1Tiling = terrain.layer1Props.x;
        let layer2Tiling = terrain.layer2Props.x;
        let layer3Tiling = terrain.layer3Props.x;

        // Apply UV offset to break tiling patterns
        let distortedUV = uv + adjustedUvOffset;

        // Sample each layer with UV offset applied
        // Layer 0
        let l0HasAlbedo = (textureFlags & LAYER0_HAS_ALBEDO) != 0u;
        let l0HasNormal = (textureFlags & LAYER0_HAS_NORMAL) != 0u;
        let l0HasRoughness = (textureFlags & LAYER0_HAS_ROUGHNESS) != 0u;

        let l0Albedo = sampleLayerAlbedo(layer0AlbedoTex, l0HasAlbedo, terrain.layer0Albedo.rgb, distortedUV, worldPosition, N, layer0Tiling, triplanarFactor, triWeights);
        let l0Normal = sampleLayerNormalWorldSpace(layer0NormalTex, l0HasNormal, distortedUV, worldPosition, N, layer0Tiling, triplanarFactor, triWeights, uvTBN);
        let l0Roughness = sampleLayerRoughness(layer0RoughnessTex, l0HasRoughness, terrain.layer0Props.z, distortedUV, worldPosition, layer0Tiling, triplanarFactor, triWeights);

        // Layer 1
        let l1HasAlbedo = (textureFlags & LAYER1_HAS_ALBEDO) != 0u;
        let l1HasNormal = (textureFlags & LAYER1_HAS_NORMAL) != 0u;
        let l1HasRoughness = (textureFlags & LAYER1_HAS_ROUGHNESS) != 0u;

        let l1Albedo = sampleLayerAlbedo(layer1AlbedoTex, l1HasAlbedo, terrain.layer1Albedo.rgb, distortedUV, worldPosition, N, layer1Tiling, triplanarFactor, triWeights);
        let l1Normal = sampleLayerNormalWorldSpace(layer1NormalTex, l1HasNormal, distortedUV, worldPosition, N, layer1Tiling, triplanarFactor, triWeights, uvTBN);
        let l1Roughness = sampleLayerRoughness(layer1RoughnessTex, l1HasRoughness, terrain.layer1Props.z, distortedUV, worldPosition, layer1Tiling, triplanarFactor, triWeights);

        // Layer 2
        let l2HasAlbedo = (textureFlags & LAYER2_HAS_ALBEDO) != 0u;
        let l2HasNormal = (textureFlags & LAYER2_HAS_NORMAL) != 0u;
        let l2HasRoughness = (textureFlags & LAYER2_HAS_ROUGHNESS) != 0u;

        let l2Albedo = sampleLayerAlbedo(layer2AlbedoTex, l2HasAlbedo, terrain.layer2Albedo.rgb, distortedUV, worldPosition, N, layer2Tiling, triplanarFactor, triWeights);
        let l2Normal = sampleLayerNormalWorldSpace(layer2NormalTex, l2HasNormal, distortedUV, worldPosition, N, layer2Tiling, triplanarFactor, triWeights, uvTBN);
        let l2Roughness = sampleLayerRoughness(layer2RoughnessTex, l2HasRoughness, terrain.layer2Props.z, distortedUV, worldPosition, layer2Tiling, triplanarFactor, triWeights);

        // Layer 3
        let l3HasAlbedo = (textureFlags & LAYER3_HAS_ALBEDO) != 0u;
        let l3HasNormal = (textureFlags & LAYER3_HAS_NORMAL) != 0u;
        let l3HasRoughness = (textureFlags & LAYER3_HAS_ROUGHNESS) != 0u;

        let l3Albedo = sampleLayerAlbedo(layer3AlbedoTex, l3HasAlbedo, terrain.layer3Albedo.rgb, distortedUV, worldPosition, N, layer3Tiling, triplanarFactor, triWeights);
        let l3Normal = sampleLayerNormalWorldSpace(layer3NormalTex, l3HasNormal, distortedUV, worldPosition, N, layer3Tiling, triplanarFactor, triWeights, uvTBN);
        let l3Roughness = sampleLayerRoughness(layer3RoughnessTex, l3HasRoughness, terrain.layer3Props.z, distortedUV, worldPosition, layer3Tiling, triplanarFactor, triWeights);

        // Debug mode check
        let debugMode = u32(terrain.macroSettings.w);

        // Blend layers based on splatmap weights
        // Note: l0Normal etc. are now world-space normals from sampleLayerNormalWorldSpace
        var blendedAlbedo = l0Albedo * splatWeights.r + l1Albedo * splatWeights.g + l2Albedo * splatWeights.b + l3Albedo * splatWeights.a;
        let blendedNormal = normalize(l0Normal * splatWeights.r + l1Normal * splatWeights.g + l2Normal * splatWeights.b + l3Normal * splatWeights.a);
        let blendedRoughness = l0Roughness * splatWeights.r + l1Roughness * splatWeights.g + l2Roughness * splatWeights.b + l3Roughness * splatWeights.a;

        // Debug mode 1: Show raw splatmap weights directly
        // Debug mode 2: Show UV coordinates as RG
        // Debug mode 3: Calculate weights from world height (bypass splatmap)
        // Debug mode 4: Show raw layer 0 texture sample (verify texture loading)
        if (debugMode == 1u) {
          // Direct splatmap visualization: R=grass, G=dirt, B=rock, brightness=snow
          blendedAlbedo = vec3f(splatWeights.r, splatWeights.g, splatWeights.b);
        } else if (debugMode == 2u) {
          // UV coordinate visualization
          blendedAlbedo = vec3f(uv.x, uv.y, 0.0);
        } else if (debugMode == 4u) {
          // Raw texture sample from layer 0 - verifies texture is loaded and can be sampled
          let rawSample = textureSampleLevel(layer0AlbedoTex, layerSampler, uv * layer0Tiling, 0.0).rgb;
          blendedAlbedo = rawSample;
        } else if (debugMode == 3u) {
          // Calculate height-based weights directly from world position
          // Assuming terrain height roughly maps to worldPosition.y
          // Normalize assuming terrain height scale ~25 units, centered at 0
          let normalizedHeight = clamp((worldPosition.y + 12.5) / 25.0, 0.0, 1.0);

          // Simple 4-band gradient based on height
          var hw0 = 1.0 - clamp(normalizedHeight / 0.35, 0.0, 1.0); // Grass: high at low heights
          var hw1 = 1.0 - abs(normalizedHeight - 0.4) / 0.2; // Dirt: peak at 0.4
          var hw2 = 1.0 - abs(normalizedHeight - 0.65) / 0.2; // Rock: peak at 0.65
          var hw3 = clamp((normalizedHeight - 0.7) / 0.3, 0.0, 1.0); // Snow: high at high heights

          hw0 = max(hw0, 0.0);
          hw1 = max(hw1, 0.0);
          hw2 = max(hw2, 0.0);
          hw3 = max(hw3, 0.0);

          // Normalize
          let totalHW = hw0 + hw1 + hw2 + hw3 + 0.001;
          hw0 /= totalHW; hw1 /= totalHW; hw2 /= totalHW; hw3 /= totalHW;

          // Show as colors
          blendedAlbedo = vec3f(hw0, hw1, hw2) + vec3f(hw3 * 0.3);
        }

        // Calculate average color for distance-based simplification
        // At far distances, blend towards a simplified average to reduce tiling visibility
        let avgLayerColor = terrain.layer0Albedo.rgb * splatWeights.r +
                           terrain.layer1Albedo.rgb * splatWeights.g +
                           terrain.layer2Albedo.rgb * splatWeights.b +
                           terrain.layer3Albedo.rgb * splatWeights.a;

        // Apply macro variation (reduce effect at distance where tiling is less visible)
        let distanceAdjustedMacro = mix(macroVariation, 1.0, detailFade * 0.5);
        blendedAlbedo *= distanceAdjustedMacro;

        // Blend between detailed texture and simplified average color based on distance
        // This reduces the perception of tiling at far distances
        blendedAlbedo = mix(blendedAlbedo, avgLayerColor * distanceAdjustedMacro, detailFade * 0.3);

        // Blend metallic (usually 0 for terrain)
        let blendedMetallic = terrain.layer0Props.w * splatWeights.r + terrain.layer1Props.w * splatWeights.g +
                             terrain.layer2Props.w * splatWeights.b + terrain.layer3Props.w * splatWeights.a;

        // blendedNormal is already in world space from sampleLayerNormalWorldSpace
        // which handles per-plane TBN for triplanar and UV-based TBN for standard sampling

        // Output to GBuffer
        output.albedo = vec4<f32>(blendedAlbedo, blendedRoughness);
        output.normal = vec4<f32>(blendedNormal * 0.5 + 0.5, blendedMetallic);
        output.position = vec4<f32>(worldPosition, 1.0); // Occlusion = 1.0
        output.emissive = vec4<f32>(0.0, 0.0, 0.0, 1.0); // No emissive for terrain

        return output;
      }
    `;
  }
  buildForwardFragmentShader(commonDefines) {
    return `
      ${commonDefines}

      @fragment
      fn fs_main(
        @location(0) worldNormal : vec3<f32>,
        @location(1) inUV : vec2<f32>,
        @location(2) worldPosition : vec3<f32>
      ) -> @location(0) vec4f {
        let normalLen = length(worldNormal);
        let N = select(vec3f(0.0, 1.0, 0.0), worldNormal / normalLen, normalLen > 0.0001);

        // Simple shading
        let lightDir = normalize(vec3f(0.5, 1.0, 0.3));
        let NdotL = max(dot(N, lightDir), 0.0);

        let textureFlags = u32(terrain.macroSettings.z);
        let hasSplatmap = (textureFlags & HAS_SPLATMAP) != 0u;

        var splatWeights = vec4f(1.0, 0.0, 0.0, 0.0);
        if (hasSplatmap) {
          splatWeights = textureSampleLevel(splatmapTex, splatmapSampler, inUV, 0.0);
        }

        let blendedColor = terrain.layer0Albedo.rgb * splatWeights.r +
                          terrain.layer1Albedo.rgb * splatWeights.g +
                          terrain.layer2Albedo.rgb * splatWeights.b +
                          terrain.layer3Albedo.rgb * splatWeights.a;

        let ambient = 0.1;
        let diffuse = NdotL * 0.9;
        let color = blendedColor * (ambient + diffuse);

        return vec4f(color, 1.0);
      }
    `;
  }
  getTextureFlags() {
    let flags = 0;
    if (this.layers[0].albedoMap)
      flags |= 1;
    if (this.layers[0].normalMap)
      flags |= 2;
    if (this.layers[0].roughnessMap)
      flags |= 4;
    if (this.layers[1].albedoMap)
      flags |= 8;
    if (this.layers[1].normalMap)
      flags |= 16;
    if (this.layers[1].roughnessMap)
      flags |= 32;
    if (this.layers[2].albedoMap)
      flags |= 64;
    if (this.layers[2].normalMap)
      flags |= 128;
    if (this.layers[2].roughnessMap)
      flags |= 256;
    if (this.layers[3].albedoMap)
      flags |= 512;
    if (this.layers[3].normalMap)
      flags |= 1024;
    if (this.layers[3].roughnessMap)
      flags |= 2048;
    if (this.splatmap)
      flags |= 4096;
    return flags;
  }
  getVertexShader(pass) {
    return this.vertexShaderCode;
  }
  getFragmentShader(pass) {
    if (pass === "forward") {
      return this.forwardFragmentShaderCode;
    }
    return this.fragmentShaderCode;
  }
  getUniformBufferSize() {
    return 176;
  }
  updateUniforms(device, buffer, offset, context) {
    const arrayBuffer = new ArrayBuffer(this.getUniformBufferSize());
    const floatView = new Float32Array(arrayBuffer);
    let i = 0;
    floatView[i++] = this.layers[0].tilingScale;
    floatView[i++] = this.layers[0].displacementScale;
    floatView[i++] = this.layers[0].roughness;
    floatView[i++] = this.layers[0].metallic;
    floatView[i++] = this.layers[1].tilingScale;
    floatView[i++] = this.layers[1].displacementScale;
    floatView[i++] = this.layers[1].roughness;
    floatView[i++] = this.layers[1].metallic;
    floatView[i++] = this.layers[2].tilingScale;
    floatView[i++] = this.layers[2].displacementScale;
    floatView[i++] = this.layers[2].roughness;
    floatView[i++] = this.layers[2].metallic;
    floatView[i++] = this.layers[3].tilingScale;
    floatView[i++] = this.layers[3].displacementScale;
    floatView[i++] = this.layers[3].roughness;
    floatView[i++] = this.layers[3].metallic;
    floatView[i++] = this.layers[0].albedo.x;
    floatView[i++] = this.layers[0].albedo.y;
    floatView[i++] = this.layers[0].albedo.z;
    floatView[i++] = 0;
    floatView[i++] = this.layers[1].albedo.x;
    floatView[i++] = this.layers[1].albedo.y;
    floatView[i++] = this.layers[1].albedo.z;
    floatView[i++] = 0;
    floatView[i++] = this.layers[2].albedo.x;
    floatView[i++] = this.layers[2].albedo.y;
    floatView[i++] = this.layers[2].albedo.z;
    floatView[i++] = 0;
    floatView[i++] = this.layers[3].albedo.x;
    floatView[i++] = this.layers[3].albedo.y;
    floatView[i++] = this.layers[3].albedo.z;
    floatView[i++] = 0;
    floatView[i++] = this.triplanarSharpness;
    floatView[i++] = this.triplanarBlendThreshold;
    floatView[i++] = this.heightBlendSharpness;
    floatView[i++] = this.triplanarEnabled ? 1 : 0;
    floatView[i++] = this.macroVariationScale;
    floatView[i++] = this.tilingReductionEnabled ? this.macroVariationStrength : 0;
    floatView[i++] = this.getTextureFlags();
    floatView[i++] = this.debugMode;
    floatView[i++] = this.tilingReductionEnabled ? this.detailFadeStart : 1e5;
    floatView[i++] = this.tilingReductionEnabled ? this.detailFadeEnd : 100001;
    floatView[i++] = this.uvOffsetNoiseScale;
    floatView[i++] = this.tilingReductionEnabled ? this.uvOffsetNoiseStrength : 0;
    device.queue.writeBuffer(buffer, offset, arrayBuffer);
  }
  layerSampler = null;
  getLayerSampler(device) {
    if (!this.layerSampler) {
      this.layerSampler = device.createSampler({
        label: "Terrain Layer Sampler (repeat)",
        magFilter: "linear",
        minFilter: "linear",
        mipmapFilter: "linear",
        addressModeU: "repeat",
        addressModeV: "repeat",
        maxAnisotropy: 4
      });
    }
    return this.layerSampler;
  }
  getBindGroupEntries(device, uniformBuffer) {
    const defaultTex = Texture.getDefault(device);
    return [
      { binding: 0, resource: { buffer: uniformBuffer } },
      { binding: 1, resource: this.splatmap?.sampler || defaultTex.sampler },
      { binding: 2, resource: this.getLayerSampler(device) },
      { binding: 3, resource: this.splatmap?.view || defaultTex.view },
      { binding: 4, resource: this.layers[0].albedoMap?.view || defaultTex.view },
      { binding: 5, resource: this.layers[0].normalMap?.view || defaultTex.view },
      { binding: 6, resource: this.layers[0].roughnessMap?.view || defaultTex.view },
      { binding: 7, resource: this.layers[1].albedoMap?.view || defaultTex.view },
      { binding: 8, resource: this.layers[1].normalMap?.view || defaultTex.view },
      { binding: 9, resource: this.layers[1].roughnessMap?.view || defaultTex.view },
      { binding: 10, resource: this.layers[2].albedoMap?.view || defaultTex.view },
      { binding: 11, resource: this.layers[2].normalMap?.view || defaultTex.view },
      { binding: 12, resource: this.layers[2].roughnessMap?.view || defaultTex.view },
      { binding: 13, resource: this.layers[3].albedoMap?.view || defaultTex.view },
      { binding: 14, resource: this.layers[3].normalMap?.view || defaultTex.view },
      { binding: 15, resource: this.layers[3].roughnessMap?.view || defaultTex.view }
    ];
  }
  createBindGroupLayout(device) {
    return device.createBindGroupLayout({
      label: "TerrainMaterial Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX, buffer: { type: "uniform" } },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "filtering" } },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "filtering" } },
        { binding: 3, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 4, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 5, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 6, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 7, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 8, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 9, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 10, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 11, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 12, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 13, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 14, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 15, visibility: GPUShaderStage.FRAGMENT, texture: {} }
      ]
    });
  }
}

// ../../src/core/sprites/SpriteGeometry.ts
class SpriteGeometry extends Geometry {
  _width;
  _height;
  _anchorX;
  _anchorY;
  constructor(width = 1, height = 1, anchor = { x: 0.5, y: 0.5 }) {
    super();
    this._width = width;
    this._height = height;
    this._anchorX = anchor.x;
    this._anchorY = anchor.y;
    this.buildGeometry();
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this._width = value;
    this.buildGeometry();
  }
  get height() {
    return this._height;
  }
  set height(value) {
    this._height = value;
    this.buildGeometry();
  }
  get anchorX() {
    return this._anchorX;
  }
  get anchorY() {
    return this._anchorY;
  }
  setAnchor(x, y) {
    this._anchorX = x;
    this._anchorY = y;
    this.buildGeometry();
  }
  setSize(width, height) {
    this._width = width;
    this._height = height;
    this.buildGeometry();
  }
  buildGeometry() {
    const w = this._width;
    const h = this._height;
    const ax = this._anchorX;
    const ay = this._anchorY;
    const left = -w * ax;
    const right = w * (1 - ax);
    const bottom = -h * ay;
    const top = h * (1 - ay);
    const positions = new Float32Array([
      left,
      bottom,
      0,
      right,
      bottom,
      0,
      right,
      top,
      0,
      left,
      top,
      0
    ]);
    const normals = new Float32Array([
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1
    ]);
    const uvs = new Float32Array([
      0,
      1,
      1,
      1,
      1,
      0,
      0,
      0
    ]);
    const indices = new Uint16Array([
      0,
      1,
      2,
      0,
      2,
      3
    ]);
    this.setAttribute("position", positions);
    this.setAttribute("normal", normals);
    this.setAttribute("uv", uvs);
    this.setIndices(indices);
  }
  static createShared(width = 1, height = 1, anchor = { x: 0.5, y: 0.5 }) {
    return new SpriteGeometry(width, height, anchor);
  }
}

// ../../src/core/sprites/SpriteMaterial.ts
class SpriteMaterial extends Material {
  texture = null;
  tint = new Vector3(1, 1, 1);
  opacity = 1;
  uvOffset = { x: 0, y: 0 };
  uvScale = { x: 1, y: 1 };
  alphaMode = "BLEND";
  alphaCutoff = 0.5;
  pixelPerfect = false;
  billboard = "none";
  depthWrite = false;
  depthTest = true;
  _pixelPerfectSampler = null;
  _linearSampler = null;
  static MAX_LIGHTS = 8;
  constructor() {
    super();
    const commonDefines = `
      struct Light {
        position: vec3f,
        _pad1: f32,
        direction: vec3f,
        _pad2: f32,
        color: vec3f,
        intensity: f32,
        attenuation: vec3f,
        lightType: u32,
        coneAngles: vec2f,
        shadowIndex: i32,
        shadowRadius: f32,
        shadowIntensity: f32,
        _pad3: f32,
        _pad4: f32,
        _pad5: f32,
      }

      struct SceneUniforms {
        viewMatrix : mat4x4<f32>,
        projectionMatrix : mat4x4<f32>,
        lightViewProj : mat4x4<f32>,
        prevViewProj : mat4x4<f32>,
        inverseProjectionMatrix : mat4x4<f32>,
        cameraPosition : vec3f,
        time : f32,
        lightCount : u32,
        debugMode : u32,
        flags : u32,
        environmentIntensity : f32,
        fogColor: vec3f,
        fogDensity: f32,
        fogParams: vec4f,
        fogSettings: vec4u,
        lights : array<Light, ${SpriteMaterial.MAX_LIGHTS}>,
      }

      struct ObjectData {
        modelMatrix : mat4x4<f32>,
        normalMatrix : mat4x4<f32>,
        aabbMin : vec3f,
        _pad1 : f32,
        aabbMax : vec3f,
        _pad2 : f32,
        prevModelMatrix : mat4x4<f32>,
        _pad3 : vec4<f32>,
        _pad4 : vec4<f32>,
      }

      struct SpriteUniforms {
        modelMatrix : mat4x4<f32>,
        tint : vec3<f32>,
        opacity : f32,
        uvOffset : vec2<f32>,
        uvScale : vec2<f32>,
        alphaCutoff : f32,
        textureFlags : u32,
        alphaMode : u32,
        billboard : u32,
        jitter : vec2<f32>,          // TAA jitter to counter (for pixel-perfect rendering)
        _pad : vec2<f32>,
      }

      @group(0) @binding(0) var<uniform> scene : SceneUniforms;
      @group(0) @binding(1) var<storage, read> objects : array<ObjectData>;

      @group(1) @binding(0) var<uniform> material : SpriteUniforms;
      @group(1) @binding(1) var samp : sampler;
      @group(1) @binding(2) var spriteTex : texture_2d<f32>;

      struct VertexInput {
        @location(0) position : vec3<f32>,
        @location(1) normal : vec3<f32>,
        @location(2) uv : vec2<f32>,
      }

      struct VertexOutput {
        @builtin(position) position : vec4<f32>,
        @location(0) uv : vec2<f32>,
        @location(1) worldPosition : vec3<f32>,
      }
    `;
    this.vertexShaderCode = `
      ${commonDefines}

      @vertex
      fn vs_main(input : VertexInput) -> VertexOutput {
        var output : VertexOutput;

        // Use model matrix from material uniforms (each sprite has its own)
        let modelMatrix = material.modelMatrix;
        var worldPos : vec4<f32>;

        if (material.billboard == 1u) {
          // Spherical billboard - always face camera
          let camRight = vec3f(scene.viewMatrix[0][0], scene.viewMatrix[1][0], scene.viewMatrix[2][0]);
          let camUp = vec3f(scene.viewMatrix[0][1], scene.viewMatrix[1][1], scene.viewMatrix[2][1]);
          let center = vec3f(modelMatrix[3][0], modelMatrix[3][1], modelMatrix[3][2]);
          let scaleX = length(vec3f(modelMatrix[0][0], modelMatrix[0][1], modelMatrix[0][2]));
          let scaleY = length(vec3f(modelMatrix[1][0], modelMatrix[1][1], modelMatrix[1][2]));

          worldPos = vec4f(
            center +
            camRight * input.position.x * scaleX +
            camUp * input.position.y * scaleY,
            1.0
          );
        } else if (material.billboard == 2u) {
          // Cylindrical billboard - rotate around Y axis only to face camera
          let center = vec3f(modelMatrix[3][0], modelMatrix[3][1], modelMatrix[3][2]);
          let scaleX = length(vec3f(modelMatrix[0][0], modelMatrix[0][1], modelMatrix[0][2]));
          let scaleY = length(vec3f(modelMatrix[1][0], modelMatrix[1][1], modelMatrix[1][2]));

          // Calculate direction from sprite to camera in XZ plane
          let toCamera = scene.cameraPosition - center;
          let toCameraXZ = normalize(vec2f(toCamera.x, toCamera.z));

          // Sprite's right vector = cross(worldUp, forward) = (forward.z, 0, -forward.x)
          let spriteRight = vec3f(toCameraXZ.y, 0.0, -toCameraXZ.x);
          let worldUp = vec3f(0.0, 1.0, 0.0);

          worldPos = vec4f(
            center +
            spriteRight * input.position.x * scaleX +
            worldUp * input.position.y * scaleY,
            1.0
          );
        } else {
          // No billboard - standard transform
          worldPos = modelMatrix * vec4f(input.position, 1.0);
        }

        output.worldPosition = worldPos.xyz;
        output.position = scene.projectionMatrix * scene.viewMatrix * worldPos;

        // Counter TAA jitter for pixel-perfect rendering
        // The jitter was added to projection matrix, so we subtract it from clip position
        output.position.x -= material.jitter.x * output.position.w;
        output.position.y -= material.jitter.y * output.position.w;

        // Apply small depth bias to prevent z-fighting with nearby geometry
        // This pushes the sprite slightly towards the camera in clip space
        output.position.z = output.position.z - 0.0001 * output.position.w;

        // Apply UV transform for spritesheet frames
        output.uv = input.uv * material.uvScale + material.uvOffset;

        return output;
      }
    `;
    this.fragmentShaderCode = `
      ${commonDefines}

      @fragment
      fn fs_main(@location(0) uv : vec2<f32>, @location(1) worldPosition : vec3<f32>) -> @location(0) vec4<f32> {
        var color = material.tint;
        var alpha = material.opacity;

        // Sample texture if available
        if ((material.textureFlags & 1u) != 0u) {
          let texColor = textureSample(spriteTex, samp, uv);
          color = color * texColor.rgb;
          alpha = alpha * texColor.a;
        }

        // Alpha cutoff for MASK mode
        if (material.alphaMode == 1u && alpha < material.alphaCutoff) {
          discard;
        }

        // For OPAQUE mode, force alpha to 1
        if (material.alphaMode == 0u) {
          alpha = 1.0;
        }

        return vec4f(color, alpha);
      }
    `;
  }
  getRenderingPath() {
    return "forward";
  }
  getTextureFlags() {
    let flags = 0;
    if (this.texture)
      flags |= 1;
    return flags;
  }
  getBillboardFlag() {
    switch (this.billboard) {
      case "none":
        return 0;
      case "spherical":
        return 1;
      case "cylindrical":
        return 2;
      default:
        return 0;
    }
  }
  getAlphaModeFlag() {
    switch (this.alphaMode) {
      case "OPAQUE":
        return 0;
      case "MASK":
        return 1;
      case "BLEND":
        return 2;
      default:
        return 2;
    }
  }
  getUniformBufferSize() {
    return 128;
  }
  updateUniforms(device, buffer, offset, context) {
    const arrayBuffer = new ArrayBuffer(this.getUniformBufferSize());
    const floatView = new Float32Array(arrayBuffer);
    const uintView = new Uint32Array(arrayBuffer);
    let i = 0;
    if (context.modelMatrix) {
      const m = context.modelMatrix.elements;
      for (let j = 0;j < 16; j++) {
        floatView[i++] = m[j];
      }
    } else {
      floatView[i++] = 1;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 1;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 1;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 1;
    }
    floatView[i++] = this.tint.x;
    floatView[i++] = this.tint.y;
    floatView[i++] = this.tint.z;
    floatView[i++] = this.opacity;
    floatView[i++] = this.uvOffset.x;
    floatView[i++] = this.uvOffset.y;
    floatView[i++] = this.uvScale.x;
    floatView[i++] = this.uvScale.y;
    floatView[i++] = this.alphaCutoff;
    uintView[i++] = this.getTextureFlags();
    uintView[i++] = this.getAlphaModeFlag();
    uintView[i++] = this.getBillboardFlag();
    const jitter = context.camera?.projectionJitter;
    floatView[i++] = jitter?.x ?? 0;
    floatView[i++] = jitter?.y ?? 0;
    floatView[i++] = 0;
    floatView[i++] = 0;
    device.queue.writeBuffer(buffer, offset, arrayBuffer);
  }
  getSampler(device) {
    if (this.pixelPerfect) {
      if (!this._pixelPerfectSampler) {
        this._pixelPerfectSampler = device.createSampler({
          magFilter: "nearest",
          minFilter: "nearest",
          mipmapFilter: "nearest",
          addressModeU: "clamp-to-edge",
          addressModeV: "clamp-to-edge"
        });
      }
      return this._pixelPerfectSampler;
    } else {
      if (!this._linearSampler) {
        this._linearSampler = device.createSampler({
          magFilter: "linear",
          minFilter: "linear",
          mipmapFilter: "linear",
          addressModeU: "clamp-to-edge",
          addressModeV: "clamp-to-edge"
        });
      }
      return this._linearSampler;
    }
  }
  getBindGroupEntries(device, uniformBuffer) {
    const defaultTex = Texture.getDefault(device);
    const sampler = this.getSampler(device);
    return [
      { binding: 0, resource: { buffer: uniformBuffer } },
      { binding: 1, resource: sampler },
      { binding: 2, resource: this.texture?.view || defaultTex.view }
    ];
  }
  createBindGroupLayout(device) {
    return device.createBindGroupLayout({
      label: "SpriteMaterial Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX, buffer: { type: "uniform" } },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "filtering" } },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, texture: {} }
      ]
    });
  }
  setUVRegion(x, y, width, height, textureWidth, textureHeight) {
    this.uvOffset.x = x / textureWidth;
    this.uvOffset.y = y / textureHeight;
    this.uvScale.x = width / textureWidth;
    this.uvScale.y = height / textureHeight;
  }
  resetUV() {
    this.uvOffset.x = 0;
    this.uvOffset.y = 0;
    this.uvScale.x = 1;
    this.uvScale.y = 1;
  }
}

// ../../src/core/sprites/SpriteAnimator.ts
class SpriteAnimator {
  spritesheet = null;
  currentAnimation = null;
  currentFrameIndex = 0;
  elapsed = 0;
  playing = false;
  playMode = "forward";
  speed = 1;
  pingpongDirection = 1;
  onFrameChange = null;
  onAnimationEnd = null;
  onLoop = null;
  constructor(spritesheet) {
    if (spritesheet) {
      this.spritesheet = spritesheet;
    }
  }
  play(animationName, options) {
    if (!this.spritesheet)
      return false;
    const animation = this.spritesheet.getAnimation(animationName);
    if (!animation) {
      console.warn(`Animation '${animationName}' not found`);
      return false;
    }
    const restart = options?.restart ?? this.currentAnimation !== animationName;
    if (restart) {
      this.currentFrameIndex = 0;
      this.elapsed = 0;
      this.pingpongDirection = 1;
    }
    this.currentAnimation = animationName;
    this.playing = true;
    this.playMode = options?.playMode ?? this.playMode;
    this.speed = options?.speed ?? this.speed;
    const frame = this.getCurrentFrame();
    if (frame !== null && this.onFrameChange) {
      this.onFrameChange(frame);
    }
    return true;
  }
  pause() {
    this.playing = false;
  }
  resume() {
    this.playing = true;
  }
  stop() {
    this.playing = false;
    this.currentFrameIndex = 0;
    this.elapsed = 0;
    this.pingpongDirection = 1;
  }
  setFrame(index) {
    const animation = this.getCurrentAnimationData();
    if (!animation)
      return;
    this.currentFrameIndex = Math.max(0, Math.min(index, animation.frames.length - 1));
    this.elapsed = 0;
    const frame = this.getCurrentFrame();
    if (frame !== null && this.onFrameChange) {
      this.onFrameChange(frame);
    }
  }
  nextFrame() {
    const animation = this.getCurrentAnimationData();
    if (!animation)
      return;
    this.currentFrameIndex = (this.currentFrameIndex + 1) % animation.frames.length;
    this.elapsed = 0;
    const frame = this.getCurrentFrame();
    if (frame !== null && this.onFrameChange) {
      this.onFrameChange(frame);
    }
  }
  prevFrame() {
    const animation = this.getCurrentAnimationData();
    if (!animation)
      return;
    this.currentFrameIndex = this.currentFrameIndex - 1;
    if (this.currentFrameIndex < 0) {
      this.currentFrameIndex = animation.frames.length - 1;
    }
    this.elapsed = 0;
    const frame = this.getCurrentFrame();
    if (frame !== null && this.onFrameChange) {
      this.onFrameChange(frame);
    }
  }
  update(dt) {
    if (!this.playing || !this.currentAnimation || !this.spritesheet) {
      return this.getCurrentFrame();
    }
    const animation = this.spritesheet.getAnimation(this.currentAnimation);
    if (!animation || animation.frames.length === 0) {
      return null;
    }
    const frameDuration = 1 / (animation.frameRate * this.speed);
    this.elapsed += dt;
    let frameChanged = false;
    while (this.elapsed >= frameDuration) {
      this.elapsed -= frameDuration;
      frameChanged = true;
      if (this.playMode === "forward") {
        this.currentFrameIndex++;
        if (this.currentFrameIndex >= animation.frames.length) {
          if (animation.loop) {
            this.currentFrameIndex = 0;
            if (this.onLoop) {
              this.onLoop(this.currentAnimation);
            }
          } else {
            this.currentFrameIndex = animation.frames.length - 1;
            this.playing = false;
            if (this.onAnimationEnd) {
              this.onAnimationEnd(this.currentAnimation);
            }
          }
        }
      } else if (this.playMode === "reverse") {
        this.currentFrameIndex--;
        if (this.currentFrameIndex < 0) {
          if (animation.loop) {
            this.currentFrameIndex = animation.frames.length - 1;
            if (this.onLoop) {
              this.onLoop(this.currentAnimation);
            }
          } else {
            this.currentFrameIndex = 0;
            this.playing = false;
            if (this.onAnimationEnd) {
              this.onAnimationEnd(this.currentAnimation);
            }
          }
        }
      } else if (this.playMode === "pingpong") {
        this.currentFrameIndex += this.pingpongDirection;
        if (this.currentFrameIndex >= animation.frames.length) {
          this.pingpongDirection = -1;
          this.currentFrameIndex = animation.frames.length - 2;
          if (this.currentFrameIndex < 0)
            this.currentFrameIndex = 0;
        } else if (this.currentFrameIndex < 0) {
          if (animation.loop) {
            this.pingpongDirection = 1;
            this.currentFrameIndex = 1;
            if (this.currentFrameIndex >= animation.frames.length)
              this.currentFrameIndex = 0;
            if (this.onLoop) {
              this.onLoop(this.currentAnimation);
            }
          } else {
            this.currentFrameIndex = 0;
            this.playing = false;
            if (this.onAnimationEnd) {
              this.onAnimationEnd(this.currentAnimation);
            }
          }
        }
      }
    }
    const frame = this.getCurrentFrame();
    if (frameChanged && this.onFrameChange && frame !== null) {
      this.onFrameChange(frame);
    }
    return frame;
  }
  isPlaying() {
    return this.playing;
  }
  getCurrentFrame() {
    const animation = this.getCurrentAnimationData();
    if (!animation || animation.frames.length === 0) {
      return null;
    }
    const frameIndex = Math.max(0, Math.min(this.currentFrameIndex, animation.frames.length - 1));
    return animation.frames[frameIndex];
  }
  getProgress() {
    const animation = this.getCurrentAnimationData();
    if (!animation || animation.frames.length <= 1) {
      return 0;
    }
    return this.currentFrameIndex / (animation.frames.length - 1);
  }
  getCurrentAnimationData() {
    if (!this.spritesheet || !this.currentAnimation) {
      return null;
    }
    return this.spritesheet.getAnimation(this.currentAnimation);
  }
  hasAnimation(name) {
    return this.spritesheet?.getAnimation(name) !== null;
  }
  getAnimationDuration(name) {
    if (!this.spritesheet)
      return 0;
    const animation = this.spritesheet.getAnimation(name);
    if (!animation)
      return 0;
    return animation.frames.length / animation.frameRate;
  }
}

// ../../src/core/sprites/Sprite.ts
class Sprite extends Node {
  geometry;
  material;
  uniformBuffer = null;
  bindGroup = null;
  worldBounds = new AABB;
  worldBoundingSphere = { center: new Vector3, radius: 0 };
  renderIndex = -1;
  previousWorldMatrix = new Matrix4;
  _spritesheet = null;
  _currentFrame = null;
  _animator = null;
  constructor(width = 1, height = 1, anchor) {
    super("Sprite");
    this.geometry = new SpriteGeometry(width, height, anchor);
    this.material = new SpriteMaterial;
    this.renderOrder = 10;
    this._animator = new SpriteAnimator;
    this._animator.onFrameChange = (frame) => {
      this.setFrame(frame);
    };
  }
  get texture() {
    return this.material.texture;
  }
  set texture(tex) {
    this.material.texture = tex;
    if (!this._spritesheet) {
      this.material.resetUV();
    }
    this.bindGroup = null;
  }
  get tint() {
    return this.material.tint;
  }
  set tint(color) {
    this.material.tint.copy(color);
  }
  get opacity() {
    return this.material.opacity;
  }
  set opacity(value) {
    this.material.opacity = Math.max(0, Math.min(1, value));
  }
  get pixelPerfect() {
    return this.material.pixelPerfect;
  }
  set pixelPerfect(value) {
    if (this.material.pixelPerfect !== value) {
      this.material.pixelPerfect = value;
      this.bindGroup = null;
    }
  }
  setSize(width, height) {
    this.geometry.setSize(width, height);
  }
  getSize() {
    return { width: this.geometry.width, height: this.geometry.height };
  }
  setAnchor(x, y) {
    this.geometry.setAnchor(x, y);
  }
  setBillboard(mode) {
    this.material.billboard = mode;
  }
  get billboard() {
    return this.material.billboard;
  }
  get spritesheet() {
    return this._spritesheet;
  }
  set spritesheet(sheet) {
    this._spritesheet = sheet;
    if (sheet) {
      this.material.texture = sheet.texture;
      this._animator.spritesheet = sheet;
      if (sheet.frameCount > 0) {
        this.setFrame(0);
      }
    }
    this.bindGroup = null;
  }
  get currentFrame() {
    return this._currentFrame;
  }
  setFrame(frame) {
    if (!this._spritesheet)
      return;
    const uv = this._spritesheet.getFrameUV(frame);
    if (uv) {
      this.material.uvOffset.x = uv.offset.x;
      this.material.uvOffset.y = uv.offset.y;
      this.material.uvScale.x = uv.scale.x;
      this.material.uvScale.y = uv.scale.y;
      this._currentFrame = frame;
    }
  }
  get animator() {
    return this._animator;
  }
  play(animationName, options) {
    if (!this._animator || !this._spritesheet)
      return false;
    return this._animator.play(animationName, options);
  }
  pause() {
    this._animator?.pause();
  }
  resume() {
    this._animator?.resume();
  }
  stop() {
    this._animator?.stop();
  }
  isPlaying() {
    return this._animator?.isPlaying() ?? false;
  }
  update(dt) {
    if (this._animator) {
      this._animator.update(dt);
    }
  }
  updateWorldBounds() {
    const min = this.geometry.aabb.min;
    const max = this.geometry.aabb.max;
    const corners = [
      new Vector3(min.x, min.y, min.z),
      new Vector3(min.x, min.y, max.z),
      new Vector3(min.x, max.y, min.z),
      new Vector3(min.x, max.y, max.z),
      new Vector3(max.x, min.y, min.z),
      new Vector3(max.x, min.y, max.z),
      new Vector3(max.x, max.y, min.z),
      new Vector3(max.x, max.y, max.z)
    ];
    this.worldBounds.min.set(Infinity, Infinity, Infinity);
    this.worldBounds.max.set(-Infinity, -Infinity, -Infinity);
    for (const corner of corners) {
      corner.applyMatrix4(this.transform.worldMatrix);
      this.worldBounds.min.min(corner);
      this.worldBounds.max.max(corner);
    }
    this.worldBoundingSphere.center = this.geometry.boundingSphere.center.clone().applyMatrix4(this.transform.worldMatrix);
    const scale = this.transform.scale;
    const maxScale = Math.max(Math.abs(scale.x), Math.max(Math.abs(scale.y), Math.abs(scale.z)));
    this.worldBoundingSphere.radius = this.geometry.boundingSphere.radius * maxScale;
  }
  setTint(r, g, b) {
    this.material.tint.set(r, g, b);
  }
  setTintHex(hex) {
    const r = (hex >> 16 & 255) / 255;
    const g = (hex >> 8 & 255) / 255;
    const b = (hex & 255) / 255;
    this.material.tint.set(r, g, b);
  }
  flipX() {
    this.transform.scale.x *= -1;
  }
  flipY() {
    this.transform.scale.y *= -1;
  }
  setFlipped(flipX, flipY) {
    this.transform.scale.x = Math.abs(this.transform.scale.x) * (flipX ? -1 : 1);
    this.transform.scale.y = Math.abs(this.transform.scale.y) * (flipY ? -1 : 1);
  }
  static async fromTexture(device, url, options) {
    const texture = new Texture("Sprite Texture");
    await texture.load(device, url);
    const sprite = new Sprite(options?.width ?? 1, options?.height ?? 1);
    sprite.texture = texture;
    if (options?.pixelPerfect !== undefined) {
      sprite.pixelPerfect = options.pixelPerfect;
    }
    if (options?.billboard) {
      sprite.setBillboard(options.billboard);
    }
    return sprite;
  }
}

// ../../src/core/tilemaps/TilemapGeometry.ts
class TilemapGeometry extends Geometry {
  _width;
  _height;
  _anchorX;
  _anchorY;
  constructor(width = 1, height = 1, anchor = { x: 0, y: 0 }) {
    super();
    this._width = width;
    this._height = height;
    this._anchorX = anchor.x;
    this._anchorY = anchor.y;
    this.buildGeometry();
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  setSize(width, height) {
    if (this._width !== width || this._height !== height) {
      this._width = width;
      this._height = height;
      this.buildGeometry();
    }
  }
  setAnchor(x, y) {
    if (this._anchorX !== x || this._anchorY !== y) {
      this._anchorX = x;
      this._anchorY = y;
      this.buildGeometry();
    }
  }
  buildGeometry() {
    const w = this._width;
    const h = this._height;
    const ax = this._anchorX;
    const ay = this._anchorY;
    const left = -w * ax;
    const right = w * (1 - ax);
    const bottom = -h * ay;
    const top = h * (1 - ay);
    const positions = new Float32Array([
      left,
      bottom,
      0,
      right,
      bottom,
      0,
      right,
      top,
      0,
      left,
      top,
      0
    ]);
    const normals = new Float32Array([
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1
    ]);
    const uvs = new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1
    ]);
    const indices = new Uint16Array([
      0,
      1,
      2,
      0,
      2,
      3
    ]);
    this.setAttribute("position", positions);
    this.setAttribute("normal", normals);
    this.setAttribute("uv", uvs);
    this.setIndices(indices);
  }
}

// ../../src/core/tilemaps/TilemapMaterial.ts
class TilemapMaterial extends Material {
  tileset;
  mapWidth = 1;
  mapHeight = 1;
  tileScaleX = 1;
  tileScaleY = 1;
  tint = new Vector3(1, 1, 1);
  opacity = 1;
  alphaMode = "BLEND";
  alphaCutoff = 0.1;
  depthWrite = false;
  depthTest = true;
  pixelPerfect = true;
  _dataTexture = null;
  _linearSampler = null;
  _pixelSampler = null;
  static MAX_LIGHTS = 8;
  constructor(tileset) {
    super();
    this.tileset = tileset;
    const commonDefines = `
      struct Light {
        position: vec3f,
        _pad1: f32,
        direction: vec3f,
        _pad2: f32,
        color: vec3f,
        intensity: f32,
        attenuation: vec3f,
        lightType: u32,
        coneAngles: vec2f,
        shadowIndex: i32,
        shadowRadius: f32,
        shadowIntensity: f32,
        _pad3: f32,
        _pad4: f32,
        _pad5: f32,
      }

      struct SceneUniforms {
        viewMatrix : mat4x4<f32>,
        projectionMatrix : mat4x4<f32>,
        lightViewProj : mat4x4<f32>,
        prevViewProj : mat4x4<f32>,
        inverseProjectionMatrix : mat4x4<f32>,
        cameraPosition : vec3f,
        time : f32,
        lightCount : u32,
        debugMode : u32,
        flags : u32,
        environmentIntensity : f32,
        fogColor: vec3f,
        fogDensity: f32,
        fogParams: vec4f,
        fogSettings: vec4u,
        lights : array<Light, ${TilemapMaterial.MAX_LIGHTS}>,
      }

      struct ObjectData {
        modelMatrix : mat4x4<f32>,
        normalMatrix : mat4x4<f32>,
        aabbMin : vec3f,
        _pad1 : f32,
        aabbMax : vec3f,
        _pad2 : f32,
        prevModelMatrix : mat4x4<f32>,
        _pad3 : vec4<f32>,
        _pad4 : vec4<f32>,
      }

      struct TilemapUniforms {
        modelMatrix : mat4x4<f32>,
        mapSize : vec2<u32>,         // Width/height in tiles
        tileSize : vec2<f32>,        // Tileset tile size in UV (0-1)
        tilesetSize : vec2<f32>,     // Tileset dimensions in tiles
        firstGid : u32,
        _pad1 : u32,
        tint : vec3<f32>,
        opacity : f32,
        alphaCutoff : f32,
        alphaMode : u32,
        textureFlags : u32,
        _pad2 : u32,
        jitter : vec2<f32>,          // TAA jitter to counter (for pixel-perfect rendering)
        _pad3 : vec2<f32>,
      }

      @group(0) @binding(0) var<uniform> scene : SceneUniforms;
      @group(0) @binding(1) var<storage, read> objects : array<ObjectData>;

      @group(1) @binding(0) var<uniform> material : TilemapUniforms;
      @group(1) @binding(1) var tileSampler : sampler;
      @group(1) @binding(2) var tilesetTex : texture_2d<f32>;
      @group(1) @binding(3) var tileDataTex : texture_2d<u32>;

      struct VertexInput {
        @location(0) position : vec3<f32>,
        @location(1) normal : vec3<f32>,
        @location(2) uv : vec2<f32>,
      }

      struct VertexOutput {
        @builtin(position) position : vec4<f32>,
        @location(0) uv : vec2<f32>,
        @location(1) worldPosition : vec3<f32>,
      }
    `;
    this.vertexShaderCode = `
      ${commonDefines}

      @vertex
      fn vs_main(input : VertexInput) -> VertexOutput {
        var output : VertexOutput;

        let worldPos = material.modelMatrix * vec4f(input.position, 1.0);
        output.worldPosition = worldPos.xyz;
        output.position = scene.projectionMatrix * scene.viewMatrix * worldPos;

        // Counter TAA jitter for pixel-perfect rendering
        // The jitter was added to projection matrix, so we subtract it from clip position
        output.position.x -= material.jitter.x * output.position.w;
        output.position.y -= material.jitter.y * output.position.w;

        // UV spans 0-1 across entire tilemap
        output.uv = input.uv;

        return output;
      }
    `;
    this.fragmentShaderCode = `
      ${commonDefines}

      @fragment
      fn fs_main(@location(0) uv : vec2<f32>, @location(1) worldPosition : vec3<f32>) -> @location(0) vec4<f32> {
        // Calculate which tile we're in
        let mapSizeF = vec2f(f32(material.mapSize.x), f32(material.mapSize.y));
        let tileCoordF = uv * mapSizeF;
        let tileCoord = vec2u(u32(tileCoordF.x), u32(tileCoordF.y));

        // Clamp to valid range
        let clampedCoord = vec2u(
          min(tileCoord.x, material.mapSize.x - 1u),
          min(tileCoord.y, material.mapSize.y - 1u)
        );

        // Sample tile ID from data texture
        let tileId = textureLoad(tileDataTex, clampedCoord, 0).r;

        // Skip empty tiles (ID 0)
        if (tileId == 0u) {
          discard;
        }

        // Convert to local tile index (subtract firstGid)
        let localIndex = tileId - material.firstGid;

        // Calculate UV within current tile (fractional part)
        let tileUV = fract(tileCoordF);

        // Calculate which tile in tileset (column, row)
        let tilesetCols = u32(material.tilesetSize.x);
        let tileCol = localIndex % tilesetCols;
        let tileRow = localIndex / tilesetCols;

        // Calculate tileset UV
        // tileSize is the UV size of one tile in the tileset
        let tilesetUV = (vec2f(f32(tileCol), f32(tileRow)) + tileUV) * material.tileSize;

        // Sample tileset texture
        let texColor = textureSample(tilesetTex, tileSampler, tilesetUV);

        // Apply tint and opacity
        var finalColor = texColor.rgb * material.tint;
        var finalAlpha = texColor.a * material.opacity;

        // Alpha cutoff for MASK mode
        if (material.alphaMode == 1u && finalAlpha < material.alphaCutoff) {
          discard;
        }

        // For OPAQUE mode, force alpha to 1
        if (material.alphaMode == 0u) {
          finalAlpha = 1.0;
        }

        // Discard nearly transparent pixels
        if (finalAlpha < 0.01) {
          discard;
        }

        return vec4f(finalColor, finalAlpha);
      }
    `;
  }
  getRenderingPath() {
    return "forward";
  }
  getTextureFlags() {
    let flags = 0;
    if (this.tileset.texture)
      flags |= 1;
    if (this._dataTexture)
      flags |= 2;
    return flags;
  }
  getAlphaModeFlag() {
    switch (this.alphaMode) {
      case "OPAQUE":
        return 0;
      case "MASK":
        return 1;
      case "BLEND":
        return 2;
      default:
        return 2;
    }
  }
  getUniformBufferSize() {
    return 144;
  }
  updateUniforms(device, buffer, offset, context) {
    const arrayBuffer = new ArrayBuffer(this.getUniformBufferSize());
    const floatView = new Float32Array(arrayBuffer);
    const uintView = new Uint32Array(arrayBuffer);
    let i = 0;
    if (context.modelMatrix) {
      const m = context.modelMatrix.elements;
      for (let j = 0;j < 16; j++) {
        floatView[i++] = m[j];
      }
    } else {
      floatView[i++] = 1;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 1;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 1;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 0;
      floatView[i++] = 1;
    }
    uintView[i++] = this.mapWidth;
    uintView[i++] = this.mapHeight;
    floatView[i++] = this.tileset.tileWidth / this.tileset.getTextureSize().width;
    floatView[i++] = this.tileset.tileHeight / this.tileset.getTextureSize().height;
    floatView[i++] = this.tileset.columns;
    floatView[i++] = this.tileset.rows;
    uintView[i++] = this.tileset.firstGid;
    uintView[i++] = 0;
    floatView[i++] = this.tint.x;
    floatView[i++] = this.tint.y;
    floatView[i++] = this.tint.z;
    floatView[i++] = this.opacity;
    floatView[i++] = this.alphaCutoff;
    uintView[i++] = this.getAlphaModeFlag();
    uintView[i++] = this.getTextureFlags();
    uintView[i++] = 0;
    const jitter = context.camera?.projectionJitter;
    floatView[i++] = jitter?.x ?? 0;
    floatView[i++] = jitter?.y ?? 0;
    floatView[i++] = 0;
    floatView[i++] = 0;
    device.queue.writeBuffer(buffer, offset, arrayBuffer);
  }
  updateDataTexture(device, data, width, height) {
    this.mapWidth = width;
    this.mapHeight = height;
    if (!this._dataTexture || this._dataTexture.width !== width || this._dataTexture.height !== height) {
      if (this._dataTexture) {
        this._dataTexture.destroy();
      }
      this._dataTexture = device.createTexture({
        label: "Tilemap Data Texture",
        size: [width, height],
        format: "r32uint",
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
      });
    }
    const dataBuffer = new Uint32Array(data).buffer;
    device.queue.writeTexture({ texture: this._dataTexture }, dataBuffer, { bytesPerRow: width * 4, rowsPerImage: height }, [width, height]);
  }
  getSampler(device) {
    if (this.pixelPerfect) {
      if (!this._pixelSampler) {
        this._pixelSampler = device.createSampler({
          magFilter: "nearest",
          minFilter: "nearest",
          mipmapFilter: "nearest",
          addressModeU: "clamp-to-edge",
          addressModeV: "clamp-to-edge"
        });
      }
      return this._pixelSampler;
    } else {
      if (!this._linearSampler) {
        this._linearSampler = device.createSampler({
          magFilter: "linear",
          minFilter: "linear",
          mipmapFilter: "linear",
          addressModeU: "clamp-to-edge",
          addressModeV: "clamp-to-edge"
        });
      }
      return this._linearSampler;
    }
  }
  getBindGroupEntries(device, uniformBuffer) {
    const defaultTex = Texture.getDefault(device);
    const sampler = this.getSampler(device);
    if (!this._dataTexture) {
      this._dataTexture = device.createTexture({
        label: "Tilemap Data Texture (default)",
        size: [1, 1],
        format: "r32uint",
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
      });
      device.queue.writeTexture({ texture: this._dataTexture }, new Uint32Array([0]), { bytesPerRow: 4 }, [1, 1]);
    }
    return [
      { binding: 0, resource: { buffer: uniformBuffer } },
      { binding: 1, resource: sampler },
      { binding: 2, resource: this.tileset.texture?.view || defaultTex.view },
      { binding: 3, resource: this._dataTexture.createView() }
    ];
  }
  createBindGroupLayout(device) {
    return device.createBindGroupLayout({
      label: "TilemapMaterial Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT | GPUShaderStage.VERTEX, buffer: { type: "uniform" } },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "filtering" } },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "float" } },
        { binding: 3, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "uint" } }
      ]
    });
  }
  destroy() {
    if (this._dataTexture) {
      this._dataTexture.destroy();
      this._dataTexture = null;
    }
  }
}

// ../../src/core/tilemaps/TilemapLayer.ts
class TilemapLayer extends Node {
  geometry;
  material;
  uniformBuffer = null;
  bindGroup = null;
  worldBounds = new AABB;
  worldBoundingSphere = { center: new Vector3, radius: 0 };
  renderIndex = -1;
  previousWorldMatrix = new Matrix4;
  _tileset;
  _data;
  _tileScaleX = 1;
  _tileScaleY = 1;
  _device = null;
  constructor(tileset, data, options) {
    super("TilemapLayer");
    this._tileset = tileset;
    this._data = data;
    this._tileScaleX = options?.tileScaleX ?? 1;
    this._tileScaleY = options?.tileScaleY ?? 1;
    const worldWidth = data.width * this._tileScaleX;
    const worldHeight = data.height * this._tileScaleY;
    const anchor = options?.anchor ?? { x: 0, y: 0 };
    this.geometry = new TilemapGeometry(worldWidth, worldHeight, anchor);
    this.material = new TilemapMaterial(tileset);
    this.material.mapWidth = data.width;
    this.material.mapHeight = data.height;
    this.material.tileScaleX = this._tileScaleX;
    this.material.tileScaleY = this._tileScaleY;
  }
  get tileset() {
    return this._tileset;
  }
  set tileset(tileset) {
    this._tileset = tileset;
    this.material.tileset = tileset;
    this.bindGroup = null;
  }
  get data() {
    return this._data;
  }
  set data(data) {
    this._data = data;
    this.material.mapWidth = data.width;
    this.material.mapHeight = data.height;
    this.updateGeometrySize();
    this._data.markDirty();
  }
  get tileScaleX() {
    return this._tileScaleX;
  }
  set tileScaleX(value) {
    if (this._tileScaleX !== value) {
      this._tileScaleX = value;
      this.material.tileScaleX = value;
      this.updateGeometrySize();
    }
  }
  get tileScaleY() {
    return this._tileScaleY;
  }
  set tileScaleY(value) {
    if (this._tileScaleY !== value) {
      this._tileScaleY = value;
      this.material.tileScaleY = value;
      this.updateGeometrySize();
    }
  }
  setTileScale(x, y) {
    if (this._tileScaleX !== x || this._tileScaleY !== y) {
      this._tileScaleX = x;
      this._tileScaleY = y;
      this.material.tileScaleX = x;
      this.material.tileScaleY = y;
      this.updateGeometrySize();
    }
  }
  get tint() {
    return this.material.tint;
  }
  set tint(color) {
    this.material.tint.copy(color);
  }
  get opacity() {
    return this.material.opacity;
  }
  set opacity(value) {
    this.material.opacity = Math.max(0, Math.min(1, value));
  }
  get alphaMode() {
    return this.material.alphaMode;
  }
  set alphaMode(mode) {
    this.material.alphaMode = mode;
  }
  get pixelPerfect() {
    return this.material.pixelPerfect;
  }
  set pixelPerfect(value) {
    if (this.material.pixelPerfect !== value) {
      this.material.pixelPerfect = value;
      this.bindGroup = null;
    }
  }
  getTile(x, y) {
    return this._data.getTile(x, y);
  }
  setTile(x, y, tileId) {
    this._data.setTile(x, y, tileId);
  }
  fillRect(x, y, width, height, tileId) {
    this._data.fillRect(x, y, width, height, tileId);
  }
  clear() {
    this._data.clear();
  }
  worldToTile(worldX, worldY) {
    const localX = worldX - this.transform.position.x;
    const localY = worldY - this.transform.position.y;
    return {
      x: Math.floor(localX / this._tileScaleX),
      y: Math.floor(localY / this._tileScaleY)
    };
  }
  tileToWorld(tileX, tileY) {
    return {
      x: this.transform.position.x + (tileX + 0.5) * this._tileScaleX,
      y: this.transform.position.y + (tileY + 0.5) * this._tileScaleY
    };
  }
  getTileBounds(tileX, tileY) {
    const bounds = new AABB;
    const worldX = this.transform.position.x + tileX * this._tileScaleX;
    const worldY = this.transform.position.y + tileY * this._tileScaleY;
    bounds.min.set(worldX, worldY, this.transform.position.z - 0.01);
    bounds.max.set(worldX + this._tileScaleX, worldY + this._tileScaleY, this.transform.position.z + 0.01);
    return bounds;
  }
  getMapSize() {
    return { width: this._data.width, height: this._data.height };
  }
  getWorldSize() {
    return {
      width: this._data.width * this._tileScaleX,
      height: this._data.height * this._tileScaleY
    };
  }
  initGPU(device) {
    this._device = device;
    this.syncDataTexture();
  }
  syncDataTexture() {
    if (!this._device || !this._data.dirty)
      return;
    this.material.updateDataTexture(this._device, this._data.data, this._data.width, this._data.height);
    this._data.markClean();
    this.bindGroup = null;
  }
  forceSync() {
    this._data.markDirty();
    this.syncDataTexture();
  }
  updateWorldBounds() {
    const min = this.geometry.aabb.min;
    const max = this.geometry.aabb.max;
    const corners = [
      new Vector3(min.x, min.y, min.z),
      new Vector3(min.x, min.y, max.z),
      new Vector3(min.x, max.y, min.z),
      new Vector3(min.x, max.y, max.z),
      new Vector3(max.x, min.y, min.z),
      new Vector3(max.x, min.y, max.z),
      new Vector3(max.x, max.y, min.z),
      new Vector3(max.x, max.y, max.z)
    ];
    this.worldBounds.min.set(Infinity, Infinity, Infinity);
    this.worldBounds.max.set(-Infinity, -Infinity, -Infinity);
    for (const corner of corners) {
      corner.applyMatrix4(this.transform.worldMatrix);
      this.worldBounds.min.min(corner);
      this.worldBounds.max.max(corner);
    }
    this.worldBoundingSphere.center = this.geometry.boundingSphere.center.clone().applyMatrix4(this.transform.worldMatrix);
    const scale = this.transform.scale;
    const maxScale = Math.max(Math.abs(scale.x), Math.max(Math.abs(scale.y), Math.abs(scale.z)));
    this.worldBoundingSphere.radius = this.geometry.boundingSphere.radius * maxScale;
  }
  setTint(r, g, b) {
    this.material.tint.set(r, g, b);
  }
  setTintHex(hex) {
    const r = (hex >> 16 & 255) / 255;
    const g = (hex >> 8 & 255) / 255;
    const b = (hex & 255) / 255;
    this.material.tint.set(r, g, b);
  }
  updateGeometrySize() {
    const worldWidth = this._data.width * this._tileScaleX;
    const worldHeight = this._data.height * this._tileScaleY;
    this.geometry.setSize(worldWidth, worldHeight);
  }
  destroy() {
    this.material.destroy();
    if (this.uniformBuffer) {
      this.uniformBuffer.destroy();
      this.uniformBuffer = null;
    }
    this.bindGroup = null;
    this._device = null;
  }
}

// ../../src/core/animation/Bone.ts
class Bone {
  name;
  index;
  parent = null;
  children = [];
  bindPosition;
  bindRotation;
  bindScale;
  inverseBindMatrix;
  _position;
  _rotation;
  _scale;
  _localMatrix = new Matrix4;
  _worldMatrix = new Matrix4;
  _finalMatrix = new Matrix4;
  _localMatrixDirty = true;
  _worldMatrixDirty = true;
  constructor(data) {
    this.name = data.name;
    this.index = data.index;
    this.bindPosition = data.localBindPose.position.clone();
    this.bindRotation = data.localBindPose.rotation.clone();
    this.bindScale = data.localBindPose.scale.clone();
    this.inverseBindMatrix = data.inverseBindMatrix.clone();
    this._position = this.bindPosition.clone();
    this._rotation = this.bindRotation.clone();
    this._scale = this.bindScale.clone();
  }
  get position() {
    return this._position;
  }
  set position(value) {
    this._position.copy(value);
    this._markLocalDirty();
  }
  get rotation() {
    return this._rotation;
  }
  set rotation(value) {
    this._rotation.copy(value);
    this._markLocalDirty();
  }
  get scale() {
    return this._scale;
  }
  set scale(value) {
    this._scale.copy(value);
    this._markLocalDirty();
  }
  get localMatrix() {
    if (this._localMatrixDirty) {
      this.updateLocalMatrix();
    }
    return this._localMatrix;
  }
  get worldMatrix() {
    if (this._worldMatrixDirty) {
      this.updateWorldMatrix();
    }
    return this._worldMatrix;
  }
  get finalMatrix() {
    if (this._worldMatrixDirty) {
      this.updateWorldMatrix();
    }
    return this._finalMatrix;
  }
  updateLocalMatrix() {
    this._localMatrix.compose(this._position, this._rotation.toMatrix4(), this._scale);
    this._localMatrixDirty = false;
  }
  updateWorldMatrix() {
    if (this._localMatrixDirty) {
      this.updateLocalMatrix();
    }
    if (this.parent) {
      this._worldMatrix.multiplyMatrices(this.parent.worldMatrix, this._localMatrix);
    } else {
      this._worldMatrix.copy(this._localMatrix);
    }
    this._finalMatrix.multiplyMatrices(this._worldMatrix, this.inverseBindMatrix);
    this._worldMatrixDirty = false;
  }
  copyBindPose() {
    this._position.copy(this.bindPosition);
    this._rotation.copy(this.bindRotation);
    this._scale.copy(this.bindScale);
    this._markLocalDirty();
  }
  setPosition(x, y, z) {
    this._position.set(x, y, z);
    this._markLocalDirty();
  }
  setRotation(x, y, z, w) {
    this._rotation.x = x;
    this._rotation.y = y;
    this._rotation.z = z;
    this._rotation.w = w;
    this._markLocalDirty();
  }
  setScale(x, y, z) {
    this._scale.set(x, y, z);
    this._markLocalDirty();
  }
  addChild(bone) {
    if (bone.parent) {
      bone.parent.removeChild(bone);
    }
    bone.parent = this;
    this.children.push(bone);
    bone._markWorldDirty();
  }
  removeChild(bone) {
    const index = this.children.indexOf(bone);
    if (index !== -1) {
      this.children.splice(index, 1);
      bone.parent = null;
    }
  }
  _markLocalDirty() {
    this._localMatrixDirty = true;
    this._markWorldDirty();
  }
  _markWorldDirty() {
    this._worldMatrixDirty = true;
    for (const child of this.children) {
      child._markWorldDirty();
    }
  }
  clone() {
    const cloned = new Bone({
      name: this.name,
      index: this.index,
      parentIndex: this.parent?.index ?? -1,
      localBindPose: {
        position: this.bindPosition.clone(),
        rotation: this.bindRotation.clone(),
        scale: this.bindScale.clone()
      },
      inverseBindMatrix: this.inverseBindMatrix.clone()
    });
    cloned._position.copy(this._position);
    cloned._rotation.copy(this._rotation);
    cloned._scale.copy(this._scale);
    return cloned;
  }
  toString() {
    return `Bone(${this.name}, index=${this.index}, parent=${this.parent?.name ?? "none"})`;
  }
}
// ../../src/core/animation/Skeleton.ts
var MAX_BONES = 128;

class Skeleton {
  bones = [];
  bonesByName = new Map;
  rootBones = [];
  boneMatricesBuffer = null;
  bindGroup = null;
  _boneMatrices;
  _gpuDirty = true;
  _device = null;
  constructor(bonesData) {
    this._boneMatrices = new Float32Array(MAX_BONES * 16);
    for (const data of bonesData) {
      const bone = new Bone(data);
      this.bones[bone.index] = bone;
      this.bonesByName.set(bone.name, bone);
    }
    for (const data of bonesData) {
      const bone = this.bones[data.index];
      if (data.parentIndex >= 0 && data.parentIndex < this.bones.length) {
        const parent = this.bones[data.parentIndex];
        if (parent) {
          parent.addChild(bone);
        }
      } else {
        this.rootBones.push(bone);
      }
    }
  }
  getBone(name) {
    return this.bonesByName.get(name) ?? null;
  }
  getBoneIndex(name) {
    const bone = this.bonesByName.get(name);
    return bone?.index ?? -1;
  }
  get boneCount() {
    return this.bones.length;
  }
  update() {
    for (const root of this.rootBones) {
      this._updateBoneRecursive(root);
    }
    this._gpuDirty = true;
  }
  _updateBoneRecursive(bone) {
    bone.updateWorldMatrix();
    for (const child of bone.children) {
      this._updateBoneRecursive(child);
    }
  }
  initGPU(device) {
    if (this._device === device && this.boneMatricesBuffer) {
      return;
    }
    this._device = device;
    this.boneMatricesBuffer = device.createBuffer({
      label: `Skeleton Bone Matrices (${this.boneCount} bones)`,
      size: MAX_BONES * 16 * 4,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
    });
    this.uploadToGPU(device);
  }
  static createBindGroupLayout(device) {
    return device.createBindGroupLayout({
      label: "Skeleton Bind Group Layout",
      entries: [
        {
          binding: 0,
          visibility: GPUShaderStage.VERTEX,
          buffer: {
            type: "read-only-storage"
          }
        }
      ]
    });
  }
  createBindGroup(device, layout) {
    if (!this.boneMatricesBuffer) {
      this.initGPU(device);
    }
    this.bindGroup = device.createBindGroup({
      label: "Skeleton Bind Group",
      layout,
      entries: [
        {
          binding: 0,
          resource: { buffer: this.boneMatricesBuffer }
        }
      ]
    });
    return this.bindGroup;
  }
  uploadToGPU(device) {
    if (!this._gpuDirty)
      return;
    if (!this.boneMatricesBuffer) {
      this.initGPU(device);
    }
    for (let i = 0;i < this.bones.length; i++) {
      const bone = this.bones[i];
      if (bone) {
        const matrix = bone.finalMatrix;
        const offset = i * 16;
        this._boneMatrices.set(matrix.elements, offset);
      }
    }
    const identityElements = Matrix4.identity.elements;
    for (let i = this.bones.length;i < MAX_BONES; i++) {
      const offset = i * 16;
      this._boneMatrices.set(identityElements, offset);
    }
    device.queue.writeBuffer(this.boneMatricesBuffer, 0, this._boneMatrices.buffer, this._boneMatrices.byteOffset, this._boneMatrices.byteLength);
    this._gpuDirty = false;
  }
  getBoneMatrices() {
    return this._boneMatrices;
  }
  copyBindPose() {
    for (const bone of this.bones) {
      if (bone) {
        bone.copyBindPose();
      }
    }
    this._gpuDirty = true;
  }
  clone() {
    const bonesData = this.bones.map((bone) => ({
      name: bone.name,
      index: bone.index,
      parentIndex: bone.parent?.index ?? -1,
      localBindPose: {
        position: bone.bindPosition.clone(),
        rotation: bone.bindRotation.clone(),
        scale: bone.bindScale.clone()
      },
      inverseBindMatrix: bone.inverseBindMatrix.clone()
    }));
    const cloned = new Skeleton(bonesData);
    for (let i = 0;i < this.bones.length; i++) {
      const srcBone = this.bones[i];
      const dstBone = cloned.bones[i];
      if (srcBone && dstBone) {
        dstBone.position.copy(srcBone.position);
        dstBone.rotation.copy(srcBone.rotation);
        dstBone.scale.copy(srcBone.scale);
      }
    }
    return cloned;
  }
  traverse(callback) {
    const traverseRecursive = (bone) => {
      callback(bone);
      for (const child of bone.children) {
        traverseRecursive(child);
      }
    };
    for (const root of this.rootBones) {
      traverseRecursive(root);
    }
  }
  destroy() {
    this.boneMatricesBuffer?.destroy();
    this.boneMatricesBuffer = null;
    this.bindGroup = null;
    this._device = null;
  }
  toString() {
    return `Skeleton(${this.boneCount} bones, ${this.rootBones.length} roots)`;
  }
}
// ../../src/core/animation/AnimationTrack.ts
class AnimationTrack {
  targetBoneIndex;
  property;
  interpolation;
  keyframes;
  duration;
  constructor(targetBoneIndex, property, interpolation, times, values) {
    this.targetBoneIndex = targetBoneIndex;
    this.property = property;
    this.interpolation = interpolation;
    this.keyframes = [];
    const componentCount = property === "rotation" ? 4 : 3;
    const keyframeCount = times.length;
    const stride = interpolation === "CUBICSPLINE" ? componentCount * 3 : componentCount;
    for (let i = 0;i < keyframeCount; i++) {
      const time = times[i];
      const valueOffset = i * stride;
      let value;
      let inTangent;
      let outTangent;
      if (interpolation === "CUBICSPLINE") {
        const inOffset = valueOffset;
        const valOffset = valueOffset + componentCount;
        const outOffset = valueOffset + componentCount * 2;
        if (property === "rotation") {
          inTangent = new Quaternion(values[inOffset], values[inOffset + 1], values[inOffset + 2], values[inOffset + 3]);
          value = new Quaternion(values[valOffset], values[valOffset + 1], values[valOffset + 2], values[valOffset + 3]);
          outTangent = new Quaternion(values[outOffset], values[outOffset + 1], values[outOffset + 2], values[outOffset + 3]);
        } else {
          inTangent = new Vector3(values[inOffset], values[inOffset + 1], values[inOffset + 2]);
          value = new Vector3(values[valOffset], values[valOffset + 1], values[valOffset + 2]);
          outTangent = new Vector3(values[outOffset], values[outOffset + 1], values[outOffset + 2]);
        }
      } else {
        if (property === "rotation") {
          value = new Quaternion(values[valueOffset], values[valueOffset + 1], values[valueOffset + 2], values[valueOffset + 3]);
        } else {
          value = new Vector3(values[valueOffset], values[valueOffset + 1], values[valueOffset + 2]);
        }
      }
      this.keyframes.push({ time, value, inTangent, outTangent });
    }
    this.duration = keyframeCount > 0 ? this.keyframes[keyframeCount - 1].time : 0;
  }
  sample(time) {
    if (this.keyframes.length === 0) {
      return this.property === "rotation" ? Quaternion.identity : this.property === "scale" ? Vector3.one : Vector3.zero;
    }
    if (this.keyframes.length === 1) {
      return this.cloneValue(this.keyframes[0].value);
    }
    const firstKeyframe = this.keyframes[0];
    const lastKeyframe = this.keyframes[this.keyframes.length - 1];
    if (time <= firstKeyframe.time) {
      return this.cloneValue(firstKeyframe.value);
    }
    if (time >= lastKeyframe.time) {
      return this.cloneValue(lastKeyframe.value);
    }
    let prevKeyframe = firstKeyframe;
    let nextKeyframe = this.keyframes[1];
    for (let i = 1;i < this.keyframes.length; i++) {
      nextKeyframe = this.keyframes[i];
      if (nextKeyframe.time >= time) {
        prevKeyframe = this.keyframes[i - 1];
        break;
      }
    }
    const duration = nextKeyframe.time - prevKeyframe.time;
    const t = duration > 0 ? (time - prevKeyframe.time) / duration : 0;
    switch (this.interpolation) {
      case "STEP":
        return this.cloneValue(prevKeyframe.value);
      case "CUBICSPLINE":
        return this.cubicSplineInterpolate(prevKeyframe, nextKeyframe, t, duration);
      case "LINEAR":
      default:
        return this.linearInterpolate(prevKeyframe.value, nextKeyframe.value, t);
    }
  }
  linearInterpolate(a, b, t) {
    if (this.property === "rotation") {
      return a.clone().slerp(b, t);
    } else {
      const va = a;
      const vb = b;
      return new Vector3(va.x + (vb.x - va.x) * t, va.y + (vb.y - va.y) * t, va.z + (vb.z - va.z) * t);
    }
  }
  cubicSplineInterpolate(prev, next, t, duration) {
    const t2 = t * t;
    const t3 = t2 * t;
    const h00 = 2 * t3 - 3 * t2 + 1;
    const h10 = t3 - 2 * t2 + t;
    const h01 = -2 * t3 + 3 * t2;
    const h11 = t3 - t2;
    if (this.property === "rotation") {
      const p0 = prev.value;
      const m0 = prev.outTangent;
      const p1 = next.value;
      const m1 = next.inTangent;
      const scaledM0 = new Quaternion(m0.x * duration, m0.y * duration, m0.z * duration, m0.w * duration);
      const scaledM1 = new Quaternion(m1.x * duration, m1.y * duration, m1.z * duration, m1.w * duration);
      const result = new Quaternion(h00 * p0.x + h10 * scaledM0.x + h01 * p1.x + h11 * scaledM1.x, h00 * p0.y + h10 * scaledM0.y + h01 * p1.y + h11 * scaledM1.y, h00 * p0.z + h10 * scaledM0.z + h01 * p1.z + h11 * scaledM1.z, h00 * p0.w + h10 * scaledM0.w + h01 * p1.w + h11 * scaledM1.w);
      return result.normalize();
    } else {
      const p0 = prev.value;
      const m0 = prev.outTangent;
      const p1 = next.value;
      const m1 = next.inTangent;
      const scaledM0 = m0.multiply(duration);
      const scaledM1 = m1.multiply(duration);
      return new Vector3(h00 * p0.x + h10 * scaledM0.x + h01 * p1.x + h11 * scaledM1.x, h00 * p0.y + h10 * scaledM0.y + h01 * p1.y + h11 * scaledM1.y, h00 * p0.z + h10 * scaledM0.z + h01 * p1.z + h11 * scaledM1.z);
    }
  }
  cloneValue(value) {
    if (value instanceof Quaternion) {
      return value.clone();
    }
    return value.clone();
  }
  getStartValue() {
    return this.keyframes.length > 0 ? this.keyframes[0].value : null;
  }
  getEndValue() {
    return this.keyframes.length > 0 ? this.keyframes[this.keyframes.length - 1].value : null;
  }
  toString() {
    return `AnimationTrack(bone=${this.targetBoneIndex}, property=${this.property}, ` + `keyframes=${this.keyframes.length}, duration=${this.duration.toFixed(2)}s)`;
  }
}
// ../../src/core/animation/NodeAnimationTrack.ts
class NodeAnimationTrack {
  targetNode;
  property;
  interpolation;
  keyframes;
  duration;
  constructor(targetNode, property, interpolation, times, values) {
    this.targetNode = targetNode;
    this.property = property;
    this.interpolation = interpolation;
    this.keyframes = [];
    const componentCount = property === "rotation" ? 4 : 3;
    const keyframeCount = times.length;
    const stride = interpolation === "CUBICSPLINE" ? componentCount * 3 : componentCount;
    for (let i = 0;i < keyframeCount; i++) {
      const time = times[i];
      const valueOffset = i * stride;
      let value;
      let inTangent;
      let outTangent;
      if (interpolation === "CUBICSPLINE") {
        const inOffset = valueOffset;
        const valOffset = valueOffset + componentCount;
        const outOffset = valueOffset + componentCount * 2;
        if (property === "rotation") {
          inTangent = new Quaternion(values[inOffset], values[inOffset + 1], values[inOffset + 2], values[inOffset + 3]);
          value = new Quaternion(values[valOffset], values[valOffset + 1], values[valOffset + 2], values[valOffset + 3]);
          outTangent = new Quaternion(values[outOffset], values[outOffset + 1], values[outOffset + 2], values[outOffset + 3]);
        } else {
          inTangent = new Vector3(values[inOffset], values[inOffset + 1], values[inOffset + 2]);
          value = new Vector3(values[valOffset], values[valOffset + 1], values[valOffset + 2]);
          outTangent = new Vector3(values[outOffset], values[outOffset + 1], values[outOffset + 2]);
        }
      } else {
        if (property === "rotation") {
          value = new Quaternion(values[valueOffset], values[valueOffset + 1], values[valueOffset + 2], values[valueOffset + 3]);
        } else {
          value = new Vector3(values[valueOffset], values[valueOffset + 1], values[valueOffset + 2]);
        }
      }
      this.keyframes.push({ time, value, inTangent, outTangent });
    }
    this.duration = keyframeCount > 0 ? this.keyframes[keyframeCount - 1].time : 0;
  }
  sample(time) {
    if (this.keyframes.length === 0) {
      return this.property === "rotation" ? Quaternion.identity : Vector3.zero;
    }
    if (this.keyframes.length === 1) {
      return this.keyframes[0].value;
    }
    const first = this.keyframes[0];
    const last = this.keyframes[this.keyframes.length - 1];
    if (time <= first.time)
      return first.value;
    if (time >= last.time)
      return last.value;
    let prev = first;
    let next = this.keyframes[1];
    for (let i = 1;i < this.keyframes.length; i++) {
      next = this.keyframes[i];
      if (next.time >= time) {
        prev = this.keyframes[i - 1];
        break;
      }
    }
    const duration = next.time - prev.time;
    const t = duration > 0 ? (time - prev.time) / duration : 0;
    switch (this.interpolation) {
      case "STEP":
        return prev.value;
      case "CUBICSPLINE":
        return this.cubicSplineInterpolate(prev, next, t, duration);
      case "LINEAR":
      default:
        return this.linearInterpolate(prev.value, next.value, t);
    }
  }
  apply(time) {
    const value = this.sample(time);
    if (!this._debugLogged) {
      console.log(`NodeAnimationTrack.apply: "${this.targetNode.name}" ${this.property}`, value);
      this._debugLogged = true;
    }
    switch (this.property) {
      case "position":
        this.targetNode.transform.position = value;
        break;
      case "rotation":
        this.targetNode.transform.rotation = value;
        break;
      case "scale":
        this.targetNode.transform.scale = value;
        break;
    }
  }
  _debugLogged = false;
  linearInterpolate(a, b, t) {
    if (a instanceof Quaternion && b instanceof Quaternion) {
      return a.clone().slerp(b, t);
    }
    return a.clone().lerp(b, t);
  }
  cubicSplineInterpolate(prev, next, t, duration) {
    const t2 = t * t;
    const t3 = t2 * t;
    const h00 = 2 * t3 - 3 * t2 + 1;
    const h10 = t3 - 2 * t2 + t;
    const h01 = -2 * t3 + 3 * t2;
    const h11 = t3 - t2;
    if (prev.value instanceof Quaternion) {
      const p0 = prev.value;
      const m0 = prev.outTangent;
      const p1 = next.value;
      const m1 = next.inTangent;
      const m0s = new Quaternion(m0.x * duration, m0.y * duration, m0.z * duration, m0.w * duration);
      const m1s = new Quaternion(m1.x * duration, m1.y * duration, m1.z * duration, m1.w * duration);
      return new Quaternion(h00 * p0.x + h10 * m0s.x + h01 * p1.x + h11 * m1s.x, h00 * p0.y + h10 * m0s.y + h01 * p1.y + h11 * m1s.y, h00 * p0.z + h10 * m0s.z + h01 * p1.z + h11 * m1s.z, h00 * p0.w + h10 * m0s.w + h01 * p1.w + h11 * m1s.w).normalize();
    } else {
      const p0 = prev.value;
      const m0 = prev.outTangent;
      const p1 = next.value;
      const m1 = next.inTangent;
      const m0s = m0.clone().multiply(duration);
      const m1s = m1.clone().multiply(duration);
      return new Vector3(h00 * p0.x + h10 * m0s.x + h01 * p1.x + h11 * m1s.x, h00 * p0.y + h10 * m0s.y + h01 * p1.y + h11 * m1s.y, h00 * p0.z + h10 * m0s.z + h01 * p1.z + h11 * m1s.z);
    }
  }
}
// ../../src/core/animation/AnimationClip.ts
class AnimationClip {
  name;
  duration = 0;
  tracks = [];
  nodeAnimationTracks = [];
  morphWeightsTracks = [];
  _trackMap = new Map;
  constructor(name = "animation") {
    this.name = name;
  }
  addTrack(track) {
    this.tracks.push(track);
    if (track.duration > this.duration) {
      this.duration = track.duration;
    }
    const key = this._getTrackKey(track.targetBoneIndex, track.property);
    this._trackMap.set(key, track);
  }
  addMorphWeightsTrack(track) {
    this.morphWeightsTracks.push(track);
    if (track.duration > this.duration) {
      this.duration = track.duration;
    }
  }
  addNodeAnimationTrack(track) {
    this.nodeAnimationTracks.push(track);
    if (track.duration > this.duration) {
      this.duration = track.duration;
    }
  }
  getTrack(boneIndex, property) {
    const key = this._getTrackKey(boneIndex, property);
    return this._trackMap.get(key) ?? null;
  }
  apply(skeleton, time, weight = 1) {
    if (weight <= 0)
      return;
    if (skeleton) {
      for (const track of this.tracks) {
        const bone = skeleton.bones[track.targetBoneIndex];
        if (!bone)
          continue;
        const value = track.sample(time);
        if (weight >= 1) {
          this._applyValue(bone, track.property, value);
        } else {
          this._blendValue(bone, track.property, value, weight);
        }
      }
    }
    for (const morphTrack of this.morphWeightsTracks) {
      const weights = morphTrack.sample(time);
      if (weight >= 1) {
        morphTrack.targetMesh.setMorphWeights(weights);
      } else {
        const currentWeights = morphTrack.targetMesh.morphTargets.weights;
        const blendedWeights = new Float32Array(weights.length);
        for (let i = 0;i < weights.length; i++) {
          blendedWeights[i] = currentWeights[i] + (weights[i] - currentWeights[i]) * weight;
        }
        morphTrack.targetMesh.setMorphWeights(blendedWeights);
      }
    }
    for (const nodeTrack of this.nodeAnimationTracks) {
      nodeTrack.apply(time);
    }
  }
  _applyValue(bone, property, value) {
    switch (property) {
      case "position":
        bone.position.copy(value);
        break;
      case "rotation":
        bone.rotation.copy(value);
        break;
      case "scale":
        bone.scale.copy(value);
        break;
    }
  }
  _blendValue(bone, property, value, weight) {
    switch (property) {
      case "position": {
        const v = value;
        bone.position.set(bone.position.x + (v.x - bone.position.x) * weight, bone.position.y + (v.y - bone.position.y) * weight, bone.position.z + (v.z - bone.position.z) * weight);
        break;
      }
      case "rotation": {
        const q = value;
        const blended = bone.rotation.slerp(q, weight);
        bone.rotation.copy(blended);
        break;
      }
      case "scale": {
        const s = value;
        bone.scale.set(bone.scale.x + (s.x - bone.scale.x) * weight, bone.scale.y + (s.y - bone.scale.y) * weight, bone.scale.z + (s.z - bone.scale.z) * weight);
        break;
      }
    }
  }
  _getTrackKey(boneIndex, property) {
    return `${boneIndex}:${property}`;
  }
  getAnimatedBoneIndices() {
    const indices = new Set;
    for (const track of this.tracks) {
      indices.add(track.targetBoneIndex);
    }
    return Array.from(indices);
  }
  animatesBone(boneIndex) {
    return this.tracks.some((t) => t.targetBoneIndex === boneIndex);
  }
  hasMorphTargetAnimations() {
    return this.morphWeightsTracks.length > 0;
  }
  hasNodeAnimations() {
    return this.nodeAnimationTracks.length > 0;
  }
  clone() {
    const cloned = new AnimationClip(this.name);
    cloned.duration = this.duration;
    for (const track of this.tracks) {
      cloned.addTrack(track);
    }
    for (const morphTrack of this.morphWeightsTracks) {
      cloned.addMorphWeightsTrack(morphTrack);
    }
    for (const nodeTrack of this.nodeAnimationTracks) {
      cloned.addNodeAnimationTrack(nodeTrack);
    }
    return cloned;
  }
  trim(startTime, endTime) {
    const cloned = this.clone();
    cloned.duration = Math.min(cloned.duration, endTime - startTime);
    return cloned;
  }
  getStats() {
    let keyframeCount = 0;
    const boneIndices = new Set;
    for (const track of this.tracks) {
      keyframeCount += track.keyframes.length;
      boneIndices.add(track.targetBoneIndex);
    }
    let nodeKeyframeCount = 0;
    for (const nodeTrack of this.nodeAnimationTracks) {
      nodeKeyframeCount += nodeTrack.keyframes.length;
    }
    let morphKeyframeCount = 0;
    for (const morphTrack of this.morphWeightsTracks) {
      morphKeyframeCount += morphTrack.keyframes.length;
    }
    return {
      trackCount: this.tracks.length,
      boneCount: boneIndices.size,
      keyframeCount,
      nodeTrackCount: this.nodeAnimationTracks.length,
      nodeKeyframeCount,
      morphTrackCount: this.morphWeightsTracks.length,
      morphKeyframeCount,
      duration: this.duration
    };
  }
  toString() {
    const stats = this.getStats();
    let str = `AnimationClip("${this.name}", duration=${this.duration.toFixed(2)}s, ` + `boneTracks=${stats.trackCount}, bones=${stats.boneCount}`;
    if (stats.nodeTrackCount > 0) {
      str += `, nodeTracks=${stats.nodeTrackCount}`;
    }
    if (stats.morphTrackCount > 0) {
      str += `, morphTracks=${stats.morphTrackCount}`;
    }
    str += ")";
    return str;
  }
}
// ../../src/core/animation/AnimationAction.ts
class AnimationAction {
  clip;
  mixer;
  _time = 0;
  _timeScale = 1;
  _weight = 1;
  _effectiveWeight = 1;
  _loop = "repeat";
  _paused = false;
  _enabled = true;
  _clampWhenFinished = false;
  _direction = 1;
  _fadeStartTime = 0;
  _fadeDuration = 0;
  _fadeStartWeight = 0;
  _fadeTargetWeight = 0;
  _isFading = false;
  _repetitions = Infinity;
  _currentRepetition = 0;
  constructor(mixer, clip) {
    this.mixer = mixer;
    this.clip = clip;
  }
  get time() {
    return this._time;
  }
  set time(value) {
    this._time = value;
  }
  get timeScale() {
    return this._timeScale;
  }
  set timeScale(value) {
    this._timeScale = value;
  }
  get weight() {
    return this._weight;
  }
  set weight(value) {
    this._weight = Math.max(0, Math.min(1, value));
  }
  get effectiveWeight() {
    return this._effectiveWeight;
  }
  get loop() {
    return this._loop;
  }
  set loop(value) {
    this._loop = value;
  }
  get paused() {
    return this._paused;
  }
  set paused(value) {
    this._paused = value;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
  }
  get clampWhenFinished() {
    return this._clampWhenFinished;
  }
  set clampWhenFinished(value) {
    this._clampWhenFinished = value;
  }
  get repetitions() {
    return this._repetitions;
  }
  set repetitions(value) {
    this._repetitions = value;
  }
  isRunning() {
    return this._enabled && !this._paused && this._effectiveWeight > 0;
  }
  isScheduled() {
    return this._enabled;
  }
  play() {
    this._enabled = true;
    this._paused = false;
    this.mixer._addAction(this);
    return this;
  }
  stop() {
    this._enabled = false;
    this._time = 0;
    this._currentRepetition = 0;
    this._direction = 1;
    this._isFading = false;
    return this;
  }
  reset() {
    this._time = 0;
    this._currentRepetition = 0;
    this._direction = 1;
    this._paused = false;
    this._enabled = true;
    this._isFading = false;
    this._effectiveWeight = this._weight;
    return this;
  }
  halt() {
    this._paused = true;
    return this;
  }
  fadeIn(duration) {
    return this._fade(0, this._weight, duration);
  }
  fadeOut(duration) {
    return this._fade(this._effectiveWeight, 0, duration);
  }
  crossFadeTo(otherAction, duration, warp = false) {
    this.fadeOut(duration);
    otherAction.fadeIn(duration);
    otherAction.play();
    return this;
  }
  syncWith(otherAction) {
    this._time = otherAction._time;
    return this;
  }
  _fade(startWeight, endWeight, duration) {
    this._fadeStartTime = 0;
    this._fadeDuration = duration;
    this._fadeStartWeight = startWeight;
    this._fadeTargetWeight = endWeight;
    this._isFading = true;
    this._effectiveWeight = startWeight;
    return this;
  }
  _update(deltaTime, mixerTime) {
    if (!this._enabled || this._paused) {
      return false;
    }
    let finished = false;
    if (this._isFading) {
      this._fadeStartTime += deltaTime;
      const fadeProgress = this._fadeDuration > 0 ? Math.min(1, this._fadeStartTime / this._fadeDuration) : 1;
      this._effectiveWeight = this._fadeStartWeight + (this._fadeTargetWeight - this._fadeStartWeight) * fadeProgress;
      if (fadeProgress >= 1) {
        this._isFading = false;
        this._weight = this._fadeTargetWeight;
        this._effectiveWeight = this._fadeTargetWeight;
        if (this._fadeTargetWeight <= 0) {
          this._enabled = false;
        }
      }
    } else {
      this._effectiveWeight = this._weight;
    }
    const scaledDelta = deltaTime * this._timeScale * this._direction;
    this._time += scaledDelta;
    const duration = this.clip.duration;
    if (duration > 0) {
      switch (this._loop) {
        case "once":
          if (this._time >= duration) {
            this._time = this._clampWhenFinished ? duration : 0;
            this._enabled = this._clampWhenFinished;
            finished = true;
          } else if (this._time < 0) {
            this._time = 0;
            finished = true;
          }
          break;
        case "repeat":
          while (this._time >= duration) {
            this._time -= duration;
            this._currentRepetition++;
            if (this._currentRepetition >= this._repetitions) {
              this._time = this._clampWhenFinished ? duration : 0;
              this._enabled = this._clampWhenFinished;
              finished = true;
              break;
            }
          }
          while (this._time < 0) {
            this._time += duration;
          }
          break;
        case "pingpong":
          while (this._time >= duration || this._time < 0) {
            if (this._time >= duration) {
              this._time = 2 * duration - this._time;
              this._direction = -1;
              this._currentRepetition++;
            } else if (this._time < 0) {
              this._time = -this._time;
              this._direction = 1;
              this._currentRepetition++;
            }
            if (this._currentRepetition >= this._repetitions * 2) {
              this._time = this._clampWhenFinished ? this._direction > 0 ? 0 : duration : 0;
              this._enabled = this._clampWhenFinished;
              finished = true;
              break;
            }
          }
          break;
      }
    }
    return finished;
  }
  _apply() {
    if (!this._enabled || this._effectiveWeight <= 0) {
      return;
    }
    this.clip.apply(this.mixer.skeleton, this._time, this._effectiveWeight);
  }
  toString() {
    return `AnimationAction("${this.clip.name}", time=${this._time.toFixed(2)}, ` + `weight=${this._effectiveWeight.toFixed(2)}, enabled=${this._enabled})`;
  }
}
// ../../src/core/animation/AnimationMixer.ts
class AnimationMixer {
  skeleton;
  _actions = [];
  _actionsByClip = new Map;
  _time = 0;
  _listeners = new Map;
  _device = null;
  constructor(skeleton) {
    this.skeleton = skeleton;
  }
  setDevice(device) {
    this._device = device;
    this.skeleton.initGPU(device);
  }
  clipAction(clip) {
    let action = this._actionsByClip.get(clip);
    if (!action) {
      action = new AnimationAction(this, clip);
      this._actionsByClip.set(clip, action);
    }
    return action;
  }
  existingAction(clip) {
    return this._actionsByClip.get(clip) ?? null;
  }
  get actions() {
    return this._actions.slice();
  }
  get time() {
    return this._time;
  }
  update(deltaTime) {
    this._time += deltaTime;
    this.skeleton.copyBindPose();
    let totalWeight = 0;
    for (const action of this._actions) {
      if (action.enabled && action.effectiveWeight > 0) {
        totalWeight += action.effectiveWeight;
      }
    }
    const finishedActions = [];
    for (const action of this._actions) {
      if (!action.enabled)
        continue;
      const finished = action._update(deltaTime, this._time);
      if (action.effectiveWeight > 0) {
        const normalizedWeight = totalWeight > 1 ? action.effectiveWeight / totalWeight : action.effectiveWeight;
        const originalWeight = action.effectiveWeight;
        action._effectiveWeight = normalizedWeight;
        action._apply();
        action._effectiveWeight = originalWeight;
      }
      if (finished) {
        finishedActions.push(action);
      }
    }
    this.skeleton.update();
    if (this._device) {
      this.skeleton.uploadToGPU(this._device);
    }
    for (const action of finishedActions) {
      this._dispatchEvent({
        type: "finished",
        action,
        direction: 1
      });
    }
  }
  stopAllAction() {
    for (const action of this._actions) {
      action.stop();
    }
    this._actions.length = 0;
  }
  setTimeScaleForAll(scale) {
    for (const action of this._actions) {
      action.timeScale = scale;
    }
  }
  getActionByName(name) {
    for (const [clip, action] of this._actionsByClip) {
      if (clip.name === name) {
        return action;
      }
    }
    return null;
  }
  addEventListener(type, callback) {
    let listeners = this._listeners.get(type);
    if (!listeners) {
      listeners = [];
      this._listeners.set(type, listeners);
    }
    listeners.push(callback);
  }
  removeEventListener(type, callback) {
    const listeners = this._listeners.get(type);
    if (listeners) {
      const index = listeners.indexOf(callback);
      if (index !== -1) {
        listeners.splice(index, 1);
      }
    }
  }
  isPlaying() {
    return this._actions.some((action) => action.isRunning());
  }
  get activeActionCount() {
    return this._actions.filter((action) => action.isRunning()).length;
  }
  _addAction(action) {
    if (!this._actions.includes(action)) {
      this._actions.push(action);
    }
  }
  _removeAction(action) {
    const index = this._actions.indexOf(action);
    if (index !== -1) {
      this._actions.splice(index, 1);
    }
  }
  _dispatchEvent(event) {
    const listeners = this._listeners.get(event.type);
    if (listeners) {
      for (const callback of listeners) {
        callback(event);
      }
    }
  }
  dispose() {
    this.stopAllAction();
    this._actionsByClip.clear();
    this._listeners.clear();
    this._device = null;
  }
  toString() {
    return `AnimationMixer(skeleton=${this.skeleton.boneCount} bones, ` + `actions=${this._actions.length}, active=${this.activeActionCount})`;
  }
}
// ../../src/core/animation/SkinnedMesh.ts
class SkinnedMesh extends Mesh {
  skeleton = null;
  bindMatrix = new Matrix4;
  bindMatrixInverse = new Matrix4;
  isSkinned = true;
  jointsBuffer = null;
  weightsBuffer = null;
  constructor(geometry, material, skeleton) {
    super(geometry, material);
    this.name = "SkinnedMesh";
    if (skeleton) {
      this.bind(skeleton);
    }
  }
  bind(skeleton, bindMatrix) {
    this.skeleton = skeleton;
    if (bindMatrix) {
      this.bindMatrix.copy(bindMatrix);
    } else {
      this.bindMatrix.identity();
    }
    this.bindMatrixInverse.copy(this.bindMatrix).inverse();
  }
  initSkinningBuffers(device) {
    const jointsData = this.geometry.attributes["joints"];
    if (jointsData && !this.jointsBuffer) {
      const jointsUint = new Uint32Array(jointsData.length);
      for (let i = 0;i < jointsData.length; i++) {
        jointsUint[i] = Math.floor(jointsData[i]);
      }
      this.jointsBuffer = device.createBuffer({
        label: "SkinnedMesh Joints Buffer",
        size: jointsUint.byteLength,
        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
        mappedAtCreation: true
      });
      new Uint32Array(this.jointsBuffer.getMappedRange()).set(jointsUint);
      this.jointsBuffer.unmap();
    }
    const weightsData = this.geometry.attributes["weights"];
    if (weightsData && !this.weightsBuffer) {
      this.weightsBuffer = device.createBuffer({
        label: "SkinnedMesh Weights Buffer",
        size: weightsData.byteLength,
        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
        mappedAtCreation: true
      });
      new Float32Array(this.weightsBuffer.getMappedRange()).set(weightsData);
      this.weightsBuffer.unmap();
    }
    if (this.skeleton) {
      this.skeleton.initGPU(device);
    }
  }
  hasSkinningData() {
    return !!(this.geometry.attributes["joints"] && this.geometry.attributes["weights"] && this.skeleton);
  }
  get skinnedVertexCount() {
    const joints = this.geometry.attributes["joints"];
    return joints ? joints.length / 4 : 0;
  }
  prepareSkinning(device) {
    if (!this.skeleton)
      return;
    if (!this.jointsBuffer || !this.weightsBuffer) {
      this.initSkinningBuffers(device);
    }
    this.skeleton.uploadToGPU(device);
  }
  normalizeWeights() {
    const weights = this.geometry.attributes["weights"];
    if (!weights)
      return;
    const vertexCount = weights.length / 4;
    for (let i = 0;i < vertexCount; i++) {
      const offset = i * 4;
      const w0 = weights[offset];
      const w1 = weights[offset + 1];
      const w2 = weights[offset + 2];
      const w3 = weights[offset + 3];
      const sum = w0 + w1 + w2 + w3;
      if (sum > 0 && Math.abs(sum - 1) > 0.001) {
        const invSum = 1 / sum;
        weights[offset] = w0 * invSum;
        weights[offset + 1] = w1 * invSum;
        weights[offset + 2] = w2 * invSum;
        weights[offset + 3] = w3 * invSum;
      }
    }
    this.geometry.markBuffersDirty();
    if (this.weightsBuffer) {
      this.weightsBuffer.destroy();
      this.weightsBuffer = null;
    }
  }
  clone() {
    const cloned = new SkinnedMesh(this.geometry, this.material, this.skeleton?.clone());
    cloned.transform.position.copy(this.transform.position);
    cloned.transform.rotation.copy(this.transform.rotation);
    cloned.transform.scale.copy(this.transform.scale);
    cloned.bindMatrix.copy(this.bindMatrix);
    cloned.bindMatrixInverse.copy(this.bindMatrixInverse);
    return cloned;
  }
  destroy() {
    this.jointsBuffer?.destroy();
    this.weightsBuffer?.destroy();
    this.jointsBuffer = null;
    this.weightsBuffer = null;
  }
  toString() {
    return `SkinnedMesh("${this.name}", vertices=${this.geometry.vertexCount}, ` + `skeleton=${this.skeleton?.boneCount ?? 0} bones)`;
  }
}
// ../../src/core/animation/skinning/SkinningShader.ts
var SKINNING_UNIFORMS = `
// Bone matrices storage buffer (bind group 2)
@group(2) @binding(0) var<storage, read> boneMatrices: array<mat4x4<f32>, ${MAX_BONES}>;
`;
var SKINNING_RESULT = `
struct SkinningResult {
  position: vec3<f32>,
  normal: vec3<f32>,
}
`;
var APPLY_SKINNING_FUNCTION = `
fn applySkinning(
  position: vec3<f32>,
  normal: vec3<f32>,
  joints: vec4<u32>,
  weights: vec4<f32>
) -> SkinningResult {
  var skinnedPosition = vec3<f32>(0.0);
  var skinnedNormal = vec3<f32>(0.0);

  // Apply up to 4 bone influences
  // Unrolled for performance
  let bone0 = boneMatrices[joints.x];
  let bone1 = boneMatrices[joints.y];
  let bone2 = boneMatrices[joints.z];
  let bone3 = boneMatrices[joints.w];

  let w0 = weights.x;
  let w1 = weights.y;
  let w2 = weights.z;
  let w3 = weights.w;

  // Position skinning
  skinnedPosition += w0 * (bone0 * vec4<f32>(position, 1.0)).xyz;
  skinnedPosition += w1 * (bone1 * vec4<f32>(position, 1.0)).xyz;
  skinnedPosition += w2 * (bone2 * vec4<f32>(position, 1.0)).xyz;
  skinnedPosition += w3 * (bone3 * vec4<f32>(position, 1.0)).xyz;

  // Normal skinning (using 3x3 rotation part of matrix)
  // For uniform scale, this is correct. For non-uniform scale, we'd need inverse transpose.
  skinnedNormal += w0 * (bone0 * vec4<f32>(normal, 0.0)).xyz;
  skinnedNormal += w1 * (bone1 * vec4<f32>(normal, 0.0)).xyz;
  skinnedNormal += w2 * (bone2 * vec4<f32>(normal, 0.0)).xyz;
  skinnedNormal += w3 * (bone3 * vec4<f32>(normal, 0.0)).xyz;

  return SkinningResult(skinnedPosition, normalize(skinnedNormal));
}
`;
function getSkinningShaderHeader() {
  return `
${SKINNING_UNIFORMS}
${SKINNING_RESULT}
${APPLY_SKINNING_FUNCTION}
`;
}
function createSkinnedVertexShader(standardVertexShader) {
  let modifiedShader = standardVertexShader;
  const skinningHeader = getSkinningShaderHeader();
  const vertexInputRegex = /struct VertexInput \{[^}]+\}/;
  const skinnedVertexInput = `struct VertexInput {
  @location(0) position: vec3<f32>,
  @location(1) normal: vec3<f32>,
  @location(2) uv: vec2<f32>,
  @location(3) joints: vec4<u32>,
  @location(4) weights: vec4<f32>,
}`;
  const vertexInputMatch = modifiedShader.match(vertexInputRegex);
  console.log("SkinningShader: VertexInput match:", vertexInputMatch ? "found" : "NOT FOUND");
  modifiedShader = modifiedShader.replace(vertexInputRegex, skinnedVertexInput);
  const vsMainIndex = modifiedShader.indexOf("@vertex");
  console.log("SkinningShader: @vertex found at index:", vsMainIndex);
  if (vsMainIndex > -1) {
    modifiedShader = modifiedShader.slice(0, vsMainIndex) + skinningHeader + `
` + modifiedShader.slice(vsMainIndex);
  }
  const worldPosPattern = /let worldPos = modelMatrix \* vec4<f32>\(input\.position, 1\.0\);/g;
  const worldPosMatch = modifiedShader.match(worldPosPattern);
  console.log("SkinningShader: worldPos (input.position) pattern match:", worldPosMatch ? "found" : "NOT FOUND");
  let skinnedDefined = false;
  if (worldPosMatch) {
    modifiedShader = modifiedShader.replace(worldPosPattern, `let skinned = applySkinning(input.position, input.normal, input.joints, input.weights);
        let worldPos = modelMatrix * vec4<f32>(skinned.position, 1.0);`);
    skinnedDefined = true;
  }
  const localPosPattern = /let worldPos = modelMatrix \* vec4<f32>\(localPos, 1\.0\);/g;
  const localPosMatch = modifiedShader.match(localPosPattern);
  console.log("SkinningShader: worldPos (localPos) pattern match:", localPosMatch ? "found" : "NOT FOUND");
  if (localPosMatch) {
    modifiedShader = modifiedShader.replace(/var localPos = input\.position;/g, `let skinned = applySkinning(input.position, input.normal, input.joints, input.weights);
        var localPos = skinned.position;`);
    skinnedDefined = true;
  }
  const normalPattern = /output\.worldNormal = \(normalMatrix \* vec4<f32>\(input\.normal, 0\.0\)\)\.xyz;/g;
  const normalMatch = modifiedShader.match(normalPattern);
  console.log("SkinningShader: normal pattern match:", normalMatch ? "found" : "NOT FOUND");
  if (skinnedDefined) {
    modifiedShader = modifiedShader.replace(normalPattern, "output.worldNormal = (normalMatrix * vec4<f32>(skinned.normal, 0.0)).xyz;");
  }
  if (skinnedDefined) {
    const prevWorldPosPattern = /let prevWorldPos = prevModelMatrix \* vec4<f32>\(input\.position, 1\.0\);/g;
    modifiedShader = modifiedShader.replace(prevWorldPosPattern, "let prevWorldPos = prevModelMatrix * vec4<f32>(skinned.position, 1.0);");
  }
  return modifiedShader;
}
// ../../src/core/animation/MorphTarget.ts
var MAX_MORPH_TARGETS = 8;
class MorphTargets {
  targets = [];
  weights;
  vertexCount;
  deltasBuffer = null;
  weightsBuffer = null;
  bindGroup = null;
  weightsDirty = true;
  constructor(vertexCount) {
    this.vertexCount = vertexCount;
    this.weights = new Float32Array(MAX_MORPH_TARGETS);
  }
  addTarget(target) {
    if (this.targets.length >= MAX_MORPH_TARGETS) {
      console.warn(`MorphTargets: Maximum of ${MAX_MORPH_TARGETS} morph targets exceeded. Ignoring target "${target.name}".`);
      return;
    }
    const targetVertexCount = target.positionDeltas.length / 3;
    if (targetVertexCount !== this.vertexCount) {
      console.warn(`MorphTargets: Target "${target.name}" has ${targetVertexCount} vertices, expected ${this.vertexCount}`);
    }
    target.index = this.targets.length;
    this.targets.push(target);
  }
  getTarget(name) {
    return this.targets.find((t) => t.name === name) ?? null;
  }
  getTargetByIndex(index) {
    return this.targets[index] ?? null;
  }
  setWeight(name, weight) {
    const target = this.getTarget(name);
    if (target) {
      this.setWeightByIndex(target.index, weight);
    }
  }
  setWeightByIndex(index, weight) {
    if (index >= 0 && index < MAX_MORPH_TARGETS) {
      const clampedWeight = Math.max(0, Math.min(1, weight));
      if (this.weights[index] !== clampedWeight) {
        this.weights[index] = clampedWeight;
        this.weightsDirty = true;
      }
    }
  }
  setWeights(weights) {
    for (let i = 0;i < Math.min(weights.length, MAX_MORPH_TARGETS); i++) {
      this.weights[i] = Math.max(0, Math.min(1, weights[i]));
    }
    this.weightsDirty = true;
  }
  getWeight(index) {
    return this.weights[index] ?? 0;
  }
  resetWeights() {
    this.weights.fill(0);
    this.weightsDirty = true;
  }
  get targetCount() {
    return this.targets.length;
  }
  get isActive() {
    for (let i = 0;i < this.targets.length; i++) {
      if (this.weights[i] > 0.001) {
        return true;
      }
    }
    return false;
  }
  initGPU(device) {
    if (this.targets.length === 0)
      return;
    const deltasPerTarget = this.vertexCount * 6;
    const totalFloats = MAX_MORPH_TARGETS * deltasPerTarget;
    const deltasData = new Float32Array(totalFloats);
    for (let t = 0;t < this.targets.length; t++) {
      const target = this.targets[t];
      const targetOffset = t * deltasPerTarget;
      for (let v = 0;v < this.vertexCount; v++) {
        const srcPosOffset = v * 3;
        const dstOffset = targetOffset + v * 6;
        deltasData[dstOffset + 0] = target.positionDeltas[srcPosOffset + 0];
        deltasData[dstOffset + 1] = target.positionDeltas[srcPosOffset + 1];
        deltasData[dstOffset + 2] = target.positionDeltas[srcPosOffset + 2];
        if (target.normalDeltas) {
          deltasData[dstOffset + 3] = target.normalDeltas[srcPosOffset + 0];
          deltasData[dstOffset + 4] = target.normalDeltas[srcPosOffset + 1];
          deltasData[dstOffset + 5] = target.normalDeltas[srcPosOffset + 2];
        }
      }
    }
    this.deltasBuffer = device.createBuffer({
      label: "MorphTarget Deltas Buffer",
      size: deltasData.byteLength,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
      mappedAtCreation: true
    });
    new Float32Array(this.deltasBuffer.getMappedRange()).set(deltasData);
    this.deltasBuffer.unmap();
    const weightsBufferSize = Math.ceil(MAX_MORPH_TARGETS / 4) * 16;
    this.weightsBuffer = device.createBuffer({
      label: "MorphTarget Weights Buffer",
      size: weightsBufferSize,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.uploadWeights(device);
  }
  uploadWeights(device) {
    if (!this.weightsBuffer || !this.weightsDirty)
      return;
    const paddedWeights = new Float32Array(Math.ceil(MAX_MORPH_TARGETS / 4) * 4);
    paddedWeights.set(this.weights);
    device.queue.writeBuffer(this.weightsBuffer, 0, paddedWeights);
    this.weightsDirty = false;
  }
  static createBindGroupLayout(device) {
    return device.createBindGroupLayout({
      label: "MorphTarget BindGroup Layout",
      entries: [
        {
          binding: 0,
          visibility: GPUShaderStage.VERTEX,
          buffer: { type: "read-only-storage" }
        },
        {
          binding: 1,
          visibility: GPUShaderStage.VERTEX,
          buffer: { type: "uniform" }
        }
      ]
    });
  }
  createBindGroup(device, layout) {
    if (!this.deltasBuffer || !this.weightsBuffer) {
      console.warn("MorphTargets: Cannot create bind group - buffers not initialized");
      return;
    }
    this.bindGroup = device.createBindGroup({
      label: "MorphTarget BindGroup",
      layout,
      entries: [
        { binding: 0, resource: { buffer: this.deltasBuffer } },
        { binding: 1, resource: { buffer: this.weightsBuffer } }
      ]
    });
  }
  prepare(device) {
    if (this.weightsDirty && this.weightsBuffer) {
      this.uploadWeights(device);
    }
  }
  destroy() {
    this.deltasBuffer?.destroy();
    this.weightsBuffer?.destroy();
    this.deltasBuffer = null;
    this.weightsBuffer = null;
    this.bindGroup = null;
  }
  clone() {
    const cloned = new MorphTargets(this.vertexCount);
    for (const target of this.targets) {
      cloned.targets.push(target);
    }
    cloned.weights.set(this.weights);
    cloned.weightsDirty = true;
    return cloned;
  }
  toString() {
    const activeTargets = this.targets.filter((_, i) => this.weights[i] > 0.001);
    return `MorphTargets(${this.targets.length} targets, ${activeTargets.length} active)`;
  }
}
// ../../src/core/animation/MorphTargetMesh.ts
class MorphTargetMesh extends Mesh {
  morphTargets;
  hasMorphTargets = true;
  morphGPUInitialized = false;
  constructor(geometry, material, morphTargets) {
    super(geometry, material);
    this.name = "MorphTargetMesh";
    if (morphTargets) {
      this.morphTargets = morphTargets;
    } else {
      this.morphTargets = new MorphTargets(geometry.vertexCount);
    }
  }
  addMorphTarget(target) {
    this.morphTargets.addTarget(target);
    this.morphGPUInitialized = false;
  }
  setMorphWeight(name, weight) {
    this.morphTargets.setWeight(name, weight);
  }
  setMorphWeightByIndex(index, weight) {
    this.morphTargets.setWeightByIndex(index, weight);
  }
  setMorphWeights(weights) {
    this.morphTargets.setWeights(weights);
  }
  getMorphWeight(index) {
    return this.morphTargets.getWeight(index);
  }
  resetMorphWeights() {
    this.morphTargets.resetWeights();
  }
  get morphTargetCount() {
    return this.morphTargets.targetCount;
  }
  get morphTargetNames() {
    return this.morphTargets.targets.map((t) => t.name);
  }
  get isMorphActive() {
    return this.morphTargets.isActive;
  }
  initMorphGPU(device) {
    if (this.morphGPUInitialized)
      return;
    this.morphTargets.initGPU(device);
    this.morphGPUInitialized = true;
    console.log(`MorphTargetMesh: Initialized GPU for "${this.name}" with ${this.morphTargets.targetCount} targets`);
  }
  createMorphBindGroup(device, layout) {
    if (!this.morphGPUInitialized) {
      this.initMorphGPU(device);
    }
    this.morphTargets.createBindGroup(device, layout);
  }
  prepareMorph(device) {
    if (!this.morphGPUInitialized) {
      this.initMorphGPU(device);
    }
    this.morphTargets.prepare(device);
  }
  clone() {
    const cloned = new MorphTargetMesh(this.geometry, this.material, this.morphTargets.clone());
    cloned.transform.position.copy(this.transform.position);
    cloned.transform.rotation.copy(this.transform.rotation);
    cloned.transform.scale.copy(this.transform.scale);
    return cloned;
  }
  destroy() {
    this.morphTargets.destroy();
  }
  toString() {
    return `MorphTargetMesh("${this.name}", vertices=${this.geometry.vertexCount}, ` + `morphTargets=${this.morphTargets.targetCount})`;
  }
}
// ../../src/core/animation/morphing/MorphTargetShader.ts
var MORPH_TARGET_UNIFORMS = `
// Morph target deltas storage buffer (bind group 2 or 3 depending on skinning)
// Layout: For each target, vertexCount * (3 floats position + 3 floats normal)
@group(2) @binding(0) var<storage, read> morphDeltas: array<f32>;

// Morph weights uniform buffer
// Layout: vec4 * ceil(MAX_MORPH_TARGETS / 4)
@group(2) @binding(1) var<uniform> morphWeights: array<vec4<f32>, ${Math.ceil(MAX_MORPH_TARGETS / 4)}>;

// Constants
const MAX_MORPH_TARGETS: u32 = ${MAX_MORPH_TARGETS}u;
`;
var MORPH_RESULT = `
struct MorphResult {
  position: vec3<f32>,
  normal: vec3<f32>,
}
`;
var APPLY_MORPH_FUNCTION = `
fn applyMorphTargets(
  vertexIndex: u32,
  basePosition: vec3<f32>,
  baseNormal: vec3<f32>,
  vertexCount: u32,
  targetCount: u32
) -> MorphResult {
  var morphedPosition = basePosition;
  var morphedNormal = baseNormal;

  // Each target stores vertexCount * 6 floats (pos.xyz + normal.xyz per vertex)
  let deltasPerTarget = vertexCount * 6u;

  // Apply each morph target
  for (var t = 0u; t < targetCount && t < MAX_MORPH_TARGETS; t++) {
    // Get weight for this target
    let weightIndex = t / 4u;
    let weightComponent = t % 4u;
    var weight: f32;
    switch (weightComponent) {
      case 0u: { weight = morphWeights[weightIndex].x; }
      case 1u: { weight = morphWeights[weightIndex].y; }
      case 2u: { weight = morphWeights[weightIndex].z; }
      default: { weight = morphWeights[weightIndex].w; }
    }

    // Skip if weight is negligible
    if (weight < 0.001) {
      continue;
    }

    // Calculate offset into deltas buffer for this target and vertex
    let targetOffset = t * deltasPerTarget;
    let vertexOffset = targetOffset + vertexIndex * 6u;

    // Read position delta
    let positionDelta = vec3<f32>(
      morphDeltas[vertexOffset + 0u],
      morphDeltas[vertexOffset + 1u],
      morphDeltas[vertexOffset + 2u]
    );

    // Read normal delta
    let normalDelta = vec3<f32>(
      morphDeltas[vertexOffset + 3u],
      morphDeltas[vertexOffset + 4u],
      morphDeltas[vertexOffset + 5u]
    );

    // Apply weighted deltas
    morphedPosition += weight * positionDelta;
    morphedNormal += weight * normalDelta;
  }

  // Normalize the final normal
  return MorphResult(morphedPosition, normalize(morphedNormal));
}
`;
function getOptimizedMorphFunction(targetCount) {
  if (targetCount <= 0)
    return "";
  let code = `
fn applyMorphTargetsOptimized(
  vertexIndex: u32,
  basePosition: vec3<f32>,
  baseNormal: vec3<f32>,
  vertexCount: u32
) -> MorphResult {
  var morphedPosition = basePosition;
  var morphedNormal = baseNormal;
  let deltasPerTarget = vertexCount * 6u;
`;
  for (let t = 0;t < Math.min(targetCount, MAX_MORPH_TARGETS); t++) {
    const weightIndex = Math.floor(t / 4);
    const component = ["x", "y", "z", "w"][t % 4];
    code += `
  // Target ${t}
  {
    let weight = morphWeights[${weightIndex}].${component};
    if (weight > 0.001) {
      let vertexOffset = ${t}u * deltasPerTarget + vertexIndex * 6u;
      morphedPosition += weight * vec3<f32>(
        morphDeltas[vertexOffset],
        morphDeltas[vertexOffset + 1u],
        morphDeltas[vertexOffset + 2u]
      );
      morphedNormal += weight * vec3<f32>(
        morphDeltas[vertexOffset + 3u],
        morphDeltas[vertexOffset + 4u],
        morphDeltas[vertexOffset + 5u]
      );
    }
  }`;
  }
  code += `
  return MorphResult(morphedPosition, normalize(morphedNormal));
}
`;
  return code;
}
function getMorphTargetShaderHeader() {
  return `
${MORPH_TARGET_UNIFORMS}
${MORPH_RESULT}
${APPLY_MORPH_FUNCTION}
`;
}
function createMorphedVertexShader(standardVertexShader, targetCount = MAX_MORPH_TARGETS) {
  let modifiedShader = standardVertexShader;
  const morphHeader = getMorphTargetShaderHeader();
  const optimizedMorphFn = targetCount > 0 && targetCount <= 8 ? getOptimizedMorphFunction(targetCount) : "";
  const vsMainIndex = modifiedShader.indexOf("@vertex");
  if (vsMainIndex > -1) {
    modifiedShader = modifiedShader.slice(0, vsMainIndex) + morphHeader + `
` + optimizedMorphFn + `
` + modifiedShader.slice(vsMainIndex);
  }
  const vsMainFnRegex = /fn vs_main\(input\s*:\s*VertexInput,\s*@builtin\(instance_index\)\s*instanceIndex\s*:\s*u32\)/;
  modifiedShader = modifiedShader.replace(vsMainFnRegex, "fn vs_main(input: VertexInput, @builtin(instance_index) instanceIndex: u32, @builtin(vertex_index) vertexIndex: u32)");
  const morphConfigUniform = `
// Morph configuration: x = vertexCount, y = targetCount
var<private> morphConfig: vec2<u32>;
`;
  const morphHeaderEndIndex = modifiedShader.indexOf(APPLY_MORPH_FUNCTION) + APPLY_MORPH_FUNCTION.length;
  if (morphHeaderEndIndex > APPLY_MORPH_FUNCTION.length) {
    modifiedShader = modifiedShader.slice(0, morphHeaderEndIndex) + morphConfigUniform + modifiedShader.slice(morphHeaderEndIndex);
  }
  const worldPosPattern = /let worldPos = modelMatrix \* vec4<f32>\(input\.position, 1\.0\);/g;
  const worldPosMatch = modifiedShader.match(worldPosPattern);
  let morphedDefined = false;
  if (worldPosMatch) {
    modifiedShader = modifiedShader.replace(worldPosPattern, `// Apply morph targets
        let morphed = applyMorphTargets(vertexIndex, input.position, input.normal, ${targetCount}u, ${targetCount}u);
        let worldPos = modelMatrix * vec4<f32>(morphed.position, 1.0);`);
    morphedDefined = true;
  }
  const localPosPattern = /let worldPos = modelMatrix \* vec4<f32>\(localPos, 1\.0\);/g;
  const localPosMatch = modifiedShader.match(localPosPattern);
  if (localPosMatch) {
    modifiedShader = modifiedShader.replace(/var localPos = input\.position;/g, `let morphed = applyMorphTargets(vertexIndex, input.position, input.normal, ${targetCount}u, ${targetCount}u);
        var localPos = morphed.position;`);
    morphedDefined = true;
  }
  if (morphedDefined) {
    const normalPattern = /output\.worldNormal = \(normalMatrix \* vec4<f32>\(input\.normal, 0\.0\)\)\.xyz;/g;
    modifiedShader = modifiedShader.replace(normalPattern, "output.worldNormal = (normalMatrix * vec4<f32>(morphed.normal, 0.0)).xyz;");
    const prevWorldPosPattern = /let prevWorldPos = prevModelMatrix \* vec4<f32>\(input\.position, 1\.0\);/g;
    modifiedShader = modifiedShader.replace(prevWorldPosPattern, "let prevWorldPos = prevModelMatrix * vec4<f32>(morphed.position, 1.0);");
  }
  return modifiedShader;
}
// ../../src/core/animation/Easing.ts
var linear2 = (t) => t;
var easeInQuad = (t) => t * t;
var easeOutQuad = (t) => 1 - (1 - t) * (1 - t);
var easeInOutQuad = (t) => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
var easeInCubic = (t) => t * t * t;
var easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);
var easeInOutCubic = (t) => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
var easeInQuart = (t) => t * t * t * t;
var easeOutQuart = (t) => 1 - Math.pow(1 - t, 4);
var easeInOutQuart = (t) => t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2;
var easeInQuint = (t) => t * t * t * t * t;
var easeOutQuint = (t) => 1 - Math.pow(1 - t, 5);
var easeInOutQuint = (t) => t < 0.5 ? 16 * t * t * t * t * t : 1 - Math.pow(-2 * t + 2, 5) / 2;
var easeInSine = (t) => 1 - Math.cos(t * Math.PI / 2);
var easeOutSine = (t) => Math.sin(t * Math.PI / 2);
var easeInOutSine = (t) => -(Math.cos(Math.PI * t) - 1) / 2;
var easeInExpo = (t) => t === 0 ? 0 : Math.pow(2, 10 * t - 10);
var easeOutExpo = (t) => t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
var easeInOutExpo = (t) => t === 0 ? 0 : t === 1 ? 1 : t < 0.5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2;
var easeInCirc = (t) => 1 - Math.sqrt(1 - Math.pow(t, 2));
var easeOutCirc = (t) => Math.sqrt(1 - Math.pow(t - 1, 2));
var easeInOutCirc = (t) => t < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * t, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * t + 2, 2)) + 1) / 2;
var c4 = 2 * Math.PI / 3;
var c5 = 2 * Math.PI / 4.5;
var easeInElastic = (t) => t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * c4);
var easeOutElastic = (t) => t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
var easeInOutElastic = (t) => t === 0 ? 0 : t === 1 ? 1 : t < 0.5 ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * c5)) / 2 : Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * c5) / 2 + 1;
var c1 = 1.70158;
var c2 = c1 * 1.525;
var c3 = c1 + 1;
var easeInBack = (t) => c3 * t * t * t - c1 * t * t;
var easeOutBack = (t) => 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
var easeInOutBack = (t) => t < 0.5 ? Math.pow(2 * t, 2) * ((c2 + 1) * 2 * t - c2) / 2 : (Math.pow(2 * t - 2, 2) * ((c2 + 1) * (t * 2 - 2) + c2) + 2) / 2;
var n1 = 7.5625;
var d1 = 2.75;
var easeOutBounce = (t) => {
  if (t < 1 / d1) {
    return n1 * t * t;
  } else if (t < 2 / d1) {
    return n1 * (t -= 1.5 / d1) * t + 0.75;
  } else if (t < 2.5 / d1) {
    return n1 * (t -= 2.25 / d1) * t + 0.9375;
  } else {
    return n1 * (t -= 2.625 / d1) * t + 0.984375;
  }
};
var easeInBounce = (t) => 1 - easeOutBounce(1 - t);
var easeInOutBounce = (t) => t < 0.5 ? (1 - easeOutBounce(1 - 2 * t)) / 2 : (1 + easeOutBounce(2 * t - 1)) / 2;
var Easing = {
  linear: linear2,
  easeInQuad,
  easeOutQuad,
  easeInOutQuad,
  easeInCubic,
  easeOutCubic,
  easeInOutCubic,
  easeInQuart,
  easeOutQuart,
  easeInOutQuart,
  easeInQuint,
  easeOutQuint,
  easeInOutQuint,
  easeInSine,
  easeOutSine,
  easeInOutSine,
  easeInExpo,
  easeOutExpo,
  easeInOutExpo,
  easeInCirc,
  easeOutCirc,
  easeInOutCirc,
  easeInElastic,
  easeOutElastic,
  easeInOutElastic,
  easeInBack,
  easeOutBack,
  easeInOutBack,
  easeInBounce,
  easeOutBounce,
  easeInOutBounce
};
function getEasing(name) {
  if (typeof name === "function") {
    return name;
  }
  return Easing[name] ?? linear2;
}
// ../../src/core/animation/Tween.ts
function isVector2(value) {
  return value instanceof Vector2 || typeof value === "object" && value !== null && "x" in value && "y" in value && !("z" in value);
}
function isVector3(value) {
  return value instanceof Vector3 || typeof value === "object" && value !== null && "x" in value && "y" in value && "z" in value;
}
function isColor(value) {
  return typeof value === "object" && value !== null && "r" in value && "g" in value && "b" in value;
}
function interpolate(start, end, t) {
  if (typeof start === "number" && typeof end === "number") {
    return start + (end - start) * t;
  }
  if (isVector3(start) && isVector3(end)) {
    return new Vector3(start.x + (end.x - start.x) * t, start.y + (end.y - start.y) * t, start.z + (end.z - start.z) * t);
  }
  if (isVector2(start) && isVector2(end)) {
    return new Vector2(start.x + (end.x - start.x) * t, start.y + (end.y - start.y) * t);
  }
  if (isColor(start) && isColor(end)) {
    return {
      r: start.r + (end.r - start.r) * t,
      g: start.g + (end.g - start.g) * t,
      b: start.b + (end.b - start.b) * t,
      a: (start.a ?? 1) + ((end.a ?? 1) - (start.a ?? 1)) * t
    };
  }
  return start;
}
function cloneValue(value) {
  if (typeof value === "number") {
    return value;
  }
  if (isVector3(value)) {
    return new Vector3(value.x, value.y, value.z);
  }
  if (isVector2(value)) {
    return new Vector2(value.x, value.y);
  }
  if (isColor(value)) {
    return { r: value.r, g: value.g, b: value.b, a: value.a };
  }
  return value;
}
function applyValue(target, key, value) {
  const obj = target;
  const existing = obj[key];
  if (typeof value === "number") {
    obj[key] = value;
  } else if (isVector3(value) && isVector3(existing)) {
    existing.x = value.x;
    existing.y = value.y;
    existing.z = value.z;
  } else if (isVector2(value) && isVector2(existing)) {
    existing.x = value.x;
    existing.y = value.y;
  } else if (isColor(value) && isColor(existing)) {
    existing.r = value.r;
    existing.g = value.g;
    existing.b = value.b;
    if (value.a !== undefined) {
      existing.a = value.a;
    }
  } else {
    obj[key] = value;
  }
}

class Tween {
  target;
  startValues = new Map;
  endValues = new Map;
  _state = "idle";
  _elapsed = 0;
  _delayElapsed = 0;
  _repeatCount = 0;
  _reversed = false;
  _started = false;
  duration = 1;
  delay = 0;
  easing = linear2;
  repeat = 0;
  repeatDelay = 0;
  yoyo = false;
  onStartCallback;
  onUpdateCallback;
  onCompleteCallback;
  onRepeatCallback;
  onStopCallback;
  chainedTween;
  _manager;
  constructor(target, options) {
    this.target = target;
    if (options) {
      this.configure(options);
    }
  }
  configure(options) {
    if (options.duration !== undefined)
      this.duration = options.duration;
    if (options.delay !== undefined)
      this.delay = options.delay;
    if (options.easing !== undefined)
      this.easing = getEasing(options.easing);
    if (options.repeat !== undefined)
      this.repeat = options.repeat;
    if (options.repeatDelay !== undefined)
      this.repeatDelay = options.repeatDelay;
    if (options.yoyo !== undefined)
      this.yoyo = options.yoyo;
    if (options.onStart !== undefined)
      this.onStartCallback = options.onStart;
    if (options.onUpdate !== undefined)
      this.onUpdateCallback = options.onUpdate;
    if (options.onComplete !== undefined)
      this.onCompleteCallback = options.onComplete;
    if (options.onRepeat !== undefined)
      this.onRepeatCallback = options.onRepeat;
    if (options.onStop !== undefined)
      this.onStopCallback = options.onStop;
    return this;
  }
  to(values, duration) {
    if (duration !== undefined) {
      this.duration = duration;
    }
    for (const key of Object.keys(values)) {
      const targetValue = this.target[key];
      const endValue = values[key];
      if (targetValue !== undefined && endValue !== undefined) {
        this.startValues.set(key, cloneValue(targetValue));
        this.endValues.set(key, cloneValue(endValue));
      }
    }
    return this;
  }
  from(values) {
    for (const key of Object.keys(values)) {
      const value = values[key];
      if (value !== undefined) {
        this.startValues.set(key, cloneValue(value));
      }
    }
    return this;
  }
  setDuration(duration) {
    this.duration = duration;
    return this;
  }
  setDelay(delay) {
    this.delay = delay;
    return this;
  }
  setEasing(easing) {
    this.easing = getEasing(easing);
    return this;
  }
  setRepeat(count) {
    this.repeat = count;
    return this;
  }
  setRepeatDelay(delay) {
    this.repeatDelay = delay;
    return this;
  }
  setYoyo(enabled) {
    this.yoyo = enabled;
    return this;
  }
  onStart(callback) {
    this.onStartCallback = callback;
    return this;
  }
  onUpdate(callback) {
    this.onUpdateCallback = callback;
    return this;
  }
  onComplete(callback) {
    this.onCompleteCallback = callback;
    return this;
  }
  onRepeat(callback) {
    this.onRepeatCallback = callback;
    return this;
  }
  onStop(callback) {
    this.onStopCallback = callback;
    return this;
  }
  chain(tween) {
    this.chainedTween = tween;
    return tween;
  }
  start() {
    if (this._state === "running")
      return this;
    this._state = "running";
    this._elapsed = 0;
    this._delayElapsed = 0;
    this._repeatCount = 0;
    this._reversed = false;
    this._started = false;
    for (const key of this.endValues.keys()) {
      if (!this.startValues.has(key)) {
        const currentValue = this.target[key];
        if (currentValue !== undefined) {
          this.startValues.set(key, cloneValue(currentValue));
        }
      }
    }
    return this;
  }
  stop() {
    if (this._state !== "running" && this._state !== "paused")
      return this;
    this._state = "completed";
    this.onStopCallback?.();
    if (this._manager) {
      this._manager.remove(this);
    }
    return this;
  }
  pause() {
    if (this._state === "running") {
      this._state = "paused";
    }
    return this;
  }
  resume() {
    if (this._state === "paused") {
      this._state = "running";
    }
    return this;
  }
  reset() {
    this._state = "idle";
    this._elapsed = 0;
    this._delayElapsed = 0;
    this._repeatCount = 0;
    this._reversed = false;
    this._started = false;
    for (const [key, startValue] of this.startValues) {
      applyValue(this.target, key, startValue);
    }
    return this;
  }
  get state() {
    return this._state;
  }
  get progress() {
    if (this.duration === 0)
      return 1;
    return Math.min(this._elapsed / this.duration, 1);
  }
  get elapsed() {
    return this._elapsed;
  }
  get isRunning() {
    return this._state === "running";
  }
  get isComplete() {
    return this._state === "completed";
  }
  setManager(manager) {
    this._manager = manager;
  }
  getTarget() {
    return this.target;
  }
  update(dt) {
    if (this._state !== "running") {
      return this._state !== "completed";
    }
    if (this._delayElapsed < this.delay) {
      this._delayElapsed += dt;
      if (this._delayElapsed < this.delay) {
        return true;
      }
      dt = this._delayElapsed - this.delay;
    }
    if (!this._started) {
      this._started = true;
      this.onStartCallback?.();
    }
    this._elapsed += dt;
    let progress = this.duration > 0 ? Math.min(this._elapsed / this.duration, 1) : 1;
    if (this._reversed) {
      progress = 1 - progress;
    }
    const easedProgress = this.easing(progress);
    for (const [key, startValue] of this.startValues) {
      const endValue = this.endValues.get(key);
      if (endValue !== undefined) {
        const value = interpolate(startValue, endValue, easedProgress);
        applyValue(this.target, key, value);
      }
    }
    this.onUpdateCallback?.(this._reversed ? 1 - progress : progress);
    if (this._elapsed >= this.duration) {
      if (this.repeat === -1 || this._repeatCount < this.repeat) {
        this._repeatCount++;
        this._elapsed = 0;
        if (this.yoyo) {
          this._reversed = !this._reversed;
        }
        if (this.repeatDelay > 0) {
          this._delayElapsed = this.delay - this.repeatDelay;
        }
        this.onRepeatCallback?.(this._repeatCount);
        return true;
      }
      this._state = "completed";
      this.onCompleteCallback?.();
      if (this.chainedTween) {
        this.chainedTween.start();
      }
      return false;
    }
    return true;
  }
}
// ../../src/core/animation/TweenManager.ts
class TweenManager {
  tweens = new Set;
  static _instance = null;
  static get instance() {
    if (!TweenManager._instance) {
      TweenManager._instance = new TweenManager;
    }
    return TweenManager._instance;
  }
  create(target, options) {
    const tween = new Tween(target, options);
    tween.setManager(this);
    this.tweens.add(tween);
    return tween;
  }
  add(tween) {
    tween.setManager(this);
    this.tweens.add(tween);
    return this;
  }
  remove(tween) {
    this.tweens.delete(tween);
    return this;
  }
  update(dt) {
    for (const tween of this.tweens) {
      const shouldContinue = tween.update(dt);
      if (!shouldContinue) {
        this.tweens.delete(tween);
      }
    }
  }
  stopAll() {
    for (const tween of this.tweens) {
      tween.stop();
    }
    this.tweens.clear();
  }
  pauseAll() {
    for (const tween of this.tweens) {
      tween.pause();
    }
  }
  resumeAll() {
    for (const tween of this.tweens) {
      tween.resume();
    }
  }
  getTweensForTarget(target) {
    const result = [];
    for (const tween of this.tweens) {
      if (tween.getTarget() === target) {
        result.push(tween);
      }
    }
    return result;
  }
  stopTweensForTarget(target) {
    const tweens = this.getTweensForTarget(target);
    for (const tween of tweens) {
      tween.stop();
      this.tweens.delete(tween);
    }
  }
  get count() {
    return this.tweens.size;
  }
  get hasActiveTweens() {
    return this.tweens.size > 0;
  }
  clear() {
    this.tweens.clear();
  }
}
// ../../src/core/renderer/ForwardRenderPass.ts
function usesGlobalResources(material) {
  return typeof material.createBindGroupLayout === "function";
}

class ForwardRenderPass {
  device = null;
  context = null;
  presentationFormat = null;
  depthTexture = null;
  depthCopyTexture = null;
  sceneColorCopyTexture = null;
  gBuffer = null;
  width = 0;
  height = 0;
  ssrTexture = null;
  constructor(gBuffer = null) {
    this.gBuffer = gBuffer;
  }
  init(device, context, presentationFormat) {
    this.device = device;
    this.context = context;
    this.presentationFormat = presentationFormat;
    const canvas = context.canvas;
    this.width = canvas.width;
    this.height = canvas.height;
    this.createDepthTexture();
  }
  resize(width, height) {
    this.width = width;
    this.height = height;
    this.createDepthTexture();
  }
  createDepthTexture() {
    if (!this.device || this.width === 0 || this.height === 0)
      return;
    if (this.depthCopyTexture) {
      this.depthCopyTexture.destroy();
    }
    if (this.sceneColorCopyTexture) {
      this.sceneColorCopyTexture.destroy();
    }
    if (!this.gBuffer) {
      if (this.depthTexture) {
        this.depthTexture.destroy();
      }
      this.depthTexture = this.device.createTexture({
        size: [this.width, this.height],
        format: "depth32float",
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
      });
    }
    const depthCopyFormat = this.gBuffer?.depthTexture?.format || "depth32float";
    this.depthCopyTexture = this.device.createTexture({
      size: [this.width, this.height],
      format: depthCopyFormat,
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
      label: "Depth Copy for Water"
    });
    this.sceneColorCopyTexture = this.device.createTexture({
      size: [this.width, this.height],
      format: "rgba16float",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
      label: "Scene Color Copy for Water Refraction"
    });
  }
  execute(commandEncoder, context, globalResources) {
    const depthTexture = this.gBuffer ? this.gBuffer.depthTexture : this.depthTexture;
    if (!this.device || !this.context || !this.presentationFormat || !depthTexture)
      return;
    const { scene, camera } = context;
    let textureView;
    let currentTexture = null;
    if (this.gBuffer && this.gBuffer.accumulationTexture) {
      currentTexture = this.gBuffer.accumulationTexture;
      textureView = currentTexture.createView();
    } else {
      currentTexture = this.context.getCurrentTexture();
      textureView = currentTexture.createView();
    }
    const loadOp = this.gBuffer ? "load" : "clear";
    const depthLoadOp = this.gBuffer ? "load" : "clear";
    const opaqueMeshes = [];
    const transparentMeshes = [];
    const flames = [];
    const billboardClouds = [];
    let hasWater = false;
    scene.traverse((node) => {
      if (!node.visible)
        return false;
      if (node.isFlame === true) {
        flames.push(node);
        return;
      }
      if (node.isBillboardClouds === true) {
        billboardClouds.push(node);
        return;
      }
      if (node instanceof Sprite) {
        if (node.material.opacity < 1 || node.material.alphaMode === "BLEND") {
          transparentMeshes.push(node);
        } else {
          opaqueMeshes.push(node);
        }
        return;
      }
      if (node instanceof TilemapLayer) {
        if (this.device) {
          node.initGPU(this.device);
          node.syncDataTexture();
        }
        if (node.material.opacity < 1 || node.material.alphaMode === "BLEND") {
          transparentMeshes.push(node);
        } else {
          opaqueMeshes.push(node);
        }
        return;
      }
      if (node instanceof Mesh) {
        if (node.material instanceof WaterMaterial) {
          hasWater = true;
        }
        if (this.gBuffer) {
          if (node.material instanceof StandardMaterial || node.material instanceof TerrainMaterial) {
            if (node instanceof SkinnedMesh) {
              return;
            }
            if (node.material.getRenderingPath() === "deferred") {
              return;
            }
            transparentMeshes.push(node);
          } else {
            if (node.material.opacity < 1 || node.material.alphaMode === "BLEND") {
              transparentMeshes.push(node);
            } else {
              opaqueMeshes.push(node);
            }
          }
        } else {
          if (node.material.opacity < 1 || node.material.alphaMode === "BLEND") {
            transparentMeshes.push(node);
          } else {
            opaqueMeshes.push(node);
          }
        }
      }
    });
    for (const flame of flames) {
      flame.setDeltaTime(context.deltaTime || 0.016);
      flame.runCompute(commandEncoder);
    }
    transparentMeshes.sort((a, b) => {
      const orderA = a.renderOrder ?? 0;
      const orderB = b.renderOrder ?? 0;
      if (orderA !== orderB) {
        return orderA - orderB;
      }
      const distA = a.transform.position.distanceTo(camera.transform.position);
      const distB = b.transform.position.distanceTo(camera.transform.position);
      return distB - distA;
    });
    if (hasWater && transparentMeshes.length > 0) {
      const opaquePassDescriptor = {
        colorAttachments: [{
          view: textureView,
          clearValue: scene.backgroundColor,
          loadOp,
          storeOp: "store"
        }],
        depthStencilAttachment: {
          view: depthTexture.createView(),
          depthClearValue: 1,
          depthLoadOp,
          depthStoreOp: "store"
        }
      };
      const opaquePass = commandEncoder.beginRenderPass(opaquePassDescriptor);
      for (const mesh of opaqueMeshes) {
        this.renderMesh(mesh, context, opaquePass, globalResources);
      }
      opaquePass.end();
      const depthSource = this.gBuffer?.depthTexture || this.depthTexture;
      if (depthSource && this.depthCopyTexture) {
        commandEncoder.copyTextureToTexture({ texture: depthSource }, { texture: this.depthCopyTexture }, [this.width, this.height]);
      }
      const colorSource = this.gBuffer?.accumulationTexture || currentTexture;
      if (colorSource && this.sceneColorCopyTexture) {
        commandEncoder.copyTextureToTexture({ texture: colorSource }, { texture: this.sceneColorCopyTexture }, [this.width, this.height]);
      }
      for (const mesh of transparentMeshes) {
        if (mesh instanceof Mesh && mesh.material instanceof WaterMaterial) {
          mesh.material.depthTexture = this.depthCopyTexture;
          mesh.material.ssrTexture = this.ssrTexture;
          mesh.material.sceneColorTexture = this.sceneColorCopyTexture;
          mesh.material.screenWidth = this.width;
          mesh.material.screenHeight = this.height;
          mesh.bindGroup = null;
        }
      }
      const transparentTextureView = currentTexture ? currentTexture.createView() : textureView;
      const transparentPassDescriptor = {
        colorAttachments: [{
          view: transparentTextureView,
          loadOp: "load",
          storeOp: "store"
        }],
        depthStencilAttachment: {
          view: depthTexture.createView(),
          depthLoadOp: "load",
          depthStoreOp: "store"
        }
      };
      const transparentPass = commandEncoder.beginRenderPass(transparentPassDescriptor);
      for (const mesh of transparentMeshes) {
        this.renderMesh(mesh, context, transparentPass, globalResources);
      }
      transparentPass.end();
      if (billboardClouds.length > 0) {
        for (const clouds of billboardClouds) {
          clouds.setDeltaTime(context.deltaTime || 0.016);
          clouds.render(commandEncoder, camera, currentTexture, depthTexture, scene);
        }
      }
      if (flames.length > 0) {
        for (const flame of flames) {
          flame.render(commandEncoder, camera, currentTexture, depthTexture);
        }
      }
    } else {
      const renderPassDescriptor = {
        colorAttachments: [{
          view: textureView,
          clearValue: scene.backgroundColor,
          loadOp,
          storeOp: "store"
        }],
        depthStencilAttachment: {
          view: depthTexture.createView(),
          depthClearValue: 1,
          depthLoadOp,
          depthStoreOp: "store"
        }
      };
      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
      for (const mesh of opaqueMeshes) {
        this.renderMesh(mesh, context, passEncoder, globalResources);
      }
      for (const mesh of transparentMeshes) {
        if (mesh instanceof Mesh && mesh.material instanceof WaterMaterial) {
          mesh.material.depthTexture = null;
          mesh.material.ssrTexture = this.ssrTexture;
          mesh.material.sceneColorTexture = null;
          mesh.material.screenWidth = this.width;
          mesh.material.screenHeight = this.height;
        }
      }
      for (const mesh of transparentMeshes) {
        this.renderMesh(mesh, context, passEncoder, globalResources);
      }
      passEncoder.end();
      const accumulationTexture = this.gBuffer?.accumulationTexture || currentTexture;
      if (accumulationTexture && billboardClouds.length > 0) {
        for (const clouds of billboardClouds) {
          clouds.setDeltaTime(context.deltaTime || 0.016);
          clouds.render(commandEncoder, camera, accumulationTexture, depthTexture, scene);
        }
      }
      if (accumulationTexture && flames.length > 0) {
        for (const flame of flames) {
          flame.render(commandEncoder, camera, accumulationTexture, depthTexture);
        }
      }
    }
  }
  renderMesh(mesh, context, passEncoder, globalResources) {
    if (!this.device || !this.presentationFormat)
      return;
    const needsInit = mesh.geometry.buffersDirty || Object.keys(mesh.geometry.attributes).some((name) => !mesh.geometry.vertexBuffers[name]);
    if (needsInit) {
      this.initGeometryBuffers(mesh.geometry);
      return;
    }
    if (!mesh.material.pipeline) {
      this.initMaterialPipeline(mesh.material, mesh.geometry, globalResources);
    }
    if (!mesh.uniformBuffer || !mesh.bindGroup) {
      this.initMeshUniforms(mesh, globalResources);
    }
    this.updateMeshUniforms(mesh, context);
    if (mesh.material.pipeline && mesh.bindGroup) {
      passEncoder.setPipeline(mesh.material.pipeline);
      if (usesGlobalResources(mesh.material)) {
        if (globalResources.renderBindGroup) {
          passEncoder.setBindGroup(0, globalResources.renderBindGroup);
        }
        passEncoder.setBindGroup(1, mesh.bindGroup);
        const instanceIndex = mesh.renderIndex >= 0 ? mesh.renderIndex : 0;
        this.bindVertexBuffers(passEncoder, mesh);
        if (mesh.geometry.indexBuffer) {
          const indexFormat = mesh.geometry.indices instanceof Uint32Array ? "uint32" : "uint16";
          passEncoder.setIndexBuffer(mesh.geometry.indexBuffer, indexFormat);
          passEncoder.drawIndexed(mesh.geometry.indexCount, 1, 0, 0, instanceIndex);
        } else {
          passEncoder.draw(mesh.geometry.vertexCount, 1, 0, instanceIndex);
        }
      } else {
        passEncoder.setBindGroup(0, mesh.bindGroup);
        this.bindVertexBuffers(passEncoder, mesh);
        if (mesh.geometry.indexBuffer) {
          const indexFormat = mesh.geometry.indices instanceof Uint32Array ? "uint32" : "uint16";
          passEncoder.setIndexBuffer(mesh.geometry.indexBuffer, indexFormat);
          passEncoder.drawIndexed(mesh.geometry.indexCount);
        } else {
          passEncoder.draw(mesh.geometry.vertexCount);
        }
      }
      if (context.frameStats) {
        context.frameStats.drawCalls++;
        context.frameStats.triangles += mesh.geometry.triangleCount;
      }
    }
  }
  bindVertexBuffers(passEncoder, mesh) {
    if (mesh.geometry.vertexBuffers["position"]) {
      passEncoder.setVertexBuffer(0, mesh.geometry.vertexBuffers["position"]);
    }
    if (mesh.geometry.vertexBuffers["normal"]) {
      passEncoder.setVertexBuffer(1, mesh.geometry.vertexBuffers["normal"]);
    }
    if (mesh.geometry.vertexBuffers["uv"]) {
      passEncoder.setVertexBuffer(2, mesh.geometry.vertexBuffers["uv"]);
    }
  }
  initGeometryBuffers(geometry) {
    if (!this.device)
      return;
    if (geometry.buffersDirty) {
      for (const key in geometry.vertexBuffers) {
        geometry.vertexBuffers[key]?.destroy();
        delete geometry.vertexBuffers[key];
      }
      if (geometry.indexBuffer) {
        geometry.indexBuffer.destroy();
        geometry.indexBuffer = null;
      }
    }
    for (const [name, data] of Object.entries(geometry.attributes)) {
      if (!geometry.vertexBuffers[name]) {
        const buffer = this.device.createBuffer({
          label: `${name} Buffer`,
          size: data.byteLength,
          usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
          mappedAtCreation: true
        });
        new Float32Array(buffer.getMappedRange()).set(data);
        buffer.unmap();
        geometry.vertexBuffers[name] = buffer;
      }
    }
    if (geometry.indices && !geometry.indexBuffer) {
      const size = geometry.indices.byteLength;
      const alignedSize = size + 3 & ~3;
      geometry.indexBuffer = this.device.createBuffer({
        label: "Index Buffer",
        size: alignedSize,
        usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,
        mappedAtCreation: true
      });
      if (geometry.indices instanceof Uint16Array) {
        new Uint16Array(geometry.indexBuffer.getMappedRange()).set(geometry.indices);
      } else {
        new Uint32Array(geometry.indexBuffer.getMappedRange()).set(geometry.indices);
      }
      geometry.indexBuffer.unmap();
    }
    geometry.markBuffersClean();
  }
  initMaterialPipeline(material, geometry, globalResources) {
    if (!this.device || !this.presentationFormat)
      return;
    const vertexModule = createShaderModuleSafe(this.device, {
      label: "Material Vertex Shader",
      code: material.getVertexShader("forward")
    });
    const fragmentModule = createShaderModuleSafe(this.device, {
      label: "Material Fragment Shader",
      code: material.getFragmentShader("forward")
    });
    const buffers = [];
    if (geometry.attributes["position"]) {
      buffers.push({
        arrayStride: 3 * 4,
        attributes: [{ shaderLocation: 0, offset: 0, format: "float32x3" }]
      });
    }
    if (geometry.attributes["normal"]) {
      buffers.push({
        arrayStride: 3 * 4,
        attributes: [{ shaderLocation: 1, offset: 0, format: "float32x3" }]
      });
    }
    if (geometry.attributes["uv"]) {
      buffers.push({
        arrayStride: 2 * 4,
        attributes: [{ shaderLocation: 2, offset: 0, format: "float32x2" }]
      });
    }
    let pipelineLayout = "auto";
    if (usesGlobalResources(material)) {
      const materialLayout = material.createBindGroupLayout(this.device);
      pipelineLayout = this.device.createPipelineLayout({
        bindGroupLayouts: [globalResources.renderBindGroupLayout, materialLayout]
      });
    }
    const isTransparent = material.alphaMode === "BLEND" || material.opacity < 1;
    const isSprite = material instanceof SpriteMaterial;
    const blendState = isTransparent ? {
      color: {
        srcFactor: "src-alpha",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      },
      alpha: {
        srcFactor: "src-alpha",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
      }
    } : undefined;
    const depthFormat = this.gBuffer && this.gBuffer.depthTexture ? this.gBuffer.depthTexture.format : "depth32float";
    const targetFormat = this.gBuffer ? "rgba16float" : this.presentationFormat;
    let depthWriteEnabled = !isTransparent;
    let depthCompare = "less";
    if (isSprite) {
      depthWriteEnabled = material.depthWrite;
      depthCompare = material.depthTest ? "less-equal" : "always";
    }
    material.pipeline = this.device.createRenderPipeline({
      label: isSprite ? "Sprite Pipeline" : "Material Pipeline",
      layout: pipelineLayout,
      vertex: {
        module: vertexModule,
        entryPoint: "vs_main",
        buffers
      },
      fragment: {
        module: fragmentModule,
        entryPoint: "fs_main",
        targets: [{
          format: targetFormat,
          blend: blendState
        }]
      },
      primitive: {
        topology: "triangle-list",
        cullMode: "none"
      },
      depthStencil: {
        depthWriteEnabled,
        depthCompare,
        format: depthFormat
      }
    });
  }
  initMeshUniforms(mesh, globalResources) {
    if (!this.device || !mesh.material.pipeline)
      return;
    const uniformBufferSize = mesh.material.getUniformBufferSize();
    mesh.uniformBuffer = this.device.createBuffer({
      label: "Uniform Buffer",
      size: uniformBufferSize,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    let layout;
    if (usesGlobalResources(mesh.material)) {
      layout = mesh.material.createBindGroupLayout(this.device);
    } else {
      layout = mesh.material.pipeline.getBindGroupLayout(0);
    }
    mesh.bindGroup = this.device.createBindGroup({
      label: "Uniform Bind Group",
      layout,
      entries: mesh.material.getBindGroupEntries(this.device, mesh.uniformBuffer)
    });
  }
  updateMeshUniforms(mesh, parentContext) {
    if (!this.device || !mesh.uniformBuffer)
      return;
    const context = {
      ...parentContext,
      modelMatrix: mesh.transform.worldMatrix
    };
    mesh.material.updateUniforms(this.device, mesh.uniformBuffer, 0, context);
  }
}

// ../../src/math/Frustum.ts
class Plane {
  normal;
  constant;
  constructor() {
    this.normal = new Vector3(1, 0, 0);
    this.constant = 0;
  }
  setComponents(x, y, z, w) {
    this.normal.set(x, y, z);
    this.constant = w;
    this.normalize();
    return this;
  }
  normalize() {
    const length = this.normal.magnitude();
    if (length > 0) {
      const inverseLength = 1 / length;
      this.normal = this.normal.multiply(inverseLength);
      this.constant *= inverseLength;
    }
    return this;
  }
  distanceToPoint(point) {
    return this.normal.dot(point) + this.constant;
  }
}

class Frustum {
  planes;
  constructor() {
    this.planes = [
      new Plane,
      new Plane,
      new Plane,
      new Plane,
      new Plane,
      new Plane
    ];
  }
  setFromProjectionMatrix(m) {
    const me = m.elements;
    const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
    const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
    const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
    const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
    this.planes[0].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12);
    this.planes[1].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12);
    this.planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13);
    this.planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13);
    this.planes[4].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14);
    this.planes[5].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14);
    return this;
  }
  intersectsBox(minX, minY, minZ, maxX, maxY, maxZ) {
    for (let i = 0;i < 6; i++) {
      const plane = this.planes[i];
      const normal = plane.normal;
      const px = normal.x > 0 ? maxX : minX;
      const py = normal.y > 0 ? maxY : minY;
      const pz = normal.z > 0 ? maxZ : minZ;
      if (normal.x * px + normal.y * py + normal.z * pz + plane.constant < 0) {
        return false;
      }
    }
    return true;
  }
}

// ../../src/core/procedural/noise/NoiseShaders.ts
var NoiseShaderLib = `
// ============================================
// HASH FUNCTIONS (high quality, pattern-free)
// ============================================

// Sine-based hash with carefully chosen constants (IQ's method, improved)
fn hash11(p: f32) -> f32 {
    let p2 = fract(p * 0.1031);
    let p3 = p2 * (p2 + 33.33);
    return fract(p3 * (p3 + p3));
}

fn hash21(p: vec2f) -> f32 {
    // Use sine for better distribution (Inigo Quilez style)
    var p3 = fract(p.xyx * vec3f(0.1031, 0.1030, 0.0973));
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

fn hash31(p: vec3f) -> f32 {
    var p3 = fract(p * vec3f(0.1031, 0.1030, 0.0973));
    p3 += dot(p3, p3.yxz + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

fn hash22(p: vec2f) -> vec2f {
    var p3 = fract(p.xyx * vec3f(0.1031, 0.1030, 0.0973));
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.xx + p3.yz) * p3.zy);
}

fn hash33(p: vec3f) -> vec3f {
    var p3 = fract(p * vec3f(0.1031, 0.1030, 0.0973));
    p3 += dot(p3, p3.yxz + 33.33);
    return fract((p3.xxy + p3.yxx) * p3.zyx);
}

// Seeded hash function
fn hashWithSeed(p: vec2f, seed: f32) -> f32 {
    return hash21(p + vec2f(seed * 127.1, seed * 311.7));
}

// ============================================
// VALUE NOISE
// ============================================

fn valueNoise2D(p: vec2f) -> f32 {
    let i = floor(p);
    let f = fract(p);

    // Quintic interpolation for smoother results (C2 continuity)
    let u = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);

    return mix(
        mix(hash21(i + vec2f(0.0, 0.0)), hash21(i + vec2f(1.0, 0.0)), u.x),
        mix(hash21(i + vec2f(0.0, 1.0)), hash21(i + vec2f(1.0, 1.0)), u.x),
        u.y
    );
}

fn valueNoise3D(p: vec3f) -> f32 {
    let i = floor(p);
    let f = fract(p);
    let u = f * f * (3.0 - 2.0 * f);

    return mix(
        mix(
            mix(hash31(i + vec3f(0,0,0)), hash31(i + vec3f(1,0,0)), u.x),
            mix(hash31(i + vec3f(0,1,0)), hash31(i + vec3f(1,1,0)), u.x),
            u.y
        ),
        mix(
            mix(hash31(i + vec3f(0,0,1)), hash31(i + vec3f(1,0,1)), u.x),
            mix(hash31(i + vec3f(0,1,1)), hash31(i + vec3f(1,1,1)), u.x),
            u.y
        ),
        u.z
    );
}

// ============================================
// GRADIENT NOISE (Perlin-style)
// ============================================

// Generate a random 2D gradient vector from a hash
fn gradient2D(p: vec2f) -> vec2f {
    // Use hash to generate angle, then convert to unit vector
    let angle = hash21(p) * 6.283185307; // 2*PI
    return vec2f(cos(angle), sin(angle));
}

fn perlinNoise2D(p: vec2f) -> f32 {
    let i = floor(p);
    let f = fract(p);

    // Quintic interpolation for C2 continuity (smoother)
    let u = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);

    // Get gradients at four corners
    let g00 = gradient2D(i + vec2f(0.0, 0.0));
    let g10 = gradient2D(i + vec2f(1.0, 0.0));
    let g01 = gradient2D(i + vec2f(0.0, 1.0));
    let g11 = gradient2D(i + vec2f(1.0, 1.0));

    // Calculate dot products with distance vectors
    let d00 = dot(g00, f - vec2f(0.0, 0.0));
    let d10 = dot(g10, f - vec2f(1.0, 0.0));
    let d01 = dot(g01, f - vec2f(0.0, 1.0));
    let d11 = dot(g11, f - vec2f(1.0, 1.0));

    // Bilinear interpolation
    let x0 = mix(d00, d10, u.x);
    let x1 = mix(d01, d11, u.x);
    let n = mix(x0, x1, u.y);

    // Scale to [0, 1] range (Perlin noise range is approximately [-0.7, 0.7])
    return n * 0.7071 + 0.5;
}

// ============================================
// SIMPLEX NOISE (2D)
// ============================================

fn mod289_2(x: vec2f) -> vec2f { return x - floor(x * (1.0 / 289.0)) * 289.0; }
fn mod289_3(x: vec3f) -> vec3f { return x - floor(x * (1.0 / 289.0)) * 289.0; }
fn permute(x: vec3f) -> vec3f { return mod289_3((x * 34.0 + 1.0) * x); }

fn simplexNoise2D(v: vec2f) -> f32 {
    let C = vec4f(
        0.211324865405187,  // (3.0-sqrt(3.0))/6.0
        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
        -0.577350269189626, // -1.0 + 2.0 * C.x
        0.024390243902439   // 1.0 / 41.0
    );

    // First corner
    var i = floor(v + dot(v, vec2f(C.y)));
    let x0 = v - i + dot(i, vec2f(C.x));

    // Other corners
    let i1 = select(vec2f(0.0, 1.0), vec2f(1.0, 0.0), x0.x > x0.y);
    var x12 = x0.xyxy + C.xxzz;
    x12 = vec4f(x12.xy - i1, x12.zw);

    // Permutations
    i = mod289_2(i);
    let p = permute(permute(i.y + vec3f(0.0, i1.y, 1.0)) + i.x + vec3f(0.0, i1.x, 1.0));

    var m = max(0.5 - vec3f(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), vec3f(0.0));
    m = m * m;
    m = m * m;

    // Gradients
    let x = 2.0 * fract(p * C.www) - 1.0;
    let h = abs(x) - 0.5;
    let ox = floor(x + 0.5);
    let a0 = x - ox;

    m = m * (1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h));

    let g = vec3f(
        a0.x * x0.x + h.x * x0.y,
        a0.y * x12.x + h.y * x12.y,
        a0.z * x12.z + h.z * x12.w
    );

    return (130.0 * dot(m, g)) * 0.5 + 0.5;
}

// ============================================
// WORLEY (CELLULAR) NOISE
// ============================================

fn worleyNoise2D(p: vec2f) -> f32 {
    let n = floor(p);
    let f = fract(p);

    var minDist = 1.0;

    for (var j = -1; j <= 1; j++) {
        for (var i = -1; i <= 1; i++) {
            let neighbor = vec2f(f32(i), f32(j));
            let point = hash22(n + neighbor);
            let diff = neighbor + point - f;
            let dist = length(diff);
            minDist = min(minDist, dist);
        }
    }

    return minDist;
}

fn worleyNoise2D_F1F2(p: vec2f) -> vec2f {
    let n = floor(p);
    let f = fract(p);

    var minDist1 = 1.0;
    var minDist2 = 1.0;

    for (var j = -1; j <= 1; j++) {
        for (var i = -1; i <= 1; i++) {
            let neighbor = vec2f(f32(i), f32(j));
            let point = hash22(n + neighbor);
            let diff = neighbor + point - f;
            let dist = length(diff);

            if (dist < minDist1) {
                minDist2 = minDist1;
                minDist1 = dist;
            } else if (dist < minDist2) {
                minDist2 = dist;
            }
        }
    }

    return vec2f(minDist1, minDist2);
}

// ============================================
// FBM (FRACTAL BROWNIAN MOTION)
// ============================================

fn fbm2D(p: vec2f, octaves: u32, lacunarity: f32, gain: f32) -> f32 {
    var value = 0.0;
    var amplitude = 0.5;
    var frequency = 1.0;
    var totalAmplitude = 0.0;
    var pos = p;

    for (var i = 0u; i < octaves; i++) {
        value += amplitude * valueNoise2D(pos * frequency);
        totalAmplitude += amplitude;
        amplitude *= gain;
        frequency *= lacunarity;
    }

    return value / totalAmplitude;
}

fn fbmPerlin2D(p: vec2f, octaves: u32, lacunarity: f32, gain: f32) -> f32 {
    var value = 0.0;
    var amplitude = 0.5;
    var frequency = 1.0;
    var totalAmplitude = 0.0;
    var pos = p;

    for (var i = 0u; i < octaves; i++) {
        value += amplitude * perlinNoise2D(pos * frequency);
        totalAmplitude += amplitude;
        amplitude *= gain;
        frequency *= lacunarity;
    }

    return value / totalAmplitude;
}

fn fbmSimplex2D(p: vec2f, octaves: u32, lacunarity: f32, gain: f32) -> f32 {
    var value = 0.0;
    var amplitude = 0.5;
    var frequency = 1.0;
    var totalAmplitude = 0.0;
    var pos = p;

    for (var i = 0u; i < octaves; i++) {
        value += amplitude * simplexNoise2D(pos * frequency);
        totalAmplitude += amplitude;
        amplitude *= gain;
        frequency *= lacunarity;
    }

    return value / totalAmplitude;
}

// ============================================
// RIDGED NOISE (for mountains)
// ============================================

fn ridgedNoise2D(p: vec2f) -> f32 {
    // Use Simplex noise for grid-free ridges (no directional artifacts)
    let n = simplexNoise2D(p);
    // Create ridge by folding: values near 0.5 become peaks
    return 1.0 - abs(n * 2.0 - 1.0);
}

fn ridgedFBM2D(p: vec2f, octaves: u32, lacunarity: f32, gain: f32) -> f32 {
    var value = 0.0;
    var amplitude = 0.5;
    var frequency = 1.0;
    var totalAmplitude = 0.0;
    var weight = 1.0;
    var pos = p;

    for (var i = 0u; i < octaves; i++) {
        let n = ridgedNoise2D(pos * frequency);
        // Softer signal shaping - use sqrt instead of square for less harsh peaks
        let signal = pow(n, 1.5) * weight;
        value += amplitude * signal;
        totalAmplitude += amplitude;

        // Gentler weight feedback
        weight = clamp(signal * 1.5, 0.0, 1.0);
        amplitude *= gain;
        frequency *= lacunarity;
    }

    return value / totalAmplitude;
}

// ============================================
// BILLOWY NOISE (for soft hills, clouds)
// ============================================

fn billowyNoise2D(p: vec2f) -> f32 {
    // Use Simplex noise for grid-free billows
    let n = simplexNoise2D(p);
    return abs(n * 2.0 - 1.0);
}

fn billowyFBM2D(p: vec2f, octaves: u32, lacunarity: f32, gain: f32) -> f32 {
    var value = 0.0;
    var amplitude = 0.5;
    var frequency = 1.0;
    var totalAmplitude = 0.0;
    var pos = p;

    for (var i = 0u; i < octaves; i++) {
        value += amplitude * billowyNoise2D(pos * frequency);
        totalAmplitude += amplitude;
        amplitude *= gain;
        frequency *= lacunarity;
    }

    return value / totalAmplitude;
}

// ============================================
// DOMAIN WARPING
// ============================================

fn warpedNoise2D(p: vec2f, warpStrength: f32, warpFrequency: f32) -> f32 {
    // Use Perlin noise for smoother warping
    let warp = vec2f(
        fbmPerlin2D(p * warpFrequency, 4u, 2.0, 0.5),
        fbmPerlin2D(p * warpFrequency + vec2f(5.2, 1.3), 4u, 2.0, 0.5)
    );
    return fbmPerlin2D(p + warp * warpStrength, 4u, 2.0, 0.5);
}

fn warpedRidged2D(p: vec2f, warpStrength: f32, warpFrequency: f32) -> f32 {
    // Use Perlin noise for smoother warping
    let warp = vec2f(
        fbmPerlin2D(p * warpFrequency, 4u, 2.0, 0.5),
        fbmPerlin2D(p * warpFrequency + vec2f(5.2, 1.3), 4u, 2.0, 0.5)
    );
    return ridgedFBM2D(p + warp * warpStrength, 6u, 2.0, 0.5);
}

// ============================================
// EROSION PATTERNS
// ============================================

// Simulate basic hydraulic erosion patterns
fn erosionPattern2D(p: vec2f, height: f32) -> f32 {
    // Use worley noise to create erosion channels
    let w = worleyNoise2D_F1F2(p * 4.0);
    let channels = smoothstep(0.0, 0.3, w.y - w.x);

    // Erosion is stronger at lower heights
    let erosionStrength = 1.0 - height;

    return mix(height, height * channels, erosionStrength * 0.3);
}

// ============================================
// TERRACING
// ============================================

fn terrace(value: f32, steps: f32) -> f32 {
    // Always use smooth terracing for better visuals
    return smoothTerrace(value, steps, 0.3);
}

fn smoothTerrace(value: f32, steps: f32, smoothness: f32) -> f32 {
    let t = value * steps;
    let floor_t = floor(t);
    let fract_t = fract(t);

    // Use a smoother S-curve for transitions between terraces
    // This creates flat plateaus with smooth ramps between them
    let edgeWidth = clamp(smoothness, 0.1, 0.45);

    // Remap fract_t so the flat part is in the middle
    var s: f32;
    if (fract_t < edgeWidth) {
        // Rising edge from previous terrace
        s = smoothstep(0.0, edgeWidth, fract_t) * 0.5;
    } else if (fract_t > 1.0 - edgeWidth) {
        // Rising edge to next terrace
        s = 0.5 + smoothstep(1.0 - edgeWidth, 1.0, fract_t) * 0.5;
    } else {
        // Flat plateau in the middle
        s = 0.5;
    }

    return (floor_t + s) / steps;
}

// Even smoother terrace with continuous slopes
fn smoothTerraceGradual(value: f32, steps: f32, smoothness: f32) -> f32 {
    let t = value * steps;
    let floor_t = floor(t);
    let fract_t = fract(t);

    // Hermite interpolation for C1 continuity
    let s = fract_t * fract_t * (3.0 - 2.0 * fract_t);

    // Blend between sharp terrace and smooth based on smoothness
    let sharpened = select(0.0, 1.0, fract_t > 0.5);
    let result = mix(sharpened, s, smoothness * 2.0);

    return (floor_t + result) / steps;
}

// ============================================
// CONTINENTAL NOISE
// Large-scale landmass shapes with detail
// ============================================

fn continentalBase(p: vec2f) -> f32 {
    // Use Voronoi-like cells for continent shapes
    let scale = 0.5;
    let w = worleyNoise2D_F1F2(p * scale);
    // F2 - F1 creates cell-like patterns good for continents
    return smoothstep(0.0, 0.5, w.y - w.x);
}

fn continentalNoise2D(p: vec2f, octaves: u32, lacunarity: f32, gain: f32) -> f32 {
    // Layer 1: Large-scale continental shapes
    let continentMask = continentalBase(p);

    // Layer 2: Mid-scale mountain ranges using ridged noise
    let ridges = ridgedFBM2D(p * 2.0, 4u, lacunarity, gain);

    // Layer 3: Small-scale detail using simplex
    let detail = fbmSimplex2D(p * 4.0, octaves, lacunarity, gain);

    // Combine: continents define where land is, ridges create mountains, detail adds texture
    var height = continentMask * 0.3; // Base continental height
    height += continentMask * ridges * 0.5; // Mountains only on continents
    height += detail * 0.2 * continentMask; // Detail everywhere there's land

    return clamp(height, 0.0, 1.0);
}

// ============================================
// HYBRID NOISE
// Intelligently combines multiple noise types
// ============================================

fn hybridMultifractal2D(p: vec2f, octaves: u32, lacunarity: f32, gain: f32, offset: f32) -> f32 {
    // Hybrid multifractal: smoother in valleys, rougher on peaks
    var result = (simplexNoise2D(p) + offset) * gain;
    var weight = result;
    var amplitude = gain;
    var frequency = lacunarity;

    for (var i = 1u; i < octaves; i++) {
        weight = clamp(weight, 0.0, 1.0);
        let signal = (simplexNoise2D(p * frequency) + offset) * amplitude;
        result += signal * weight;
        weight *= signal;
        amplitude *= gain;
        frequency *= lacunarity;
    }

    return clamp(result * 0.5, 0.0, 1.0);
}

fn swissNoise2D(p: vec2f, octaves: u32, lacunarity: f32, gain: f32) -> f32 {
    // Swiss turbulence: creates glacier-carved valley shapes
    var sum = 0.0;
    var amplitude = 1.0;
    var frequency = 1.0;
    var dsum = vec2f(0.0);

    for (var i = 0u; i < octaves; i++) {
        let n = simplexNoise2D((p + dsum * 0.5) * frequency);
        let dn = vec2f(
            simplexNoise2D((p + dsum * 0.5 + vec2f(0.01, 0.0)) * frequency) - n,
            simplexNoise2D((p + dsum * 0.5 + vec2f(0.0, 0.01)) * frequency) - n
        ) / 0.01;

        sum += amplitude * (1.0 - abs(n));
        dsum += amplitude * dn * -n;

        amplitude *= gain * clamp(sum, 0.0, 1.0);
        frequency *= lacunarity;
    }

    return clamp(sum * 0.5, 0.0, 1.0);
}

// ============================================
// CRATER NOISE
// Impact crater generation
// ============================================

fn craterProfile(dist: f32, radius: f32) -> f32 {
    let normalizedDist = dist / radius;

    if (normalizedDist > 1.5) {
        return 0.0; // Outside crater influence
    }

    if (normalizedDist < 0.3) {
        // Central peak (smoothstep requires low < high per WGSL spec)
        return (1.0 - smoothstep(0.0, 0.3, normalizedDist)) * 0.3;
    } else if (normalizedDist < 0.8) {
        // Crater floor
        return -0.3 * (1.0 - smoothstep(0.3, 0.8, normalizedDist));
    } else if (normalizedDist < 1.0) {
        // Crater rim (raised edge)
        let rimFactor = smoothstep(0.8, 1.0, normalizedDist);
        return mix(-0.1, 0.4, rimFactor);
    } else {
        // Outside rim - gentle slope back to base
        return 0.4 * (1.0 - smoothstep(1.0, 1.5, normalizedDist));
    }
}

fn singleCrater(p: vec2f, center: vec2f, radius: f32, rimHeight: f32) -> f32 {
    let dist = length(p - center);
    return craterProfile(dist, radius) * rimHeight;
}

fn craterField2D(p: vec2f, density: f32, sizeVariation: f32, seed: f32) -> f32 {
    // Generate multiple craters using cell-based placement
    let cellSize = 1.0 / density;
    let cell = floor(p / cellSize);

    var totalCrater = 0.0;

    // Check surrounding cells for craters
    for (var dy = -1; dy <= 1; dy++) {
        for (var dx = -1; dx <= 1; dx++) {
            let checkCell = cell + vec2f(f32(dx), f32(dy));
            let cellHash = hash21(checkCell + seed * 0.1);

            // Probability of crater in cell
            if (cellHash > 0.6) {
                // Random position within cell
                let craterPos = (checkCell + hash22(checkCell + seed * 0.2)) * cellSize;
                // Random size
                let craterRadius = 0.05 + cellHash * sizeVariation * 0.15;
                let rimHeight = 0.3 + hash21(checkCell * 2.0) * 0.4;

                totalCrater += singleCrater(p, craterPos, craterRadius, rimHeight);
            }
        }
    }

    return totalCrater;
}

// ============================================
// ISLAND NOISE
// Creates natural island shapes with beaches
// ============================================

fn islandMask(p: vec2f, center: vec2f, radius: f32, irregularity: f32) -> f32 {
    // Distance from center with noise-based irregularity
    let baseD = length(p - center) / radius;

    // Add noise to make coastline irregular
    let noise = fbmSimplex2D(p * 5.0, 3u, 2.0, 0.5);
    let d = baseD + (noise - 0.5) * irregularity;

    // Smooth falloff from center
    return 1.0 - smoothstep(0.3, 1.0, d);
}

fn islandNoise2D(p: vec2f, octaves: u32, lacunarity: f32, gain: f32) -> f32 {
    // Create island mask centered in terrain
    let islandFactor = islandMask(p, vec2f(0.5), 0.4, 0.3);

    // Base terrain using ridged noise for mountains
    let terrain = ridgedFBM2D(p * 2.0, octaves, lacunarity, gain);

    // Combine: island mask determines where land appears
    var height = islandFactor * terrain;

    // Add beach shelf at low elevations
    if (height > 0.0 && height < 0.15) {
        height = smoothstep(0.0, 0.15, height) * 0.15;
    }

    return clamp(height, 0.0, 1.0);
}
`;
var HeightmapComputeShader = `
${NoiseShaderLib}

// Configuration constants (set via specialization or uniforms)
const NOISE_VALUE: u32 = 0u;
const NOISE_PERLIN: u32 = 1u;
const NOISE_SIMPLEX: u32 = 2u;
const NOISE_RIDGED: u32 = 3u;
const NOISE_BILLOWY: u32 = 4u;
const NOISE_WORLEY: u32 = 5u;
const NOISE_CONTINENTAL: u32 = 6u;
const NOISE_HYBRID: u32 = 7u;
const NOISE_SWISS: u32 = 8u;
const NOISE_CRATER: u32 = 9u;
const NOISE_ISLAND: u32 = 10u;

struct HeightmapConfig {
    frequency: f32,
    amplitude: f32,
    lacunarity: f32,
    persistence: f32,
    octaves: u32,
    noiseType: u32,
    seed: f32,
    warpEnabled: u32,
    warpStrength: f32,
    warpFrequency: f32,
    terracing: u32,
    terraceCount: f32,
    smoothTerraces: u32,
    terraceSmooth: f32,
    erosion: u32,
    _pad: f32,
}

@group(0) @binding(0) var outputTexture: texture_storage_2d<r32float, write>;
@group(0) @binding(1) var<uniform> config: HeightmapConfig;

fn generateHeight(uv: vec2f) -> f32 {
    // Apply seed offset - use fract to keep values in reasonable range for float precision
    let seedX = fract(config.seed * 0.1031) * 100.0;
    let seedY = fract(config.seed * 0.0973) * 100.0;
    var p = uv * config.frequency + vec2f(seedX, seedY);

    // Apply domain warping if enabled (using Perlin for smoothness)
    if (config.warpEnabled != 0u) {
        let warp = vec2f(
            fbmPerlin2D(p * config.warpFrequency, 4u, 2.0, 0.5),
            fbmPerlin2D(p * config.warpFrequency + vec2f(5.2, 1.3), 4u, 2.0, 0.5)
        );
        p = p + warp * config.warpStrength;
    }

    // Generate base noise based on type
    var height = 0.0;

    switch (config.noiseType) {
        case NOISE_VALUE: {
            height = fbm2D(p, config.octaves, config.lacunarity, config.persistence);
        }
        case NOISE_PERLIN: {
            height = fbmPerlin2D(p, config.octaves, config.lacunarity, config.persistence);
        }
        case NOISE_SIMPLEX: {
            height = fbmSimplex2D(p, config.octaves, config.lacunarity, config.persistence);
        }
        case NOISE_RIDGED: {
            height = ridgedFBM2D(p, config.octaves, config.lacunarity, config.persistence);
        }
        case NOISE_BILLOWY: {
            height = billowyFBM2D(p, config.octaves, config.lacunarity, config.persistence);
        }
        case NOISE_WORLEY: {
            height = 1.0 - worleyNoise2D(p);
        }
        case NOISE_CONTINENTAL: {
            height = continentalNoise2D(p, config.octaves, config.lacunarity, config.persistence);
        }
        case NOISE_HYBRID: {
            height = hybridMultifractal2D(p, config.octaves, config.lacunarity, config.persistence, 0.7);
        }
        case NOISE_SWISS: {
            height = swissNoise2D(p, config.octaves, config.lacunarity, config.persistence);
        }
        case NOISE_CRATER: {
            // Base terrain with craters overlaid
            let baseTerrain = fbmSimplex2D(p, 4u, 2.0, 0.5) * 0.3;
            let craters = craterField2D(uv, 3.0, 0.5, config.seed);
            height = clamp(baseTerrain + craters, 0.0, 1.0);
        }
        case NOISE_ISLAND: {
            height = islandNoise2D(p, config.octaves, config.lacunarity, config.persistence);
        }
        default: {
            height = fbmPerlin2D(p, config.octaves, config.lacunarity, config.persistence);
        }
    }

    // Apply amplitude
    height *= config.amplitude;

    // Apply terracing if enabled
    if (config.terracing != 0u) {
        if (config.smoothTerraces != 0u) {
            height = smoothTerrace(height, config.terraceCount, config.terraceSmooth);
        } else {
            height = terrace(height, config.terraceCount);
        }
    }

    // Apply erosion pattern if enabled
    if (config.erosion != 0u) {
        height = erosionPattern2D(uv * 8.0, height);
    }

    return clamp(height, 0.0, 1.0);
}

@compute @workgroup_size(8, 8, 1)
fn main(@builtin(global_invocation_id) id: vec3u) {
    let dims = textureDimensions(outputTexture);
    if (id.x >= dims.x || id.y >= dims.y) { return; }

    let uv = vec2f(id.xy) / vec2f(dims);
    let height = generateHeight(uv);

    textureStore(outputTexture, id.xy, vec4f(height, 0.0, 0.0, 1.0));
}
`;

// ../../src/core/procedural/grass/GrassRenderer.ts
var INSTANCE_STRIDE = 12;

class GrassRenderer {
  config;
  device = null;
  initialized = false;
  instanceBuffer = null;
  vertexBuffer = null;
  indexBuffer = null;
  uniformBuffer = null;
  pipeline = null;
  bindGroup = null;
  bindGroupLayout = null;
  bladeTexture = null;
  bladeTextureView = null;
  sampler = null;
  instanceData = null;
  instanceCount = 0;
  vertexCount = 0;
  indexCount = 0;
  constructor(config) {
    this.config = config;
  }
  init(device, globalBindGroupLayout, bladeTexture) {
    this.device = device;
    const vertices = this.config.mode === "billboard" ? GrassRenderer.getBillboardVertices() : GrassRenderer.getGeometryVertices(this.config.segments, this.config.curvature);
    this.vertexCount = vertices.length / 5;
    this.vertexBuffer = device.createBuffer({
      label: "Grass Vertex Buffer",
      size: vertices.byteLength,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
      mappedAtCreation: true
    });
    new Float32Array(this.vertexBuffer.getMappedRange()).set(vertices);
    this.vertexBuffer.unmap();
    if (this.config.mode === "geometry") {
      const indices = GrassRenderer.getGeometryIndices(this.config.segments);
      this.indexCount = indices.length;
      this.indexBuffer = device.createBuffer({
        label: "Grass Index Buffer",
        size: indices.byteLength,
        usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,
        mappedAtCreation: true
      });
      new Uint16Array(this.indexBuffer.getMappedRange()).set(indices);
      this.indexBuffer.unmap();
    }
    const instanceBufferSize = this.config.maxInstances * INSTANCE_STRIDE * 4;
    this.instanceBuffer = device.createBuffer({
      label: "Grass Instance Buffer",
      size: instanceBufferSize,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
    });
    this.instanceData = new Float32Array(this.config.maxInstances * INSTANCE_STRIDE);
    this.uniformBuffer = device.createBuffer({
      label: "Grass Uniform Buffer",
      size: 64,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    if (bladeTexture) {
      this.bladeTexture = bladeTexture;
    } else {
      this.bladeTexture = device.createTexture({
        label: "Grass Default Texture",
        size: [1, 1],
        format: "rgba8unorm",
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
      });
      device.queue.writeTexture({ texture: this.bladeTexture }, new Uint8Array([255, 255, 255, 255]), { bytesPerRow: 4 }, { width: 1, height: 1 });
    }
    this.bladeTextureView = this.bladeTexture.createView();
    this.sampler = device.createSampler({
      label: "Grass Texture Sampler",
      magFilter: "linear",
      minFilter: "linear",
      mipmapFilter: "linear",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    });
    this.bindGroupLayout = device.createBindGroupLayout({
      label: "Grass Bind Group Layout",
      entries: [
        {
          binding: 0,
          visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
          buffer: { type: "uniform" }
        },
        {
          binding: 1,
          visibility: GPUShaderStage.FRAGMENT,
          texture: { sampleType: "float", viewDimension: "2d" }
        },
        {
          binding: 2,
          visibility: GPUShaderStage.FRAGMENT,
          sampler: { type: "filtering" }
        }
      ]
    });
    this.bindGroup = device.createBindGroup({
      label: "Grass Bind Group",
      layout: this.bindGroupLayout,
      entries: [
        { binding: 0, resource: { buffer: this.uniformBuffer } },
        { binding: 1, resource: this.bladeTextureView },
        { binding: 2, resource: this.sampler }
      ]
    });
    this.createPipeline(device, globalBindGroupLayout);
    this.initialized = true;
  }
  setBladeTexture(texture) {
    if (!this.device || !this.uniformBuffer || !this.sampler)
      return;
    this.bladeTexture = texture;
    this.bladeTextureView = texture.createView();
    this.bindGroup = this.device.createBindGroup({
      label: "Grass Bind Group",
      layout: this.bindGroupLayout,
      entries: [
        { binding: 0, resource: { buffer: this.uniformBuffer } },
        { binding: 1, resource: this.bladeTextureView },
        { binding: 2, resource: this.sampler }
      ]
    });
  }
  createPipeline(device, globalBindGroupLayout) {
    const vertexModule = device.createShaderModule({
      label: "Grass Vertex Shader",
      code: this.getVertexShaderCode()
    });
    const fragmentModule = device.createShaderModule({
      label: "Grass Fragment Shader",
      code: this.getFragmentShaderCode()
    });
    const pipelineLayout = device.createPipelineLayout({
      bindGroupLayouts: [globalBindGroupLayout, this.bindGroupLayout]
    });
    const vertexBuffers = [
      {
        arrayStride: 5 * 4,
        stepMode: "vertex",
        attributes: [
          { shaderLocation: 0, offset: 0, format: "float32x3" },
          { shaderLocation: 1, offset: 12, format: "float32x2" }
        ]
      },
      {
        arrayStride: INSTANCE_STRIDE * 4,
        stepMode: "instance",
        attributes: [
          { shaderLocation: 2, offset: 0, format: "float32x4" }
        ]
      },
      {
        arrayStride: INSTANCE_STRIDE * 4,
        stepMode: "instance",
        attributes: [
          { shaderLocation: 3, offset: 16, format: "float32x4" }
        ]
      },
      {
        arrayStride: INSTANCE_STRIDE * 4,
        stepMode: "instance",
        attributes: [
          { shaderLocation: 4, offset: 32, format: "float32x4" }
        ]
      }
    ];
    this.pipeline = device.createRenderPipeline({
      label: "Grass Render Pipeline",
      layout: pipelineLayout,
      vertex: {
        module: vertexModule,
        entryPoint: "vs_main",
        buffers: vertexBuffers
      },
      fragment: {
        module: fragmentModule,
        entryPoint: "fs_main",
        targets: [
          { format: "rgba16float" },
          { format: "rgba16float" },
          { format: "rgba16float" },
          { format: "rgba16float" },
          { format: "rg16float" }
        ]
      },
      primitive: {
        topology: "triangle-list",
        cullMode: "none"
      },
      depthStencil: {
        depthWriteEnabled: true,
        depthCompare: "less",
        format: "depth24plus"
      }
    });
  }
  uploadInstances(instances) {
    if (!this.device || !this.instanceBuffer || !this.instanceData)
      return;
    this.instanceCount = Math.min(instances.length, this.config.maxInstances);
    for (let i = 0;i < this.instanceCount; i++) {
      const inst = instances[i];
      const offset = i * INSTANCE_STRIDE;
      this.instanceData[offset + 0] = inst.position.x;
      this.instanceData[offset + 1] = inst.position.y;
      this.instanceData[offset + 2] = inst.position.z;
      this.instanceData[offset + 3] = inst.rotation;
      this.instanceData[offset + 4] = inst.scale;
      this.instanceData[offset + 5] = inst.random;
      this.instanceData[offset + 6] = 0;
      this.instanceData[offset + 7] = 0;
      this.instanceData[offset + 8] = inst.color.x;
      this.instanceData[offset + 9] = inst.color.y;
      this.instanceData[offset + 10] = inst.color.z;
      this.instanceData[offset + 11] = 1;
    }
    this.device.queue.writeBuffer(this.instanceBuffer, 0, this.instanceData.buffer, 0, this.instanceCount * INSTANCE_STRIDE * 4);
  }
  updateUniforms(viewProjMatrix, cameraPos, time, windDir, windStrength, windSpeed, turbulence, curvature = 0.5) {
    if (!this.device || !this.uniformBuffer)
      return;
    const data = new Float32Array(16);
    data[0] = windDir.x;
    data[1] = windDir.z;
    data[2] = windStrength;
    data[3] = windSpeed;
    data[4] = cameraPos.x;
    data[5] = cameraPos.y;
    data[6] = cameraPos.z;
    data[7] = time;
    data[8] = turbulence;
    data[9] = curvature;
    data[10] = 0;
    data[11] = 0;
    data[12] = 0;
    data[13] = 0;
    data[14] = 0;
    data[15] = 0;
    this.device.queue.writeBuffer(this.uniformBuffer, 0, data);
  }
  render(passEncoder, globalBindGroup) {
    if (!this.initialized || !this.pipeline || !this.bindGroup || this.instanceCount === 0)
      return;
    if (!this.vertexBuffer || !this.instanceBuffer)
      return;
    passEncoder.setPipeline(this.pipeline);
    passEncoder.setBindGroup(0, globalBindGroup);
    passEncoder.setBindGroup(1, this.bindGroup);
    passEncoder.setVertexBuffer(0, this.vertexBuffer);
    passEncoder.setVertexBuffer(1, this.instanceBuffer);
    passEncoder.setVertexBuffer(2, this.instanceBuffer);
    passEncoder.setVertexBuffer(3, this.instanceBuffer);
    if (this.config.mode === "geometry" && this.indexBuffer) {
      passEncoder.setIndexBuffer(this.indexBuffer, "uint16");
      passEncoder.drawIndexed(this.indexCount, this.instanceCount);
    } else {
      passEncoder.draw(this.vertexCount, this.instanceCount);
    }
  }
  getInstanceCount() {
    return this.instanceCount;
  }
  getVertexShaderCode() {
    return `
      // Noise functions for wind variation
      ${NoiseShaderLib}

      struct SceneUniforms {
        viewMatrix: mat4x4<f32>,
        projectionMatrix: mat4x4<f32>,
        lightViewProj: mat4x4<f32>,
        prevViewProj: mat4x4<f32>,
        inverseProjectionMatrix: mat4x4<f32>,
        cameraPosition: vec3f,
        time: f32,
        lightCount: u32,
        debugMode: u32,
        flags: u32,
        environmentIntensity: f32,
        fogColor: vec3f,
        fogDensity: f32,
        fogParams: vec4f,
        fogSettings: vec4u,
        // lights array omitted for grass
      }

      struct GrassUniforms {
        windDir: vec2f,
        windStrength: f32,
        windSpeed: f32,
        cameraPos: vec3f,
        time: f32,
        turbulence: f32,
        curvature: f32,
        _pad: vec2f,
      }

      @group(0) @binding(0) var<uniform> scene: SceneUniforms;
      @group(1) @binding(0) var<uniform> grass: GrassUniforms;

      struct VertexInput {
        @location(0) position: vec3f,
        @location(1) uv: vec2f,
        @location(2) instancePosRot: vec4f,   // position.xyz, rotation
        @location(3) instanceData: vec4f,     // scale, random, colorVar, unused
        @location(4) instanceColor: vec4f,    // color.rgb, unused
      }

      struct VertexOutput {
        @builtin(position) position: vec4f,
        @location(0) worldNormal: vec3f,
        @location(1) uv: vec2f,
        @location(2) worldPosition: vec3f,
        @location(3) currentClip: vec4f,
        @location(4) prevClip: vec4f,
        @location(5) color: vec3f,
      }

      @vertex
      fn vs_main(input: VertexInput) -> VertexOutput {
        var output: VertexOutput;

        let instancePos = input.instancePosRot.xyz;
        let rotation = input.instancePosRot.w;
        let scale = input.instanceData.x;
        let random = input.instanceData.y;
        let baseColor = input.instanceColor.rgb;

        // Rotate blade around Y axis
        let cosR = cos(rotation);
        let sinR = sin(rotation);
        var localPos = vec3f(
          input.position.x * cosR - input.position.z * sinR,
          input.position.y,
          input.position.x * sinR + input.position.z * cosR
        );

        // Scale blade
        localPos *= scale;

        // Height from base: UV.y is 1 at bottom, 0 at top
        // So (1 - uv.y) gives us 0 at bottom, 1 at top
        let heightFromBase = 1.0 - input.uv.y;

        // TRUE BEZIER CURVE for grass blade shape
        // t goes from 0 (base) to 1 (tip)
        let t = heightFromBase;
        let oneMinusT = 1.0 - t;
        let oneMinusT2 = oneMinusT * oneMinusT;
        let oneMinusT3 = oneMinusT2 * oneMinusT;
        let t2 = t * t;
        let t3 = t2 * t;

        // Each blade has a random lean direction
        let naturalBendDir = random * 6.28318; // Random direction in radians

        // Use second random value for curvature variation (derived from first)
        let random2 = fract(sin(random * 12345.6789) * 43758.5453);
        let random3 = fract(sin(random2 * 98765.4321) * 12345.6789);

        // Cubic bezier control points for X displacement (as function of height t)
        // P0 = 0 (base - no displacement)
        // P1 = near 0 (keeps base tangent nearly vertical)
        // P2 = bulge amount (how much the blade curves outward)
        // P3 = tip displacement (can be less than P2 for droop effect)
        //
        // Cubic bezier: B(t) = (1-t)³P0 + 3(1-t)²t*P1 + 3(1-t)t²*P2 + t³P3

        // Vary the control points per blade for natural variation
        let p1 = 0.0 + random3 * 0.1;  // 0.0 to 0.1 - keeps base vertical
        let p2 = 1.0 + random2 * 0.8;   // 1.0 to 1.8 - bulge amount
        let p3 = 0.5 + random3 * 0.5;   // 0.5 to 1.0 - tip position (droop)

        // Calculate bezier curve value for horizontal displacement
        let bezierCurve = 3.0 * oneMinusT2 * t * p1
                        + 3.0 * oneMinusT * t2 * p2
                        + t3 * p3;

        // Curvature amount varies per blade
        let bladeCurvature = grass.curvature * (0.3 + random2 * 1.2) * scale;

        // Apply bezier curve displacement
        let naturalBendX = cos(naturalBendDir) * bezierCurve * bladeCurvature;
        let naturalBendZ = sin(naturalBendDir) * bezierCurve * bladeCurvature;

        // Apply natural curve
        localPos.x += naturalBendX;
        localPos.z += naturalBendZ;

        // Height influence for wind (still quadratic, zero at base)
        let heightInfluence = t2;

        // Wind animation (stronger at top of blade, zero at base)
        // Sample noise for wind variation
        let noisePos = instancePos.xz * 0.05 + vec2f(grass.time * grass.windSpeed * 0.3);
        let windNoise = simplexNoise2D(noisePos) * 2.0 - 1.0;

        // Secondary turbulence layer
        let turbNoisePos = instancePos.xz * 0.2 + vec2f(grass.time * grass.windSpeed * 0.7 + random * 10.0);
        let turbNoise = simplexNoise2D(turbNoisePos) * grass.turbulence;

        // Calculate wind offset
        let windPhase = grass.time * grass.windSpeed + random * 6.28318;
        let windWave = sin(windPhase) * 0.5 + 0.5;

        let windOffsetX = grass.windDir.x * grass.windStrength * heightInfluence *
                          (windWave + windNoise * 0.3 + turbNoise);
        let windOffsetZ = grass.windDir.y * grass.windStrength * heightInfluence *
                          (windWave * 0.7 + windNoise * 0.3 + turbNoise);

        localPos.x += windOffsetX;
        localPos.z += windOffsetZ;

        // Slight vertical compression when bent (based on total bend)
        let totalBend = length(vec2f(naturalBendX + windOffsetX, naturalBendZ + windOffsetZ));
        localPos.y *= 1.0 - totalBend * 0.15;

        // World position
        let worldPos = localPos + instancePos;

        // Calculate normal (approximation for grass blade)
        // Normal points outward from center of blade, more upward at base
        var normal = vec3f(
          -sinR * (0.5 + heightFromBase * 0.5),
          1.0 - heightFromBase * 0.5,
          cosR * (0.5 + heightFromBase * 0.5)
        );
        normal = normalize(normal);

        // Perturb normal based on total bend (natural + wind)
        normal.x += (naturalBendX + windOffsetX) * 0.5;
        normal.z += (naturalBendZ + windOffsetZ) * 0.5;
        normal = normalize(normal);

        let viewPos = scene.viewMatrix * vec4f(worldPos, 1.0);
        let clipPos = scene.projectionMatrix * viewPos;

        output.position = clipPos;
        output.currentClip = clipPos;
        output.prevClip = scene.prevViewProj * vec4f(worldPos, 1.0);
        output.worldPosition = worldPos;
        output.worldNormal = normal;
        output.uv = input.uv;

        // Color variation based on height (darker at base, lighter at tip)
        let heightGradient = mix(0.6, 1.0, heightFromBase);
        output.color = baseColor * heightGradient;

        return output;
      }
    `;
  }
  getFragmentShaderCode() {
    return `
      @group(1) @binding(1) var bladeTexture: texture_2d<f32>;
      @group(1) @binding(2) var bladeSampler: sampler;

      struct FragmentInput {
        @location(0) worldNormal: vec3f,
        @location(1) uv: vec2f,
        @location(2) worldPosition: vec3f,
        @location(3) currentClip: vec4f,
        @location(4) prevClip: vec4f,
        @location(5) color: vec3f,
      }

      struct FragmentOutput {
        @location(0) albedo: vec4f,    // RGB = Color, A = Roughness
        @location(1) normal: vec4f,    // RGB = Normal, A = Metalness
        @location(2) position: vec4f,  // RGB = World Position, A = Occlusion
        @location(3) emissive: vec4f,  // RGB = Emissive, A = Unused
        @location(4) velocity: vec2f,  // RG = Velocity
      }

      @fragment
      fn fs_main(input: FragmentInput) -> FragmentOutput {
        var output: FragmentOutput;

        // Sample blade texture
        let texColor = textureSample(bladeTexture, bladeSampler, input.uv);

        // Alpha test - discard fully transparent pixels
        if (texColor.a < 0.1) {
          discard;
        }

        // Blend texture color with instance color
        // Texture provides shape and base coloring, instance provides variation
        let finalColor = texColor.rgb * input.color * 1.5;

        // Grass is not metallic, fairly rough
        let roughness = 0.8;
        let metallic = 0.0;
        let occlusion = mix(0.7, 1.0, input.uv.y); // Darker at base

        // Normalize the normal
        let N = normalize(input.worldNormal);

        // Velocity for TAA
        let currentNDC = input.currentClip.xy / input.currentClip.w;
        let prevNDC = input.prevClip.xy / input.prevClip.w;
        let velocity = (currentNDC - prevNDC) * 0.5;

        output.albedo = vec4f(finalColor, roughness);
        output.normal = vec4f(N * 0.5 + 0.5, metallic);
        output.position = vec4f(input.worldPosition, occlusion);
        output.emissive = vec4f(0.0, 0.0, 0.0, 1.0);
        output.velocity = vec2f(velocity.x, -velocity.y);

        return output;
      }
    `;
  }
  static getBillboardVertices() {
    return new Float32Array([
      -0.5,
      0,
      0,
      0,
      1,
      0.5,
      0,
      0,
      1,
      1,
      0.5,
      1,
      0,
      1,
      0,
      -0.5,
      0,
      0,
      0,
      1,
      0.5,
      1,
      0,
      1,
      0,
      -0.5,
      1,
      0,
      0,
      0
    ]);
  }
  static getGeometryVertices(segments, curvature) {
    const vertices = [];
    for (let i = 0;i <= segments; i++) {
      const t = i / segments;
      const y = t;
      const width = 1 - t * 0.8;
      const curve = curvature * t * t;
      vertices.push(-0.5 * width, y, curve, 0, 1 - t);
      vertices.push(0.5 * width, y, curve, 1, 1 - t);
    }
    return new Float32Array(vertices);
  }
  static getGeometryIndices(segments) {
    const indices = [];
    for (let i = 0;i < segments; i++) {
      const bl = i * 2;
      const br = i * 2 + 1;
      const tl = (i + 1) * 2;
      const tr = (i + 1) * 2 + 1;
      indices.push(bl, br, tr);
      indices.push(bl, tr, tl);
    }
    return new Uint16Array(indices);
  }
  destroy() {
    this.vertexBuffer?.destroy();
    this.indexBuffer?.destroy();
    this.instanceBuffer?.destroy();
    this.uniformBuffer?.destroy();
    this.vertexBuffer = null;
    this.indexBuffer = null;
    this.instanceBuffer = null;
    this.uniformBuffer = null;
    this.pipeline = null;
    this.bindGroup = null;
    this.bindGroupLayout = null;
    this.instanceData = null;
    this.device = null;
    this.initialized = false;
  }
}

// ../../src/core/procedural/grass/GrassTextureGenerator.ts
var DEFAULT_GRASS_TEXTURE_CONFIG = {
  width: 256,
  height: 256,
  bladeCount: 12,
  baseColor: { r: 0.15, g: 0.35, b: 0.08 },
  tipColor: { r: 0.3, g: 0.55, b: 0.15 },
  colorVariation: 0.15,
  bladeWidth: 8,
  curvature: 0.4,
  seed: 12345,
  noisy: true
};
function createRng(seed) {
  return function() {
    let t = seed += 1831565813;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}

class GrassTextureGenerator {
  config;
  constructor(config = {}) {
    this.config = { ...DEFAULT_GRASS_TEXTURE_CONFIG, ...config };
  }
  generate() {
    const { width, height } = this.config;
    const imageData = new ImageData(width, height);
    const data = imageData.data;
    for (let i = 0;i < data.length; i += 4) {
      data[i] = 0;
      data[i + 1] = 0;
      data[i + 2] = 0;
      data[i + 3] = 0;
    }
    const rng = createRng(this.config.seed);
    for (let b = 0;b < this.config.bladeCount; b++) {
      this.drawBlade(data, width, height, rng);
    }
    return imageData;
  }
  generateTexture(device) {
    const imageData = this.generate();
    const texture = device.createTexture({
      label: "Grass Blade Texture",
      size: [this.config.width, this.config.height],
      format: "rgba8unorm",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
    });
    device.queue.writeTexture({ texture }, imageData.data, { bytesPerRow: this.config.width * 4 }, { width: this.config.width, height: this.config.height });
    return texture;
  }
  drawBlade(data, width, height, rng) {
    const { baseColor, tipColor, colorVariation, bladeWidth, curvature, noisy } = this.config;
    const startX = width * 0.1 + rng() * width * 0.8;
    const bladeHeight = 0.6 + rng() * 0.4;
    const curveDir = (rng() - 0.5) * 2;
    const curveAmount = curvature * (0.5 + rng() * 0.5);
    const thisBladeWidth = bladeWidth * (0.5 + rng() * 0.5);
    const colorMult = 1 + (rng() - 0.5) * colorVariation * 2;
    const maxY = Math.floor(height * bladeHeight);
    for (let y = height - 1;y >= height - maxY; y--) {
      const normalizedY = (height - 1 - y) / maxY;
      const curveOffset = curveDir * curveAmount * width * 0.3 * normalizedY * normalizedY;
      const centerX = startX + curveOffset;
      const widthAtY = thisBladeWidth * (1 - normalizedY * 0.85);
      const leftX = Math.floor(centerX - widthAtY / 2);
      const rightX = Math.ceil(centerX + widthAtY / 2);
      for (let x = leftX;x <= rightX; x++) {
        if (x < 0 || x >= width)
          continue;
        const distFromCenter = Math.abs(x - centerX) / (widthAtY / 2 + 0.001);
        let alpha = 1 - Math.pow(distFromCenter, 2);
        alpha = Math.max(0, Math.min(1, alpha));
        if (normalizedY > 0.85) {
          alpha *= 1 - (normalizedY - 0.85) / 0.15;
        }
        if (noisy) {
          alpha *= 0.85 + rng() * 0.15;
        }
        if (alpha <= 0)
          continue;
        const r = baseColor.r + (tipColor.r - baseColor.r) * normalizedY;
        const g = baseColor.g + (tipColor.g - baseColor.g) * normalizedY;
        const b = baseColor.b + (tipColor.b - baseColor.b) * normalizedY;
        const finalR = Math.max(0, Math.min(1, r * colorMult));
        const finalG = Math.max(0, Math.min(1, g * colorMult));
        const finalB = Math.max(0, Math.min(1, b * colorMult));
        const idx = (y * width + x) * 4;
        const existingAlpha = data[idx + 3] / 255;
        const newAlpha = alpha;
        const outAlpha = newAlpha + existingAlpha * (1 - newAlpha);
        if (outAlpha > 0) {
          data[idx] = Math.round((finalR * 255 * newAlpha + data[idx] * existingAlpha * (1 - newAlpha)) / outAlpha);
          data[idx + 1] = Math.round((finalG * 255 * newAlpha + data[idx + 1] * existingAlpha * (1 - newAlpha)) / outAlpha);
          data[idx + 2] = Math.round((finalB * 255 * newAlpha + data[idx + 2] * existingAlpha * (1 - newAlpha)) / outAlpha);
          data[idx + 3] = Math.round(outAlpha * 255);
        }
      }
    }
  }
  getConfig() {
    return { ...this.config };
  }
  setConfig(config) {
    this.config = { ...this.config, ...config };
  }
}

// ../../src/core/procedural/grass/Grass.ts
var DEFAULT_GRASS_CONFIG = {
  densityMode: true,
  blade: {
    height: { min: 0.3, max: 0.8 },
    width: { min: 0.02, max: 0.05 },
    segments: 3,
    curvature: 0.3
  },
  colorVariation: 0.1,
  wind: {
    enabled: true,
    direction: { x: 1, z: 0 },
    strength: 0.5,
    speed: 1,
    turbulence: 0.3
  },
  renderMode: "billboard",
  bladesPerTexture: 8,
  maxDistance: 100,
  lodDistances: [20, 50, 80],
  seed: 12345,
  curvature: 0.8
};
function createRng2(seed) {
  return function() {
    let t = seed += 1831565813;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}

class Grass extends Node {
  config;
  device = null;
  initialized = false;
  renderer = null;
  instances = [];
  globalResources = null;
  heightMapData = null;
  heightMapWidth = 0;
  heightMapHeight = 0;
  constructor(config) {
    super();
    this.config = { ...DEFAULT_GRASS_CONFIG, ...config };
    if (config.blade) {
      this.config.blade = { ...DEFAULT_GRASS_CONFIG.blade, ...config.blade };
    }
    if (config.wind) {
      this.config.wind = { ...DEFAULT_GRASS_CONFIG.wind, ...config.wind };
    }
  }
  async init(device, globalResources) {
    this.device = device;
    this.globalResources = globalResources || null;
    let sceneBindGroupLayout;
    if (globalResources?.renderBindGroupLayout) {
      sceneBindGroupLayout = globalResources.renderBindGroupLayout;
    } else {
      sceneBindGroupLayout = device.createBindGroupLayout({
        label: "Grass Scene Bind Group Layout (Standalone)",
        entries: [
          {
            binding: 0,
            visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
            buffer: { type: "uniform" }
          }
        ]
      });
    }
    const textureGenerator = new GrassTextureGenerator({
      width: 256,
      height: 256,
      bladeCount: this.config.bladesPerTexture || 8,
      baseColor: {
        r: this.config.color.x * 0.7,
        g: this.config.color.y * 0.7,
        b: this.config.color.z * 0.7
      },
      tipColor: {
        r: Math.min(1, this.config.color.x * 1.3),
        g: Math.min(1, this.config.color.y * 1.3),
        b: Math.min(1, this.config.color.z * 1.3)
      },
      colorVariation: this.config.colorVariation || 0.15,
      bladeWidth: 12,
      curvature: 0.5,
      seed: this.config.seed || 12345,
      noisy: true,
      ...this.config.texture
    });
    const bladeTexture = textureGenerator.generateTexture(device);
    const bladeCount = this.getBladeCount();
    const maxInstances = Math.max(bladeCount, 500000);
    this.renderer = new GrassRenderer({
      maxInstances,
      verticesPerBlade: this.config.renderMode === "billboard" ? 6 : (this.config.blade.segments + 1) * 2,
      alphaToCoverage: true,
      mode: this.config.renderMode === "geometry" ? "geometry" : "billboard",
      segments: this.config.blade.segments || 3,
      curvature: this.config.blade.curvature || 0.3
    });
    this.renderer.init(device, sceneBindGroupLayout, bladeTexture);
    this.generateInstances();
    this.renderer.uploadInstances(this.instances);
    this.initialized = true;
    console.log(`Grass: Initialized with ${this.instances.length} blades`);
  }
  generateInstances() {
    const rng = createRng2(this.config.seed || 12345);
    const width = this.config.area.width;
    const depth = this.config.area.depth;
    const offset = this.config.offset || new Vector3(0, 0, 0);
    const area = width * depth;
    const totalBlades = Math.floor(this.config.density * area);
    this.instances = [];
    for (let i = 0;i < totalBlades; i++) {
      const x = (rng() - 0.5) * width + offset.x;
      const z = (rng() - 0.5) * depth + offset.z;
      const y = this.getHeightAtLocal(x - offset.x, z - offset.z) + offset.y;
      const rotation = rng() * Math.PI * 2;
      const heightRange = this.config.blade.height.max - this.config.blade.height.min;
      const height = this.config.blade.height.min + rng() * heightRange;
      const widthRange = this.config.blade.width.max - this.config.blade.width.min;
      const bladeWidth = this.config.blade.width.min + rng() * widthRange;
      const colorVar = this.config.colorVariation || 0;
      const colorMult = 1 + (rng() - 0.5) * colorVar * 2;
      const color = new Vector3(Math.max(0, Math.min(1, this.config.color.x * colorMult)), Math.max(0, Math.min(1, this.config.color.y * colorMult)), Math.max(0, Math.min(1, this.config.color.z * colorMult)));
      const random = rng();
      this.instances.push({
        position: new Vector3(x, y, z),
        rotation,
        scale: height * bladeWidth * 10,
        color,
        random
      });
    }
  }
  getHeightAtLocal(x, z) {
    if (!this.heightMapData || this.heightMapWidth === 0 || this.heightMapHeight === 0) {
      return 0;
    }
    const halfWidth = this.config.area.width / 2;
    const halfDepth = this.config.area.depth / 2;
    const u = (x + halfWidth) / this.config.area.width;
    const v = (z + halfDepth) / this.config.area.depth;
    const clampedU = Math.max(0, Math.min(1, u));
    const clampedV = Math.max(0, Math.min(1, v));
    const px = clampedU * (this.heightMapWidth - 1);
    const py = clampedV * (this.heightMapHeight - 1);
    const x0 = Math.floor(px);
    const y0 = Math.floor(py);
    const x1 = Math.min(x0 + 1, this.heightMapWidth - 1);
    const y1 = Math.min(y0 + 1, this.heightMapHeight - 1);
    const fx = px - x0;
    const fy = py - y0;
    const h00 = this.heightMapData[y0 * this.heightMapWidth + x0];
    const h10 = this.heightMapData[y0 * this.heightMapWidth + x1];
    const h01 = this.heightMapData[y1 * this.heightMapWidth + x0];
    const h11 = this.heightMapData[y1 * this.heightMapWidth + x1];
    const h0 = h00 * (1 - fx) + h10 * fx;
    const h1 = h01 * (1 - fx) + h11 * fx;
    return h0 * (1 - fy) + h1 * fy;
  }
  setHeightMap(data, width, height) {
    this.heightMapData = data;
    this.heightMapWidth = width;
    this.heightMapHeight = height;
    if (this.initialized) {
      this.generateInstances();
      this.renderer?.uploadInstances(this.instances);
    }
  }
  update(time, cameraPosition) {
    if (!this.initialized || !this.device || !this.renderer)
      return;
    const wind = this.config.wind;
    this.renderer.updateUniforms(new Float32Array(16), cameraPosition || new Vector3(0, 0, 0), time, wind.enabled ? wind.direction : { x: 0, z: 0 }, wind.enabled ? wind.strength : 0, wind.speed, wind.turbulence, this.config.curvature || 0.5);
  }
  render(passEncoder, globalBindGroup) {
    if (!this.initialized || !this.renderer)
      return;
    const bindGroup = globalBindGroup || this.globalResources?.renderBindGroup;
    if (!bindGroup) {
      console.warn("Grass.render: No bind group available");
      return;
    }
    this.renderer.render(passEncoder, bindGroup);
  }
  getGlobalResources() {
    return this.globalResources;
  }
  getRenderer() {
    return this.renderer;
  }
  setDensity(density) {
    this.config.density = Math.max(0, density);
    if (this.initialized) {
      this.regenerate();
    }
  }
  async setTextureFromURL(url) {
    if (!this.device || !this.renderer)
      return;
    const img = new Image;
    img.crossOrigin = "anonymous";
    await new Promise((resolve, reject) => {
      img.onload = () => resolve();
      img.onerror = () => reject(new Error("Failed to load image"));
      img.src = url;
    });
    const imageBitmap = await createImageBitmap(img);
    const texture = this.device.createTexture({
      label: `Grass Texture: ${url.slice(0, 50)}`,
      size: [imageBitmap.width, imageBitmap.height],
      format: "rgba8unorm",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
    });
    this.device.queue.copyExternalImageToTexture({ source: imageBitmap }, { texture }, [imageBitmap.width, imageBitmap.height]);
    this.renderer.setBladeTexture(texture);
    console.log(`Grass: Set custom texture (${imageBitmap.width}x${imageBitmap.height})`);
  }
  resetToProceduralTexture() {
    if (!this.device || !this.renderer)
      return;
    const textureGenerator = new GrassTextureGenerator({
      width: 256,
      height: 256,
      bladeCount: this.config.bladesPerTexture || 8,
      baseColor: {
        r: this.config.color.x * 0.7,
        g: this.config.color.y * 0.7,
        b: this.config.color.z * 0.7
      },
      tipColor: {
        r: Math.min(1, this.config.color.x * 1.3),
        g: Math.min(1, this.config.color.y * 1.3),
        b: Math.min(1, this.config.color.z * 1.3)
      },
      colorVariation: this.config.colorVariation || 0.15,
      bladeWidth: 12,
      curvature: 0.5,
      seed: this.config.seed || 12345,
      noisy: true,
      ...this.config.texture
    });
    const bladeTexture = textureGenerator.generateTexture(this.device);
    this.renderer.setBladeTexture(bladeTexture);
    console.log("Grass: Reset to procedural texture");
  }
  setWind(wind) {
    this.config.wind = { ...this.config.wind, ...wind };
  }
  setCurvature(curvature) {
    this.config.curvature = Math.max(0, Math.min(2, curvature));
  }
  setColor(color) {
    this.config.color = color;
    if (this.initialized) {
      for (const inst of this.instances) {
        const colorVar = this.config.colorVariation || 0;
        const rng = createRng2(Math.floor(inst.random * 1e4));
        const colorMult = 1 + (rng() - 0.5) * colorVar * 2;
        inst.color = new Vector3(Math.max(0, Math.min(1, color.x * colorMult)), Math.max(0, Math.min(1, color.y * colorMult)), Math.max(0, Math.min(1, color.z * colorMult)));
      }
      this.renderer?.uploadInstances(this.instances);
    }
  }
  setConfig(config) {
    const needsRegenerate = config.area !== undefined || config.density !== undefined || config.blade !== undefined || config.seed !== undefined;
    this.config = { ...this.config, ...config };
    if (config.blade) {
      this.config.blade = { ...this.config.blade, ...config.blade };
    }
    if (config.wind) {
      this.config.wind = { ...this.config.wind, ...config.wind };
    }
    if (this.initialized && needsRegenerate) {
      console.log(`Grass.setConfig: regenerating with area=${this.config.area.width}x${this.config.area.depth}, density=${this.config.density}`);
      this.regenerate();
    }
  }
  async regenerate() {
    if (!this.device || !this.renderer)
      return;
    this.generateInstances();
    this.renderer.uploadInstances(this.instances);
    console.log(`Grass: Regenerated with ${this.instances.length} blades`);
  }
  getConfig() {
    return { ...this.config };
  }
  getBladeCount() {
    const area = this.config.area.width * this.config.area.depth;
    return Math.floor(this.config.density * area);
  }
  getInstanceCount() {
    return this.renderer?.getInstanceCount() || 0;
  }
  getDensityAt(_x, _z) {
    return 1;
  }
  destroy() {
    this.renderer?.destroy();
    this.renderer = null;
    this.globalResources = null;
    this.instances = [];
    this.device = null;
    this.initialized = false;
  }
}

// ../../src/core/procedural/flowers/FlowerTextureGenerator.ts
var DEFAULT_FLOWER_TEXTURE_CONFIG = {
  width: 64,
  height: 64,
  flowerType: "daisy",
  petalCount: 8,
  petalColor: { r: 1, g: 1, b: 1 },
  centerColor: { r: 1, g: 0.8, b: 0.2 },
  stemColor: { r: 0.2, g: 0.5, b: 0.15 },
  colorVariation: 0.1,
  seed: 12345
};
function createRng3(seed) {
  return function() {
    let t = seed += 1831565813;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}

class FlowerTextureGenerator {
  config;
  constructor(config = {}) {
    this.config = { ...DEFAULT_FLOWER_TEXTURE_CONFIG, ...config };
  }
  generateTexture(device) {
    const { width, height } = this.config;
    const data = new Uint8Array(width * height * 4);
    this.drawFlower(data, width, height);
    const texture = device.createTexture({
      label: `Flower Texture (${this.config.flowerType})`,
      size: [width, height],
      format: "rgba8unorm",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
    });
    device.queue.writeTexture({ texture }, data, { bytesPerRow: width * 4 }, { width, height });
    return texture;
  }
  drawFlower(data, width, height) {
    const rng = createRng3(this.config.seed);
    const centerX = width / 2;
    const centerY = height * 0.35;
    for (let i = 0;i < data.length; i += 4) {
      data[i] = 0;
      data[i + 1] = 0;
      data[i + 2] = 0;
      data[i + 3] = 0;
    }
    this.drawStem(data, width, height, centerX, centerY, rng);
    switch (this.config.flowerType) {
      case "daisy":
        this.drawDaisy(data, width, height, centerX, centerY, rng);
        break;
      case "poppy":
        this.drawPoppy(data, width, height, centerX, centerY, rng);
        break;
      case "dandelion":
        this.drawDandelion(data, width, height, centerX, centerY, rng);
        break;
      case "bluebell":
        this.drawBluebell(data, width, height, centerX, centerY, rng);
        break;
      case "tulip":
        this.drawTulip(data, width, height, centerX, centerY, rng);
        break;
      case "wildflower":
        this.drawWildflower(data, width, height, centerX, centerY, rng);
        break;
    }
  }
  drawStem(data, width, height, topX, topY, rng) {
    const stemWidth = Math.max(1, width * 0.06);
    const stemTop = topY + height * 0.08;
    const stemBottom = height - 2;
    for (let y = Math.floor(stemTop);y < stemBottom; y++) {
      const t = (y - stemTop) / (stemBottom - stemTop);
      const curve = Math.sin(t * Math.PI * 0.5) * width * 0.05;
      const x = topX + curve;
      const stemWidthAtY = stemWidth * (1 - t * 0.3);
      for (let dx = -stemWidthAtY;dx <= stemWidthAtY; dx++) {
        const px = Math.floor(x + dx);
        if (px >= 0 && px < width && y >= 0 && y < height) {
          const idx = (y * width + px) * 4;
          const colorVar = (rng() - 0.5) * this.config.colorVariation;
          data[idx] = Math.floor((this.config.stemColor.r + colorVar) * 255);
          data[idx + 1] = Math.floor((this.config.stemColor.g + colorVar) * 255);
          data[idx + 2] = Math.floor((this.config.stemColor.b + colorVar) * 255);
          data[idx + 3] = 255;
        }
      }
    }
  }
  drawDaisy(data, width, height, centerX, centerY, rng) {
    const petalLength = height * 0.25;
    const petalWidth = width * 0.08;
    const centerRadius = height * 0.08;
    for (let i = 0;i < this.config.petalCount; i++) {
      const angle = i / this.config.petalCount * Math.PI * 2 + rng() * 0.2;
      this.drawPetal(data, width, height, centerX, centerY, angle, petalLength, petalWidth, rng);
    }
    this.drawCircle(data, width, height, centerX, centerY, centerRadius, this.config.centerColor, rng);
  }
  drawPoppy(data, width, height, centerX, centerY, rng) {
    const petalRadius = height * 0.28;
    const centerRadius = height * 0.06;
    for (let i = 0;i < 5; i++) {
      const angle = i / 5 * Math.PI * 2 + rng() * 0.3;
      const px = centerX + Math.cos(angle) * petalRadius * 0.4;
      const py = centerY + Math.sin(angle) * petalRadius * 0.4;
      this.drawCircle(data, width, height, px, py, petalRadius * 0.8, this.config.petalColor, rng);
    }
    this.drawCircle(data, width, height, centerX, centerY, centerRadius, { r: 0.1, g: 0.1, b: 0.1 }, rng);
  }
  drawDandelion(data, width, height, centerX, centerY, rng) {
    const radius = height * 0.3;
    const seedCount = 30;
    for (let i = 0;i < seedCount; i++) {
      const angle = rng() * Math.PI * 2;
      const dist = rng() * radius;
      const px = centerX + Math.cos(angle) * dist;
      const py = centerY + Math.sin(angle) * dist;
      const seedRadius = 1 + rng() * 2;
      const brightness = 0.9 + rng() * 0.1;
      this.drawCircle(data, width, height, px, py, seedRadius, { r: brightness, g: brightness, b: brightness }, rng);
    }
  }
  drawBluebell(data, width, height, centerX, centerY, rng) {
    const bellWidth = width * 0.3;
    const bellHeight = height * 0.25;
    for (let y = Math.floor(centerY - bellHeight * 0.3);y < centerY + bellHeight; y++) {
      const t = (y - (centerY - bellHeight * 0.3)) / (bellHeight * 1.3);
      const widthAtY = bellWidth * (0.3 + t * 0.7) * Math.sqrt(1 - Math.pow(t - 0.7, 2) / 0.5);
      for (let x = Math.floor(centerX - widthAtY);x < centerX + widthAtY; x++) {
        if (x >= 0 && x < width && y >= 0 && y < height) {
          const idx = (y * width + x) * 4;
          const colorVar = (rng() - 0.5) * this.config.colorVariation;
          data[idx] = Math.floor((this.config.petalColor.r * 0.3 + colorVar) * 255);
          data[idx + 1] = Math.floor((this.config.petalColor.g * 0.4 + colorVar) * 255);
          data[idx + 2] = Math.floor((this.config.petalColor.b * 1 + colorVar) * 255);
          data[idx + 3] = 255;
        }
      }
    }
  }
  drawTulip(data, width, height, centerX, centerY, rng) {
    const tulipWidth = width * 0.25;
    const tulipHeight = height * 0.35;
    for (let y = Math.floor(centerY - tulipHeight * 0.5);y < centerY + tulipHeight * 0.5; y++) {
      const t = (y - (centerY - tulipHeight * 0.5)) / tulipHeight;
      const shape = Math.sin(t * Math.PI) * 0.7 + 0.3;
      const widthAtY = tulipWidth * shape;
      for (let x = Math.floor(centerX - widthAtY);x < centerX + widthAtY; x++) {
        if (x >= 0 && x < width && y >= 0 && y < height) {
          const idx = (y * width + x) * 4;
          const colorVar = (rng() - 0.5) * this.config.colorVariation;
          const edgeFactor = Math.abs(x - centerX) / widthAtY;
          const shade = 1 - edgeFactor * 0.3;
          data[idx] = Math.floor((this.config.petalColor.r * shade + colorVar) * 255);
          data[idx + 1] = Math.floor((this.config.petalColor.g * shade + colorVar) * 255);
          data[idx + 2] = Math.floor((this.config.petalColor.b * shade + colorVar) * 255);
          data[idx + 3] = 255;
        }
      }
    }
  }
  drawWildflower(data, width, height, centerX, centerY, rng) {
    const petalLength = height * 0.2;
    const petalWidth = width * 0.1;
    const centerRadius = height * 0.06;
    for (let i = 0;i < 5; i++) {
      const angle = i / 5 * Math.PI * 2 - Math.PI / 2;
      this.drawPetal(data, width, height, centerX, centerY, angle, petalLength, petalWidth, rng);
    }
    this.drawCircle(data, width, height, centerX, centerY, centerRadius, { r: 1, g: 0.9, b: 0.3 }, rng);
  }
  drawPetal(data, width, height, cx, cy, angle, length, petalWidth, rng) {
    const steps = Math.ceil(length);
    for (let i = 0;i < steps; i++) {
      const t = i / steps;
      const x = cx + Math.cos(angle) * length * t;
      const y = cy + Math.sin(angle) * length * t;
      const w = petalWidth * Math.sin(t * Math.PI);
      this.drawCircle(data, width, height, x, y, w, this.config.petalColor, rng);
    }
  }
  drawCircle(data, width, height, cx, cy, radius, color, rng) {
    const r2 = radius * radius;
    for (let y = Math.floor(cy - radius);y <= Math.ceil(cy + radius); y++) {
      for (let x = Math.floor(cx - radius);x <= Math.ceil(cx + radius); x++) {
        if (x >= 0 && x < width && y >= 0 && y < height) {
          const dx = x - cx;
          const dy = y - cy;
          const d2 = dx * dx + dy * dy;
          if (d2 < r2) {
            const idx = (y * width + x) * 4;
            const colorVar = (rng() - 0.5) * this.config.colorVariation;
            const edge = 1 - Math.sqrt(d2) / radius;
            const alpha = Math.min(1, edge * 2);
            data[idx] = Math.floor(Math.min(255, (color.r + colorVar) * 255));
            data[idx + 1] = Math.floor(Math.min(255, (color.g + colorVar) * 255));
            data[idx + 2] = Math.floor(Math.min(255, (color.b + colorVar) * 255));
            data[idx + 3] = Math.max(data[idx + 3], Math.floor(alpha * 255));
          }
        }
      }
    }
  }
  setConfig(config) {
    this.config = { ...this.config, ...config };
  }
  getConfig() {
    return { ...this.config };
  }
  static getFlowerPreset(type) {
    switch (type) {
      case "daisy":
        return {
          petalCount: 12,
          petalColor: { r: 1, g: 1, b: 1 },
          centerColor: { r: 1, g: 0.85, b: 0.2 }
        };
      case "poppy":
        return {
          petalCount: 4,
          petalColor: { r: 0.9, g: 0.15, b: 0.1 },
          centerColor: { r: 0.1, g: 0.1, b: 0.1 }
        };
      case "dandelion":
        return {
          petalCount: 30,
          petalColor: { r: 1, g: 1, b: 0.95 },
          centerColor: { r: 0.95, g: 0.95, b: 0.9 }
        };
      case "bluebell":
        return {
          petalCount: 1,
          petalColor: { r: 0.3, g: 0.4, b: 0.9 },
          centerColor: { r: 0.2, g: 0.3, b: 0.7 }
        };
      case "tulip":
        return {
          petalCount: 6,
          petalColor: { r: 0.9, g: 0.2, b: 0.4 },
          centerColor: { r: 0.8, g: 0.15, b: 0.3 }
        };
      case "wildflower":
        return {
          petalCount: 5,
          petalColor: { r: 0.8, g: 0.3, b: 0.7 },
          centerColor: { r: 1, g: 0.9, b: 0.3 }
        };
    }
  }
}

// ../../src/core/procedural/flowers/Flower.ts
var DEFAULT_FLOWER_CONFIG = {
  area: { width: 50, depth: 50 },
  density: 0.5,
  densityMode: true,
  flowerTypes: ["daisy", "poppy", "wildflower"],
  scale: { min: 0.3, max: 0.8 },
  windEnabled: true,
  windStrength: 0.3,
  seed: 54321
};
function createRng4(seed) {
  return function() {
    let t = seed += 1831565813;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}

class Flower extends Node {
  config;
  device = null;
  initialized = false;
  renderers = new Map;
  instances = new Map;
  textures = new Map;
  globalResources = null;
  constructor(config = {}) {
    super("FlowerField");
    this.config = { ...DEFAULT_FLOWER_CONFIG, ...config };
  }
  async init(device, globalResources) {
    if (this.initialized)
      return;
    this.device = device;
    this.globalResources = globalResources || null;
    let sceneBindGroupLayout;
    if (globalResources?.renderBindGroupLayout) {
      sceneBindGroupLayout = globalResources.renderBindGroupLayout;
    } else {
      sceneBindGroupLayout = device.createBindGroupLayout({
        label: "Flower Scene Bind Group Layout (Standalone)",
        entries: [
          {
            binding: 0,
            visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
            buffer: { type: "uniform" }
          }
        ]
      });
    }
    for (const flowerType of this.config.flowerTypes) {
      const preset = FlowerTextureGenerator.getFlowerPreset(flowerType);
      const textureGenerator = new FlowerTextureGenerator({
        width: 64,
        height: 64,
        flowerType,
        seed: this.config.seed,
        ...preset
      });
      const texture = textureGenerator.generateTexture(device);
      this.textures.set(flowerType, texture);
      const renderer = new GrassRenderer({
        maxInstances: 1e5,
        verticesPerBlade: 6,
        alphaToCoverage: true,
        mode: "billboard",
        segments: 1,
        curvature: 0
      });
      renderer.init(device, sceneBindGroupLayout, texture);
      this.renderers.set(flowerType, renderer);
      this.instances.set(flowerType, []);
    }
    this.generateInstances();
    for (const [flowerType, instances] of this.instances) {
      const renderer = this.renderers.get(flowerType);
      if (renderer) {
        renderer.uploadInstances(instances);
      }
    }
    this.initialized = true;
    const totalFlowers = Array.from(this.instances.values()).reduce((sum, arr) => sum + arr.length, 0);
    console.log(`Flower: Initialized with ${totalFlowers} flowers across ${this.config.flowerTypes.length} types`);
  }
  generateInstances() {
    const rng = createRng4(this.config.seed || 54321);
    const width = this.config.area.width;
    const depth = this.config.area.depth;
    const offset = this.config.offset || new Vector3(0, 0, 0);
    const area = width * depth;
    const totalFlowers = this.config.densityMode ? Math.floor(this.config.density * area) : this.config.density;
    for (const instances of this.instances.values()) {
      instances.length = 0;
    }
    for (let i = 0;i < totalFlowers; i++) {
      const x = (rng() - 0.5) * width + offset.x;
      const z = (rng() - 0.5) * depth + offset.z;
      const y = this.config.heightSampler ? this.config.heightSampler(x, z) + offset.y : offset.y;
      const flowerType = this.config.flowerTypes[Math.floor(rng() * this.config.flowerTypes.length)];
      const rotation = rng() * Math.PI * 2;
      const scaleRange = this.config.scale.max - this.config.scale.min;
      const scale = this.config.scale.min + rng() * scaleRange;
      const colorVar = 0.9 + rng() * 0.2;
      const color = new Vector3(colorVar, colorVar, colorVar);
      const instance = {
        position: new Vector3(x, y, z),
        rotation,
        scale,
        color,
        random: rng()
      };
      const instances = this.instances.get(flowerType);
      if (instances) {
        instances.push(instance);
      }
    }
  }
  update(time, cameraPosition) {
    if (!this.initialized || !this.device)
      return;
    const windDir = { x: 1, z: 0.5 };
    const windStrength = this.config.windEnabled ? this.config.windStrength || 0.3 : 0;
    for (const renderer of this.renderers.values()) {
      renderer.updateUniforms(new Float32Array(16), cameraPosition || new Vector3(0, 0, 0), time, windDir, windStrength, 1, 0.2, 0.1);
    }
  }
  render(passEncoder, globalBindGroup) {
    if (!this.initialized)
      return;
    const bindGroup = globalBindGroup || this.globalResources?.renderBindGroup;
    if (!bindGroup) {
      console.warn("Flower.render: No bind group available");
      return;
    }
    for (const renderer of this.renderers.values()) {
      renderer.render(passEncoder, bindGroup);
    }
  }
  getFlowerCount() {
    let total = 0;
    for (const instances of this.instances.values()) {
      total += instances.length;
    }
    return total;
  }
  setDensity(density) {
    this.config.density = Math.max(0, density);
    if (this.initialized) {
      this.regenerate();
    }
  }
  setConfig(config) {
    const needsRegenerate = config.area !== undefined || config.density !== undefined || config.flowerTypes !== undefined || config.scale !== undefined || config.seed !== undefined;
    this.config = { ...this.config, ...config };
    if (this.initialized && needsRegenerate) {
      this.regenerate();
    }
  }
  regenerate() {
    if (!this.device)
      return;
    this.generateInstances();
    for (const [flowerType, instances] of this.instances) {
      const renderer = this.renderers.get(flowerType);
      if (renderer) {
        renderer.uploadInstances(instances);
      }
    }
    console.log(`Flower: Regenerated with ${this.getFlowerCount()} flowers`);
  }
  getConfig() {
    return { ...this.config };
  }
  destroy() {
    for (const renderer of this.renderers.values()) {
      renderer.destroy();
    }
    for (const texture of this.textures.values()) {
      texture.destroy();
    }
    this.renderers.clear();
    this.instances.clear();
    this.textures.clear();
    this.globalResources = null;
    this.device = null;
    this.initialized = false;
  }
}

// ../../src/loaders/GLBLoader.ts
var GLB_MAGIC = 1179937895;
var GLB_VERSION = 2;
var GLB_CHUNK_TYPE_JSON = 1313821514;
var GLB_CHUNK_TYPE_BIN = 5130562;
var COMPONENT_TYPES = {
  5120: { size: 1, array: Int8Array },
  5121: { size: 1, array: Uint8Array },
  5122: { size: 2, array: Int16Array },
  5123: { size: 2, array: Uint16Array },
  5125: { size: 4, array: Uint32Array },
  5126: { size: 4, array: Float32Array }
};
var TYPE_SIZES = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
var DRACO_WORKER_CODE = `
let dracoModule = null;
let dracoDecoder = null;
let initPromise = null;
let decoderPath = './draco/';

async function initDraco() {
    if (initPromise) return initPromise;

    initPromise = (async () => {
        try {
            const jsUrl = decoderPath + 'draco_decoder.js';
            const wasmUrl = decoderPath + 'draco_decoder.wasm';

            // Load the decoder JS - use importScripts if available (Web Worker),
            // otherwise fall back to fetch + eval (MystralNative Worker polyfill)
            if (typeof importScripts === 'function') {
                console.log('[Draco Worker] Loading decoder via importScripts (WebWorker)');
                importScripts(jsUrl);
            } else {
                console.warn('[Draco Worker] importScripts not available, falling back to fetch + eval (not compatible with AOT/MystralScript)');
                const jsResponse = await fetch(jsUrl);
                if (!jsResponse.ok) throw new Error('Failed to fetch Draco decoder JS: ' + jsResponse.status);
                const jsCode = await jsResponse.text();
                (0, eval)(jsCode);
            }

            // Load WASM binary
            const wasmResponse = await fetch(wasmUrl);
            if (!wasmResponse.ok) {
                throw new Error('Failed to fetch Draco WASM: ' + wasmResponse.status);
            }
            const wasmBinary = await wasmResponse.arrayBuffer();

            // Initialize Draco module - DracoDecoderModule is now in global scope
            dracoModule = await new Promise((resolve, reject) => {
                DracoDecoderModule({
                    wasmBinary: wasmBinary,
                }).then(resolve).catch(reject);
            });

            dracoDecoder = new dracoModule.Decoder();
        } catch (e) {
            console.error('[Draco Worker] Failed to initialize:', e);
            throw e;
        }
    })();

    return initPromise;
}

function extractFloatAttribute(decoder, geometry, attributeId, numComponents) {
    const attribute = decoder.GetAttributeByUniqueId(geometry, attributeId);
    if (!attribute) return null;

    const numPoints = geometry.num_points();
    const numValues = numPoints * numComponents;
    const array = new dracoModule.DracoFloat32Array();

    decoder.GetAttributeFloatForAllPoints(geometry, attribute, array);

    const result = new Float32Array(numValues);
    for (let i = 0; i < numValues; i++) {
        result[i] = array.GetValue(i);
    }

    dracoModule.destroy(array);
    return result;
}

function extractIndices(decoder, mesh) {
    const numFaces = mesh.num_faces();
    const numIndices = numFaces * 3;
    const indices = new Uint32Array(numIndices);
    const faceArray = new dracoModule.DracoInt32Array();

    for (let i = 0; i < numFaces; i++) {
        decoder.GetFaceFromMesh(mesh, i, faceArray);
        indices[i * 3] = faceArray.GetValue(0);
        indices[i * 3 + 1] = faceArray.GetValue(1);
        indices[i * 3 + 2] = faceArray.GetValue(2);
    }

    dracoModule.destroy(faceArray);
    return indices;
}

async function decodeMesh(compressedData, attributeIds) {
    await initDraco();

    const buffer = new dracoModule.DecoderBuffer();
    buffer.Init(new Int8Array(compressedData), compressedData.byteLength);

    const geometryType = dracoDecoder.GetEncodedGeometryType(buffer);

    let geometry;
    let status;

    if (geometryType === dracoModule.TRIANGULAR_MESH) {
        geometry = new dracoModule.Mesh();
        status = dracoDecoder.DecodeBufferToMesh(buffer, geometry);
    } else if (geometryType === dracoModule.POINT_CLOUD) {
        geometry = new dracoModule.PointCloud();
        status = dracoDecoder.DecodeBufferToPointCloud(buffer, geometry);
    } else {
        dracoModule.destroy(buffer);
        throw new Error('Unknown Draco geometry type');
    }

    if (!status.ok()) {
        dracoModule.destroy(geometry);
        dracoModule.destroy(buffer);
        throw new Error('Draco decode failed: ' + status.error_msg());
    }

    const result = {
        positions: null,
        normals: null,
        uvs: null,
        indices: null
    };

    // Extract attributes using GLTF attribute IDs from the extension
    const posId = attributeIds.POSITION !== undefined ? attributeIds.POSITION : 0;
    result.positions = extractFloatAttribute(dracoDecoder, geometry, posId, 3);

    if (attributeIds.NORMAL !== undefined) {
        result.normals = extractFloatAttribute(dracoDecoder, geometry, attributeIds.NORMAL, 3);
    }

    if (attributeIds.TEXCOORD_0 !== undefined) {
        result.uvs = extractFloatAttribute(dracoDecoder, geometry, attributeIds.TEXCOORD_0, 2);
    }

    if (geometryType === dracoModule.TRIANGULAR_MESH) {
        result.indices = extractIndices(dracoDecoder, geometry);
    }

    dracoModule.destroy(geometry);
    dracoModule.destroy(buffer);

    return result;
}

self.onmessage = async (e) => {
    const { requestId, type, compressedData, attributeIds, path } = e.data;

    if (type === 'init') {
        decoderPath = path || './draco/';
        postMessage({ requestId, success: true });
        return;
    }

    try {
        const result = await decodeMesh(compressedData, attributeIds);

        const transfers = [];
        if (result.positions) transfers.push(result.positions.buffer);
        if (result.normals) transfers.push(result.normals.buffer);
        if (result.uvs) transfers.push(result.uvs.buffer);
        if (result.indices) transfers.push(result.indices.buffer);

        postMessage({
            requestId,
            success: true,
            ...result
        }, transfers);
    } catch (error) {
        postMessage({
            requestId,
            success: false,
            error: error.message || 'Unknown error'
        });
    }
};
`;

class GLBLoader {
  device;
  textures = new Map;
  materials = new Map;
  externalBuffers = new Map;
  options;
  skeletons = new Map;
  nodeToJointIndex = new Map;
  skinnedMeshes = [];
  morphTargetMeshes = [];
  nodeIndexToNode = new Map;
  meshIndexToMorphMesh = new Map;
  static dracoWorker = null;
  static dracoInitPromise = null;
  static dracoRequestId = 0;
  static dracoCallbacks = new Map;
  static dracoInitialized = false;
  static currentDracoPath = null;
  constructor(device, options = {}) {
    this.device = device;
    this.options = {
      dracoDecoderPath: options.dracoDecoderPath ?? "/draco/"
    };
  }
  getDracoPath() {
    if (this.options.dracoDecoderPath === "cdn") {
      return "https://www.gstatic.com/draco/versioned/decoders/1.5.6/";
    }
    let path = this.options.dracoDecoderPath || "/draco/";
    if (path.startsWith("http://") || path.startsWith("https://")) {
      return path;
    }
    if (typeof document !== "undefined") {
      const baseURI = document.baseURI;
      const url = new URL(path, baseURI);
      return url.href;
    }
    if (typeof window !== "undefined") {
      const base = window.location.origin;
      if (path.startsWith("/")) {
        return base + path;
      } else {
        const currentPath = window.location.pathname;
        const lastSlash = currentPath.lastIndexOf("/");
        const basePath = lastSlash >= 0 ? currentPath.substring(0, lastSlash + 1) : "/";
        return base + basePath + path;
      }
    }
    return path;
  }
  async initDracoWorker() {
    const dracoPath = this.getDracoPath();
    if (GLBLoader.dracoInitialized && GLBLoader.currentDracoPath === dracoPath) {
      return GLBLoader.dracoInitPromise;
    }
    if (GLBLoader.dracoInitPromise && GLBLoader.currentDracoPath === dracoPath) {
      return GLBLoader.dracoInitPromise;
    }
    if (GLBLoader.dracoWorker && GLBLoader.currentDracoPath !== dracoPath) {
      GLBLoader.dracoWorker.terminate();
      GLBLoader.dracoWorker = null;
      GLBLoader.dracoInitialized = false;
    }
    GLBLoader.currentDracoPath = dracoPath;
    GLBLoader.dracoInitPromise = new Promise((resolve, reject) => {
      try {
        const blob = new Blob([DRACO_WORKER_CODE], { type: "application/javascript" });
        const workerUrl = URL.createObjectURL(blob);
        GLBLoader.dracoWorker = new Worker(workerUrl);
        GLBLoader.dracoWorker.onmessage = (e) => {
          const { requestId, success, error, positions, normals, uvs, indices } = e.data;
          const callback = GLBLoader.dracoCallbacks.get(requestId);
          if (callback) {
            GLBLoader.dracoCallbacks.delete(requestId);
            if (success) {
              if (positions) {
                callback.resolve({ positions, normals, uvs, indices });
              } else {
                callback.resolve({});
              }
            } else {
              callback.reject(new Error(error || "Draco decode failed"));
            }
          }
        };
        GLBLoader.dracoWorker.onerror = (e) => {
          console.error("Draco worker error:", e);
          reject(e);
        };
        const initRequestId = GLBLoader.dracoRequestId++;
        GLBLoader.dracoCallbacks.set(initRequestId, {
          resolve: () => {
            GLBLoader.dracoInitialized = true;
            console.log(`GLBLoader: Draco decoder initialized (path: ${dracoPath})`);
            resolve();
          },
          reject
        });
        GLBLoader.dracoWorker.postMessage({
          requestId: initRequestId,
          type: "init",
          path: dracoPath
        });
      } catch (e) {
        reject(e);
      }
    });
    return GLBLoader.dracoInitPromise;
  }
  async decodeDraco(compressedData, attributeIds) {
    if (typeof globalThis.__mystralNativeDecodeDracoAsync === "function") {
      const result = await globalThis.__mystralNativeDecodeDracoAsync(compressedData, attributeIds);
      if (result) {
        return {
          positions: new Float32Array(result.positions),
          normals: result.normals ? new Float32Array(result.normals) : null,
          uvs: result.uvs ? new Float32Array(result.uvs) : null,
          indices: new Uint32Array(result.indices)
        };
      }
    }
    await this.initDracoWorker();
    return new Promise((resolve, reject) => {
      const requestId = GLBLoader.dracoRequestId++;
      GLBLoader.dracoCallbacks.set(requestId, { resolve, reject });
      GLBLoader.dracoWorker.postMessage({
        requestId,
        type: "decode",
        compressedData,
        attributeIds
      }, [compressedData]);
    });
  }
  usesDraco(gltf) {
    if (!gltf.meshes)
      return false;
    for (const mesh of gltf.meshes) {
      for (const prim of mesh.primitives) {
        if (prim.extensions?.KHR_draco_mesh_compression) {
          return true;
        }
      }
    }
    return false;
  }
  async load(url) {
    console.log(`GLBLoader: Loading ${url}...`);
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Failed to fetch ${url}: ${response.status}`);
    }
    const isGLTF = url.toLowerCase().endsWith(".gltf");
    if (isGLTF) {
      const jsonText = await response.text();
      return this.parseGLTF(jsonText, url);
    } else {
      const buffer = await response.arrayBuffer();
      return this.parseGLB(buffer, url);
    }
  }
  async parseGLTF(jsonText, baseUrl) {
    const gltf = JSON.parse(jsonText);
    console.log(`GLBLoader: Parsed GLTF JSON - ${gltf.meshes?.length || 0} meshes, ${gltf.materials?.length || 0} materials, ${gltf.images?.length || 0} images`);
    const lastSlash = baseUrl.lastIndexOf("/");
    const basePath = lastSlash >= 0 ? baseUrl.substring(0, lastSlash + 1) : "";
    this.externalBuffers.clear();
    if (gltf.buffers) {
      for (let i = 0;i < gltf.buffers.length; i++) {
        const bufferDef = gltf.buffers[i];
        if (bufferDef.uri) {
          if (bufferDef.uri.startsWith("data:")) {
            const base64Data = bufferDef.uri.split(",")[1];
            const binaryStr = atob(base64Data);
            const bytes = new Uint8Array(binaryStr.length);
            for (let j = 0;j < binaryStr.length; j++) {
              bytes[j] = binaryStr.charCodeAt(j);
            }
            this.externalBuffers.set(i, bytes.buffer);
          } else {
            const bufferUrl = basePath + bufferDef.uri;
            console.log(`GLBLoader: Loading external buffer: ${bufferUrl}`);
            const bufferResponse = await fetch(bufferUrl);
            if (!bufferResponse.ok) {
              throw new Error(`Failed to fetch buffer ${bufferUrl}: ${bufferResponse.status}`);
            }
            const bufferData = await bufferResponse.arrayBuffer();
            this.externalBuffers.set(i, bufferData);
          }
        }
      }
    }
    this.textures.clear();
    this.materials.clear();
    this.skeletons.clear();
    this.nodeToJointIndex.clear();
    this.skinnedMeshes = [];
    this.morphTargetMeshes = [];
    this.nodeIndexToNode.clear();
    this.meshIndexToMorphMesh.clear();
    await this.loadTextures(gltf, null, baseUrl);
    this.loadMaterials(gltf);
    this.parseSkins(gltf, null);
    const rootNode = await this.buildSceneGraph(gltf, null);
    const animations = this.parseAnimations(gltf, null);
    return {
      rootNode,
      animations,
      skeletons: this.skeletons,
      skinnedMeshes: this.skinnedMeshes,
      morphTargetMeshes: this.morphTargetMeshes
    };
  }
  async parseGLB(buffer, baseUrl) {
    const dataView = new DataView(buffer);
    const magic = dataView.getUint32(0, true);
    const version = dataView.getUint32(4, true);
    const length = dataView.getUint32(8, true);
    if (magic !== GLB_MAGIC) {
      throw new Error("Invalid GLB magic number");
    }
    if (version !== GLB_VERSION) {
      throw new Error(`Unsupported GLB version: ${version}`);
    }
    let jsonChunk = null;
    let binChunk = null;
    let offset = 12;
    while (offset < length) {
      const chunkLength = dataView.getUint32(offset, true);
      const chunkType = dataView.getUint32(offset + 4, true);
      const chunkData = buffer.slice(offset + 8, offset + 8 + chunkLength);
      if (chunkType === GLB_CHUNK_TYPE_JSON) {
        jsonChunk = new TextDecoder().decode(chunkData);
      } else if (chunkType === GLB_CHUNK_TYPE_BIN) {
        binChunk = chunkData;
      }
      offset += 8 + chunkLength;
    }
    if (!jsonChunk) {
      throw new Error("GLB file has no JSON chunk");
    }
    const gltf = JSON.parse(jsonChunk);
    console.log(`GLBLoader: Parsed GLTF - ${gltf.meshes?.length || 0} meshes, ${gltf.materials?.length || 0} materials, ${gltf.images?.length || 0} images`);
    this.externalBuffers.clear();
    this.textures.clear();
    this.materials.clear();
    this.skeletons.clear();
    this.nodeToJointIndex.clear();
    this.skinnedMeshes = [];
    this.morphTargetMeshes = [];
    this.nodeIndexToNode.clear();
    this.meshIndexToMorphMesh.clear();
    if (gltf.textures && gltf.images) {
      await this.loadTextures(gltf, binChunk, baseUrl);
    }
    if (gltf.materials) {
      this.loadMaterials(gltf);
    }
    this.parseSkins(gltf, binChunk);
    const rootNode = await this.buildSceneGraph(gltf, binChunk);
    const animations = this.parseAnimations(gltf, binChunk);
    return {
      rootNode,
      animations,
      skeletons: this.skeletons,
      skinnedMeshes: this.skinnedMeshes,
      morphTargetMeshes: this.morphTargetMeshes
    };
  }
  async loadTextures(gltf, binChunk, baseUrl) {
    if (!gltf.textures || !gltf.images)
      return;
    let basePath = "";
    if (baseUrl) {
      const lastSlash = baseUrl.lastIndexOf("/");
      if (lastSlash >= 0) {
        basePath = baseUrl.substring(0, lastSlash + 1);
      }
    }
    for (let i = 0;i < gltf.textures.length; i++) {
      const texDef = gltf.textures[i];
      let imageSource = texDef.source;
      if (imageSource === undefined && texDef.extensions?.EXT_texture_webp?.source !== undefined) {
        imageSource = texDef.extensions.EXT_texture_webp.source;
      }
      if (imageSource === undefined) {
        console.warn(`GLBLoader: Texture ${i} has no source, skipping`);
        continue;
      }
      const imgDef = gltf.images[imageSource];
      if (!imgDef) {
        console.warn(`GLBLoader: Texture ${i} references missing image ${imageSource}, skipping`);
        continue;
      }
      try {
        let imageData = null;
        let mimeType = imgDef.mimeType || "image/png";
        if (imgDef.bufferView !== undefined) {
          const bufferView = gltf.bufferViews[imgDef.bufferView];
          const bufferIndex = bufferView.buffer || 0;
          const start = bufferView.byteOffset || 0;
          let bufferData = null;
          if (binChunk && bufferIndex === 0) {
            bufferData = binChunk;
          } else {
            bufferData = this.externalBuffers.get(bufferIndex) || null;
          }
          if (bufferData) {
            imageData = bufferData.slice(start, start + bufferView.byteLength);
          } else {
            console.warn(`GLBLoader: Texture ${i} references buffer ${bufferIndex} which is not loaded`);
          }
        } else if (imgDef.uri) {
          if (imgDef.uri.startsWith("data:")) {
            const base64 = imgDef.uri.split(",")[1];
            const binary = atob(base64);
            const bytes = new Uint8Array(binary.length);
            for (let j = 0;j < binary.length; j++) {
              bytes[j] = binary.charCodeAt(j);
            }
            imageData = bytes.buffer;
          } else {
            const imageUrl = basePath + imgDef.uri;
            try {
              const response = await fetch(imageUrl);
              if (response.ok) {
                imageData = await response.arrayBuffer();
                if (!imgDef.mimeType) {
                  if (imgDef.uri.endsWith(".webp"))
                    mimeType = "image/webp";
                  else if (imgDef.uri.endsWith(".png"))
                    mimeType = "image/png";
                  else if (imgDef.uri.endsWith(".jpg") || imgDef.uri.endsWith(".jpeg"))
                    mimeType = "image/jpeg";
                }
              } else {
                console.warn(`GLBLoader: Failed to fetch texture ${imgDef.uri}: ${response.status}`);
              }
            } catch (fetchErr) {
              console.warn(`GLBLoader: Error fetching texture ${imgDef.uri}:`, fetchErr);
            }
          }
        }
        if (imageData) {
          const blob = new Blob([imageData], { type: mimeType });
          const bitmap = await createImageBitmap(blob, { colorSpaceConversion: "none" });
          const isSrgb = this.isColorTexture(gltf, i);
          const texture = new Texture(`GLB Texture ${i}`, { srgb: isSrgb });
          texture.createFromImageBitmap(this.device, bitmap);
          this.textures.set(i, texture);
        } else {
          console.warn(`GLBLoader: No image data found for texture ${i} (bufferView=${imgDef.bufferView}, uri=${imgDef.uri})`);
        }
      } catch (e) {
        console.error(`GLBLoader: Failed to load texture ${i}:`, e);
      }
    }
  }
  isColorTexture(gltf, textureIndex) {
    if (!gltf.materials)
      return false;
    for (const mat of gltf.materials) {
      const pbr = mat.pbrMetallicRoughness;
      if (pbr?.baseColorTexture?.index === textureIndex)
        return true;
      if (mat.emissiveTexture?.index === textureIndex)
        return true;
    }
    return false;
  }
  loadMaterials(gltf) {
    if (!gltf.materials)
      return;
    for (let i = 0;i < gltf.materials.length; i++) {
      const matDef = gltf.materials[i];
      const material = new StandardMaterial;
      const pbr = matDef.pbrMetallicRoughness;
      if (pbr) {
        if (pbr.baseColorFactor) {
          material.albedo = new Vector3(pbr.baseColorFactor[0], pbr.baseColorFactor[1], pbr.baseColorFactor[2]);
          if (pbr.baseColorFactor.length > 3) {
            material.opacity = pbr.baseColorFactor[3];
          }
        }
        if (pbr.baseColorTexture?.index !== undefined) {
          const tex = this.textures.get(pbr.baseColorTexture.index);
          if (tex)
            material.albedoMap = tex;
        }
        material.metallic = pbr.metallicFactor ?? 1;
        material.roughness = pbr.roughnessFactor ?? 1;
        if (pbr.metallicRoughnessTexture?.index !== undefined) {
          const tex = this.textures.get(pbr.metallicRoughnessTexture.index);
          if (tex) {
            material.metallicMap = tex;
            material.roughnessMap = tex;
          }
        }
      }
      if (matDef.normalTexture?.index !== undefined) {
        const tex = this.textures.get(matDef.normalTexture.index);
        if (tex)
          material.normalMap = tex;
      }
      if (matDef.occlusionTexture?.index !== undefined) {
        const tex = this.textures.get(matDef.occlusionTexture.index);
        if (tex)
          material.occlusionMap = tex;
      }
      if (matDef.emissiveFactor) {
        material.emissive = new Vector3(matDef.emissiveFactor[0], matDef.emissiveFactor[1], matDef.emissiveFactor[2]);
      }
      if (matDef.emissiveTexture?.index !== undefined) {
        const tex = this.textures.get(matDef.emissiveTexture.index);
        if (tex)
          material.emissiveMap = tex;
      }
      if (matDef.alphaMode) {
        material.alphaMode = matDef.alphaMode;
      }
      if (matDef.alphaCutoff !== undefined) {
        material.alphaCutoff = matDef.alphaCutoff;
      } else if (matDef.alphaMode === "MASK") {
        material.alphaCutoff = 0.5;
      }
      if (matDef.doubleSided) {
        material.doubleSided = true;
      }
      this.materials.set(i, material);
    }
  }
  async buildSceneGraph(gltf, binChunk) {
    const rootNode = new Node("GLB Root");
    const nodeMap = new Map;
    if (this.usesDraco(gltf)) {
      console.log("GLBLoader: Model uses Draco compression, initializing decoder...");
      if (typeof globalThis.__mystralNativeDecodeDracoAsync !== "function") {
        await this.initDracoWorker();
      }
    }
    if (gltf.nodes) {
      for (let i = 0;i < gltf.nodes.length; i++) {
        const nodeDef = gltf.nodes[i];
        const node = new Node(nodeDef.name || `Node ${i}`);
        if (nodeDef.translation) {
          node.transform.position = new Vector3(nodeDef.translation[0], nodeDef.translation[1], nodeDef.translation[2]);
        }
        if (nodeDef.rotation) {
          node.transform.rotation = new Quaternion(nodeDef.rotation[0], nodeDef.rotation[1], nodeDef.rotation[2], nodeDef.rotation[3]);
        }
        if (nodeDef.scale) {
          node.transform.scale = new Vector3(nodeDef.scale[0], nodeDef.scale[1], nodeDef.scale[2]);
        }
        const hasBufferData = binChunk !== null || this.externalBuffers.size > 0;
        if (nodeDef.mesh !== undefined && gltf.meshes && hasBufferData) {
          const meshDef = gltf.meshes[nodeDef.mesh];
          const skinIdx = nodeDef.skin;
          await this.createMesh(node, meshDef, gltf, binChunk, skinIdx, nodeDef.mesh);
        }
        nodeMap.set(i, node);
        this.nodeIndexToNode.set(i, node);
      }
    }
    if (gltf.nodes) {
      for (let i = 0;i < gltf.nodes.length; i++) {
        const nodeDef = gltf.nodes[i];
        const node = nodeMap.get(i);
        if (nodeDef.children) {
          for (const childIdx of nodeDef.children) {
            const childNode = nodeMap.get(childIdx);
            if (childNode) {
              node.addChild(childNode);
            }
          }
        }
      }
    }
    const sceneIdx = gltf.scene ?? 0;
    const scene = gltf.scenes?.[sceneIdx];
    if (scene?.nodes) {
      for (const nodeIdx of scene.nodes) {
        const node = nodeMap.get(nodeIdx);
        if (node) {
          rootNode.addChild(node);
        }
      }
    } else {
      const childNodes = new Set;
      if (gltf.nodes) {
        for (const node of gltf.nodes) {
          if (node.children) {
            for (const child of node.children) {
              childNodes.add(child);
            }
          }
        }
        for (let i = 0;i < gltf.nodes.length; i++) {
          if (!childNodes.has(i)) {
            const node = nodeMap.get(i);
            if (node) {
              rootNode.addChild(node);
            }
          }
        }
      }
    }
    return rootNode;
  }
  async createMesh(node, meshDef, gltf, binChunk, skinIdx, meshIdx) {
    for (const primDef of meshDef.primitives) {
      const geometry = new Geometry;
      const hasSkin = skinIdx !== undefined && this.skeletons.has(skinIdx);
      const hasMorphTargets = primDef.targets && primDef.targets.length > 0;
      const dracoExt = primDef.extensions?.KHR_draco_mesh_compression;
      if (dracoExt && binChunk) {
        const bufferView = gltf.bufferViews?.[dracoExt.bufferView];
        if (!bufferView) {
          console.error("GLBLoader: Draco extension references missing bufferView");
          continue;
        }
        const start = bufferView.byteOffset || 0;
        const compressedData = binChunk.slice(start, start + bufferView.byteLength);
        try {
          const decoded = await this.decodeDraco(compressedData, dracoExt.attributes);
          if (decoded.positions) {
            geometry.setAttribute("position", decoded.positions);
          }
          if (decoded.normals) {
            geometry.setAttribute("normal", decoded.normals);
          }
          if (decoded.uvs) {
            geometry.setAttribute("uv", decoded.uvs);
          }
          if (decoded.indices) {
            geometry.setIndices(decoded.indices);
          }
        } catch (e) {
          console.error("GLBLoader: Failed to decode Draco mesh:", e);
          continue;
        }
      } else {
        if (primDef.attributes.POSITION !== undefined) {
          const positions = this.readAccessor(gltf, binChunk, primDef.attributes.POSITION);
          if (positions) {
            geometry.setAttribute("position", positions);
          }
        }
        if (primDef.attributes.NORMAL !== undefined) {
          const normals = this.readAccessor(gltf, binChunk, primDef.attributes.NORMAL);
          if (normals) {
            geometry.setAttribute("normal", normals);
          }
        }
        if (primDef.attributes.TEXCOORD_0 !== undefined) {
          const uvs = this.readAccessor(gltf, binChunk, primDef.attributes.TEXCOORD_0);
          if (uvs) {
            geometry.setAttribute("uv", uvs);
          }
        }
        if (primDef.attributes.TANGENT !== undefined) {
          const tangents = this.readAccessor(gltf, binChunk, primDef.attributes.TANGENT);
          if (tangents) {
            geometry.setAttribute("tangent", tangents);
          }
        }
        if (hasSkin) {
          if (primDef.attributes.JOINTS_0 !== undefined) {
            const joints = this.readAccessor(gltf, binChunk, primDef.attributes.JOINTS_0);
            if (joints) {
              geometry.setAttribute("joints", new Float32Array(joints));
            }
          }
          if (primDef.attributes.WEIGHTS_0 !== undefined) {
            const weights = this.readAccessor(gltf, binChunk, primDef.attributes.WEIGHTS_0);
            if (weights) {
              geometry.setAttribute("weights", weights);
            }
          }
        }
        if (primDef.indices !== undefined) {
          const indices = this.readAccessor(gltf, binChunk, primDef.indices);
          if (indices) {
            geometry.setIndices(new Uint32Array(indices));
          }
        }
      }
      const material = primDef.material !== undefined ? this.materials.get(primDef.material) : new StandardMaterial;
      let mesh;
      if (hasSkin) {
        const skeleton = this.skeletons.get(skinIdx);
        const skinnedMesh = new SkinnedMesh(geometry, material || new StandardMaterial, skeleton);
        skinnedMesh.name = meshDef.name || "GLB SkinnedMesh";
        this.skinnedMeshes.push(skinnedMesh);
        mesh = skinnedMesh;
        console.log(`GLBLoader: Created SkinnedMesh "${skinnedMesh.name}" with ${skeleton.boneCount} bones`);
      } else if (hasMorphTargets) {
        const vertexCount = geometry.vertexCount;
        const morphTargets = new MorphTargets(vertexCount);
        for (let targetIdx = 0;targetIdx < primDef.targets.length; targetIdx++) {
          const targetDef = primDef.targets[targetIdx];
          const positionDeltas = targetDef.POSITION !== undefined ? this.readAccessor(gltf, binChunk, targetDef.POSITION) : null;
          if (!positionDeltas)
            continue;
          const normalDeltas = targetDef.NORMAL !== undefined ? this.readAccessor(gltf, binChunk, targetDef.NORMAL) : null;
          const tangentDeltas = targetDef.TANGENT !== undefined ? this.readAccessor(gltf, binChunk, targetDef.TANGENT) : null;
          let targetName = `target_${targetIdx}`;
          if (gltf.meshes && meshIdx !== undefined) {
            const meshDefWithExtras = gltf.meshes[meshIdx];
            if (meshDefWithExtras.extras?.targetNames?.[targetIdx]) {
              targetName = meshDefWithExtras.extras.targetNames[targetIdx];
            }
          }
          morphTargets.addTarget({
            name: targetName,
            index: targetIdx,
            positionDeltas,
            normalDeltas,
            tangentDeltas
          });
        }
        if (meshDef.weights) {
          morphTargets.setWeights(meshDef.weights);
        }
        const morphMesh = new MorphTargetMesh(geometry, material || new StandardMaterial, morphTargets);
        morphMesh.name = meshDef.name || "GLB MorphTargetMesh";
        this.morphTargetMeshes.push(morphMesh);
        if (meshIdx !== undefined) {
          this.meshIndexToMorphMesh.set(meshIdx, morphMesh);
        }
        mesh = morphMesh;
        console.log(`GLBLoader: Created MorphTargetMesh "${morphMesh.name}" with ${morphTargets.targetCount} targets`);
      } else {
        mesh = new Mesh(geometry, material || new StandardMaterial);
        mesh.name = meshDef.name || "GLB Mesh";
      }
      node.addChild(mesh);
    }
  }
  parseSkins(gltf, binChunk) {
    if (!gltf.skins || !gltf.nodes)
      return;
    for (let skinIdx = 0;skinIdx < gltf.skins.length; skinIdx++) {
      const skinDef = gltf.skins[skinIdx];
      let inverseBindMatrices = [];
      if (skinDef.inverseBindMatrices !== undefined) {
        const ibmData = this.readAccessor(gltf, binChunk, skinDef.inverseBindMatrices);
        if (ibmData) {
          const floatData = ibmData instanceof Float32Array ? ibmData : new Float32Array(ibmData);
          for (let i = 0;i < skinDef.joints.length; i++) {
            const offset = i * 16;
            const matrix = new Matrix4;
            matrix.elements.set(floatData.subarray(offset, offset + 16));
            inverseBindMatrices.push(matrix);
          }
        }
      }
      const nodeParents = new Map;
      for (let i = 0;i < gltf.nodes.length; i++) {
        const node = gltf.nodes[i];
        if (node.children) {
          for (const childIdx of node.children) {
            nodeParents.set(childIdx, i);
          }
        }
      }
      const jointNodeSet = new Set(skinDef.joints);
      const bonesData = [];
      const nodeToJoint = new Map;
      for (let jointIdx = 0;jointIdx < skinDef.joints.length; jointIdx++) {
        nodeToJoint.set(skinDef.joints[jointIdx], jointIdx);
      }
      this.nodeToJointIndex.set(skinIdx, nodeToJoint);
      for (let jointIdx = 0;jointIdx < skinDef.joints.length; jointIdx++) {
        const nodeIdx = skinDef.joints[jointIdx];
        const nodeDef = gltf.nodes[nodeIdx];
        let parentBoneIdx = -1;
        let parentNodeIdx = nodeParents.get(nodeIdx);
        while (parentNodeIdx !== undefined) {
          if (jointNodeSet.has(parentNodeIdx)) {
            parentBoneIdx = nodeToJoint.get(parentNodeIdx);
            break;
          }
          parentNodeIdx = nodeParents.get(parentNodeIdx);
        }
        const position = nodeDef.translation ? new Vector3(nodeDef.translation[0], nodeDef.translation[1], nodeDef.translation[2]) : new Vector3(0, 0, 0);
        const rotation = nodeDef.rotation ? new Quaternion(nodeDef.rotation[0], nodeDef.rotation[1], nodeDef.rotation[2], nodeDef.rotation[3]) : new Quaternion(0, 0, 0, 1);
        const scale = nodeDef.scale ? new Vector3(nodeDef.scale[0], nodeDef.scale[1], nodeDef.scale[2]) : new Vector3(1, 1, 1);
        const inverseBindMatrix = inverseBindMatrices[jointIdx] || Matrix4.identity.clone();
        bonesData.push({
          name: nodeDef.name || `Joint_${jointIdx}`,
          index: jointIdx,
          parentIndex: parentBoneIdx,
          localBindPose: { position, rotation, scale },
          inverseBindMatrix
        });
      }
      const skeleton = new Skeleton(bonesData);
      this.skeletons.set(skinIdx, skeleton);
      console.log(`GLBLoader: Parsed skin ${skinIdx} "${skinDef.name || "unnamed"}" with ${bonesData.length} bones`);
    }
  }
  parseAnimations(gltf, binChunk) {
    const animations = [];
    if (!gltf.animations || !gltf.nodes)
      return animations;
    for (let animIdx = 0;animIdx < gltf.animations.length; animIdx++) {
      const animDef = gltf.animations[animIdx];
      const clip = new AnimationClip(animDef.name || `Animation_${animIdx}`);
      for (const channel of animDef.channels) {
        const samplerDef = animDef.samplers[channel.sampler];
        const targetNodeIdx = channel.target.node;
        const property = channel.target.path;
        if (targetNodeIdx === undefined)
          continue;
        const timesData = this.readAccessor(gltf, binChunk, samplerDef.input);
        if (!timesData)
          continue;
        const times = timesData instanceof Float32Array ? timesData : new Float32Array(timesData);
        const valuesData = this.readAccessor(gltf, binChunk, samplerDef.output);
        if (!valuesData)
          continue;
        const values = valuesData instanceof Float32Array ? valuesData : new Float32Array(valuesData);
        const interpolation = samplerDef.interpolation || "LINEAR";
        let foundBone = false;
        for (const [_skinIdx, nodeToJoint] of this.nodeToJointIndex.entries()) {
          const jointIdx = nodeToJoint.get(targetNodeIdx);
          if (jointIdx !== undefined && property !== "weights") {
            const track = new AnimationTrack(jointIdx, property, interpolation, times, values);
            clip.addTrack(track);
            foundBone = true;
            break;
          }
        }
        if (!foundBone && property !== "weights") {
          const targetNode = this.nodeIndexToNode.get(targetNodeIdx);
          if (targetNode) {
            const nodeTrack = new NodeAnimationTrack(targetNode, property, interpolation, times, values);
            clip.addNodeAnimationTrack(nodeTrack);
          }
        }
        if (property === "weights") {}
      }
      animations.push(clip);
      console.log(`GLBLoader: Parsed animation "${clip.name}" - ${clip.tracks.length} bone tracks, ${clip.nodeAnimationTracks.length} node tracks, duration=${clip.duration.toFixed(2)}s`);
    }
    return animations;
  }
  readAccessor(gltf, binChunk, accessorIdx) {
    const accessor = gltf.accessors?.[accessorIdx];
    if (!accessor)
      return null;
    const bufferView = gltf.bufferViews?.[accessor.bufferView];
    if (!bufferView)
      return null;
    let bufferData = binChunk;
    if (!bufferData && bufferView.buffer !== undefined) {
      bufferData = this.externalBuffers.get(bufferView.buffer) || null;
    }
    if (!bufferData) {
      console.warn(`GLBLoader: No buffer data available for accessor ${accessorIdx}`);
      return null;
    }
    const componentInfo = COMPONENT_TYPES[accessor.componentType];
    if (!componentInfo) {
      console.warn(`GLBLoader: Unknown component type ${accessor.componentType}`);
      return null;
    }
    const typeSize = TYPE_SIZES[accessor.type];
    if (!typeSize) {
      console.warn(`GLBLoader: Unknown accessor type ${accessor.type}`);
      return null;
    }
    const byteOffset = (bufferView.byteOffset || 0) + (accessor.byteOffset || 0);
    const elementCount = accessor.count * typeSize;
    const componentByteSize = componentInfo.size;
    const elementByteSize = componentByteSize * typeSize;
    const byteStride = bufferView.byteStride;
    const ArrayType = componentInfo.array;
    if (byteStride && byteStride !== elementByteSize) {
      const result = new ArrayType(elementCount);
      const dataView = new DataView(bufferData);
      for (let i = 0;i < accessor.count; i++) {
        const elementOffset = byteOffset + i * byteStride;
        for (let j = 0;j < typeSize; j++) {
          const componentOffset = elementOffset + j * componentByteSize;
          let value;
          switch (accessor.componentType) {
            case 5120:
              value = dataView.getInt8(componentOffset);
              break;
            case 5121:
              value = dataView.getUint8(componentOffset);
              break;
            case 5122:
              value = dataView.getInt16(componentOffset, true);
              break;
            case 5123:
              value = dataView.getUint16(componentOffset, true);
              break;
            case 5125:
              value = dataView.getUint32(componentOffset, true);
              break;
            case 5126:
              value = dataView.getFloat32(componentOffset, true);
              break;
            default:
              value = 0;
          }
          result[i * typeSize + j] = value;
        }
      }
      return result;
    } else {
      const data = new ArrayType(bufferData, byteOffset, elementCount);
      return data;
    }
  }
}

// ../../src/core/procedural/instancing/InstancedGLBMesh.ts
var INSTANCE_STRIDE2 = 12;

class InstancedGLBMesh extends Node {
  config;
  device = null;
  globalResources = null;
  initialized = false;
  pipeline = null;
  shadowPipeline = null;
  shadowBindGroup = null;
  shadowUniformBuffer = null;
  instanceBuffer = null;
  vertexBuffer = null;
  indexBuffer = null;
  uniformBuffer = null;
  bindGroup = null;
  albedoTexture = null;
  albedoTextureView = null;
  sampler = null;
  vertexCount = 0;
  indexCount = 0;
  indexFormat = "uint16";
  instances = [];
  instanceData = null;
  instanceCount = 0;
  time = 0;
  constructor(config) {
    super();
    this.config = {
      windEnabled: false,
      windStrength: 0.3,
      windSpeed: 1,
      alphaCutoff: 0.5,
      receiveShadows: true,
      doubleSided: true,
      ...config
    };
  }
  async init(device, globalResources) {
    this.device = device;
    this.globalResources = globalResources || null;
    const loader = new GLBLoader(device);
    const result = await loader.load(this.config.url);
    if (!result || !result.rootNode) {
      throw new Error(`Failed to load GLB: ${this.config.url}`);
    }
    let meshFound = false;
    result.rootNode.traverse((node) => {
      if (meshFound)
        return;
      if (node instanceof Mesh && node.geometry) {
        this.extractMeshData(node);
        meshFound = true;
      }
    });
    if (!meshFound) {
      throw new Error(`No mesh found in GLB: ${this.config.url}`);
    }
    const instanceBufferSize = this.config.maxInstances * INSTANCE_STRIDE2 * 4;
    this.instanceBuffer = device.createBuffer({
      label: `InstancedGLB Instance Buffer: ${this.config.url}`,
      size: instanceBufferSize,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
    });
    this.instanceData = new Float32Array(this.config.maxInstances * INSTANCE_STRIDE2);
    this.uniformBuffer = device.createBuffer({
      label: "InstancedGLB Uniform Buffer",
      size: 32,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.sampler = device.createSampler({
      label: "InstancedGLB Sampler",
      magFilter: "linear",
      minFilter: "linear",
      mipmapFilter: "linear",
      addressModeU: "repeat",
      addressModeV: "repeat"
    });
    this.createPipeline();
    this.createShadowPipeline();
    this.initialized = true;
    console.log(`[InstancedGLBMesh] Initialized: ${this.config.url}, vertices=${this.vertexCount}, maxInstances=${this.config.maxInstances}`);
  }
  extractMeshData(mesh) {
    const geometry = mesh.geometry;
    const material = mesh.material;
    const positions = geometry.attributes["position"];
    const normals = geometry.attributes["normal"];
    const uvs = geometry.attributes["uv"];
    const indices = geometry.indices;
    if (!positions) {
      throw new Error("Mesh has no position attribute");
    }
    const vertexCount = positions.length / 3;
    this.vertexCount = vertexCount;
    const vertexData = new Float32Array(vertexCount * 8);
    for (let i = 0;i < vertexCount; i++) {
      vertexData[i * 8 + 0] = positions[i * 3 + 0];
      vertexData[i * 8 + 1] = positions[i * 3 + 1];
      vertexData[i * 8 + 2] = positions[i * 3 + 2];
      vertexData[i * 8 + 3] = normals ? normals[i * 3 + 0] : 0;
      vertexData[i * 8 + 4] = normals ? normals[i * 3 + 1] : 1;
      vertexData[i * 8 + 5] = normals ? normals[i * 3 + 2] : 0;
      vertexData[i * 8 + 6] = uvs ? uvs[i * 2 + 0] : 0;
      vertexData[i * 8 + 7] = uvs ? uvs[i * 2 + 1] : 0;
    }
    this.vertexBuffer = this.device.createBuffer({
      label: "InstancedGLB Vertex Buffer",
      size: vertexData.byteLength,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
      mappedAtCreation: true
    });
    new Float32Array(this.vertexBuffer.getMappedRange()).set(vertexData);
    this.vertexBuffer.unmap();
    if (indices) {
      this.indexCount = indices.length;
      this.indexFormat = indices instanceof Uint32Array ? "uint32" : "uint16";
      this.indexBuffer = this.device.createBuffer({
        label: "InstancedGLB Index Buffer",
        size: indices.byteLength,
        usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,
        mappedAtCreation: true
      });
      if (indices instanceof Uint32Array) {
        new Uint32Array(this.indexBuffer.getMappedRange()).set(indices);
      } else {
        new Uint16Array(this.indexBuffer.getMappedRange()).set(indices);
      }
      this.indexBuffer.unmap();
    }
    if (material && "albedoMap" in material && material.albedoMap) {
      const albedoMap = material.albedoMap;
      if (albedoMap.gpuTexture) {
        this.albedoTexture = albedoMap.gpuTexture;
        this.albedoTextureView = this.albedoTexture.createView();
      }
    }
    if (!this.albedoTexture) {
      this.albedoTexture = this.device.createTexture({
        label: "InstancedGLB Default Texture",
        size: [1, 1],
        format: "rgba8unorm",
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
      });
      this.device.queue.writeTexture({ texture: this.albedoTexture }, new Uint8Array([255, 255, 255, 255]), { bytesPerRow: 4 }, [1, 1]);
      this.albedoTextureView = this.albedoTexture.createView();
    }
  }
  createPipeline() {
    if (!this.device || !this.globalResources)
      return;
    const shaderModule = this.device.createShaderModule({
      label: "InstancedGLB Shader",
      code: this.getShaderCode()
    });
    const bindGroupLayout = this.device.createBindGroupLayout({
      label: "InstancedGLB Bind Group Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "float" } },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "filtering" } }
      ]
    });
    const pipelineLayout = this.device.createPipelineLayout({
      label: "InstancedGLB Pipeline Layout",
      bindGroupLayouts: [
        this.globalResources.renderBindGroupLayout,
        bindGroupLayout
      ]
    });
    this.pipeline = this.device.createRenderPipeline({
      label: "InstancedGLB Render Pipeline",
      layout: pipelineLayout,
      vertex: {
        module: shaderModule,
        entryPoint: "vs_main",
        buffers: [
          {
            arrayStride: 32,
            stepMode: "vertex",
            attributes: [
              { shaderLocation: 0, offset: 0, format: "float32x3" },
              { shaderLocation: 1, offset: 12, format: "float32x3" },
              { shaderLocation: 2, offset: 24, format: "float32x2" }
            ]
          },
          {
            arrayStride: 48,
            stepMode: "instance",
            attributes: [
              { shaderLocation: 3, offset: 0, format: "float32x4" },
              { shaderLocation: 4, offset: 16, format: "float32x4" },
              { shaderLocation: 5, offset: 32, format: "float32x4" }
            ]
          }
        ]
      },
      fragment: {
        module: shaderModule,
        entryPoint: "fs_main",
        targets: [
          { format: "rgba16float" },
          { format: "rgba16float" },
          { format: "rgba16float" },
          { format: "rgba16float" },
          { format: "rg16float" }
        ]
      },
      primitive: {
        topology: "triangle-list",
        cullMode: this.config.doubleSided ? "none" : "back"
      },
      depthStencil: {
        format: "depth24plus",
        depthWriteEnabled: true,
        depthCompare: "less"
      },
      multisample: {
        count: 1,
        alphaToCoverageEnabled: false
      }
    });
    this.bindGroup = this.device.createBindGroup({
      label: "InstancedGLB Bind Group",
      layout: bindGroupLayout,
      entries: [
        { binding: 0, resource: { buffer: this.uniformBuffer } },
        { binding: 1, resource: this.albedoTextureView },
        { binding: 2, resource: this.sampler }
      ]
    });
  }
  createShadowPipeline() {
    if (!this.device)
      return;
    const shadowShaderCode = `
      struct ShadowUniforms {
        lightViewProj: mat4x4<f32>,
        alphaCutoff: f32,
        time: f32,
        windStrength: f32,
        windSpeed: f32,
      }

      @group(0) @binding(0) var<uniform> shadow: ShadowUniforms;
      @group(0) @binding(1) var albedoTexture: texture_2d<f32>;
      @group(0) @binding(2) var texSampler: sampler;

      struct VertexInput {
        @location(0) position: vec3f,
        @location(1) normal: vec3f,
        @location(2) uv: vec2f,
        @location(3) instancePosRot: vec4f,
        @location(4) instanceScale: vec4f,
        @location(5) instanceColor: vec4f,
      }

      struct VertexOutput {
        @builtin(position) position: vec4f,
        @location(0) uv: vec2f,
      }

      @vertex
      fn vs_main(input: VertexInput) -> VertexOutput {
        var output: VertexOutput;

        let instancePos = input.instancePosRot.xyz;
        let rotation = input.instancePosRot.w;
        let scale = input.instanceScale.xyz;

        // Rotation matrix (Y-axis)
        let cosR = cos(rotation);
        let sinR = sin(rotation);
        let rotMat = mat3x3f(
          vec3f(cosR, 0.0, sinR),
          vec3f(0.0, 1.0, 0.0),
          vec3f(-sinR, 0.0, cosR)
        );

        var localPos = input.position * scale;

        // Wind animation (same as main shader)
        if (shadow.windStrength > 0.0) {
          let windPhase = shadow.time * shadow.windSpeed + instancePos.x * 0.1 + instancePos.z * 0.1;
          let windOffset = sin(windPhase) * shadow.windStrength * localPos.y * 0.1;
          localPos.x += windOffset;
          localPos.z += windOffset * 0.3;
        }

        let worldPos = rotMat * localPos + instancePos;
        output.position = shadow.lightViewProj * vec4f(worldPos, 1.0);
        output.uv = input.uv;

        return output;
      }

      @fragment
      fn fs_main(input: VertexOutput) {
        let alpha = textureSample(albedoTexture, texSampler, input.uv).a;
        if (alpha < shadow.alphaCutoff) {
          discard;
        }
      }
    `;
    const shaderModule = this.device.createShaderModule({
      label: "InstancedGLB Shadow Shader",
      code: shadowShaderCode
    });
    this.shadowUniformBuffer = this.device.createBuffer({
      label: "InstancedGLB Shadow Uniform Buffer",
      size: 96,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.shadowPipeline = this.device.createRenderPipeline({
      label: "InstancedGLB Shadow Pipeline",
      layout: "auto",
      vertex: {
        module: shaderModule,
        entryPoint: "vs_main",
        buffers: [
          {
            arrayStride: 32,
            stepMode: "vertex",
            attributes: [
              { shaderLocation: 0, offset: 0, format: "float32x3" },
              { shaderLocation: 1, offset: 12, format: "float32x3" },
              { shaderLocation: 2, offset: 24, format: "float32x2" }
            ]
          },
          {
            arrayStride: 48,
            stepMode: "instance",
            attributes: [
              { shaderLocation: 3, offset: 0, format: "float32x4" },
              { shaderLocation: 4, offset: 16, format: "float32x4" },
              { shaderLocation: 5, offset: 32, format: "float32x4" }
            ]
          }
        ]
      },
      fragment: {
        module: shaderModule,
        entryPoint: "fs_main",
        targets: []
      },
      primitive: {
        topology: "triangle-list",
        cullMode: "none"
      },
      depthStencil: {
        format: "depth32float",
        depthWriteEnabled: true,
        depthCompare: "less"
      }
    });
    this.shadowBindGroup = this.device.createBindGroup({
      label: "InstancedGLB Shadow Bind Group",
      layout: this.shadowPipeline.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: { buffer: this.shadowUniformBuffer } },
        { binding: 1, resource: this.albedoTextureView },
        { binding: 2, resource: this.sampler }
      ]
    });
  }
  getShaderCode() {
    return `
      // Scene uniforms (group 0) - matches GlobalResources layout
      struct SceneUniforms {
        viewMatrix: mat4x4<f32>,
        projectionMatrix: mat4x4<f32>,
        lightViewProj: mat4x4<f32>,
        prevViewProj: mat4x4<f32>,
        inverseProjectionMatrix: mat4x4<f32>,
        cameraPosition: vec3f,
        time: f32,
        lightCount: u32,
        debugMode: u32,
        flags: u32,
        environmentIntensity: f32,
        fogColor: vec3f,
        fogDensity: f32,
        fogType: u32,
        fogSkyFalloff: f32,
        cloudShadowIntensity: f32,
        cloudShadowScale: f32,
        cloudShadowSpeed: f32,
        cloudShadowCoverage: f32,
        cloudShadowSoftness: f32,
        cloudShadowWindDir: f32,
        _padding: vec2f,
      }

      @group(0) @binding(0) var<uniform> scene: SceneUniforms;

      // Material uniforms (group 1)
      struct MaterialUniforms {
        time: f32,
        windStrength: f32,
        windSpeed: f32,
        alphaCutoff: f32,
        windDirX: f32,
        windDirZ: f32,
        _padding: vec2f,
      }

      @group(1) @binding(0) var<uniform> material: MaterialUniforms;
      @group(1) @binding(1) var albedoTexture: texture_2d<f32>;
      @group(1) @binding(2) var texSampler: sampler;

      struct VertexInput {
        @location(0) position: vec3f,
        @location(1) normal: vec3f,
        @location(2) uv: vec2f,
        // Instance data
        @location(3) instancePosRot: vec4f,  // position.xyz, rotation
        @location(4) instanceScale: vec4f,   // scale.xyz, unused
        @location(5) instanceColor: vec4f,   // color.rgb, unused
      }

      struct VertexOutput {
        @builtin(position) position: vec4f,
        @location(0) worldPosition: vec3f,
        @location(1) worldNormal: vec3f,
        @location(2) uv: vec2f,
        @location(3) color: vec3f,
      }

      struct FragmentInput {
        @builtin(position) position: vec4f,
        @builtin(front_facing) frontFacing: bool,
        @location(0) worldPosition: vec3f,
        @location(1) worldNormal: vec3f,
        @location(2) uv: vec2f,
        @location(3) color: vec3f,
      }

      @vertex
      fn vs_main(input: VertexInput) -> VertexOutput {
        var output: VertexOutput;

        // Extract instance data
        let instancePos = input.instancePosRot.xyz;
        let rotation = input.instancePosRot.w;
        let scale = input.instanceScale.xyz;
        let color = input.instanceColor.rgb;

        // Create rotation matrix (Y-axis only)
        let cosR = cos(rotation);
        let sinR = sin(rotation);
        let rotMat = mat3x3f(
          vec3f(cosR, 0.0, sinR),
          vec3f(0.0, 1.0, 0.0),
          vec3f(-sinR, 0.0, cosR)
        );

        // Apply scale, rotation, then translation
        var localPos = input.position * scale;

        // Wind animation (based on vertex height)
        if (material.windStrength > 0.0) {
          let windPhase = material.time * material.windSpeed + instancePos.x * 0.1 + instancePos.z * 0.1;
          let windOffset = sin(windPhase) * material.windStrength * localPos.y * 0.1;
          localPos.x += windOffset * material.windDirX;
          localPos.z += windOffset * material.windDirZ;
        }

        let worldPos = rotMat * localPos + instancePos;
        let worldNormal = rotMat * input.normal;

        output.worldPosition = worldPos;
        output.worldNormal = normalize(worldNormal);
        output.uv = input.uv;
        output.color = color;
        output.position = scene.projectionMatrix * scene.viewMatrix * vec4f(worldPos, 1.0);

        return output;
      }

      // G-Buffer output - must match GeometryPass color attachment order:
      // 0: albedo, 1: normal, 2: position, 3: emissive, 4: velocity
      struct GBufferOutput {
        @location(0) albedo: vec4f,
        @location(1) normal: vec4f,
        @location(2) position: vec4f,
        @location(3) emissive: vec4f,
        @location(4) velocity: vec2f,
      }

      @fragment
      fn fs_main(input: FragmentInput) -> GBufferOutput {
        var output: GBufferOutput;

        // Sample texture
        let texColor = textureSample(albedoTexture, texSampler, input.uv);

        // Alpha test
        if (texColor.a < material.alphaCutoff) {
          discard;
        }

        // Apply instance color tint
        let finalColor = texColor.rgb * input.color;

        // Two-sided lighting: flip normal for back faces
        var N = normalize(input.worldNormal);
        if (!input.frontFacing) {
          N = -N;
        }

        // Material properties for natural objects (grass, rocks, flowers)
        let roughness = 0.85;   // Rough, natural surface
        let metallic = 0.0;     // Non-metallic
        let occlusion = 1.0;    // No ambient occlusion
        let ambientIntensity = 1.0; // Full ambient light contribution

        // Write to G-Buffer (matching StandardMaterial format exactly)
        // albedo.a = roughness, normal.a = metallic, position.a = occlusion, emissive.a = ambientIntensity
        output.albedo = vec4f(finalColor, roughness);
        output.normal = vec4f(N * 0.5 + 0.5, metallic);
        output.position = vec4f(input.worldPosition, occlusion);
        output.emissive = vec4f(0.0, 0.0, 0.0, ambientIntensity);
        output.velocity = vec2f(0.0, 0.0);

        return output;
      }
    `;
  }
  addInstance(instance) {
    if (this.instances.length >= this.config.maxInstances) {
      console.warn(`[InstancedGLBMesh] Max instances (${this.config.maxInstances}) reached`);
      return;
    }
    this.instances.push(instance);
  }
  clearInstances() {
    this.instances = [];
    this.instanceCount = 0;
  }
  uploadInstances() {
    if (!this.device || !this.instanceBuffer || !this.instanceData)
      return;
    const count = this.instances.length;
    this.instanceCount = count;
    for (let i = 0;i < count; i++) {
      const inst = this.instances[i];
      const offset = i * INSTANCE_STRIDE2;
      this.instanceData[offset + 0] = inst.position.x;
      this.instanceData[offset + 1] = inst.position.y;
      this.instanceData[offset + 2] = inst.position.z;
      this.instanceData[offset + 3] = inst.rotation;
      if (typeof inst.scale === "number") {
        this.instanceData[offset + 4] = inst.scale;
        this.instanceData[offset + 5] = inst.scale;
        this.instanceData[offset + 6] = inst.scale;
      } else {
        this.instanceData[offset + 4] = inst.scale.x;
        this.instanceData[offset + 5] = inst.scale.y;
        this.instanceData[offset + 6] = inst.scale.z;
      }
      this.instanceData[offset + 7] = 0;
      this.instanceData[offset + 8] = inst.color.x;
      this.instanceData[offset + 9] = inst.color.y;
      this.instanceData[offset + 10] = inst.color.z;
      this.instanceData[offset + 11] = 0;
    }
    this.device.queue.writeBuffer(this.instanceBuffer, 0, this.instanceData.buffer, 0, count * INSTANCE_STRIDE2 * 4);
  }
  update(deltaTime) {
    this.time += deltaTime;
    if (!this.device || !this.uniformBuffer)
      return;
    const uniformData = new Float32Array([
      this.time,
      this.config.windEnabled ? this.config.windStrength : 0,
      this.config.windSpeed,
      this.config.alphaCutoff,
      1,
      0.3,
      0,
      0
    ]);
    this.device.queue.writeBuffer(this.uniformBuffer, 0, uniformData);
  }
  render(passEncoder, globalBindGroup) {
    if (!this.initialized || !this.pipeline || !this.bindGroup)
      return;
    if (this.instanceCount === 0)
      return;
    passEncoder.setPipeline(this.pipeline);
    passEncoder.setBindGroup(0, globalBindGroup);
    passEncoder.setBindGroup(1, this.bindGroup);
    passEncoder.setVertexBuffer(0, this.vertexBuffer);
    passEncoder.setVertexBuffer(1, this.instanceBuffer);
    if (this.indexBuffer) {
      passEncoder.setIndexBuffer(this.indexBuffer, this.indexFormat);
      passEncoder.drawIndexed(this.indexCount, this.instanceCount);
    } else {
      passEncoder.draw(this.vertexCount, this.instanceCount);
    }
  }
  renderShadow(passEncoder, lightViewProj) {
    if (!this.initialized || !this.shadowPipeline || !this.shadowBindGroup || !this.device)
      return;
    if (this.instanceCount === 0)
      return;
    const shadowUniforms = new Float32Array(24);
    shadowUniforms.set(lightViewProj, 0);
    shadowUniforms[16] = this.config.alphaCutoff;
    shadowUniforms[17] = this.time;
    shadowUniforms[18] = this.config.windEnabled ? this.config.windStrength : 0;
    shadowUniforms[19] = this.config.windSpeed;
    this.device.queue.writeBuffer(this.shadowUniformBuffer, 0, shadowUniforms);
    passEncoder.setPipeline(this.shadowPipeline);
    passEncoder.setBindGroup(0, this.shadowBindGroup);
    passEncoder.setVertexBuffer(0, this.vertexBuffer);
    passEncoder.setVertexBuffer(1, this.instanceBuffer);
    if (this.indexBuffer) {
      passEncoder.setIndexBuffer(this.indexBuffer, this.indexFormat);
      passEncoder.drawIndexed(this.indexCount, this.instanceCount);
    } else {
      passEncoder.draw(this.vertexCount, this.instanceCount);
    }
  }
  getInstanceCount() {
    return this.instanceCount;
  }
  setWind(enabled, strength, speed) {
    this.config.windEnabled = enabled;
    if (strength !== undefined)
      this.config.windStrength = strength;
    if (speed !== undefined)
      this.config.windSpeed = speed;
  }
  destroy() {
    this.instanceBuffer?.destroy();
    this.vertexBuffer?.destroy();
    this.indexBuffer?.destroy();
    this.uniformBuffer?.destroy();
    this.instanceBuffer = null;
    this.vertexBuffer = null;
    this.indexBuffer = null;
    this.uniformBuffer = null;
    this.pipeline = null;
    this.bindGroup = null;
    this.device = null;
    this.initialized = false;
    this.instances = [];
    this.instanceData = null;
  }
}

// ../../src/core/InstancedMesh.ts
var FLOATS_PER_INSTANCE = 12;
var BYTES_PER_INSTANCE = FLOATS_PER_INSTANCE * 4;

class InstancedMesh extends Node {
  geometry;
  material;
  maxInstances;
  instanceBuffer = null;
  _instanceCount = 0;
  instances = [];
  instanceData = null;
  dirty = false;
  constructor(geometry, material, maxInstances) {
    super();
    this.geometry = geometry;
    this.material = material;
    this.maxInstances = maxInstances;
  }
  init(device) {
    this.instanceBuffer = device.createBuffer({
      label: `InstancedMesh Instance Buffer (${this.maxInstances} max)`,
      size: this.maxInstances * BYTES_PER_INSTANCE,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
    });
    this.instanceData = new Float32Array(this.maxInstances * FLOATS_PER_INSTANCE);
  }
  addInstance(data) {
    if (this.instances.length >= this.maxInstances) {
      console.warn(`[InstancedMesh] Max instances (${this.maxInstances}) reached`);
      return;
    }
    this.instances.push({
      position: data.position,
      rotation: data.rotation,
      scale: data.scale,
      color: data.color ?? new Vector3(1, 1, 1)
    });
    this.dirty = true;
  }
  clearInstances() {
    this.instances = [];
    this._instanceCount = 0;
    this.dirty = true;
  }
  uploadInstances(device) {
    if (!this.instanceBuffer || !this.instanceData) {
      console.warn("[InstancedMesh] Not initialized");
      return;
    }
    const count = this.instances.length;
    this._instanceCount = count;
    if (count === 0)
      return;
    for (let i = 0;i < count; i++) {
      const inst = this.instances[i];
      const offset = i * FLOATS_PER_INSTANCE;
      this.instanceData[offset + 0] = inst.position.x;
      this.instanceData[offset + 1] = inst.position.y;
      this.instanceData[offset + 2] = inst.position.z;
      this.instanceData[offset + 3] = inst.rotation;
      if (typeof inst.scale === "number") {
        this.instanceData[offset + 4] = inst.scale;
        this.instanceData[offset + 5] = inst.scale;
        this.instanceData[offset + 6] = inst.scale;
      } else {
        this.instanceData[offset + 4] = inst.scale.x;
        this.instanceData[offset + 5] = inst.scale.y;
        this.instanceData[offset + 6] = inst.scale.z;
      }
      this.instanceData[offset + 7] = 0;
      const color = inst.color ?? new Vector3(1, 1, 1);
      this.instanceData[offset + 8] = color.x;
      this.instanceData[offset + 9] = color.y;
      this.instanceData[offset + 10] = color.z;
      this.instanceData[offset + 11] = 0;
    }
    this.dirty = false;
  }
  _writeToGPU(device) {
    if (!this.instanceBuffer || !this.instanceData || this._instanceCount === 0)
      return;
    device.queue.writeBuffer(this.instanceBuffer, 0, this.instanceData.buffer, 0, this._instanceCount * BYTES_PER_INSTANCE);
  }
  get instanceCount() {
    return this._instanceCount;
  }
  get isDirty() {
    return this.dirty;
  }
  destroy() {
    this.instanceBuffer?.destroy();
    this.instanceBuffer = null;
    this.instanceData = null;
    this.instances = [];
    this._instanceCount = 0;
  }
  getDebugInstanceData() {
    if (!this.instanceData || this._instanceCount === 0)
      return null;
    const result = [];
    const numToShow = Math.min(3, this._instanceCount);
    for (let i = 0;i < numToShow; i++) {
      const offset = i * FLOATS_PER_INSTANCE;
      result.push({
        position: [
          this.instanceData[offset + 0],
          this.instanceData[offset + 1],
          this.instanceData[offset + 2]
        ],
        rotation: this.instanceData[offset + 3],
        scale: [
          this.instanceData[offset + 4],
          this.instanceData[offset + 5],
          this.instanceData[offset + 6]
        ]
      });
    }
    return result;
  }
}

// ../../src/core/renderer/GeometryPass.ts
class GeometryPass {
  gBuffer;
  static hasLoggedPipeline = false;
  static hasLoggedBindGroup = false;
  static hasLoggedSkinnedPipeline = false;
  hasLoggedExecution = false;
  frustum = new Frustum;
  viewProjectionMatrix = new Matrix4;
  skinnedPipelines = new Map;
  skeletonBindGroupLayout = null;
  morphedPipelines = new Map;
  morphTargetBindGroupLayout = null;
  static hasLoggedMorphedPipeline = false;
  static hasLoggedMorphedMesh = false;
  instancedPipelines = new Map;
  instancedBindGroups = new WeakMap;
  static hasLoggedInstancedPipeline = false;
  constructor(gBuffer) {
    this.gBuffer = gBuffer;
  }
  init(device, context, presentationFormat) {}
  resize(width, height) {
    console.log(`GeometryPass: Resizing GBuffer to ${width}x${height}`);
    this.gBuffer.resize(width, height);
  }
  execute(commandEncoder, context, globalResources) {
    const needsVelocity = !this.gBuffer.useComputedVelocity;
    if (!this.gBuffer.albedoTexture || !this.gBuffer.normalTexture || !this.gBuffer.positionTexture || !this.gBuffer.emissiveTexture || !this.gBuffer.depthTexture || needsVelocity && !this.gBuffer.velocityTexture) {
      console.warn("GeometryPass: GBuffer textures not initialized");
      return;
    }
    if (!globalResources.renderBindGroup) {
      console.warn("GeometryPass: Global render bind group not initialized");
      return;
    }
    const { scene } = context;
    if (!this.hasLoggedExecution) {
      console.log("GeometryPass: Depth Texture Debug", {
        format: this.gBuffer.depthTexture.format,
        width: this.gBuffer.depthTexture.width,
        height: this.gBuffer.depthTexture.height,
        usage: this.gBuffer.depthTexture.usage,
        depthOrArrayLayers: this.gBuffer.depthTexture.depthOrArrayLayers,
        mipLevelCount: this.gBuffer.depthTexture.mipLevelCount
      });
    }
    const useFrustumCulling = scene.render.frustumCulling;
    if (useFrustumCulling) {
      this.viewProjectionMatrix.multiplyMatrices(context.camera.projectionMatrix, context.camera.viewMatrix);
      this.frustum.setFromProjectionMatrix(this.viewProjectionMatrix);
    }
    let meshCount = 0;
    const meshesToRender = [];
    const grassToRender = [];
    const flowersToRender = [];
    const instancedGLBToRender = [];
    const instancedMeshesToRender = [];
    const activeSubScene = context.activeSubScene;
    scene.traverse((node) => {
      if (!node.visible)
        return false;
      if (node instanceof SubScene) {
        if (activeSubScene && node === activeSubScene) {
          return;
        }
        return false;
      }
      const isDeferredMaterial = node instanceof Mesh && (node.material instanceof StandardMaterial || node.material instanceof TerrainMaterial);
      if (isDeferredMaterial) {
        const material = node.material;
        const isSkinnedMesh = node instanceof SkinnedMesh;
        if (isSkinnedMesh || material.getRenderingPath() === "deferred") {
          if (useFrustumCulling) {
            const bounds = node.worldBounds;
            if (!this.frustum.intersectsBox(bounds.min.x, bounds.min.y, bounds.min.z, bounds.max.x, bounds.max.y, bounds.max.z)) {
              return;
            }
          }
          meshesToRender.push(node);
        }
      } else if (node instanceof Grass) {
        grassToRender.push(node);
      } else if (node instanceof Flower) {
        flowersToRender.push(node);
      } else if (node instanceof InstancedMesh) {
        if (node.instanceCount > 0) {
          instancedMeshesToRender.push(node);
        }
      } else if (node instanceof InstancedGLBMesh) {
        instancedGLBToRender.push(node);
      }
    });
    const colorAttachments = [
      { view: this.gBuffer.albedoTexture.createView(), clearValue: { r: 0, g: 0, b: 0, a: 0 }, loadOp: "clear", storeOp: "store" },
      { view: this.gBuffer.normalTexture.createView(), clearValue: { r: 0, g: 0, b: 0, a: 0 }, loadOp: "clear", storeOp: "store" },
      { view: this.gBuffer.positionTexture.createView(), clearValue: { r: 0, g: 0, b: 0, a: 0 }, loadOp: "clear", storeOp: "store" },
      { view: this.gBuffer.emissiveTexture.createView(), clearValue: { r: 0, g: 0, b: 0, a: 0 }, loadOp: "clear", storeOp: "store" }
    ];
    if (needsVelocity) {
      colorAttachments.push({ view: this.gBuffer.velocityTexture.createView(), clearValue: { r: 0, g: 0, b: 0, a: 0 }, loadOp: "clear", storeOp: "store" });
    }
    const passDescriptor = {
      colorAttachments,
      depthStencilAttachment: {
        view: this.gBuffer.depthTexture.createView(),
        depthClearValue: 1,
        depthLoadOp: "clear",
        depthStoreOp: "store"
      }
    };
    const passEncoder = commandEncoder.beginRenderPass(passDescriptor);
    passEncoder.setBindGroup(0, globalResources.renderBindGroup);
    for (const mesh of meshesToRender) {
      this.renderMesh(mesh, context, passEncoder, globalResources);
      meshCount++;
    }
    for (const grass of grassToRender) {
      grass.render(passEncoder, globalResources.renderBindGroup);
    }
    for (const flower of flowersToRender) {
      flower.render(passEncoder, globalResources.renderBindGroup);
    }
    for (const instancedGLB of instancedGLBToRender) {
      instancedGLB.render(passEncoder, globalResources.renderBindGroup);
      if (context.frameStats) {
        context.frameStats.drawCalls++;
      }
    }
    for (const instancedMesh of instancedMeshesToRender) {
      this.renderInstancedMesh(instancedMesh, context, passEncoder, globalResources);
    }
    passEncoder.end();
    if (!this.hasLoggedExecution) {
      console.log(`GeometryPass: Rendered ${meshCount} deferred meshes, ${grassToRender.length} grass fields, ${flowersToRender.length} flower fields, ${instancedGLBToRender.length} instanced GLB meshes, ${instancedMeshesToRender.length} proper instanced meshes`);
      this.hasLoggedExecution = true;
    }
  }
  static hasLoggedSkinnedMesh = false;
  renderMesh(mesh, context, passEncoder, globalResources) {
    const device = this.gBuffer.device;
    if (!device)
      return;
    if (mesh instanceof SkinnedMesh && mesh.skeleton) {
      if (!GeometryPass.hasLoggedSkinnedMesh) {
        console.log("GeometryPass: Rendering skinned mesh:", mesh.name);
        GeometryPass.hasLoggedSkinnedMesh = true;
      }
      this.renderSkinnedMesh(mesh, context, passEncoder, globalResources);
      return;
    }
    if (mesh instanceof MorphTargetMesh && mesh.morphTargetCount > 0) {
      if (!GeometryPass.hasLoggedMorphedMesh) {
        console.log("GeometryPass: Rendering morph target mesh:", mesh.name);
        GeometryPass.hasLoggedMorphedMesh = true;
      }
      this.renderMorphTargetMesh(mesh, context, passEncoder, globalResources);
      return;
    }
    const hasVertexBuffers = Object.keys(mesh.geometry.attributes).every((name) => mesh.geometry.vertexBuffers[name]);
    const needsInit = mesh.geometry.buffersDirty || !hasVertexBuffers;
    if (needsInit) {
      this.initGeometryBuffers(device, mesh.geometry);
      return;
    }
    if (!mesh.material.pipeline) {
      this.initMaterialPipeline(device, mesh.material, mesh.geometry, globalResources);
    }
    if (!mesh.uniformBuffer || !mesh.bindGroup) {
      this.initMeshUniforms(device, mesh);
    }
    this.updateMeshUniforms(device, mesh, context);
    if (mesh.material.pipeline && mesh.bindGroup) {
      passEncoder.setPipeline(mesh.material.pipeline);
      passEncoder.setBindGroup(1, mesh.bindGroup);
      if (mesh.geometry.vertexBuffers["position"]) {
        passEncoder.setVertexBuffer(0, mesh.geometry.vertexBuffers["position"]);
      }
      if (mesh.geometry.vertexBuffers["normal"]) {
        passEncoder.setVertexBuffer(1, mesh.geometry.vertexBuffers["normal"]);
      }
      if (mesh.geometry.vertexBuffers["uv"]) {
        passEncoder.setVertexBuffer(2, mesh.geometry.vertexBuffers["uv"]);
      }
      const useIndirect = context.scene.render.indirectDraw;
      if (mesh.geometry.indexBuffer) {
        const indexFormat = mesh.geometry.indices instanceof Uint32Array ? "uint32" : "uint16";
        passEncoder.setIndexBuffer(mesh.geometry.indexBuffer, indexFormat);
        if (useIndirect) {
          const offset = mesh.renderIndex * IndirectDrawBuffer.STRIDE;
          passEncoder.drawIndexedIndirect(globalResources.indirectDrawBuffer.buffer, offset);
        } else {
          passEncoder.drawIndexed(mesh.geometry.indexCount, 1, 0, 0, mesh.renderIndex);
        }
      } else {
        if (useIndirect) {
          const offset = mesh.renderIndex * IndirectDrawBuffer.STRIDE;
          passEncoder.drawIndirect(globalResources.indirectDrawBuffer.buffer, offset);
        } else {
          passEncoder.draw(mesh.geometry.vertexCount, 1, 0, mesh.renderIndex);
        }
      }
      if (context.frameStats) {
        context.frameStats.drawCalls++;
        context.frameStats.triangles += mesh.geometry.triangleCount;
      }
    }
  }
  renderInstancedMesh(instancedMesh, context, passEncoder, globalResources) {
    const device = this.gBuffer.device;
    if (!device)
      return;
    const { geometry, material } = instancedMesh;
    const needsGeomInit = geometry.buffersDirty || Object.keys(geometry.attributes).some((name) => !geometry.vertexBuffers[name]);
    if (needsGeomInit) {
      this.initGeometryBuffers(device, geometry);
      return;
    }
    if (!instancedMesh.instanceBuffer) {
      console.warn("GeometryPass: InstancedMesh instance buffer not initialized");
      return;
    }
    instancedMesh._writeToGPU(device);
    const pipelineKey = `instanced_${material.getTextureFlags()}_${material.doubleSided ? "ds" : "ss"}`;
    let pipeline = this.instancedPipelines.get(pipelineKey);
    if (!pipeline) {
      if (!GeometryPass.hasLoggedInstancedPipeline) {
        console.log("GeometryPass: Creating instanced pipeline for", pipelineKey);
        GeometryPass.hasLoggedInstancedPipeline = true;
      }
      pipeline = this.initInstancedPipeline(device, material, geometry, globalResources) ?? undefined;
      if (pipeline) {
        this.instancedPipelines.set(pipelineKey, pipeline);
      } else {
        console.error("GeometryPass: Failed to create instanced pipeline!");
        return;
      }
    }
    let bindGroup = this.instancedBindGroups.get(instancedMesh);
    if (!bindGroup) {
      const uniformBuffer = device.createBuffer({
        label: "InstancedMesh Material Uniform Buffer",
        size: material.getUniformBufferSize(),
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
      });
      const materialLayout = material.createBindGroupLayout(device);
      bindGroup = device.createBindGroup({
        label: "InstancedMesh Material Bind Group",
        layout: materialLayout,
        entries: material.getBindGroupEntries(device, uniformBuffer)
      });
      this.instancedBindGroups.set(instancedMesh, bindGroup);
      material.updateUniforms(device, uniformBuffer, 0, context);
    }
    passEncoder.setPipeline(pipeline);
    passEncoder.setBindGroup(1, bindGroup);
    if (geometry.vertexBuffers["position"]) {
      passEncoder.setVertexBuffer(0, geometry.vertexBuffers["position"]);
    }
    if (geometry.vertexBuffers["normal"]) {
      passEncoder.setVertexBuffer(1, geometry.vertexBuffers["normal"]);
    }
    if (geometry.vertexBuffers["uv"]) {
      passEncoder.setVertexBuffer(2, geometry.vertexBuffers["uv"]);
    }
    passEncoder.setVertexBuffer(3, instancedMesh.instanceBuffer);
    if (geometry.indexBuffer) {
      const indexFormat = geometry.indices instanceof Uint32Array ? "uint32" : "uint16";
      passEncoder.setIndexBuffer(geometry.indexBuffer, indexFormat);
      passEncoder.drawIndexed(geometry.indexCount, instancedMesh.instanceCount);
    } else {
      passEncoder.draw(geometry.vertexCount, instancedMesh.instanceCount);
    }
    if (context.frameStats) {
      context.frameStats.drawCalls++;
      context.frameStats.triangles += geometry.triangleCount * instancedMesh.instanceCount;
    }
  }
  initInstancedPipeline(device, material, geometry, globalResources) {
    const includeVelocity = !this.gBuffer.useComputedVelocity;
    const vertexShader = material.getInstancedVertexShader("deferred");
    const fragmentShader = material.getInstancedFragmentShader("deferred");
    const vertexModule = createShaderModuleSafe(device, {
      label: "Instanced Material Vertex Shader",
      code: vertexShader
    });
    const fragmentModule = createShaderModuleSafe(device, {
      label: "Instanced Material Fragment Shader",
      code: fragmentShader
    });
    const buffers = [
      {
        arrayStride: 3 * 4,
        attributes: [{ shaderLocation: 0, offset: 0, format: "float32x3" }]
      },
      {
        arrayStride: 3 * 4,
        attributes: [{ shaderLocation: 1, offset: 0, format: "float32x3" }]
      },
      {
        arrayStride: 2 * 4,
        attributes: [{ shaderLocation: 2, offset: 0, format: "float32x2" }]
      },
      {
        arrayStride: 48,
        stepMode: "instance",
        attributes: [
          { shaderLocation: 3, offset: 0, format: "float32x4" },
          { shaderLocation: 4, offset: 16, format: "float32x4" },
          { shaderLocation: 5, offset: 32, format: "float32x4" }
        ]
      }
    ];
    const materialLayout = material.createBindGroupLayout(device);
    const pipelineLayout = device.createPipelineLayout({
      label: "Instanced Deferred Pipeline Layout",
      bindGroupLayouts: [
        globalResources.renderBindGroupLayout,
        materialLayout
      ]
    });
    const colorTargets = [
      { format: "rgba16float" },
      { format: "rgba16float" },
      { format: "rgba16float" },
      { format: "rgba16float" }
    ];
    if (includeVelocity) {
      colorTargets.push({ format: "rg16float" });
    }
    try {
      return device.createRenderPipeline({
        label: "Instanced Deferred Geometry Pipeline",
        layout: pipelineLayout,
        vertex: {
          module: vertexModule,
          entryPoint: "vs_main",
          buffers
        },
        fragment: {
          module: fragmentModule,
          entryPoint: "fs_main",
          targets: colorTargets
        },
        primitive: {
          topology: "triangle-list",
          cullMode: material.doubleSided ? "none" : "back"
        },
        depthStencil: {
          depthWriteEnabled: true,
          depthCompare: "less",
          format: "depth24plus"
        }
      });
    } catch (e) {
      console.error("GeometryPass: Failed to create instanced pipeline:", e);
      return null;
    }
  }
  renderSkinnedMesh(mesh, context, passEncoder, globalResources) {
    const device = this.gBuffer.device;
    if (!device || !mesh.skeleton)
      return;
    const needsInit = mesh.geometry.buffersDirty || Object.keys(mesh.geometry.attributes).some((name) => !mesh.geometry.vertexBuffers[name]);
    if (needsInit) {
      this.initGeometryBuffers(device, mesh.geometry);
      return;
    }
    mesh.prepareSkinning(device);
    if (!GeometryPass.hasLoggedSkinnedPipeline) {
      console.log("GeometryPass: Skinned mesh buffers:", {
        jointsBuffer: !!mesh.jointsBuffer,
        weightsBuffer: !!mesh.weightsBuffer,
        skeletonBuffer: !!mesh.skeleton.boneMatricesBuffer
      });
    }
    const material = mesh.material;
    const pipelineKey = `skinned_${material.constructor.name}_${material.getTextureFlags()}`;
    let pipeline = this.skinnedPipelines.get(pipelineKey);
    if (!pipeline) {
      console.log("GeometryPass: Creating skinned pipeline for", pipelineKey);
      pipeline = this.initSkinnedPipeline(device, material, mesh.geometry, globalResources) ?? undefined;
      if (pipeline) {
        this.skinnedPipelines.set(pipelineKey, pipeline);
        console.log("GeometryPass: Skinned pipeline created successfully");
      } else {
        console.error("GeometryPass: Failed to create skinned pipeline!");
      }
    }
    if (!pipeline)
      return;
    if (!mesh.uniformBuffer || !mesh.bindGroup) {
      this.initMeshUniforms(device, mesh, true);
    }
    this.updateMeshUniforms(device, mesh, context);
    if (!this.skeletonBindGroupLayout) {
      this.skeletonBindGroupLayout = Skeleton.createBindGroupLayout(device);
    }
    if (!mesh.skeleton.bindGroup) {
      mesh.skeleton.createBindGroup(device, this.skeletonBindGroupLayout);
    }
    if (!mesh.bindGroup || !mesh.skeleton.bindGroup)
      return;
    passEncoder.setPipeline(pipeline);
    passEncoder.setBindGroup(1, mesh.bindGroup);
    passEncoder.setBindGroup(2, mesh.skeleton.bindGroup);
    if (mesh.geometry.vertexBuffers["position"]) {
      passEncoder.setVertexBuffer(0, mesh.geometry.vertexBuffers["position"]);
    }
    if (mesh.geometry.vertexBuffers["normal"]) {
      passEncoder.setVertexBuffer(1, mesh.geometry.vertexBuffers["normal"]);
    }
    if (mesh.geometry.vertexBuffers["uv"]) {
      passEncoder.setVertexBuffer(2, mesh.geometry.vertexBuffers["uv"]);
    }
    if (mesh.jointsBuffer) {
      passEncoder.setVertexBuffer(3, mesh.jointsBuffer);
    }
    if (mesh.weightsBuffer) {
      passEncoder.setVertexBuffer(4, mesh.weightsBuffer);
    }
    if (mesh.geometry.indexBuffer) {
      const indexFormat = mesh.geometry.indices instanceof Uint32Array ? "uint32" : "uint16";
      passEncoder.setIndexBuffer(mesh.geometry.indexBuffer, indexFormat);
      passEncoder.drawIndexed(mesh.geometry.indexCount, 1, 0, 0, mesh.renderIndex);
    } else {
      passEncoder.draw(mesh.geometry.vertexCount, 1, 0, mesh.renderIndex);
    }
    if (context.frameStats) {
      context.frameStats.drawCalls++;
      context.frameStats.triangles += mesh.geometry.triangleCount;
    }
  }
  initSkinnedPipeline(device, material, geometry, globalResources) {
    const includeVelocity = !this.gBuffer.useComputedVelocity;
    const baseVertexShader = material.getVertexShader("deferred", { includeVelocity });
    const skinnedVertexShader = createSkinnedVertexShader(baseVertexShader);
    const vertexModule = createShaderModuleSafe(device, {
      label: "Skinned Material Vertex Shader",
      code: skinnedVertexShader
    });
    const fragmentModule = createShaderModuleSafe(device, {
      label: "Standard Material Fragment Shader (Skinned)",
      code: material.getFragmentShader("deferred", { includeVelocity })
    });
    const buffers = [
      {
        arrayStride: 3 * 4,
        attributes: [{ shaderLocation: 0, offset: 0, format: "float32x3" }]
      },
      {
        arrayStride: 3 * 4,
        attributes: [{ shaderLocation: 1, offset: 0, format: "float32x3" }]
      },
      {
        arrayStride: 2 * 4,
        attributes: [{ shaderLocation: 2, offset: 0, format: "float32x2" }]
      },
      {
        arrayStride: 4 * 4,
        attributes: [{ shaderLocation: 3, offset: 0, format: "uint32x4" }]
      },
      {
        arrayStride: 4 * 4,
        attributes: [{ shaderLocation: 4, offset: 0, format: "float32x4" }]
      }
    ];
    if (!this.skeletonBindGroupLayout) {
      this.skeletonBindGroupLayout = Skeleton.createBindGroupLayout(device);
    }
    const materialLayout = material.createBindGroupLayout(device);
    const pipelineLayout = device.createPipelineLayout({
      label: "Skinned Deferred Pipeline Layout",
      bindGroupLayouts: [
        globalResources.renderBindGroupLayout,
        materialLayout,
        this.skeletonBindGroupLayout
      ]
    });
    if (!GeometryPass.hasLoggedSkinnedPipeline) {
      console.log("GeometryPass: Creating skinned pipeline for skeletal animation");
      GeometryPass.hasLoggedSkinnedPipeline = true;
    }
    if (!GeometryPass.hasLoggedSkinnedPipeline) {
      console.log("GeometryPass: Skinned vertex shader (first 500 chars):", skinnedVertexShader.substring(0, 500));
      GeometryPass.hasLoggedSkinnedPipeline = true;
    }
    try {
      return device.createRenderPipeline({
        label: "Skinned Deferred Geometry Pipeline",
        layout: pipelineLayout,
        vertex: {
          module: vertexModule,
          entryPoint: "vs_main",
          buffers
        },
        fragment: {
          module: fragmentModule,
          entryPoint: "fs_main",
          targets: this.gBuffer.useComputedVelocity ? [
            { format: "rgba16float" },
            { format: "rgba16float" },
            { format: "rgba16float" },
            { format: this.gBuffer.emissiveFormat }
          ] : [
            { format: "rgba16float" },
            { format: "rgba16float" },
            { format: "rgba16float" },
            { format: this.gBuffer.emissiveFormat },
            { format: "rg16float" }
          ]
        },
        primitive: {
          topology: "triangle-list",
          cullMode: "none"
        },
        depthStencil: {
          depthWriteEnabled: true,
          depthCompare: "less",
          format: "depth24plus"
        }
      });
    } catch (e) {
      console.error("GeometryPass: Failed to create skinned pipeline:", e);
      console.error("GeometryPass: Skinned vertex shader:", skinnedVertexShader);
      return null;
    }
  }
  renderMorphTargetMesh(mesh, context, passEncoder, globalResources) {
    const device = this.gBuffer.device;
    if (!device)
      return;
    const material = mesh.material;
    const geometry = mesh.geometry;
    const needsInit = geometry.buffersDirty || Object.keys(geometry.attributes).some((name) => !geometry.vertexBuffers[name]);
    if (needsInit) {
      this.initGeometryBuffers(device, geometry);
    }
    mesh.prepareMorph(device);
    const pipelineKey = `morphed_${material.constructor.name}_${material.getTextureFlags()}_${mesh.morphTargetCount}`;
    let pipeline = this.morphedPipelines.get(pipelineKey);
    if (!pipeline) {
      pipeline = this.initMorphedPipeline(device, material, geometry, mesh.morphTargetCount, globalResources) ?? undefined;
      if (pipeline) {
        this.morphedPipelines.set(pipelineKey, pipeline);
        console.log("GeometryPass: Morphed pipeline created successfully");
      } else {
        console.error("GeometryPass: Failed to create morphed pipeline!");
      }
    }
    if (!pipeline)
      return;
    if (!mesh.uniformBuffer || !mesh.bindGroup) {
      this.initMeshUniforms(device, mesh, false);
    }
    this.updateMeshUniforms(device, mesh, context);
    if (!this.morphTargetBindGroupLayout) {
      this.morphTargetBindGroupLayout = MorphTargets.createBindGroupLayout(device);
    }
    if (!mesh.morphTargets.bindGroup) {
      mesh.morphTargets.createBindGroup(device, this.morphTargetBindGroupLayout);
    }
    if (!mesh.bindGroup || !mesh.morphTargets.bindGroup)
      return;
    passEncoder.setPipeline(pipeline);
    passEncoder.setBindGroup(1, mesh.bindGroup);
    passEncoder.setBindGroup(2, mesh.morphTargets.bindGroup);
    if (geometry.vertexBuffers["position"]) {
      passEncoder.setVertexBuffer(0, geometry.vertexBuffers["position"]);
    }
    if (geometry.vertexBuffers["normal"]) {
      passEncoder.setVertexBuffer(1, geometry.vertexBuffers["normal"]);
    }
    if (geometry.vertexBuffers["uv"]) {
      passEncoder.setVertexBuffer(2, geometry.vertexBuffers["uv"]);
    }
    if (geometry.indexBuffer) {
      const indexFormat = geometry.indices instanceof Uint32Array ? "uint32" : "uint16";
      passEncoder.setIndexBuffer(geometry.indexBuffer, indexFormat);
      passEncoder.drawIndexed(geometry.indexCount, 1, 0, 0, mesh.renderIndex);
    } else {
      passEncoder.draw(geometry.vertexCount, 1, 0, mesh.renderIndex);
    }
    if (context.frameStats) {
      context.frameStats.drawCalls++;
      context.frameStats.triangles += geometry.triangleCount;
    }
  }
  initMorphedPipeline(device, material, geometry, targetCount, globalResources) {
    const includeVelocity = !this.gBuffer.useComputedVelocity;
    const baseVertexShader = material.getVertexShader("deferred", { includeVelocity });
    const morphedVertexShader = createMorphedVertexShader(baseVertexShader, targetCount);
    const vertexModule = createShaderModuleSafe(device, {
      label: "Morphed Material Vertex Shader",
      code: morphedVertexShader
    });
    const fragmentModule = createShaderModuleSafe(device, {
      label: "Standard Material Fragment Shader (Morphed)",
      code: material.getFragmentShader("deferred", { includeVelocity })
    });
    const buffers = [
      {
        arrayStride: 3 * 4,
        attributes: [{ shaderLocation: 0, offset: 0, format: "float32x3" }]
      },
      {
        arrayStride: 3 * 4,
        attributes: [{ shaderLocation: 1, offset: 0, format: "float32x3" }]
      },
      {
        arrayStride: 2 * 4,
        attributes: [{ shaderLocation: 2, offset: 0, format: "float32x2" }]
      }
    ];
    if (!this.morphTargetBindGroupLayout) {
      this.morphTargetBindGroupLayout = MorphTargets.createBindGroupLayout(device);
    }
    const materialLayout = material.createBindGroupLayout(device);
    const pipelineLayout = device.createPipelineLayout({
      label: "Morphed Deferred Pipeline Layout",
      bindGroupLayouts: [
        globalResources.renderBindGroupLayout,
        materialLayout,
        this.morphTargetBindGroupLayout
      ]
    });
    if (!GeometryPass.hasLoggedMorphedPipeline) {
      console.log("GeometryPass: Creating morphed pipeline for morph targets");
      GeometryPass.hasLoggedMorphedPipeline = true;
    }
    try {
      return device.createRenderPipeline({
        label: "Morphed Deferred Geometry Pipeline",
        layout: pipelineLayout,
        vertex: {
          module: vertexModule,
          entryPoint: "vs_main",
          buffers
        },
        fragment: {
          module: fragmentModule,
          entryPoint: "fs_main",
          targets: this.gBuffer.useComputedVelocity ? [
            { format: "rgba16float" },
            { format: "rgba16float" },
            { format: "rgba16float" },
            { format: this.gBuffer.emissiveFormat }
          ] : [
            { format: "rgba16float" },
            { format: "rgba16float" },
            { format: "rgba16float" },
            { format: this.gBuffer.emissiveFormat },
            { format: "rg16float" }
          ]
        },
        primitive: {
          topology: "triangle-list",
          cullMode: "none"
        },
        depthStencil: {
          depthWriteEnabled: true,
          depthCompare: "less",
          format: "depth24plus"
        }
      });
    } catch (e) {
      console.error("GeometryPass: Failed to create morphed pipeline:", e);
      console.error("GeometryPass: Morphed vertex shader:", morphedVertexShader);
      return null;
    }
  }
  initGeometryBuffers(device, geometry) {
    if (geometry.buffersDirty) {
      for (const key in geometry.vertexBuffers) {
        geometry.vertexBuffers[key]?.destroy();
        delete geometry.vertexBuffers[key];
      }
      if (geometry.indexBuffer) {
        geometry.indexBuffer.destroy();
        geometry.indexBuffer = null;
      }
    }
    for (const [name, data] of Object.entries(geometry.attributes)) {
      if (!geometry.vertexBuffers[name]) {
        geometry.vertexBuffers[name] = createBufferWithData(device, data, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST, `${name} Buffer`);
      }
    }
    if (!geometry.attributes["normal"] && !geometry.vertexBuffers["normal"] && geometry.attributes["position"]) {
      const vertexCount = geometry.attributes["position"].length / 3;
      const defaultNormals = new Float32Array(vertexCount * 3);
      for (let i = 0;i < vertexCount; i++) {
        defaultNormals[i * 3 + 1] = 1;
      }
      geometry.vertexBuffers["normal"] = createBufferWithData(device, defaultNormals, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST, "Default Normal Buffer");
    }
    if (!geometry.attributes["uv"] && !geometry.vertexBuffers["uv"] && geometry.attributes["position"]) {
      const vertexCount = geometry.attributes["position"].length / 3;
      const defaultUVs = new Float32Array(vertexCount * 2);
      geometry.vertexBuffers["uv"] = createBufferWithData(device, defaultUVs, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST, "Default UV Buffer");
    }
    if (geometry.indices && !geometry.indexBuffer) {
      geometry.indexBuffer = createBufferWithData(device, geometry.indices, GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST, "Index Buffer");
    }
    geometry.markBuffersClean();
  }
  initMaterialPipeline(device, material, geometry, globalResources) {
    const includeVelocity = !this.gBuffer.useComputedVelocity;
    const vertexModule = createShaderModuleSafe(device, {
      label: "Standard Material Vertex Shader",
      code: material.getVertexShader("deferred", { includeVelocity })
    });
    const fragmentModule = createShaderModuleSafe(device, {
      label: "Standard Material Fragment Shader",
      code: material.getFragmentShader("deferred", { includeVelocity })
    });
    const buffers = [
      {
        arrayStride: 3 * 4,
        attributes: [{ shaderLocation: 0, offset: 0, format: "float32x3" }]
      },
      {
        arrayStride: 3 * 4,
        attributes: [{ shaderLocation: 1, offset: 0, format: "float32x3" }]
      },
      {
        arrayStride: 2 * 4,
        attributes: [{ shaderLocation: 2, offset: 0, format: "float32x2" }]
      }
    ];
    const materialLayout = material.createBindGroupLayout(device);
    const pipelineLayout = device.createPipelineLayout({
      label: "Deferred Pipeline Layout",
      bindGroupLayouts: [globalResources.renderBindGroupLayout, materialLayout]
    });
    if (!GeometryPass.hasLoggedPipeline) {
      console.log("GeometryPass: Creating pipeline with depth writes enabled");
      GeometryPass.hasLoggedPipeline = true;
    }
    material.pipeline = device.createRenderPipeline({
      label: "Deferred Geometry Pipeline",
      layout: pipelineLayout,
      vertex: {
        module: vertexModule,
        entryPoint: "vs_main",
        buffers
      },
      fragment: {
        module: fragmentModule,
        entryPoint: "fs_main",
        targets: this.gBuffer.useComputedVelocity ? [
          { format: "rgba16float" },
          { format: "rgba16float" },
          { format: "rgba16float" },
          { format: this.gBuffer.emissiveFormat }
        ] : [
          { format: "rgba16float" },
          { format: "rgba16float" },
          { format: "rgba16float" },
          { format: this.gBuffer.emissiveFormat },
          { format: "rg16float" }
        ]
      },
      primitive: {
        topology: "triangle-list",
        cullMode: "none"
      },
      depthStencil: {
        depthWriteEnabled: true,
        depthCompare: "less",
        format: "depth24plus"
      }
    });
  }
  initMeshUniforms(device, mesh, forSkinned = false) {
    if (!forSkinned && !mesh.material.pipeline)
      return;
    const material = mesh.material;
    const uniformBufferSize = material.getUniformBufferSize();
    mesh.uniformBuffer = device.createBuffer({
      label: "Material Uniform Buffer",
      size: uniformBufferSize,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    const layout = material.createBindGroupLayout(device);
    const entries = material.getBindGroupEntries(device, mesh.uniformBuffer);
    if (!GeometryPass.hasLoggedBindGroup) {
      const isStandardMaterial = material instanceof StandardMaterial;
      console.log("GeometryPass: Creating material bind group (first mesh)", {
        materialType: material.constructor.name,
        hasAlbedoMap: isStandardMaterial ? !!material.albedoMap : "N/A (TerrainMaterial)",
        hasNormalMap: isStandardMaterial ? !!material.normalMap : "N/A (TerrainMaterial)",
        textureFlags: material.getTextureFlags(),
        entries: entries.map((e) => ({ binding: e.binding, hasResource: !!e.resource }))
      });
      GeometryPass.hasLoggedBindGroup = true;
    }
    mesh.bindGroup = device.createBindGroup({
      label: "Material Bind Group",
      layout,
      entries
    });
  }
  updateMeshUniforms(device, mesh, parentContext) {
    if (!mesh.uniformBuffer)
      return;
    const context = {
      ...parentContext,
      modelMatrix: mesh.transform.worldMatrix
    };
    mesh.material.updateUniforms(device, mesh.uniformBuffer, 0, context);
  }
}

// ../../src/core/renderer/DeferredLightingPass.ts
class DeferredLightingPass {
  gBuffer;
  pipeline = null;
  bindGroup = null;
  gBufferLayout = null;
  canvasContext = null;
  hasLoggedExecution = false;
  constructor(gBuffer) {
    this.gBuffer = gBuffer;
  }
  init(device, context, presentationFormat) {
    this.canvasContext = context;
  }
  resize(width, height) {
    this.bindGroup = null;
  }
  execute(commandEncoder, context, globalResources) {
    const device = this.gBuffer.device;
    if (!device || !this.canvasContext) {
      console.warn("DeferredLightingPass: Missing device or canvas context");
      return;
    }
    if (!this.pipeline) {
      this.createPipeline(device, "rgba16float", globalResources);
      console.log("DeferredLightingPass: Pipeline created");
    }
    if (!this.bindGroup) {
      this.createBindGroup(device);
      console.log("DeferredLightingPass: Bind group created");
    }
    const textureView = this.gBuffer.accumulationTexture?.createView();
    if (!textureView) {
      console.warn("DeferredLightingPass: Missing accumulation texture");
      return;
    }
    const renderPassDescriptor = {
      colorAttachments: [
        {
          view: textureView,
          clearValue: { r: 0, g: 0, b: 0, a: 1 },
          loadOp: "clear",
          storeOp: "store"
        }
      ]
    };
    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
    if (this.pipeline) {
      passEncoder.setPipeline(this.pipeline);
    }
    passEncoder.setBindGroup(0, globalResources.renderBindGroup);
    if (this.bindGroup) {
      passEncoder.setBindGroup(1, this.bindGroup);
    }
    passEncoder.draw(3);
    passEncoder.end();
    if (!this.hasLoggedExecution) {
      console.log("DeferredLightingPass: Executed fullscreen pass");
      this.hasLoggedExecution = true;
    }
  }
  createPipeline(device, format, globalResources) {
    const code = `
      struct Light {
        position: vec3f,
        _pad1: f32,
        direction: vec3f,
        _pad2: f32,
        color: vec3f,
        intensity: f32,
        attenuation: vec3f,
        lightType: u32,
        coneAngles: vec2f,
        shadowIndex: i32,  // -1 = no shadow, 0-3 = shadow atlas layer
        shadowRadius: f32, // Shadow softness/blur radius (higher = softer)
        shadowIntensity: f32, // How dark shadows get (0=no shadow, 1=fully dark)
        _pad3: f32,
        _pad4: f32,
        _pad5: f32,
      }

      struct SceneUniforms {
        viewMatrix : mat4x4<f32>,
        projectionMatrix : mat4x4<f32>,
        lightViewProj : mat4x4<f32>,
        prevViewProj : mat4x4<f32>,
        inverseProjectionMatrix : mat4x4<f32>,
        cameraPosition : vec3f,
        time : f32,
        lightCount : u32,
        debugMode : u32,
        flags : u32,
        environmentIntensity : f32,
        fogColor: vec3f,
        fogDensity: f32,
        fogParams: vec4f,     // x=start, y=end, z=height, w=heightFalloff
        fogSettings: vec4u,   // x=type, y=enabled, z=pad, w=pad
        cloudShadowParams: vec4f,  // x=enabled, y=intensity, z=scale, w=speed
        cloudShadowParams2: vec4f, // x=coverage, y=softness, z=windDirX, w=windDirZ
        // Fog2 (Three.js-style fog)
        fog2Color: vec3f,     // Fog color
        fog2Density: f32,     // FogExp2 density for objects
        fog2Params: vec4f,    // x=near, y=far, z=type (0=LINEAR, 1=EXP2), w=enabled
        fog2SkyFalloff: f32,  // How high fog extends into sky (0=none, 1=zenith)
        _fog2Pad1: f32,       // padding
        _fog2Pad2: f32,       // padding
        _fog2Pad3: f32,       // padding
        lights : array<Light, 8>, // Match MAX_LIGHTS
      }

      struct ShadowLight {
        viewProj: mat4x4<f32>,
        atlasLayer: u32,
        bias: f32,
        normalBias: f32,
        _pad: u32,
      }

      struct ShadowUniforms {
        lights: array<ShadowLight, 4>,
        shadowLightCount: u32,
        atlasResolution: f32,
        _pad: vec2<f32>,
      }

      @group(0) @binding(0) var<uniform> scene : SceneUniforms;
      // Binding 1: Objects
      // Binding 2: Hi-Z

      // Light Storage Buffer - supports up to 1024 lights (vs 8 in SceneUniforms)
      struct LightStorage {
        lightCount: u32,
        _pad1: u32,
        _pad2: u32,
        _pad3: u32,
        lights: array<Light, 1024>,
      }
      @group(0) @binding(3) var<storage, read> lightStorage : LightStorage;

      @group(0) @binding(4) var shadowTex: texture_depth_2d_array;
      @group(0) @binding(5) var shadowSamp: sampler_comparison;
      @group(0) @binding(6) var envMap: texture_cube<f32>;
      @group(0) @binding(7) var envSamp: sampler;
      @group(0) @binding(8) var<uniform> shadowUniforms: ShadowUniforms;
      @group(0) @binding(9) var pointShadowTex: texture_2d_array<f32>;
      @group(0) @binding(10) var pointShadowSamp: sampler;

      // Cascade Shadow Map uniforms for directional lights
      struct CascadeUniforms {
        viewProj: array<mat4x4<f32>, 4>,  // View-proj matrix for each cascade
        splits: vec4<f32>,                 // View-space depth thresholds
        biases: vec4<f32>,                 // Per-cascade depth bias
      }
      @group(0) @binding(11) var<uniform> cascadeUniforms: CascadeUniforms;

      @group(1) @binding(0) var albedoTex: texture_2d<f32>;
      @group(1) @binding(1) var normalTex: texture_2d<f32>;
      @group(1) @binding(2) var positionTex: texture_2d<f32>;
      @group(1) @binding(3) var depthTex: texture_depth_2d;
      @group(1) @binding(4) var emissiveTex: texture_2d<f32>;
      @group(1) @binding(5) var samp: sampler;
      @group(1) @binding(6) var ssaoTex: texture_2d<f32>;
      @group(1) @binding(7) var ssgiTex: texture_2d<f32>;
      @group(1) @binding(8) var ssgiRawTex: texture_2d<f32>;

      const PI = 3.14159265359;

      // ==========================================
      // Cloud Shadow Noise Functions (FBM)
      // ==========================================

      // Simple hash function for noise
      fn hash2(p: vec2f) -> f32 {
          let h = dot(p, vec2f(127.1, 311.7));
          return fract(sin(h) * 43758.5453);
      }

      // Value noise
      fn noise2(p: vec2f) -> f32 {
          let i = floor(p);
          let f = fract(p);
          let u = f * f * (3.0 - 2.0 * f); // Smoothstep

          let a = hash2(i);
          let b = hash2(i + vec2f(1.0, 0.0));
          let c = hash2(i + vec2f(0.0, 1.0));
          let d = hash2(i + vec2f(1.0, 1.0));

          return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
      }

      // FBM (Fractal Brownian Motion) for cloud shadows
      fn fbmCloudShadow(pos: vec2f) -> f32 {
          var p = pos;
          var value = 0.0;
          var amplitude = 0.5;
          var frequency = 1.0;

          for (var i = 0; i < 5; i++) {
              value += amplitude * noise2(p * frequency);
              amplitude *= 0.5;
              frequency *= 2.0;
          }

          return value;
      }

      // Calculate cloud shadow factor based on world position
      fn getCloudShadow(worldPos: vec3f) -> f32 {
          let enabled = scene.cloudShadowParams.x;
          if (enabled < 0.5) {
              return 1.0; // No shadow when disabled
          }

          let intensity = scene.cloudShadowParams.y;
          let scale = scene.cloudShadowParams.z;
          let speed = scene.cloudShadowParams.w;
          let coverage = scene.cloudShadowParams2.x;
          let softness = scene.cloudShadowParams2.y;
          let windDirX = scene.cloudShadowParams2.z;
          let windDirZ = scene.cloudShadowParams2.w;

          // Calculate UV from world XZ position with wind animation
          let windOffset = vec2f(windDirX, windDirZ) * scene.time * speed;
          let uv = worldPos.xz * scale + windOffset;

          // Sample FBM noise
          let noise = fbmCloudShadow(uv);

          // Apply coverage threshold - higher coverage = more shadow
          // noise is typically 0-1, coverage shifts the threshold
          let threshold = 1.0 - coverage;
          let cloudAmount = smoothstep(threshold - softness * 0.5, threshold + softness * 0.5, noise);

          // Return shadow factor: 1 = no shadow, (1-intensity) = max shadow
          return 1.0 - cloudAmount * intensity;
      }

      fn inverse(m: mat4x4f) -> mat4x4f {
        let a00 = m[0][0]; let a01 = m[0][1]; let a02 = m[0][2]; let a03 = m[0][3];
        let a10 = m[1][0]; let a11 = m[1][1]; let a12 = m[1][2]; let a13 = m[1][3];
        let a20 = m[2][0]; let a21 = m[2][1]; let a22 = m[2][2]; let a23 = m[2][3];
        let a30 = m[3][0]; let a31 = m[3][1]; let a32 = m[3][2]; let a33 = m[3][3];

        let b00 = a00 * a11 - a01 * a10;
        let b01 = a00 * a12 - a02 * a10;
        let b02 = a00 * a13 - a03 * a10;
        let b03 = a01 * a12 - a02 * a11;
        let b04 = a01 * a13 - a03 * a11;
        let b05 = a02 * a13 - a03 * a12;
        let b06 = a20 * a31 - a21 * a30;
        let b07 = a20 * a32 - a22 * a30;
        let b08 = a20 * a33 - a23 * a30;
        let b09 = a21 * a32 - a22 * a31;
        let b10 = a21 * a33 - a23 * a31;
        let b11 = a22 * a33 - a23 * a32;

        let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        let invDet = 1.0 / det;

        return mat4x4f(
            a11 * b11 - a12 * b10 + a13 * b09,
            a02 * b10 - a01 * b11 - a03 * b09,
            a31 * b05 - a32 * b04 + a33 * b03,
            a22 * b04 - a21 * b05 - a23 * b03,
            a12 * b08 - a10 * b11 - a13 * b07,
            a00 * b11 - a02 * b08 + a03 * b07,
            a32 * b02 - a30 * b05 - a33 * b00,
            a20 * b05 - a22 * b02 + a23 * b00,
            a10 * b10 - a11 * b08 + a13 * b06,
            a01 * b08 - a00 * b10 - a03 * b06,
            a30 * b04 - a31 * b02 + a33 * b01,
            a21 * b02 - a20 * b04 - a23 * b01,
            a11 * b07 - a10 * b09 - a12 * b06,
            a00 * b09 - a01 * b07 + a02 * b06,
            a31 * b01 - a30 * b03 - a32 * b00,
            a20 * b03 - a21 * b01 + a22 * b00
        ) * invDet;
      }

      fn applyFog(color: vec3f, worldPos: vec3f, cameraPos: vec3f) -> vec3f {
        let fogEnabled = scene.fogSettings.y;
        if (fogEnabled == 0u) {
            return color;
        }

        let dist = length(worldPos - cameraPos);
        var fogFactor = 0.0;
        let fogType = scene.fogSettings.x;
        let density = scene.fogDensity;

        if (fogType == 1u) { // LINEAR
            let start = scene.fogParams.x;
            let end = scene.fogParams.y;
            fogFactor = clamp((dist - start) / (end - start), 0.0, 1.0);
        } else if (fogType == 2u) { // EXPONENTIAL (like Three.js FogExp2)
            // Simple exponential: fog increases with distance
            // Using density directly (not squared) for more intuitive control
            fogFactor = 1.0 - exp(-density * dist);
            fogFactor = clamp(fogFactor, 0.0, 1.0);
        } else if (fogType == 3u) { // EXPONENTIAL HEIGHT (Unreal Engine style)
            // Fog that is denser at lower altitudes, fades with height
            // But ALWAYS has some distance-based fog to hide the horizon
            //
            // Parameters:
            // - density: base fog density
            // - fogParams.x: start distance (fog begins here, not at camera)
            // - fogParams.z: fog base height (fog is densest below this)
            // - fogParams.w: height falloff (how quickly fog fades with altitude)

            let startDist = scene.fogParams.x;
            let fogBaseHeight = scene.fogParams.z;
            let heightFalloff = scene.fogParams.w;

            // Effective distance (accounting for start distance)
            let effectiveDist = max(dist - startDist, 0.0);

            // Base exponential fog from distance - this always applies
            // This ensures distant objects (horizon) always get fogged
            let baseFog = 1.0 - exp(-density * effectiveDist);

            // Height-based density modifier
            // Fog is full strength below fogBaseHeight, decreases above
            // Both the camera and the object height affect the fog
            let avgHeight = (worldPos.y + cameraPos.y) * 0.5;
            let heightAboveBase = max(avgHeight - fogBaseHeight, 0.0);
            let heightMultiplier = exp(-heightFalloff * heightAboveBase);

            // Combine: base distance fog scaled by height factor
            // Always keep at least 30% of base fog to ensure horizon hiding
            let minFogMultiplier = 0.3;
            fogFactor = baseFog * max(heightMultiplier, minFogMultiplier);
            fogFactor = clamp(fogFactor, 0.0, 1.0);
        }

        return mix(color, scene.fogColor, fogFactor);
      }

      // ==========================================
      // Fog2: Three.js-style fog (exact port)
      // ==========================================
      // Three.js uses view-space Z depth: vFogDepth = -mvPosition.z
      // This is the distance along the camera's view direction, NOT euclidean distance
      fn applyFog2(color: vec3f, worldPos: vec3f) -> vec3f {
        // Check if fog2 is enabled (fog2Params.w)
        let fog2Enabled = scene.fog2Params.w;
        if (fog2Enabled < 0.5) {
            return color;
        }

        // Calculate view-space Z depth (exactly like Three.js)
        // Three.js: vFogDepth = -mvPosition.z where mvPosition = modelViewMatrix * position
        // We transform world position to view space and take -z
        let viewPos = scene.viewMatrix * vec4f(worldPos, 1.0);
        let fogDepth = -viewPos.z;  // Negate because camera looks down -Z in view space

        var fogFactor = 0.0;
        let fog2Type = scene.fog2Params.z; // 0 = LINEAR, 1 = EXP2

        if (fog2Type < 0.5) {
            // LINEAR fog (Three.js Fog class)
            // Formula: smoothstep(fogNear, fogFar, vFogDepth)
            let fogNear = scene.fog2Params.x;
            let fogFar = scene.fog2Params.y;
            fogFactor = smoothstep(fogNear, fogFar, fogDepth);
        } else {
            // EXPONENTIAL SQUARED fog (Three.js FogExp2 class)
            // Formula: 1.0 - exp(-fogDensity * fogDensity * vFogDepth * vFogDepth)
            let fogDensity = scene.fog2Density;
            fogFactor = 1.0 - exp(-fogDensity * fogDensity * fogDepth * fogDepth);
        }

        fogFactor = clamp(fogFactor, 0.0, 1.0);
        return mix(color, scene.fog2Color, fogFactor);
      }

      fn distributionGGX(N: vec3f, H: vec3f, roughness: f32) -> f32 {
        let a = roughness * roughness;
        let a2 = a * a;
        let NdotH = max(dot(N, H), 0.0);
        let NdotH2 = NdotH * NdotH;
        let num = a2;
        let denom = (NdotH2 * (a2 - 1.0) + 1.0);
        return num / (PI * denom * denom);
      }

      fn geometrySchlickGGX(NdotV: f32, roughness: f32) -> f32 {
        let r = (roughness + 1.0);
        let k = (r * r) / 8.0;
        let num = NdotV;
        let denom = NdotV * (1.0 - k) + k;
        return num / denom;
      }

      fn geometrySmith(N: vec3f, V: vec3f, L: vec3f, roughness: f32) -> f32 {
        let NdotV = max(dot(N, V), 0.0);
        let NdotL = max(dot(N, L), 0.0);
        let ggx2 = geometrySchlickGGX(NdotV, roughness);
        let ggx1 = geometrySchlickGGX(NdotL, roughness);
        return ggx1 * ggx2;
      }

      fn fresnelSchlick(cosTheta: f32, F0: vec3f) -> vec3f {
        return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
      }

      // Frostbite 3 physically-based distance attenuation
      // Based on: https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
      fn getDistanceAttenuation(lightDistance: f32, cutoffDistance: f32, decayExponent: f32) -> f32 {
          // Clamp minimum distance to prevent extreme brightness very close to light source
          // This creates a "core" radius where brightness is constant, matching real light behavior
          let minDistance = 0.5; // Half meter minimum distance
          let clampedDistance = max(lightDistance, minDistance);

          // Base inverse power falloff with clamped distance
          var distanceFalloff = 1.0 / max(pow(clampedDistance, decayExponent), 0.01);

          // Smooth windowing function when cutoff is specified
          if (cutoffDistance > 0.0) {
              let ratio = lightDistance / cutoffDistance;
              let ratio2 = ratio * ratio;
              let ratio4 = ratio2 * ratio2;
              // Smooth falloff to zero at cutoff distance
              distanceFalloff *= pow(saturate(1.0 - ratio4), 2.0);
          }

          return distanceFalloff;
      }

      // Get hemisphere light irradiance based on surface normal
      // Interpolates between ground and sky color based on how much the surface faces up
      fn getHemisphereLightIrradiance(skyColor: vec3f, groundColor: vec3f, normal: vec3f, direction: vec3f) -> vec3f {
          let dotNL = dot(normal, direction);
          let hemiDiffuseWeight = dotNL * 0.5 + 0.5;  // Remap [-1,1] to [0,1]
          return mix(groundColor, skyColor, hemiDiffuseWeight);
      }

      struct VertexOutput {
        @builtin(position) position : vec4f,
        @location(0) uv : vec2f,
        @location(1) @interpolate(flat) invViewProj0 : vec4f,
        @location(2) @interpolate(flat) invViewProj1 : vec4f,
        @location(3) @interpolate(flat) invViewProj2 : vec4f,
        @location(4) @interpolate(flat) invViewProj3 : vec4f,
      }

      @vertex
      fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
        var output : VertexOutput;
        let pos = array(
          vec2f(-1.0, -1.0),
          vec2f( 3.0, -1.0),
          vec2f(-1.0,  3.0)
        );
        let p = pos[vertexIndex];
        output.position = vec4f(p, 0.0, 1.0);
        output.uv = p * 0.5 + 0.5;
        output.uv.y = 1.0 - output.uv.y;
        
        let viewProj = scene.projectionMatrix * scene.viewMatrix;
        let invViewProj = inverse(viewProj);
        output.invViewProj0 = invViewProj[0];
        output.invViewProj1 = invViewProj[1];
        output.invViewProj2 = invViewProj[2];
        output.invViewProj3 = invViewProj[3];
        
        return output;
      }

      fn worldFromDepth(depth: f32, uv: vec2f, invViewProj: mat4x4f) -> vec3f {
        let clipXY = vec2f(uv.x * 2.0 - 1.0, (1.0 - uv.y) * 2.0 - 1.0);
        let clipPos = vec4f(clipXY, depth, 1.0);
        let worldPos = invViewProj * clipPos;
        return worldPos.xyz / worldPos.w;
      }

      // Sample shadow for a specific light using its shadow atlas layer
      fn sampleShadowForLight(shadowLightIdx: u32, worldPos: vec3f, N: vec3f, L: vec3f) -> f32 {
        if ((scene.flags & 1u) == 0u) {
            return 1.0;
        }
        if (shadowLightIdx >= shadowUniforms.shadowLightCount) {
            return 1.0;
        }

        let shadowLight = shadowUniforms.lights[shadowLightIdx];

        // Apply normal bias to prevent shadow acne on surfaces facing away from light
        let biasedWorldPos = worldPos + N * shadowLight.normalBias;

        // Project to light space
        let lightSpacePos = shadowLight.viewProj * vec4f(biasedWorldPos, 1.0);
        let projCoords = lightSpacePos.xyz / lightSpacePos.w;
        let uv = vec2f(projCoords.x, -projCoords.y) * 0.5 + 0.5;

        // Check bounds
        if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0 || projCoords.z < 0.0 || projCoords.z > 1.0) {
            return 1.0;
        }

        // Dynamic bias based on surface angle
        let angleBias = max(shadowLight.bias * (1.0 - dot(N, L)), shadowLight.bias * 0.1);
        let currentDepth = projCoords.z - angleBias;

        // PCF (Percentage Closer Filtering) with 3x3 kernel
        var visibility = 0.0;
        let oneOverSize = 1.0 / shadowUniforms.atlasResolution;
        let layer = i32(shadowLight.atlasLayer);

        for (var y = -1; y <= 1; y++) {
            for (var x = -1; x <= 1; x++) {
                let offset = vec2f(f32(x), f32(y)) * oneOverSize;
                visibility += textureSampleCompareLevel(
                    shadowTex, shadowSamp,
                    uv + offset, layer, currentDepth
                );
            }
        }
        return visibility / 9.0;
      }

      // Legacy function for backward compatibility (uses first shadow light)
      fn sampleShadow(worldPos: vec3f, N: vec3f, L: vec3f) -> f32 {
        return sampleShadowForLight(0u, worldPos, N, L);
      }

      // Sample a single cascade at specified index with randomized PCF
      fn sampleCascadeWithNoise(cascade: u32, worldPos: vec3f, N: vec3f, fragCoord: vec2f) -> f32 {
        let viewProj = cascadeUniforms.viewProj[cascade];
        let bias = cascadeUniforms.biases[cascade];

        // Minimal normal bias - just enough to prevent acne
        let normalBias = 0.01;
        let biasedWorldPos = worldPos + N * normalBias;

        // Project to light space
        let lightSpacePos = viewProj * vec4f(biasedWorldPos, 1.0);
        let projCoords = lightSpacePos.xyz / lightSpacePos.w;
        let uv = vec2f(projCoords.x, -projCoords.y) * 0.5 + 0.5;

        // Check bounds
        if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0 || projCoords.z < 0.0 || projCoords.z > 1.0) {
            return 1.0;
        }

        let currentDepth = projCoords.z - bias;

        // PCF with Vogel disk and per-pixel rotation to break up moire patterns
        var visibility = 0.0;
        let oneOverSize = 1.0 / 2048.0; // Shadow map size
        let layer = i32(cascade); // Cascades use layers 0-3

        // Scale filter size by cascade - larger cascades get larger filter
        let filterScale = 1.0 + f32(cascade) * 0.5;
        let filterRadius = oneOverSize * filterScale * 1.5;

        // Use IGN to rotate sampling pattern per pixel - eliminates moire/banding
        let phi = interleavedGradientNoise(fragCoord) * 6.283185307;

        // 12 Vogel disk samples for smooth, noise-free shadows
        let NUM_SAMPLES = 12;
        for (var i = 0; i < NUM_SAMPLES; i++) {
            let offset2D = vogelDiskSample(i, NUM_SAMPLES, phi) * filterRadius;
            visibility += textureSampleCompareLevel(
                shadowTex, shadowSamp,
                uv + offset2D, layer, currentDepth
            );
        }
        return visibility / f32(NUM_SAMPLES);
      }

      // Legacy function for compatibility (without noise)
      fn sampleCascade(cascade: u32, worldPos: vec3f, N: vec3f) -> f32 {
        let viewProj = cascadeUniforms.viewProj[cascade];
        let bias = cascadeUniforms.biases[cascade];
        let normalBias = 0.01;
        let biasedWorldPos = worldPos + N * normalBias;
        let lightSpacePos = viewProj * vec4f(biasedWorldPos, 1.0);
        let projCoords = lightSpacePos.xyz / lightSpacePos.w;
        let uv = vec2f(projCoords.x, -projCoords.y) * 0.5 + 0.5;
        if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0 || projCoords.z < 0.0 || projCoords.z > 1.0) {
            return 1.0;
        }
        let currentDepth = projCoords.z - bias;
        var visibility = 0.0;
        let oneOverSize = 1.0 / 2048.0;
        let layer = i32(cascade);
        for (var y = -1; y <= 1; y++) {
            for (var x = -1; x <= 1; x++) {
                let offset = vec2f(f32(x), f32(y)) * oneOverSize;
                visibility += textureSampleCompareLevel(shadowTex, shadowSamp, uv + offset, layer, currentDepth);
            }
        }
        return visibility / 9.0;
      }

      // Cascaded Shadow Map sampling for directional lights with blending
      fn sampleCascadedShadowWithNoise(worldPos: vec3f, N: vec3f, viewMatrix: mat4x4<f32>, fragCoord: vec2f) -> f32 {
        if ((scene.flags & 1u) == 0u) {
            return 1.0; // Shadows disabled
        }

        // Get view-space depth (negative Z in view space)
        let viewPos = viewMatrix * vec4f(worldPos, 1.0);
        let depth = -viewPos.z;

        // Select cascade based on depth
        var cascade = 3u;
        if (depth < cascadeUniforms.splits.x) {
            cascade = 0u;
        } else if (depth < cascadeUniforms.splits.y) {
            cascade = 1u;
        } else if (depth < cascadeUniforms.splits.z) {
            cascade = 2u;
        }

        // Sample primary cascade with noise-based PCF
        let shadow1 = sampleCascadeWithNoise(cascade, worldPos, N, fragCoord);

        // Cascade blending at boundaries (last 25% of each cascade)
        // Larger blend region reduces visible seams on flat surfaces
        if (cascade < 3u) {
            let splits = array<f32, 4>(
                cascadeUniforms.splits.x,
                cascadeUniforms.splits.y,
                cascadeUniforms.splits.z,
                cascadeUniforms.splits.w
            );
            let cascadeEnd = splits[cascade];
            let blendStart = cascadeEnd * 0.75; // Blend in last 25%

            if (depth > blendStart) {
                // Use smoothstep for a more gradual transition
                let t = (depth - blendStart) / (cascadeEnd - blendStart);
                let blendFactor = t * t * (3.0 - 2.0 * t); // smoothstep
                let shadow2 = sampleCascadeWithNoise(cascade + 1u, worldPos, N, fragCoord);
                return mix(shadow1, shadow2, blendFactor);
            }
        }

        return shadow1;
      }

      // Legacy version without noise (for compatibility)
      fn sampleCascadedShadow(worldPos: vec3f, N: vec3f, viewMatrix: mat4x4<f32>) -> f32 {
        if ((scene.flags & 1u) == 0u) { return 1.0; }
        let viewPos = viewMatrix * vec4f(worldPos, 1.0);
        let depth = -viewPos.z;
        var cascade = 3u;
        if (depth < cascadeUniforms.splits.x) { cascade = 0u; }
        else if (depth < cascadeUniforms.splits.y) { cascade = 1u; }
        else if (depth < cascadeUniforms.splits.z) { cascade = 2u; }
        let shadow1 = sampleCascade(cascade, worldPos, N);
        if (cascade < 3u) {
            let splits = array<f32, 4>(cascadeUniforms.splits.x, cascadeUniforms.splits.y, cascadeUniforms.splits.z, cascadeUniforms.splits.w);
            let cascadeEnd = splits[cascade];
            let blendStart = cascadeEnd * 0.75;
            if (depth > blendStart) {
                let t = (depth - blendStart) / (cascadeEnd - blendStart);
                let blendFactor = t * t * (3.0 - 2.0 * t);
                let shadow2 = sampleCascade(cascade + 1u, worldPos, N);
                return mix(shadow1, shadow2, blendFactor);
            }
        }
        return shadow1;
      }

      // PCF Shadow Sampling Utilities (matching Three.js approach)

      // Interleaved Gradient Noise for randomizing sampling patterns per pixel
      fn interleavedGradientNoise(position: vec2f) -> f32 {
          return fract(52.9829189 * fract(dot(position, vec2f(0.06711056, 0.00583715))));
      }

      // Vogel disk sampling for uniform circular distribution
      fn vogelDiskSample(sampleIndex: i32, samplesCount: i32, phi: f32) -> vec2f {
          let goldenAngle = 2.399963229728653;
          let r = sqrt((f32(sampleIndex) + 0.5) / f32(samplesCount));
          let theta = f32(sampleIndex) * goldenAngle + phi;
          return vec2f(cos(theta), sin(theta)) * r;
      }

      // Convert direction to cube face index and UV coordinates
      // Face order: 0=+X, 1=-X, 2=+Y, 3=-Y, 4=+Z, 5=-Z
      // Derived from lookAt view matrices: ze=eye-target, xe=up×ze, ye=ze×xe
      // UV.x = dot(dir, xe), UV.y = dot(dir, ye) but Y is flipped for texture coords
      fn dirToCubeFaceUV(dir: vec3f) -> vec3f {
          let absDir = abs(dir);
          var faceIndex: f32;
          var uv: vec2f;

          if (absDir.x >= absDir.y && absDir.x >= absDir.z) {
              // X face
              if (dir.x > 0.0) {
                  faceIndex = 0.0; // +X: xe=(0,0,-1), ye=(0,-1,0)
                  uv = vec2f(-dir.z, dir.y) / absDir.x;
              } else {
                  faceIndex = 1.0; // -X: xe=(0,0,1), ye=(0,-1,0)
                  uv = vec2f(dir.z, dir.y) / absDir.x;
              }
          } else if (absDir.y >= absDir.x && absDir.y >= absDir.z) {
              // Y face
              if (dir.y > 0.0) {
                  faceIndex = 2.0; // +Y: xe=(1,0,0), ye=(0,0,1)
                  uv = vec2f(dir.x, -dir.z) / absDir.y;
              } else {
                  faceIndex = 3.0; // -Y: xe=(1,0,0), ye=(0,0,-1)
                  uv = vec2f(dir.x, dir.z) / absDir.y;
              }
          } else {
              // Z face
              if (dir.z > 0.0) {
                  faceIndex = 4.0; // +Z: xe=(1,0,0), ye=(0,-1,0)
                  uv = vec2f(dir.x, dir.y) / absDir.z;
              } else {
                  faceIndex = 5.0; // -Z: xe=(-1,0,0), ye=(0,-1,0)
                  uv = vec2f(-dir.x, dir.y) / absDir.z;
              }
          }

          // Convert from [-1,1] to [0,1]
          uv = uv * 0.5 + 0.5;
          return vec3f(uv, faceIndex);
      }

      fn samplePointShadow(shadowIndex: i32, worldPos: vec3f, lightPos: vec3f, fragCoord: vec2f, shadowRadius: f32, shadowIntensity: f32) -> f32 {
          // Early return handled with select to avoid non-uniform control flow issues
          let shadowsEnabled = (scene.flags & 1u) != 0u;

          let lightToFrag = worldPos - lightPos;
          let dist = length(lightToFrag);
          let dir = lightToFrag / dist;

          // Calculate linear distance from light, normalized by far plane
          let far = 100.0;
          let currentDepth = dist / far;

          // Shadow softness from light.shadow.radius (adjustable via JS)
          // Higher values = softer shadows. 0.05 is default, try 0.1-0.2 for very soft
          let shadowSoftness = shadowRadius;

          // Scale offset based on distance - shadows get softer further from light
          // This simulates realistic penumbra behavior
          let diskRadius = shadowSoftness * dist;

          // Build tangent-space coordinate system for sampling offsets
          // This ensures offsets are perpendicular to the light direction
          let absDir = abs(dir);
          var tangent: vec3f;
          if (absDir.x > absDir.z) {
              tangent = vec3f(0.0, 1.0, 0.0);
          } else {
              tangent = vec3f(1.0, 0.0, 0.0);
          }
          tangent = normalize(cross(dir, tangent));
          let bitangent = cross(dir, tangent);

          // Use IGN to rotate sampling pattern per pixel - eliminates banding artifacts
          let phi = interleavedGradientNoise(fragCoord) * 6.283185307;

          // PCF with 9 Vogel disk samples for smoother shadows
          let bias = 0.003;
          var shadow = 0.0;
          let NUM_SAMPLES = 9;

          for (var i = 0; i < NUM_SAMPLES; i++) {
              let offset2D = vogelDiskSample(i, NUM_SAMPLES, phi);
              // Apply offset in world space perpendicular to light direction
              let samplePos = worldPos + (tangent * offset2D.x + bitangent * offset2D.y) * diskRadius;
              let sampleVec = samplePos - lightPos;
              let sampleDist = length(sampleVec);
              let sampleDir = sampleVec / sampleDist;
              let sampleDepth = sampleDist / far;

              let faceUV = dirToCubeFaceUV(sampleDir);
              let layerIndex = shadowIndex * 6 + i32(faceUV.z);

              let shadowMapDepth = textureSampleLevel(pointShadowTex, pointShadowSamp, faceUV.xy, layerIndex, 0.0).r;
              shadow += select(0.0, 1.0, sampleDepth - bias <= shadowMapDepth);
          }

          shadow = shadow / f32(NUM_SAMPLES);

          // Apply shadow intensity - allows ambient light to "leak through" shadows
          // shadowIntensity=1.0 means fully dark shadows, 0.7 means 30% light leaks through
          let finalShadow = mix(1.0, shadow, shadowIntensity);

          // Return 1.0 if shadows disabled, otherwise the shadow value
          return select(1.0, finalShadow, shadowsEnabled);
      }

      @fragment
      fn fs_main(
        @builtin(position) fragCoord: vec4f,
        @location(0) uv: vec2f,
        @location(1) @interpolate(flat) invViewProj0: vec4f,
        @location(2) @interpolate(flat) invViewProj1: vec4f,
        @location(3) @interpolate(flat) invViewProj2: vec4f,
        @location(4) @interpolate(flat) invViewProj3: vec4f
      ) -> @location(0) vec4f {
        let invViewProj = mat4x4f(invViewProj0, invViewProj1, invViewProj2, invViewProj3);

        let albedo = textureSample(albedoTex, samp, uv);
        let normalRough = textureSample(normalTex, samp, uv);
        let positionOccl = textureSample(positionTex, samp, uv);
        let emissiveData = textureSample(emissiveTex, samp, uv);
        let emissive = emissiveData.rgb;
        let ambientIntensity = emissiveData.a;  // Per-material ambient multiplier (0-1)
        let depth = textureLoad(depthTex, vec2i(floor(fragCoord.xy)), 0);
        let ssao = textureSample(ssaoTex, samp, uv).r;
        let ssgi = textureSample(ssgiTex, samp, uv).rgb;

        // Safe normalize to prevent NaN from degenerate/missing normals
        let rawN = normalRough.xyz * 2.0 - 1.0;
        let nLen = length(rawN);
        let N = select(vec3f(0.0, 1.0, 0.0), rawN / nLen, nLen > 0.0001);
        let worldPos = positionOccl.xyz;
        let occlusion = positionOccl.w * ssao; // Combine Material AO and SSAO

        // Debug: Show depth value
        if (scene.debugMode == 10u) {
            return vec4f(vec3f(depth), 1.0);
        }
        
        // ... Debug Modes ...
        if (scene.debugMode == 1u) { return vec4f(albedo.rgb, 1.0); }
        if (scene.debugMode == 2u) { return vec4f(N * 0.5 + 0.5, 1.0); }
        if (scene.debugMode == 3u) { return vec4f(vec3f(pow(depth, 50.0)), 1.0); }
        if (scene.debugMode == 4u) { return vec4f(worldPos, 1.0); }
        if (scene.debugMode == 7u) { return vec4f(vec3f(occlusion), 1.0); } // Debug AO (Combined)
        if (scene.debugMode == 8u) { return vec4f(emissive, 1.0); } // Debug Emissive
        if (scene.debugMode == 9u) { return vec4f(vec3f(ssao), 1.0); } // Debug SSAO Only
        if (scene.debugMode == 11u) { return vec4f(ssgi, 1.0); } // Debug SSGI (Denoised)
        if (scene.debugMode == 12u) { return vec4f(textureSample(ssgiRawTex, samp, uv).rgb, 1.0); } // Debug SSGI Raw

        // Pixels with no geometry (depth = 1.0) are at infinite distance
        // If fog is enabled, render them as fully fogged (fog color)
        // Otherwise discard to show sky behind
        if (depth >= 1.0) {
            // Check Fog2 first (Three.js-style fog)
            let fog2Enabled = scene.fog2Params.w;
            if (fog2Enabled >= 0.5) {
                return vec4f(scene.fog2Color, 1.0);
            }
            // Check old fog system
            let fogEnabled = scene.fogSettings.y;
            if (fogEnabled != 0u) {
                return vec4f(scene.fogColor, 1.0);
            }
            discard;
        }

        let roughness = albedo.a;
        let metallic = normalRough.a;
        let V = normalize(scene.cameraPosition - worldPos);

        var F0 = vec3f(0.04);
        F0 = mix(F0, albedo.rgb, metallic);
        var Lo = vec3f(0.0);

        // ===========================================
        // PHASE 1: Accumulate Ambient Irradiance
        // Ambient/Hemisphere lights are NOT affected by shadows
        // ===========================================
        var ambientIrradiance = vec3f(0.0);
        for (var i = 0u; i < lightStorage.lightCount; i++) {
          let light = lightStorage.lights[i];

          if (light.lightType == 3u) { // Ambient Light
              // Flat ambient - same everywhere regardless of normal
              ambientIrradiance += light.color * light.intensity;
          } else if (light.lightType == 4u) { // Hemisphere Light
              // Sky/ground interpolation based on surface normal
              // light.color = skyColor, light.attenuation = groundColor
              let hemiIrradiance = getHemisphereLightIrradiance(
                  light.color,
                  light.attenuation,  // groundColor stored in attenuation field
                  N,
                  light.direction     // up direction (usually 0,1,0)
              );
              ambientIrradiance += hemiIrradiance * light.intensity;
          }
        }

        // ===========================================
        // PHASE 2: Direct Lighting with Shadows
        // Only Directional, Point, and Spot lights
        // ===========================================

        // Debug: track shadow values per light (up to 4)
        var debugShadows = array<f32, 4>(1.0, 1.0, 1.0, 1.0);
        var debugShadowIndices = array<i32, 4>(-1, -1, -1, -1);
        var shadowLightCount = 0u;

        for (var i = 0u; i < lightStorage.lightCount; i++) {
          let light = lightStorage.lights[i];

          // Skip ambient and hemisphere lights (already processed above)
          if (light.lightType == 3u || light.lightType == 4u) {
              continue;
          }

          var L = vec3f(0.0);
          var attenuation = 1.0;
          var shadow = 1.0;

          if (light.lightType == 0u) { // Directional
            L = normalize(-light.direction);
          } else {
             let lightVec = light.position - worldPos;
             let dist = length(lightVec);
             L = normalize(lightVec);

             // Frostbite 3 physically-based attenuation
             // light.attenuation.x = distance (cutoff), light.attenuation.y = decay exponent
             let cutoffDistance = light.attenuation.x;
             let decayExponent = select(2.0, light.attenuation.y, light.attenuation.y > 0.0);
             attenuation = getDistanceAttenuation(dist, cutoffDistance, decayExponent);

             if (light.lightType == 2u) { // Spot
               let spotDir = normalize(-light.direction);
               let angle = acos(dot(L, spotDir));
               let inner = light.coneAngles.x;
               let outer = light.coneAngles.y;
               let spotEffect = 1.0 - smoothstep(inner, outer, angle);
               attenuation *= spotEffect;
            }
          }

          // Sample shadow if this light has a valid shadow index
          // (deferred objects always receive shadows; use forward rendering for no-shadow materials)
          if (light.shadowIndex >= 0) {
            if (light.lightType == 0u) { // Directional - use Cascaded Shadow Maps with noise-based PCF
                shadow = sampleCascadedShadowWithNoise(worldPos, N, scene.viewMatrix, fragCoord.xy);
                // Apply shadow intensity - allows ambient light to "leak through" shadows
                shadow = mix(1.0, shadow, light.shadowIntensity);
            } else if (light.lightType == 1u) { // Point
                shadow = samplePointShadow(light.shadowIndex, worldPos, light.position, fragCoord.xy, light.shadowRadius, light.shadowIntensity);
            } else { // Spot
                shadow = sampleShadowForLight(u32(light.shadowIndex), worldPos, N, L);
                // Apply shadow intensity for spot lights too
                shadow = mix(1.0, shadow, light.shadowIntensity);
            }
          }

          // Apply cloud shadow cookies to directional lights
          if (light.lightType == 0u) {
            shadow *= getCloudShadow(worldPos);
          }

          // Track for debug (for any light that casts shadows)
          if (light.shadowIndex >= 0 && shadowLightCount < 4u) {
            debugShadows[shadowLightCount] = shadow;
            debugShadowIndices[shadowLightCount] = light.shadowIndex;
            shadowLightCount++;
          }

          let H = normalize(V + L);
          let radiance = light.color * light.intensity * attenuation * shadow;

          let NDF = distributionGGX(N, H, roughness);
          let G = geometrySmith(N, V, L, roughness);
          let F = fresnelSchlick(max(dot(H, V), 0.0), F0);

          let numerator = NDF * G * F;
          let denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.0001;
          let specular = numerator / denominator;

          let kS = F;
          var kD = vec3f(1.0) - kS;
          kD *= 1.0 - metallic;

          let NdotL = max(dot(N, L), 0.0);
          // Apply SSAO to direct diffuse as well (optional but helps visibility)
          Lo += (kD * albedo.rgb * occlusion / PI + specular) * radiance * NdotL;
        }
        
        // IBL Calculations
        let R = reflect(-V, N);
        
        let numLevels = f32(textureNumLevels(envMap));
        let lod = roughness * (numLevels - 1.0);
        
        let iblSpecular = textureSampleLevel(envMap, envSamp, R, lod).rgb;
        
        let diffuseLOD = numLevels - 2.0; 
        let skyColor = textureSampleLevel(envMap, envSamp, vec3f(0.0, 1.0, 0.0), diffuseLOD).rgb;
        let groundColor = textureSampleLevel(envMap, envSamp, vec3f(0.0, -1.0, 0.0), diffuseLOD).rgb;
        let hemiMix = N.y * 0.5 + 0.5;
        var iblDiffuse = mix(groundColor, skyColor, hemiMix);
        
        // Add SSGI to IBL Diffuse
        // SSGI replaces or adds to the IBL? usually adds (indirect bounces)
        // If we use SSGI, we should probably reduce simple ambient IBL or mix them based on sky visibility?
        // For now, let's just add it.
        iblDiffuse += ssgi;

        let F_IBL = fresnelSchlick(max(dot(N, V), 0.0), F0);
        let kS_IBL = F_IBL;
        var kD_IBL = vec3f(1.0) - kS_IBL;
        kD_IBL *= 1.0 - metallic;

        // Apply AO to IBL/Ambient only
        let ambientIBL = (kD_IBL * albedo.rgb * iblDiffuse + iblSpecular * F_IBL) * scene.environmentIntensity * occlusion;

        // ===========================================
        // PHASE 3: Final Composition
        // Combine IBL, explicit ambient lights, direct lighting, and emissive
        // ===========================================

        // Explicit ambient light contribution (AmbientLight + HemisphereLight)
        // Apply as Lambertian diffuse with AO, scaled by per-material ambient intensity
        let explicitAmbient = kD_IBL * albedo.rgb * ambientIrradiance * occlusion * ambientIntensity / PI;

        // Total ambient = IBL ambient + explicit ambient lights
        let totalAmbient = ambientIBL + explicitAmbient;

        var finalColor = totalAmbient + Lo + emissive;

        // Debug mode 22: Visualize fog factor (white = full fog, black = no fog)
        if (scene.debugMode == 22u) {
            let dist = length(worldPos - scene.cameraPosition);
            var fogFactor = 0.0;
            let fogType = scene.fogSettings.x;
            let density = scene.fogDensity;

            if (fogType == 2u) { // EXPONENTIAL
                let fogExp = density * density * dist * dist;
                fogFactor = 1.0 - exp(-fogExp);
            } else if (fogType == 3u) { // EXPONENTIAL_HEIGHT
                let fogHeight = scene.fogParams.z;
                let heightBelowFog = max(fogHeight - worldPos.y, 0.0);
                let m = heightBelowFog * dist;
                let fogExp = density * density * m * m;
                fogFactor = 1.0 - exp(-fogExp);
            }
            return vec4f(vec3f(fogFactor), 1.0);
        }

        // Debug mode 23: Visualize distance from camera (normalized to 0-100 range)
        if (scene.debugMode == 23u) {
            let dist = length(worldPos - scene.cameraPosition);
            return vec4f(vec3f(dist / 100.0), 1.0);
        }

        finalColor = applyFog(finalColor, worldPos, scene.cameraPosition);

        // Apply Fog2 (Three.js-style fog) if enabled
        finalColor = applyFog2(finalColor, worldPos);

        // Debug mode 20: Raw shadow values as grayscale bands
        // Left third = shadow0, Middle third = shadow1, Right third = shadowLightCount indicator
        if (scene.debugMode == 20u) {
          if (uv.x < 0.33) {
            return vec4f(vec3f(debugShadows[0]), 1.0); // Left: shadow 0
          } else if (uv.x < 0.66) {
            return vec4f(vec3f(debugShadows[1]), 1.0); // Middle: shadow 1
          } else {
            // Right: color based on shadowLightCount
            if (shadowLightCount == 0u) { return vec4f(1.0, 0.0, 0.0, 1.0); } // RED = 0 lights
            if (shadowLightCount == 1u) { return vec4f(1.0, 1.0, 0.0, 1.0); } // YELLOW = 1 light
            if (shadowLightCount == 2u) { return vec4f(0.0, 1.0, 0.0, 1.0); } // GREEN = 2 lights
            return vec4f(0.0, 1.0, 1.0, 1.0); // CYAN = 3+ lights
          }
        }
        // Debug mode 21: Show raw shadowIndex values as bands
        // Left = light[0].shadowIndex, Right = light[1].shadowIndex
        if (scene.debugMode == 21u) {
          if (uv.x < 0.5) {
            // Left half: light[0].shadowIndex
            if (lightStorage.lightCount == 0u) { return vec4f(0.5, 0.0, 0.5, 1.0); } // PURPLE = no lights
            let idx = lightStorage.lights[0].shadowIndex;
            if (idx == -1) { return vec4f(1.0, 0.0, 0.0, 1.0); } // RED = -1
            if (idx == 0) { return vec4f(0.0, 1.0, 0.0, 1.0); } // GREEN = 0
            if (idx == 1) { return vec4f(0.0, 0.0, 1.0, 1.0); } // BLUE = 1
            return vec4f(1.0, 1.0, 0.0, 1.0); // YELLOW = other
          } else {
            // Right half: light[1].shadowIndex
            if (lightStorage.lightCount < 2u) { return vec4f(0.5, 0.0, 0.5, 1.0); } // PURPLE = < 2 lights
            let idx = lightStorage.lights[1].shadowIndex;
            if (idx == -1) { return vec4f(1.0, 0.0, 0.0, 1.0); } // RED = -1
            if (idx == 0) { return vec4f(0.0, 1.0, 0.0, 1.0); } // GREEN = 0
            if (idx == 1) { return vec4f(0.0, 0.0, 1.0, 1.0); } // BLUE = 1
            return vec4f(1.0, 1.0, 0.0, 1.0); // YELLOW = other
          }
        }
        // Debug mode 22: Show only shadow 0 (grayscale)
        if (scene.debugMode == 22u) {
          return vec4f(vec3f(debugShadows[0]), 1.0);
        }
        // Debug mode 23: Show only shadow 1 (grayscale)
        if (scene.debugMode == 23u) {
          return vec4f(vec3f(debugShadows[1]), 1.0);
        }
        // Debug mode 24: Light counts - very clear
        // GREEN = has lights, BLUE = has shadow uniforms, RED = missing something
        if (scene.debugMode == 24u) {
          var col = vec3f(0.0);
          if (lightStorage.lightCount > 0u) { col.g = 1.0; } // GREEN = has lights
          if (shadowUniforms.shadowLightCount > 0u) { col.b = 1.0; } // BLUE = has shadow uniforms
          if (lightStorage.lightCount == 0u || shadowUniforms.shadowLightCount == 0u) { col.r = 1.0; } // RED = problem
          // CYAN = both good, RED = problem
          return vec4f(col, 1.0);
        }
        // Debug mode 25: Shadow atlas direct sample
        // GREEN = layer 0 has data, BLUE = layer 1 has data
        if (scene.debugMode == 25u) {
          let layer0 = textureSampleCompareLevel(shadowTex, shadowSamp, vec2f(0.5, 0.5), 0, 0.5);
          let layer1 = textureSampleCompareLevel(shadowTex, shadowSamp, vec2f(0.5, 0.5), 1, 0.5);
          var col = vec3f(0.0);
          if (layer0 > 0.1) { col.g = 1.0; } // GREEN = layer 0 has depth
          if (layer1 > 0.1) { col.b = 1.0; } // BLUE = layer 1 has depth
          if (layer0 < 0.1 && layer1 < 0.1) { col.r = 1.0; } // RED = no data
          return vec4f(col, 1.0);
        }
        // Debug mode 26: Show atlas layer being sampled for each shadow light
        // Left = shadowUniforms.lights[0].atlasLayer, Right = shadowUniforms.lights[1].atlasLayer
        if (scene.debugMode == 26u) {
          if (uv.x < 0.5) {
            let layer = shadowUniforms.lights[0].atlasLayer;
            if (layer == 0u) { return vec4f(0.0, 1.0, 0.0, 1.0); } // GREEN = layer 0
            if (layer == 1u) { return vec4f(0.0, 0.0, 1.0, 1.0); } // BLUE = layer 1
            return vec4f(1.0, 0.0, 0.0, 1.0); // RED = other
          } else {
            let layer = shadowUniforms.lights[1].atlasLayer;
            if (layer == 0u) { return vec4f(0.0, 1.0, 0.0, 1.0); } // GREEN = layer 0
            if (layer == 1u) { return vec4f(0.0, 0.0, 1.0, 1.0); } // BLUE = layer 1
            return vec4f(1.0, 0.0, 0.0, 1.0); } // RED = other
        }
        // Debug mode 27: Sample shadow using shadowUniforms.lights[0] viewProj - shows if dirLight shadow works
        if (scene.debugMode == 27u) {
          let shadowLight = shadowUniforms.lights[0];
          let biasedWorldPos = worldPos + N * shadowLight.normalBias;
          let lightSpacePos = shadowLight.viewProj * vec4f(biasedWorldPos, 1.0);
          let projCoords = lightSpacePos.xyz / lightSpacePos.w;
          let shadowUV = vec2f(projCoords.x, -projCoords.y) * 0.5 + 0.5;
          // Show UV coords: R = U, G = V, B = depth
          return vec4f(shadowUV.x, shadowUV.y, projCoords.z, 1.0);
        }
        // Debug mode 28: Sample shadow using shadowUniforms.lights[1] viewProj - shows if spotlight shadow works
        if (scene.debugMode == 28u) {
          let shadowLight = shadowUniforms.lights[1];
          let biasedWorldPos = worldPos + N * shadowLight.normalBias;
          let lightSpacePos = shadowLight.viewProj * vec4f(biasedWorldPos, 1.0);
          let projCoords = lightSpacePos.xyz / lightSpacePos.w;
          let shadowUV = vec2f(projCoords.x, -projCoords.y) * 0.5 + 0.5;
          // Show UV coords: R = U, G = V, B = depth
          return vec4f(shadowUV.x, shadowUV.y, projCoords.z, 1.0);
        }
        // Debug mode 29: Show raw matrix diagonal elements for shadowUniforms.lights[0]
        // If all zeros, the matrix wasn't written correctly
        if (scene.debugMode == 29u) {
          let m = shadowUniforms.lights[0].viewProj;
          // Show diagonal elements: m[0][0], m[1][1], m[2][2], m[3][3]
          // Scaled to 0-1 range (assuming values roughly -1 to 1)
          let d0 = m[0][0] * 0.5 + 0.5;
          let d1 = m[1][1] * 0.5 + 0.5;
          let d2 = m[2][2] * 0.5 + 0.5;
          // Display as RGB
          return vec4f(d0, d1, d2, 1.0);
        }
        // Debug mode 30: Show raw matrix translation elements for shadowUniforms.lights[0]
        // m[3][0], m[3][1], m[3][2] are translation components
        if (scene.debugMode == 30u) {
          let m = shadowUniforms.lights[0].viewProj;
          // Show translation elements scaled to visible range
          let t0 = m[3][0] * 0.01 + 0.5; // Scale down large values
          let t1 = m[3][1] * 0.01 + 0.5;
          let t2 = m[3][2] * 0.01 + 0.5;
          return vec4f(t0, t1, t2, 1.0);
        }
        // Debug mode 31: Check if shadowUniforms.lights[0] vs lights[1] have different matrices
        // Shows lights[0] on left, lights[1] on right - diagonal sum
        if (scene.debugMode == 31u) {
          if (uv.x < 0.5) {
            let m = shadowUniforms.lights[0].viewProj;
            let sum = abs(m[0][0]) + abs(m[1][1]) + abs(m[2][2]) + abs(m[3][3]);
            return vec4f(vec3f(sum * 0.1), 1.0); // Scale to visible
          } else {
            let m = shadowUniforms.lights[1].viewProj;
            let sum = abs(m[0][0]) + abs(m[1][1]) + abs(m[2][2]) + abs(m[3][3]);
            return vec4f(vec3f(sum * 0.1), 1.0);
          }
        }
        // Debug mode 32: Sample shadow atlas layer 0 at light[0]'s projected UV
        // Shows actual shadow map depth vs current depth
        if (scene.debugMode == 32u) {
          let shadowLight = shadowUniforms.lights[0];
          let lightSpacePos = shadowLight.viewProj * vec4f(worldPos, 1.0);
          let projCoords = lightSpacePos.xyz / lightSpacePos.w;
          let shadowUV = vec2f(projCoords.x, -projCoords.y) * 0.5 + 0.5;

          // Use textureLoad instead to avoid sampler issues with depth textures
          let texSize = textureDimensions(shadowTex);
          let texCoord = vec2i(shadowUV * vec2f(texSize));
          let shadowDepth = textureLoad(shadowTex, texCoord, 0, 0);
          let currentDepth = projCoords.z;

          // R = shadow map depth, G = current depth, B = difference
          return vec4f(shadowDepth, currentDepth, abs(shadowDepth - currentDepth) * 10.0, 1.0);
        }
        // Debug mode 33: Show if point is inside light frustum for light[0]
        if (scene.debugMode == 33u) {
          let shadowLight = shadowUniforms.lights[0];
          let lightSpacePos = shadowLight.viewProj * vec4f(worldPos, 1.0);
          let projCoords = lightSpacePos.xyz / lightSpacePos.w;
          let shadowUV = vec2f(projCoords.x, -projCoords.y) * 0.5 + 0.5;

          // Check bounds
          var col = vec3f(0.0, 1.0, 0.0); // GREEN = inside
          if (shadowUV.x < 0.0 || shadowUV.x > 1.0) { col = vec3f(1.0, 0.0, 0.0); } // RED = outside X
          if (shadowUV.y < 0.0 || shadowUV.y > 1.0) { col = vec3f(1.0, 0.5, 0.0); } // ORANGE = outside Y
          if (projCoords.z < 0.0) { col = vec3f(0.0, 0.0, 1.0); } // BLUE = behind light
          if (projCoords.z > 1.0) { col = vec3f(1.0, 0.0, 1.0); } // MAGENTA = too far
          return vec4f(col, 1.0);
        }
        // Debug mode 34: Compare scene.lightViewProj vs shadowUniforms.lights[0].viewProj
        // These SHOULD be identical. If different, buffer write is wrong.
        if (scene.debugMode == 34u) {
          // Project using scene.lightViewProj (from SceneUniforms)
          let sceneLightSpace = scene.lightViewProj * vec4f(worldPos, 1.0);
          let sceneProj = sceneLightSpace.xyz / sceneLightSpace.w;
          let sceneUV = vec2f(sceneProj.x, -sceneProj.y) * 0.5 + 0.5;

          // Project using shadowUniforms.lights[0].viewProj
          let shadowLightSpace = shadowUniforms.lights[0].viewProj * vec4f(worldPos, 1.0);
          let shadowProj = shadowLightSpace.xyz / shadowLightSpace.w;
          let shadowUV = vec2f(shadowProj.x, -shadowProj.y) * 0.5 + 0.5;

          // Show difference: should be BLACK if matrices match
          let diff = abs(sceneUV - shadowUV);
          return vec4f(diff.x * 10.0, diff.y * 10.0, 0.0, 1.0);
        }
        // Debug mode 35: Show UV from scene.lightViewProj (legacy matrix)
        if (scene.debugMode == 35u) {
          let lightSpacePos = scene.lightViewProj * vec4f(worldPos, 1.0);
          let projCoords = lightSpacePos.xyz / lightSpacePos.w;
          let shadowUV = vec2f(projCoords.x, -projCoords.y) * 0.5 + 0.5;
          return vec4f(shadowUV.x, shadowUV.y, projCoords.z, 1.0);
        }

        // Debug mode 40: Point Shadow Raw Depth (using 2D array with manual face selection)
        if (scene.debugMode == 40u) {
            let lightPos = vec3f(2.0, 2.5, 2.0); // Hardcoded from atmosphere.ts
            let L = worldPos - lightPos;
            let dir = normalize(L);

            // Convert direction to face index and UV
            let faceUV = dirToCubeFaceUV(dir);
            let layerIndex = i32(faceUV.z); // shadowIndex 0 * 6 + face

            // Sample raw depth from shadow map
            let shadowDepth = textureSampleLevel(pointShadowTex, pointShadowSamp, faceUV.xy, layerIndex, 0.0).r;

            // Show: R=shadowDepth, G=currentDepth, B=comparison result
            let far = 100.0;
            let currentDepth = length(L) / far;
            let inLight = select(0.0, 1.0, currentDepth - 0.005 <= shadowDepth);
            return vec4f(shadowDepth, currentDepth, inLight, 1.0);
        }

        // Debug mode 41: Visualize cube map direction
        if (scene.debugMode == 41u) {
            let lightPos = vec3f(2.0, 2.5, 2.0);
            let L = worldPos - lightPos;
            let dir = normalize(L);
            // Show direction as color (RGB = XYZ mapped to 0-1)
            return vec4f(dir * 0.5 + 0.5, 1.0);
        }

        // Debug mode 42: Sample each face directly from 2D array (layers 0-5)
        if (scene.debugMode == 42u) {
            // Sample center of each face (layer 0-5 for light index 0)
            let depthPX = textureSampleLevel(pointShadowTex, pointShadowSamp, vec2f(0.5, 0.5), 0, 0.0).r; // +X
            let depthNX = textureSampleLevel(pointShadowTex, pointShadowSamp, vec2f(0.5, 0.5), 1, 0.0).r; // -X
            let depthPY = textureSampleLevel(pointShadowTex, pointShadowSamp, vec2f(0.5, 0.5), 2, 0.0).r; // +Y
            let depthNY = textureSampleLevel(pointShadowTex, pointShadowSamp, vec2f(0.5, 0.5), 3, 0.0).r; // -Y
            let depthPZ = textureSampleLevel(pointShadowTex, pointShadowSamp, vec2f(0.5, 0.5), 4, 0.0).r; // +Z
            let depthNZ = textureSampleLevel(pointShadowTex, pointShadowSamp, vec2f(0.5, 0.5), 5, 0.0).r; // -Z
            return vec4f(depthPX, depthNY, depthPZ, 1.0); // Show +X, -Y, +Z as RGB
        }

        // Debug mode 43: Sample center of -Y face (layer 3) - ground should be visible
        if (scene.debugMode == 43u) {
            let depth = textureSampleLevel(pointShadowTex, pointShadowSamp, vec2f(0.5, 0.5), 3, 0.0).r;
            return vec4f(vec3f(depth), 1.0); // Should be < 1.0 if ground is rendered
        }

        // Debug mode 44: Use textureLoad (no sampler) to rule out sampler issues
        if (scene.debugMode == 44u) {
            let texSize = textureDimensions(pointShadowTex);
            let coord = vec2i(i32(texSize.x) / 2, i32(texSize.y) / 2); // Center pixel
            let depth0 = textureLoad(pointShadowTex, coord, 0, 0).r; // Layer 0 (+X)
            let depth3 = textureLoad(pointShadowTex, coord, 3, 0).r; // Layer 3 (-Y)
            let depth5 = textureLoad(pointShadowTex, coord, 5, 0).r; // Layer 5 (-Z)
            return vec4f(depth0, depth3, depth5, 1.0); // RGB = layers 0, 3, 5
        }

        // Debug mode 45: Show texture dimensions
        if (scene.debugMode == 45u) {
            let texSize = textureDimensions(pointShadowTex);
            let layers = textureNumLayers(pointShadowTex);
            // Encode dimensions as colors (scaled)
            return vec4f(f32(texSize.x) / 2048.0, f32(texSize.y) / 2048.0, f32(layers) / 24.0, 1.0);
        }

        // Debug mode 46: Show which cube face is being sampled (colored by face)
        // +X=Red, -X=Cyan, +Y=Green, -Y=Magenta, +Z=Blue, -Z=Yellow
        if (scene.debugMode == 46u) {
            let lightPos = vec3f(2.0, 2.5, 2.0);
            let L = worldPos - lightPos;
            let dir = normalize(L);
            let faceUV = dirToCubeFaceUV(dir);
            let face = i32(faceUV.z);
            var col = vec3f(0.0);
            if (face == 0) { col = vec3f(1.0, 0.0, 0.0); } // +X = Red
            if (face == 1) { col = vec3f(0.0, 1.0, 1.0); } // -X = Cyan
            if (face == 2) { col = vec3f(0.0, 1.0, 0.0); } // +Y = Green
            if (face == 3) { col = vec3f(1.0, 0.0, 1.0); } // -Y = Magenta
            if (face == 4) { col = vec3f(0.0, 0.0, 1.0); } // +Z = Blue
            if (face == 5) { col = vec3f(1.0, 1.0, 0.0); } // -Z = Yellow
            return vec4f(col, 1.0);
        }

        // Debug mode 47: Show UV coordinates being used for shadow sampling
        if (scene.debugMode == 47u) {
            let lightPos = vec3f(2.0, 2.5, 2.0);
            let L = worldPos - lightPos;
            let dir = normalize(L);
            let faceUV = dirToCubeFaceUV(dir);
            return vec4f(faceUV.xy, 0.0, 1.0); // R=U, G=V
        }

        return vec4f(finalColor, 1.0);
      }`;
    this.gBufferLayout = device.createBindGroupLayout({
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 3, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "depth" } },
        { binding: 4, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 5, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "non-filtering" } },
        { binding: 6, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 7, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 8, visibility: GPUShaderStage.FRAGMENT, texture: {} }
      ]
    });
    const pipelineLayout = device.createPipelineLayout({
      bindGroupLayouts: [globalResources.renderBindGroupLayout, this.gBufferLayout]
    });
    this.pipeline = device.createRenderPipeline({
      label: "Deferred Lighting Pipeline",
      layout: pipelineLayout,
      vertex: {
        module: createShaderModuleSafe(device, { code }),
        entryPoint: "vs_main"
      },
      fragment: {
        module: createShaderModuleSafe(device, { code }),
        entryPoint: "fs_main",
        targets: [{ format }]
      },
      primitive: { topology: "triangle-list" }
    });
  }
  createBindGroup(device) {
    if (!this.gBufferLayout || !this.gBuffer.albedoTexture || !this.gBuffer.normalTexture || !this.gBuffer.positionTexture || !this.gBuffer.depthTexture || !this.gBuffer.emissiveTexture || !this.gBuffer.ssaoTexture || !this.gBuffer.ssgiTexture)
      return;
    const depthView = this.gBuffer.depthTexture.createView({
      aspect: "depth-only"
    });
    console.log("DeferredLightingPass: Creating bind group with position texture", {
      hasPosition: !!this.gBuffer.positionTexture,
      depthFormat: this.gBuffer.depthTexture.format
    });
    this.bindGroup = device.createBindGroup({
      label: "Deferred Lighting GBuffer Bind Group",
      layout: this.gBufferLayout,
      entries: [
        { binding: 0, resource: this.gBuffer.albedoTexture.createView() },
        { binding: 1, resource: this.gBuffer.normalTexture.createView() },
        { binding: 2, resource: this.gBuffer.positionTexture.createView() },
        { binding: 3, resource: depthView },
        { binding: 4, resource: this.gBuffer.emissiveTexture.createView() },
        { binding: 5, resource: device.createSampler({
          minFilter: "nearest",
          magFilter: "nearest"
        }) },
        { binding: 6, resource: this.gBuffer.ssaoTexture.createView() },
        { binding: 7, resource: this.gBuffer.ssgiTexture.createView() },
        { binding: 8, resource: this.gBuffer.ssgiRawTexture.createView() }
      ]
    });
  }
}

// ../../src/core/renderer/GBuffer.ts
class GBuffer {
  width = 0;
  height = 0;
  albedoTexture = null;
  normalTexture = null;
  positionTexture = null;
  emissiveTexture = null;
  depthTexture = null;
  ssaoTexture = null;
  ssgiTexture = null;
  ssgiRawTexture = null;
  ssgiHistoryA = null;
  ssgiHistoryB = null;
  velocityTexture = null;
  accumulationTexture = null;
  device = null;
  _emissiveFormat = "rgba8unorm";
  _useComputedVelocity = false;
  constructor(device, width, height) {
    this.device = device;
    const limit = device.limits.maxColorAttachmentBytesPerSample;
    if (limit >= 40) {
      this._emissiveFormat = "rgba16float";
      this._useComputedVelocity = false;
    } else {
      this._emissiveFormat = "rgba16float";
      this._useComputedVelocity = true;
    }
    console.log(`GBuffer: maxColorAttachmentBytesPerSample=${limit}, emissiveFormat=${this._emissiveFormat}, useComputedVelocity=${this._useComputedVelocity}`);
    this.resize(width, height);
  }
  get emissiveFormat() {
    return this._emissiveFormat;
  }
  get useComputedVelocity() {
    return this._useComputedVelocity;
  }
  resize(width, height) {
    if (width <= 0 || height <= 0)
      return;
    if (this.width === width && this.height === height)
      return;
    console.log(`GBuffer: Resizing textures to ${width}x${height}`);
    this.width = width;
    this.height = height;
    this.destroy();
    this.createTextures();
  }
  destroy() {
    if (this.albedoTexture)
      this.albedoTexture.destroy();
    if (this.normalTexture)
      this.normalTexture.destroy();
    if (this.positionTexture)
      this.positionTexture.destroy();
    if (this.emissiveTexture)
      this.emissiveTexture.destroy();
    if (this.depthTexture)
      this.depthTexture.destroy();
    if (this.ssaoTexture)
      this.ssaoTexture.destroy();
    if (this.ssgiTexture)
      this.ssgiTexture.destroy();
    if (this.ssgiRawTexture)
      this.ssgiRawTexture.destroy();
    if (this.ssgiHistoryA)
      this.ssgiHistoryA.destroy();
    if (this.ssgiHistoryB)
      this.ssgiHistoryB.destroy();
    if (this.velocityTexture)
      this.velocityTexture.destroy();
    if (this.accumulationTexture)
      this.accumulationTexture.destroy();
  }
  async readDepthValues(commandEncoder, numSamples = 100) {
    if (!this.device || !this.depthTexture)
      return;
    const bytesPerPixel = 4;
    const bytesPerRow = this.width * bytesPerPixel;
    const alignedBytesPerRow = Math.ceil(bytesPerRow / 256) * 256;
    const bufferSize = alignedBytesPerRow * this.height;
    const readbackBuffer = this.device.createBuffer({
      label: "Depth Readback Buffer",
      size: bufferSize,
      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
    });
    commandEncoder.copyTextureToBuffer({
      texture: this.depthTexture,
      aspect: "depth-only"
    }, {
      buffer: readbackBuffer,
      bytesPerRow: alignedBytesPerRow
    }, { width: this.width, height: this.height, depthOrArrayLayers: 1 });
    await readbackBuffer.mapAsync(GPUMapMode.READ);
    const rawData = new Uint8Array(readbackBuffer.getMappedRange());
    const totalPixels = this.width * this.height;
    const sampleStep = Math.floor(totalPixels / numSamples);
    const samples = [];
    let min = Infinity;
    let max = -Infinity;
    let sum = 0;
    const uniqueValues = new Set;
    let pixelIndex = 0;
    for (let y = 0;y < this.height; y++) {
      const rowOffset = y * alignedBytesPerRow;
      const rowData = new Float32Array(rawData.buffer, rawData.byteOffset + rowOffset, this.width);
      for (let x = 0;x < this.width; x++) {
        const value = rowData[x];
        min = Math.min(min, value);
        max = Math.max(max, value);
        sum += value;
        if (pixelIndex % sampleStep === 0 && samples.length < numSamples) {
          samples.push(value);
        }
        if (uniqueValues.size < 1000) {
          uniqueValues.add(value);
        }
        pixelIndex++;
      }
    }
    console.log("Depth texture samples:", {
      textureSize: `${this.width}x${this.height}`,
      totalPixels,
      samples: samples.slice(0, 20),
      min,
      max,
      avg: sum / totalPixels,
      uniqueValues: uniqueValues.size >= 1000 ? ">1000" : uniqueValues.size
    });
    readbackBuffer.unmap();
    readbackBuffer.destroy();
  }
  createTextures() {
    if (!this.device)
      return;
    this.albedoTexture = this.device.createTexture({
      label: "G-Buffer Albedo",
      size: [this.width, this.height],
      format: "rgba16float",
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
    });
    this.normalTexture = this.device.createTexture({
      label: "G-Buffer Normal",
      size: [this.width, this.height],
      format: "rgba16float",
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
    });
    this.positionTexture = this.device.createTexture({
      label: "G-Buffer Position",
      size: [this.width, this.height],
      format: "rgba16float",
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
    });
    this.emissiveTexture = this.device.createTexture({
      label: "G-Buffer Emissive",
      size: [this.width, this.height],
      format: this._emissiveFormat,
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
    });
    this.depthTexture = this.device.createTexture({
      label: "G-Buffer Depth",
      size: [this.width, this.height],
      format: "depth24plus",
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC
    });
    this.ssaoTexture = this.device.createTexture({
      label: "G-Buffer SSAO",
      size: [this.width, this.height],
      format: "r8unorm",
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
    });
    this.ssgiTexture = this.device.createTexture({
      label: "G-Buffer SSGI",
      size: [this.width, this.height],
      format: "rgba16float",
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
    });
    this.ssgiRawTexture = this.device.createTexture({
      label: "SSGI Raw (Noisy)",
      size: [this.width, this.height],
      format: "rgba16float",
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC
    });
    this.ssgiHistoryA = this.device.createTexture({
      label: "SSGI History A",
      size: [this.width, this.height],
      format: "rgba16float",
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC
    });
    this.ssgiHistoryB = this.device.createTexture({
      label: "SSGI History B",
      size: [this.width, this.height],
      format: "rgba16float",
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC
    });
    this.velocityTexture = this.device.createTexture({
      label: "G-Buffer Velocity",
      size: [this.width, this.height],
      format: "rg16float",
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
    });
    this.accumulationTexture = this.device.createTexture({
      label: "Accumulation Buffer (HDR)",
      size: [this.width, this.height],
      format: "rgba16float",
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC
    });
  }
}

// ../../src/debug/GPUProfiler.ts
class GPUProfiler {
  device = null;
  querySet = null;
  resolveBuffer = null;
  readBuffer = null;
  timestampSupported = false;
  maxPasses = 16;
  passNames = [];
  lastResults = new Map;
  pendingRead = false;
  enabled = true;
  frameCount = 0;
  sampleInterval = 60;
  constructor() {}
  init(device, adapter) {
    this.device = device;
    this.timestampSupported = adapter.features.has("timestamp-query");
    if (!this.timestampSupported) {
      console.warn("GPUProfiler: timestamp-query feature not available. GPU timing will not be available.");
      return;
    }
    console.log("GPUProfiler: timestamp-query feature available, initializing GPU profiling");
    this.querySet = device.createQuerySet({
      type: "timestamp",
      count: this.maxPasses * 2
    });
    this.resolveBuffer = device.createBuffer({
      size: this.maxPasses * 2 * 8,
      usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC
    });
    this.readBuffer = device.createBuffer({
      size: this.maxPasses * 2 * 8,
      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
    });
  }
  beginFrame() {
    this.passNames = [];
  }
  shouldProfile() {
    return this.timestampSupported && this.enabled && this.frameCount % this.sampleInterval === 0;
  }
  getTimestampWrites(passName) {
    if (!this.shouldProfile() || !this.querySet)
      return;
    const passIndex = this.passNames.length;
    if (passIndex >= this.maxPasses)
      return;
    this.passNames.push(passName);
    const beginIndex = passIndex * 2;
    const endIndex = passIndex * 2 + 1;
    return {
      querySet: this.querySet,
      beginningOfPassWriteIndex: beginIndex,
      endOfPassWriteIndex: endIndex
    };
  }
  getComputeTimestampWrites(passName) {
    return this.getTimestampWrites(passName);
  }
  endFrame(encoder) {
    this.frameCount++;
    if (!this.shouldProfile() || !this.querySet || !this.resolveBuffer || !this.readBuffer || !this.device)
      return;
    if ((this.frameCount - 1) % this.sampleInterval !== 0)
      return;
    if (this.passNames.length === 0)
      return;
    if (this.pendingRead)
      return;
    const queryCount = this.passNames.length * 2;
    encoder.resolveQuerySet(this.querySet, 0, queryCount, this.resolveBuffer, 0);
    encoder.copyBufferToBuffer(this.resolveBuffer, 0, this.readBuffer, 0, queryCount * 8);
    this.pendingRead = true;
    const passNamesCopy = [...this.passNames];
    this.readBuffer.mapAsync(GPUMapMode.READ).then(() => {
      if (!this.readBuffer)
        return;
      const data = new BigUint64Array(this.readBuffer.getMappedRange());
      for (let i = 0;i < passNamesCopy.length; i++) {
        const start = data[i * 2];
        const end = data[i * 2 + 1];
        const durationNs = Number(end - start);
        const durationMs = durationNs / 1e6;
        this.lastResults.set(passNamesCopy[i], durationMs);
      }
      this.readBuffer.unmap();
      this.pendingRead = false;
    }).catch(() => {
      this.pendingRead = false;
    });
  }
  getPassTime(passName) {
    return this.lastResults.get(passName);
  }
  getAllPassTimes() {
    return new Map(this.lastResults);
  }
  getTotalTime() {
    let total = 0;
    for (const time of this.lastResults.values()) {
      total += time;
    }
    return total;
  }
  logTimes() {
    if (this.lastResults.size === 0) {
      console.log("GPUProfiler: No timing data available" + (this.timestampSupported ? "" : " (timestamp-query not supported)"));
      return;
    }
    console.group("GPU Pass Times:");
    let total = 0;
    const sorted = [...this.lastResults.entries()].sort((a, b) => b[1] - a[1]);
    for (const [name, time] of sorted) {
      console.log(`  ${name}: ${time.toFixed(3)} ms`);
      total += time;
    }
    console.log(`  TOTAL: ${total.toFixed(3)} ms`);
    console.groupEnd();
  }
  getFormattedTimes() {
    if (this.lastResults.size === 0) {
      return this.timestampSupported ? "No data" : "timestamp-query not supported";
    }
    let result = "";
    let total = 0;
    const sorted = [...this.lastResults.entries()].sort((a, b) => b[1] - a[1]);
    for (const [name, time] of sorted) {
      result += `${name}: ${time.toFixed(2)}ms
`;
      total += time;
    }
    result += `TOTAL: ${total.toFixed(2)}ms`;
    return result;
  }
  setEnabled(enabled) {
    this.enabled = enabled;
  }
  setSampleInterval(frames) {
    this.sampleInterval = Math.max(1, frames);
  }
  isTimestampSupported() {
    return this.timestampSupported;
  }
}
var profilerInstance = null;
function getGPUProfiler() {
  if (!profilerInstance) {
    profilerInstance = new GPUProfiler;
  }
  return profilerInstance;
}

// ../../src/core/renderer/HiZGenerationPass.ts
class HiZGenerationPass {
  gBuffer;
  pipeline = null;
  copyPipeline = null;
  constructor(gBuffer) {
    this.gBuffer = gBuffer;
  }
  init(device, context, presentationFormat) {
    const copyCode = `
      @group(0) @binding(0) var depthTex : texture_depth_2d;
      @group(0) @binding(1) var outTex : texture_storage_2d<r32float, write>;

      @compute @workgroup_size(8, 8)
      fn main(@builtin(global_invocation_id) id : vec3u) {
        let dim = textureDimensions(outTex);
        if (id.x >= dim.x || id.y >= dim.y) { return; }
        
        let depth = textureLoad(depthTex, id.xy, 0);
        textureStore(outTex, id.xy, vec4f(depth, 0.0, 0.0, 0.0));
      }
    `;
    this.copyPipeline = device.createComputePipeline({
      label: "Hi-Z Copy Pipeline",
      layout: "auto",
      compute: { module: createShaderModuleSafe(device, { code: copyCode }), entryPoint: "main" }
    });
    const mipCode = `
      @group(0) @binding(0) var srcTex : texture_2d<f32>;
      @group(0) @binding(1) var outTex : texture_storage_2d<r32float, write>;

      @compute @workgroup_size(8, 8)
      fn main(@builtin(global_invocation_id) id : vec3u) {
        let dim = textureDimensions(outTex);
        if (id.x >= dim.x || id.y >= dim.y) { return; }
        
        let srcDim = textureDimensions(srcTex);
        let srcCoord = id.xy * 2;
        
        // Sample 4 texels from src (previous mip)
        // Clamp to ensure we don't read OOB on odd-sized textures
        let d0 = textureLoad(srcTex, min(srcCoord + vec2u(0, 0), srcDim - vec2u(1)), 0).r;
        let d1 = textureLoad(srcTex, min(srcCoord + vec2u(1, 0), srcDim - vec2u(1)), 0).r;
        let d2 = textureLoad(srcTex, min(srcCoord + vec2u(0, 1), srcDim - vec2u(1)), 0).r;
        let d3 = textureLoad(srcTex, min(srcCoord + vec2u(1, 1), srcDim - vec2u(1)), 0).r;
        
        // Standard Depth: 0.0 (near) to 1.0 (far).
        // Use MAX for conservative occlusion culling with temporal reprojection.
        // MAX only culls when object is definitely behind everything - prevents false culls.

        let maxDepth = max(max(d0, d1), max(d2, d3));
        textureStore(outTex, id.xy, vec4f(maxDepth, 0.0, 0.0, 0.0));
      }
    `;
    this.pipeline = device.createComputePipeline({
      label: "Hi-Z Mip Pipeline",
      layout: "auto",
      compute: { module: createShaderModuleSafe(device, { code: mipCode }), entryPoint: "main" }
    });
  }
  resize(width, height) {}
  execute(commandEncoder, context, globalResources) {
    if (!this.copyPipeline || !this.pipeline || !this.gBuffer.depthTexture || !globalResources.hiZBuffer.texture)
      return;
    const device = this.gBuffer.device;
    if (!device)
      return;
    const copyBindGroup = device.createBindGroup({
      layout: this.copyPipeline.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: this.gBuffer.depthTexture.createView({ aspect: "depth-only" }) },
        { binding: 1, resource: globalResources.hiZBuffer.texture.createView({ baseMipLevel: 0, mipLevelCount: 1 }) }
      ]
    });
    const pass = commandEncoder.beginComputePass({ label: "Hi-Z Gen Pass" });
    pass.setPipeline(this.copyPipeline);
    pass.setBindGroup(0, copyBindGroup);
    pass.dispatchWorkgroups(Math.ceil(globalResources.hiZBuffer.width / 8), Math.ceil(globalResources.hiZBuffer.height / 8));
    pass.setPipeline(this.pipeline);
    let w = globalResources.hiZBuffer.width;
    let h = globalResources.hiZBuffer.height;
    for (let i = 0;i < globalResources.hiZBuffer.mipLevels - 1; i++) {
      const srcMip = i;
      const dstMip = i + 1;
      const dstW = Math.max(1, Math.floor(w / 2));
      const dstH = Math.max(1, Math.floor(h / 2));
      const bindGroup = device.createBindGroup({
        layout: this.pipeline.getBindGroupLayout(0),
        entries: [
          { binding: 0, resource: globalResources.hiZBuffer.texture.createView({ baseMipLevel: srcMip, mipLevelCount: 1 }) },
          { binding: 1, resource: globalResources.hiZBuffer.texture.createView({ baseMipLevel: dstMip, mipLevelCount: 1 }) }
        ]
      });
      pass.setBindGroup(0, bindGroup);
      pass.dispatchWorkgroups(Math.ceil(dstW / 8), Math.ceil(dstH / 8));
      w = dstW;
      h = dstH;
    }
    pass.end();
  }
}

// ../../src/core/renderer/GPUCullingPass.ts
class GPUCullingPass {
  gBuffer;
  pipeline = null;
  bindGroup = null;
  indirectBuffer = null;
  objectBuffer = null;
  constructor(gBuffer) {
    this.gBuffer = gBuffer;
  }
  init(device, _context, _presentationFormat) {
    const code = `
      struct SceneUniforms {
        viewMatrix: mat4x4<f32>,
        projectionMatrix: mat4x4<f32>,
        lightViewProj: mat4x4<f32>,
        prevViewProj: mat4x4<f32>,
        inverseProjectionMatrix: mat4x4<f32>,
        cameraPositionAndTime: vec4<f32>,
        lightCount: u32,
        debugMode: u32,
        flags: u32,
        envIntensity: f32,
      };

      struct ObjectData {
        modelMatrix: mat4x4<f32>,
        normalMatrix: mat4x4<f32>,
        aabbMin: vec3<f32>,
        triangleCount: u32,
        aabbMax: vec3<f32>,
        pad2: f32,
        prevModelMatrix: mat4x4<f32>,
        pad3: vec4<f32>,
        pad4: vec4<f32>,
      };

      struct IndirectCommand {
         indexCount: u32,
         instanceCount: u32,
         firstIndex: u32,
         baseVertex: u32,
         firstInstance: u32,
      };
      
      struct RenderStats {
          drawCount: atomic<u32>,
          triangleCount: atomic<u32>,
          pad1: u32,
          pad2: u32,
      };

      @group(0) @binding(0) var<uniform> scene : SceneUniforms;
      @group(0) @binding(1) var<storage, read> objects : array<ObjectData>;
      @group(0) @binding(2) var<storage, read_write> indirectDraws : array<IndirectCommand>;
      @group(0) @binding(3) var hiZTexture : texture_2d<f32>;
      @group(0) @binding(4) var<storage, read_write> stats : RenderStats;
      @group(0) @binding(5) var<storage, read_write> debugData : array<f32>;

      @compute @workgroup_size(64)
      fn main(@builtin(global_invocation_id) id : vec3u) {
        let index = id.x;
        if (index >= arrayLength(&objects)) { return; }
        
        let obj = objects[index];
        var visible = true;
        
        let frustumEnabled = (scene.flags & 2u) != 0u;
        let occlusionEnabled = (scene.flags & 4u) != 0u;

        let aabbMin = obj.aabbMin;
        let aabbMax = obj.aabbMax;
        
        // --- Frustum Culling ---
        if (frustumEnabled) {
            let worldCenter = (aabbMin + aabbMax) * 0.5;
            let worldExtent = (aabbMax - aabbMin) * 0.5;
            
            // Extract Frustum Planes from ViewProjection Matrix
            let viewProjectionMatrix = scene.projectionMatrix * scene.viewMatrix;
            // Transpose to get rows (since WGSL mat4x4 is column-major)
            let m = transpose(viewProjectionMatrix);
            
            let row0 = m[0];
            let row1 = m[1];
            let row2 = m[2];
            let row3 = m[3];
            
            let left   = row3 + row0;
            let right  = row3 - row0;
            let bottom = row3 + row1;
            let top    = row3 - row1;
            let near   = row2;
            let far    = row3 - row2;
            
            var planes = array<vec4<f32>, 6>(left, right, bottom, top, near, far);
            
            for (var i = 0; i < 6; i++) {
                let plane = planes[i];
                let r = dot(abs(plane.xyz), worldExtent);
                let d = dot(plane.xyz, worldCenter) + plane.w;
                
                if (d + r < 0.0) {
                    visible = false;
                }
            }
        }

        var debugMinZ = -1.0;
        var debugHiZDepth = -1.0;
        var debugLod = -1.0;
        
        var minUV = vec2(0.0, 0.0);
        var maxUV = vec2(0.0, 0.0);
        var texDim = vec2(0.0, 0.0);

        // --- Occlusion Culling (Hi-Z) ---
        if (visible && occlusionEnabled) {
             let minP = aabbMin;
             let maxP = aabbMax;
             let corners = array<vec3<f32>, 8>(
                vec3(minP.x, minP.y, minP.z),
                vec3(maxP.x, minP.y, minP.z),
                vec3(minP.x, maxP.y, minP.z),
                vec3(maxP.x, maxP.y, minP.z),
                vec3(minP.x, minP.y, maxP.z),
                vec3(maxP.x, minP.y, maxP.z),
                vec3(minP.x, maxP.y, maxP.z),
                vec3(maxP.x, maxP.y, maxP.z)
             );
             
             minUV = vec2(1.0, 1.0);
             maxUV = vec2(0.0, 0.0);
             var minZ = 1.0;
             
             // Use Previous View Projection Matrix for Hi-Z test (History Buffer)
             let projMatrix = scene.prevViewProj;
             
             for (var k = 0; k < 8; k++) {
                let clip = projMatrix * vec4(corners[k], 1.0);
                
                // If behind camera, skip occlusion culling
                if (clip.w <= 0.0) {
                   minZ = 0.0;
                   minUV = vec2(0.0, 0.0);
                   maxUV = vec2(1.0, 1.0);
                   break;
                }

                let ndc = clip.xyz / clip.w;
                
                let uv = vec2(ndc.x * 0.5 + 0.5, 1.0 - (ndc.y * 0.5 + 0.5));
                
                minUV = min(minUV, uv);
                maxUV = max(maxUV, uv);
                minZ = min(minZ, ndc.z);
             }
             
             minUV = clamp(minUV, vec2(0.0), vec2(1.0));
             maxUV = clamp(maxUV, vec2(0.0), vec2(1.0));
             
             texDim = vec2<f32>(textureDimensions(hiZTexture));
             let boxSize = (maxUV - minUV) * texDim;
             let dim = max(boxSize.x, boxSize.y);
             
             if (dim > 0.0) {
                 // Calculate LOD such that the box fits within a 1x1 texel block (conservative).
                 // Using a coarser LOD (log2(dim) instead of log2(dim)-1) ensures we don't undersample.
                 // This prevents "flickering" where we miss a hole in the depth buffer by sampling too fine.
                 let lodRaw = ceil(log2(dim));
                 
                 // Clamp LOD to available levels
                 let maxLod = f32(textureNumLevels(hiZTexture) - 1u);
                 let lod = min(maxLod, max(0.0, lodRaw));
                 let lodLevel = i32(lod);

                 let mipSize = vec2<i32>(i32(texDim.x) >> u32(lodLevel), i32(texDim.y) >> u32(lodLevel));

                 // Sample at the 4 CORNERS of the bounding box projection (not a 2x2 at one corner).
                 // This ensures we test the full extent of the object's screen coverage.
                 let minCoord = vec2<i32>(minUV * vec2<f32>(mipSize));
                 let maxCoord = vec2<i32>(maxUV * vec2<f32>(mipSize));

                 // Sample all 4 corners of the projected bounding box
                 let d0 = textureLoad(hiZTexture, clamp(minCoord, vec2(0), mipSize - vec2(1)), lodLevel).r;
                 let d1 = textureLoad(hiZTexture, clamp(vec2(maxCoord.x, minCoord.y), vec2(0), mipSize - vec2(1)), lodLevel).r;
                 let d2 = textureLoad(hiZTexture, clamp(vec2(minCoord.x, maxCoord.y), vec2(0), mipSize - vec2(1)), lodLevel).r;
                 let d3 = textureLoad(hiZTexture, clamp(maxCoord, vec2(0), mipSize - vec2(1)), lodLevel).r;
                 
                 // Take MAX of the 4 sampled texels (conservative - furthest in coverage area)
                 let hiZDepth = max(max(d0, d1), max(d2, d3));

                 debugMinZ = minZ;
                 debugHiZDepth = hiZDepth;
                 debugLod = lod;

                 // Standard Z: 0=Near, 1=Far.
                 // Hi-Z stores MAX depth (conservative).
                 // If object minZ (closest point) > hiZDepth, object is behind everything → OCCLUDED.
                 //
                 // Use a tiny epsilon (0.0001) to handle floating point precision.
                 // Larger epsilons (0.005) cause false negatives at far distances where
                 // depth values are compressed (e.g., wall at depth 0.994 vs spheres at 0.996).

                 if (minZ > hiZDepth + 0.0001) {
                    visible = false;
                 }
             }
        }
        
        if (visible) {
            indirectDraws[index].instanceCount = 1;
            atomicAdd(&stats.drawCount, 1u);
            atomicAdd(&stats.triangleCount, obj.triangleCount);
        } else {
            indirectDraws[index].instanceCount = 0;
        }

        // --- Debug Output for Mesh 2 (first red sphere in occlusion test scene) ---
        if (index == 2u) {
            debugData[0] = f32(visible);      // 0: Visibility (1.0 = true)
            debugData[1] = debugMinZ;         // 1: Object Min Z
            debugData[2] = debugHiZDepth;     // 2: Hi-Z Sampled Depth
            debugData[3] = debugLod;          // 3: LOD Level
            debugData[4] = aabbMin.x;         // 4: AABB Min X
            debugData[5] = aabbMin.y;         // 5: AABB Min Y
            debugData[6] = aabbMin.z;         // 6: AABB Min Z
            debugData[7] = f32(occlusionEnabled); // 7: Occlusion Enabled Flag
            debugData[8] = minUV.x;           // 8: Min UV X
            debugData[9] = minUV.y;           // 9: Min UV Y
            debugData[10] = maxUV.x;          // 10: Max UV X
            debugData[11] = maxUV.y;          // 11: Max UV Y
            debugData[12] = texDim.x;         // 12: Texture Width
            debugData[13] = texDim.y;         // 13: Texture Height
            
            // Debug: Sample Center Mip 0
            let centerUV = (minUV + maxUV) * 0.5;
            let centerCoord = vec2<i32>(centerUV * texDim);
            // Clamp to avoid OOB on edge
            let safeCoord = clamp(centerCoord, vec2(0), vec2<i32>(texDim) - vec2(1));
            debugData[14] = textureLoad(hiZTexture, safeCoord, 0).r;

            // Debug: Sample Center at LOD
            let lodMipSize = vec2<i32>(i32(texDim.x) >> u32(debugLod), i32(texDim.y) >> u32(debugLod));
            let lodCenterCoord = vec2<i32>(centerUV * vec2<f32>(lodMipSize));
            let safeLodCoord = clamp(lodCenterCoord, vec2(0), lodMipSize - vec2(1));
            debugData[15] = textureLoad(hiZTexture, safeLodCoord, i32(debugLod)).r;
        }
      }
    `;
    this.pipeline = device.createComputePipeline({
      label: "GPU Culling Pipeline",
      layout: "auto",
      compute: { module: createShaderModuleSafe(device, { code }), entryPoint: "main" }
    });
  }
  resize(_width, _height) {
    this.bindGroup = null;
  }
  execute(commandEncoder, _context, globalResources) {
    if (!this.pipeline)
      return;
    const device = this.gBuffer.device;
    if (!device)
      return;
    if (this.indirectBuffer !== globalResources.indirectDrawBuffer.buffer || this.objectBuffer !== globalResources.objectBuffer.buffer) {
      console.log("[GPUCullingPass] Buffer changed, recreating bind group");
      this.bindGroup = null;
      this.indirectBuffer = globalResources.indirectDrawBuffer.buffer;
      this.objectBuffer = globalResources.objectBuffer.buffer;
    }
    if (!this.bindGroup) {
      if (!globalResources.hiZBuffer.texture)
        return;
      this.bindGroup = device.createBindGroup({
        layout: this.pipeline.getBindGroupLayout(0),
        entries: [
          { binding: 0, resource: { buffer: globalResources.sceneUniforms.buffer } },
          { binding: 1, resource: { buffer: globalResources.objectBuffer.buffer } },
          { binding: 2, resource: { buffer: globalResources.indirectDrawBuffer.buffer } },
          { binding: 3, resource: globalResources.hiZBuffer.texture.createView() },
          { binding: 4, resource: { buffer: globalResources.statsBuffer } },
          { binding: 5, resource: { buffer: globalResources.cullingDebugBuffer } }
        ]
      });
    }
    const pass = commandEncoder.beginComputePass({ label: "GPU Culling Pass" });
    pass.setPipeline(this.pipeline);
    pass.setBindGroup(0, this.bindGroup);
    const objectCount = globalResources.objectBuffer.objectCount;
    if (objectCount > 0) {
      pass.dispatchWorkgroups(Math.ceil(objectCount / 64));
    }
    pass.end();
  }
}

// ../../src/core/renderer/ShadowPass.ts
class ShadowPass {
  depthStencilState;
  pipeline = null;
  alphaPipeline = null;
  bindGroups = [];
  shadowUniformBuffers = [];
  device = null;
  frameCount = 0;
  lastLoggedLightCount = -1;
  lastObjectBuffer = null;
  alphaSampler = null;
  alphaUniformBuffer = null;
  dummyTexture = null;
  dummyTextureView = null;
  lambda = 0.5;
  shadowMapSize = 2048;
  cascadeBiases = new Float32Array([0.0005, 0.001, 0.002, 0.003]);
  defaultMaxShadowDistance = 500;
  cascadeSplits = [];
  cascadeViewProjs = [];
  hasLoggedCascade = false;
  cascadeViewProjArrays = [];
  cascadeSplitsArray = new Float32Array(CASCADE_COUNT);
  spotLightViewProjArrays = [];
  simpleInstancedShadowPipeline = null;
  simpleInstancedAlphaShadowPipeline = null;
  simpleInstancedBindGroups = [];
  simpleInstancedAlphaBindGroupCache = new Map;
  static hasLoggedInstancedShadow = false;
  constructor() {
    this.depthStencilState = {
      depthWriteEnabled: true,
      depthCompare: "less",
      format: "depth32float"
    };
    for (let i = 0;i < CASCADE_COUNT; i++) {
      this.cascadeViewProjs.push(new Matrix4);
      this.cascadeViewProjArrays.push(new Float32Array(16));
    }
    for (let i = 0;i < MAX_SHADOW_LIGHTS; i++) {
      this.spotLightViewProjArrays.push(new Float32Array(16));
    }
  }
  init(device, context, presentationFormat) {
    this.device = device;
    const shaderCode = `
      struct Uniforms {
        lightViewProj : mat4x4<f32>,
      }
      @binding(0) @group(0) var<uniform> uniforms : Uniforms;

      struct ObjectData {
        modelMatrix : mat4x4<f32>,
        normalMatrix : mat4x4<f32>,
        aabbMin : vec3f,
        _pad1 : f32,
        aabbMax : vec3f,
        _pad2 : f32,
        prevModelMatrix : mat4x4<f32>,
        _pad3 : vec4<f32>,
        _pad4 : vec4<f32>,
      }
      @binding(1) @group(0) var<storage, read> objects : array<ObjectData>;

      struct VertexInput {
        @location(0) position : vec3<f32>,
      }

      @vertex
      fn main(input : VertexInput, @builtin(instance_index) instanceIndex : u32) -> @builtin(position) vec4<f32> {
        let model = objects[instanceIndex].modelMatrix;
        return uniforms.lightViewProj * model * vec4<f32>(input.position, 1.0);
      }
    `;
    this.pipeline = device.createRenderPipeline({
      label: "Shadow Pipeline",
      layout: "auto",
      vertex: {
        module: createShaderModuleSafe(device, { code: shaderCode }),
        entryPoint: "main",
        buffers: [
          {
            arrayStride: 12,
            attributes: [{ shaderLocation: 0, offset: 0, format: "float32x3" }]
          }
        ]
      },
      primitive: {
        topology: "triangle-list",
        cullMode: "none"
      },
      depthStencil: this.depthStencilState
    });
    const alphaShaderCode = `
      struct Uniforms {
        lightViewProj : mat4x4<f32>,
      }
      @binding(0) @group(0) var<uniform> uniforms : Uniforms;

      struct ObjectData {
        modelMatrix : mat4x4<f32>,
        normalMatrix : mat4x4<f32>,
        aabbMin : vec3f,
        _pad1 : f32,
        aabbMax : vec3f,
        _pad2 : f32,
        prevModelMatrix : mat4x4<f32>,
        _pad3 : vec4<f32>,
        _pad4 : vec4<f32>,
      }
      @binding(1) @group(0) var<storage, read> objects : array<ObjectData>;

      // Alpha testing uniforms (32 bytes minimum for WebGPU uniform buffers)
      struct AlphaUniforms {
        alphaCutoff : f32,
        _pad1 : f32,
        _pad2 : f32,
        _pad3 : f32,
        _pad4 : vec4<f32>,
      }
      @binding(2) @group(0) var<uniform> alphaUniforms : AlphaUniforms;
      @binding(3) @group(0) var albedoTexture : texture_2d<f32>;
      @binding(4) @group(0) var albedoSampler : sampler;

      struct VertexInput {
        @location(0) position : vec3<f32>,
        @location(1) uv : vec2<f32>,
      }

      struct VertexOutput {
        @builtin(position) position : vec4<f32>,
        @location(0) uv : vec2<f32>,
      }

      @vertex
      fn vs_main(input : VertexInput, @builtin(instance_index) instanceIndex : u32) -> VertexOutput {
        let model = objects[instanceIndex].modelMatrix;
        var output : VertexOutput;
        output.position = uniforms.lightViewProj * model * vec4<f32>(input.position, 1.0);
        output.uv = input.uv;
        return output;
      }

      @fragment
      fn fs_main(input : VertexOutput) {
        let alpha = textureSample(albedoTexture, albedoSampler, input.uv).a;
        if (alpha < alphaUniforms.alphaCutoff) {
          discard;
        }
      }
    `;
    this.alphaPipeline = device.createRenderPipeline({
      label: "Alpha Shadow Pipeline",
      layout: "auto",
      vertex: {
        module: createShaderModuleSafe(device, { code: alphaShaderCode }),
        entryPoint: "vs_main",
        buffers: [
          {
            arrayStride: 12,
            attributes: [{ shaderLocation: 0, offset: 0, format: "float32x3" }]
          },
          {
            arrayStride: 8,
            attributes: [{ shaderLocation: 1, offset: 0, format: "float32x2" }]
          }
        ]
      },
      fragment: {
        module: createShaderModuleSafe(device, { code: alphaShaderCode }),
        entryPoint: "fs_main",
        targets: []
      },
      primitive: {
        topology: "triangle-list",
        cullMode: "none"
      },
      depthStencil: this.depthStencilState
    });
    this.alphaSampler = device.createSampler({
      label: "Alpha Shadow Sampler",
      magFilter: "linear",
      minFilter: "linear",
      addressModeU: "repeat",
      addressModeV: "repeat"
    });
    this.alphaUniformBuffer = device.createBuffer({
      label: "Alpha Shadow Uniform Buffer",
      size: 32,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.dummyTexture = device.createTexture({
      label: "Dummy Alpha Texture",
      size: { width: 1, height: 1 },
      format: "rgba8unorm",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
    });
    device.queue.writeTexture({ texture: this.dummyTexture }, new Uint8Array([255, 255, 255, 255]), { bytesPerRow: 4 }, { width: 1, height: 1 });
    this.dummyTextureView = this.dummyTexture.createView();
    const totalBuffers = CASCADE_COUNT + MAX_SHADOW_LIGHTS;
    for (let i = 0;i < totalBuffers; i++) {
      this.shadowUniformBuffers.push(device.createBuffer({
        label: `Shadow Uniform Buffer ${i}`,
        size: 64,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
      }));
    }
    this.simpleInstancedShadowPipeline = this.createSimpleInstancedShadowPipeline(device, false);
    this.simpleInstancedAlphaShadowPipeline = this.createSimpleInstancedShadowPipeline(device, true);
  }
  createSimpleInstancedShadowPipeline(device, alphaTest) {
    const shaderCode = `
      struct Uniforms {
        lightViewProj: mat4x4<f32>,
      }

      @group(0) @binding(0) var<uniform> uniforms: Uniforms;
      ${alphaTest ? `
      @group(0) @binding(1) var albedoTexture: texture_2d<f32>;
      @group(0) @binding(2) var albedoSampler: sampler;
      ` : ""}

      struct VertexInput {
        @location(0) position: vec3f,
        ${alphaTest ? "@location(1) uv: vec2f," : ""}
        // Instance data
        @location(${alphaTest ? "2" : "1"}) instancePosRot: vec4f,  // position.xyz, rotation
        @location(${alphaTest ? "3" : "2"}) instanceScale: vec4f,   // scale.xyz, unused
        @location(${alphaTest ? "4" : "3"}) instanceColor: vec4f,   // color.rgb, unused
      }

      struct VertexOutput {
        @builtin(position) position: vec4f,
        ${alphaTest ? "@location(0) uv: vec2f," : ""}
      }

      @vertex
      fn vs_main(input: VertexInput) -> VertexOutput {
        var output: VertexOutput;

        // Instance transform
        let instancePos = input.instancePosRot.xyz;
        let rotationY = input.instancePosRot.w;
        let scale = input.instanceScale.xyz;

        // Build Y-axis rotation matrix
        let cosR = cos(rotationY);
        let sinR = sin(rotationY);
        let rotMat = mat3x3f(
          vec3f(cosR, 0.0, sinR),
          vec3f(0.0, 1.0, 0.0),
          vec3f(-sinR, 0.0, cosR)
        );

        var localPos = input.position * scale;
        var worldPos = rotMat * localPos + instancePos;

        output.position = uniforms.lightViewProj * vec4f(worldPos, 1.0);
        ${alphaTest ? "output.uv = input.uv;" : ""}
        return output;
      }

      ${alphaTest ? `
      @fragment
      fn fs_main(input: VertexOutput) {
        let alpha = textureSample(albedoTexture, albedoSampler, input.uv).a;
        if (alpha < 0.5) {
          discard;
        }
      }
      ` : ""}
    `;
    const shaderModule = createShaderModuleSafe(device, {
      label: alphaTest ? "Simple Instanced Alpha Shadow Shader" : "Simple Instanced Shadow Shader",
      code: shaderCode
    });
    const buffers = alphaTest ? [
      {
        arrayStride: 12,
        attributes: [{ shaderLocation: 0, offset: 0, format: "float32x3" }]
      },
      {
        arrayStride: 8,
        attributes: [{ shaderLocation: 1, offset: 0, format: "float32x2" }]
      },
      {
        arrayStride: 48,
        stepMode: "instance",
        attributes: [
          { shaderLocation: 2, offset: 0, format: "float32x4" },
          { shaderLocation: 3, offset: 16, format: "float32x4" },
          { shaderLocation: 4, offset: 32, format: "float32x4" }
        ]
      }
    ] : [
      {
        arrayStride: 12,
        attributes: [{ shaderLocation: 0, offset: 0, format: "float32x3" }]
      },
      {
        arrayStride: 48,
        stepMode: "instance",
        attributes: [
          { shaderLocation: 1, offset: 0, format: "float32x4" },
          { shaderLocation: 2, offset: 16, format: "float32x4" },
          { shaderLocation: 3, offset: 32, format: "float32x4" }
        ]
      }
    ];
    return device.createRenderPipeline({
      label: alphaTest ? "Simple Instanced Alpha Shadow Pipeline" : "Simple Instanced Shadow Pipeline",
      layout: "auto",
      vertex: {
        module: shaderModule,
        entryPoint: "vs_main",
        buffers
      },
      ...alphaTest ? {
        fragment: {
          module: shaderModule,
          entryPoint: "fs_main",
          targets: []
        }
      } : {},
      primitive: {
        topology: "triangle-list",
        cullMode: "none"
      },
      depthStencil: this.depthStencilState
    });
  }
  resize(width, height) {}
  isAlphaMaskedMaterial(material) {
    if (material instanceof StandardMaterial) {
      return material.alphaMode === "MASK" && material.albedoMap !== null;
    }
    return false;
  }
  drawMeshesToShadowMap(passEncoder, context, globalResources, cascadeOrLayerIndex, lightViewProj) {
    if (!this.pipeline || !this.alphaPipeline || !this.device)
      return;
    const opaqueMeshes = [];
    const alphaMeshes = [];
    const instancedGLBMeshes = [];
    const instancedMeshes = [];
    context.scene.traverse((node) => {
      if (!node.visible)
        return false;
      if (node instanceof InstancedMesh) {
        if (node.instanceCount > 0 && node.instanceBuffer) {
          instancedMeshes.push(node);
        }
      } else if (node instanceof InstancedGLBMesh) {
        instancedGLBMeshes.push(node);
      } else if (node instanceof Mesh && node.material instanceof Material) {
        if (node.geometry.buffersDirty)
          return;
        if (!node.geometry.vertexBuffers["position"])
          return;
        if (this.isAlphaMaskedMaterial(node.material)) {
          alphaMeshes.push(node);
        } else {
          opaqueMeshes.push(node);
        }
      }
    });
    if (opaqueMeshes.length > 0) {
      passEncoder.setPipeline(this.pipeline);
      passEncoder.setBindGroup(0, this.bindGroups[cascadeOrLayerIndex]);
      for (const mesh of opaqueMeshes) {
        passEncoder.setVertexBuffer(0, mesh.geometry.vertexBuffers["position"]);
        const instanceIndex = mesh.renderIndex;
        if (mesh.geometry.indexBuffer) {
          const indexFormat = mesh.geometry.indices instanceof Uint32Array ? "uint32" : "uint16";
          passEncoder.setIndexBuffer(mesh.geometry.indexBuffer, indexFormat);
          passEncoder.drawIndexed(mesh.geometry.indexCount, 1, 0, 0, instanceIndex);
        } else {
          passEncoder.draw(mesh.geometry.vertexCount, 1, 0, instanceIndex);
        }
      }
    }
    if (alphaMeshes.length > 0 && this.alphaUniformBuffer && this.alphaSampler) {
      passEncoder.setPipeline(this.alphaPipeline);
      for (const mesh of alphaMeshes) {
        const material = mesh.material;
        if (!mesh.geometry.vertexBuffers["uv"])
          continue;
        const alphaCutoff = material.alphaCutoff;
        this.device.queue.writeBuffer(this.alphaUniformBuffer, 0, new Float32Array([alphaCutoff, 0, 0, 0, 0, 0, 0, 0]));
        const textureView = material.albedoMap?.view ?? this.dummyTextureView;
        if (!textureView)
          continue;
        const alphaBindGroup = this.device.createBindGroup({
          label: `Alpha Shadow Bind Group - ${mesh.name}`,
          layout: this.alphaPipeline.getBindGroupLayout(0),
          entries: [
            { binding: 0, resource: { buffer: this.shadowUniformBuffers[cascadeOrLayerIndex] } },
            { binding: 1, resource: { buffer: globalResources.objectBuffer.buffer } },
            { binding: 2, resource: { buffer: this.alphaUniformBuffer } },
            { binding: 3, resource: textureView },
            { binding: 4, resource: this.alphaSampler }
          ]
        });
        passEncoder.setBindGroup(0, alphaBindGroup);
        passEncoder.setVertexBuffer(0, mesh.geometry.vertexBuffers["position"]);
        passEncoder.setVertexBuffer(1, mesh.geometry.vertexBuffers["uv"]);
        const instanceIndex = mesh.renderIndex;
        if (mesh.geometry.indexBuffer) {
          const indexFormat = mesh.geometry.indices instanceof Uint32Array ? "uint32" : "uint16";
          passEncoder.setIndexBuffer(mesh.geometry.indexBuffer, indexFormat);
          passEncoder.drawIndexed(mesh.geometry.indexCount, 1, 0, 0, instanceIndex);
        } else {
          passEncoder.draw(mesh.geometry.vertexCount, 1, 0, instanceIndex);
        }
      }
    }
    if (instancedMeshes.length > 0) {
      this.renderInstancedMeshShadowsSimple(passEncoder, instancedMeshes, cascadeOrLayerIndex, context.time ?? 0);
    }
  }
  renderInstancedMeshShadowsSimple(passEncoder, instancedMeshes, cascadeOrLayerIndex, time) {
    if (!this.device)
      return;
    if (!this.simpleInstancedShadowPipeline || !this.simpleInstancedAlphaShadowPipeline)
      return;
    const uniformBuffer = this.shadowUniformBuffers[cascadeOrLayerIndex];
    if (!uniformBuffer)
      return;
    if (this.simpleInstancedBindGroups.length === 0) {
      const totalBuffers = CASCADE_COUNT + MAX_SHADOW_LIGHTS;
      for (let i = 0;i < totalBuffers; i++) {
        this.simpleInstancedBindGroups.push(this.device.createBindGroup({
          label: `Simple Instanced Shadow Bind Group ${i}`,
          layout: this.simpleInstancedShadowPipeline.getBindGroupLayout(0),
          entries: [
            { binding: 0, resource: { buffer: this.shadowUniformBuffers[i] } }
          ]
        }));
      }
    }
    for (const instancedMesh of instancedMeshes) {
      const { geometry, material } = instancedMesh;
      if (!geometry.vertexBuffers["position"])
        continue;
      if (!instancedMesh.instanceBuffer)
        continue;
      instancedMesh._writeToGPU(this.device);
      const needsAlphaTest = material.alphaMode === "MASK" && material.albedoMap !== null;
      if (!ShadowPass.hasLoggedInstancedShadow) {
        const debugData = instancedMesh.getDebugInstanceData();
        console.log("[ShadowPass SIMPLE] ==================== INSTANCED SHADOW DEBUG ====================");
        console.log("[ShadowPass SIMPLE] Using SAME uniform buffer as non-instanced shadows");
        console.log(`[ShadowPass SIMPLE] cascadeOrLayerIndex: ${cascadeOrLayerIndex}`);
        console.log(`[ShadowPass SIMPLE] uniformBuffer size: ${uniformBuffer.size} bytes`);
        if (debugData) {
          console.log("[ShadowPass SIMPLE] Instance positions (first 3):");
          debugData.forEach((d, i) => {
            console.log(`  Instance ${i}: pos=(${d.position[0].toFixed(2)}, ${d.position[1].toFixed(2)}, ${d.position[2].toFixed(2)}), rot=${d.rotation.toFixed(2)}, scale=(${d.scale[0].toFixed(2)}, ${d.scale[1].toFixed(2)}, ${d.scale[2].toFixed(2)})`);
          });
        }
        console.log(`[ShadowPass SIMPLE] needsAlphaTest: ${needsAlphaTest}`);
        console.log(`[ShadowPass SIMPLE] instanceCount: ${instancedMesh.instanceCount}`);
        console.log("[ShadowPass SIMPLE] ================================================================");
      }
      if (needsAlphaTest && geometry.vertexBuffers["uv"]) {
        const textureView = material.albedoMap?.view ?? this.dummyTextureView;
        if (!textureView)
          continue;
        const cacheKey = `${cascadeOrLayerIndex}-${material.albedoMap?.label ?? "dummy"}`;
        let alphaBindGroup = this.simpleInstancedAlphaBindGroupCache.get(cacheKey);
        if (!alphaBindGroup) {
          alphaBindGroup = this.device.createBindGroup({
            label: `Simple Instanced Alpha Shadow Bind Group - cascade ${cascadeOrLayerIndex}`,
            layout: this.simpleInstancedAlphaShadowPipeline.getBindGroupLayout(0),
            entries: [
              { binding: 0, resource: { buffer: uniformBuffer } },
              { binding: 1, resource: textureView },
              { binding: 2, resource: this.alphaSampler }
            ]
          });
          this.simpleInstancedAlphaBindGroupCache.set(cacheKey, alphaBindGroup);
        }
        passEncoder.setPipeline(this.simpleInstancedAlphaShadowPipeline);
        passEncoder.setBindGroup(0, alphaBindGroup);
        passEncoder.setVertexBuffer(0, geometry.vertexBuffers["position"]);
        passEncoder.setVertexBuffer(1, geometry.vertexBuffers["uv"]);
        passEncoder.setVertexBuffer(2, instancedMesh.instanceBuffer);
      } else {
        passEncoder.setPipeline(this.simpleInstancedShadowPipeline);
        passEncoder.setBindGroup(0, this.simpleInstancedBindGroups[cascadeOrLayerIndex]);
        passEncoder.setVertexBuffer(0, geometry.vertexBuffers["position"]);
        passEncoder.setVertexBuffer(1, instancedMesh.instanceBuffer);
      }
      if (geometry.indexBuffer) {
        const indexFormat = geometry.indices instanceof Uint32Array ? "uint32" : "uint16";
        passEncoder.setIndexBuffer(geometry.indexBuffer, indexFormat);
        passEncoder.drawIndexed(geometry.indexCount, instancedMesh.instanceCount);
      } else {
        passEncoder.draw(geometry.vertexCount, instancedMesh.instanceCount);
      }
    }
    if (!ShadowPass.hasLoggedInstancedShadow && instancedMeshes.length > 0) {
      console.log(`[ShadowPass SIMPLE] Rendered ${instancedMeshes.length} InstancedMesh shadows using simple pipeline`);
      ShadowPass.hasLoggedInstancedShadow = true;
    }
  }
  getShadowCastingLights(context) {
    const activeLights = context.scene.getClosestLights(context.camera.transform.position, 8);
    const maxLights = Math.min(context.scene.shadows.maxLights ?? 1, MAX_SHADOW_LIGHTS);
    return activeLights.filter((l) => (l.type === 0 /* Directional */ || l.type === 2 /* Spot */) && l.shadow.castShadow).slice(0, maxLights);
  }
  execute(commandEncoder, context, globalResources) {
    if (!this.pipeline || this.shadowUniformBuffers.length === 0 || !this.device || !globalResources.shadowAtlas)
      return;
    if (!context.scene.shadows.enabled)
      return;
    let shadowLights = this.getShadowCastingLights(context);
    if (shadowLights.length === 0) {
      const activeLights = context.scene.getClosestLights(context.camera.transform.position, 8);
      const fallbackLight = activeLights.find((l) => l.type === 0 /* Directional */);
      if (fallbackLight) {
        shadowLights = [fallbackLight];
      }
    }
    if (shadowLights.length === 0)
      return;
    this.frameCount++;
    const directionalLight = shadowLights.find((l) => l.type === 0 /* Directional */);
    const spotLights = shadowLights.filter((l) => l.type === 2 /* Spot */);
    let layerIndex = 0;
    const totalBuffers = CASCADE_COUNT + MAX_SHADOW_LIGHTS;
    if (this.lastObjectBuffer !== globalResources.objectBuffer.buffer) {
      console.log("[ShadowPass] Object buffer changed, recreating bind groups");
      this.bindGroups = [];
      this.lastObjectBuffer = globalResources.objectBuffer.buffer;
    }
    if (this.bindGroups.length === 0) {
      for (let i = 0;i < totalBuffers; i++) {
        this.bindGroups.push(this.device.createBindGroup({
          label: `Shadow Bind Group ${i}`,
          layout: this.pipeline.getBindGroupLayout(0),
          entries: [
            { binding: 0, resource: { buffer: this.shadowUniformBuffers[i] } },
            { binding: 1, resource: { buffer: globalResources.objectBuffer.buffer } }
          ]
        }));
      }
    }
    if (directionalLight) {
      const maxShadowDistance = context.scene.shadows.cascadeMaxDistance ?? this.defaultMaxShadowDistance;
      this.updateCascades(context.camera, directionalLight, maxShadowDistance);
      if (!this.hasLoggedCascade) {
        this.hasLoggedCascade = true;
      }
      for (let cascade = 0;cascade < CASCADE_COUNT; cascade++) {
        const viewProj = this.cascadeViewProjs[cascade];
        const viewProjArray = this.cascadeViewProjArrays[cascade];
        viewProjArray.set(viewProj.elements);
        this.device.queue.writeBuffer(this.shadowUniformBuffers[cascade], 0, viewProjArray.buffer);
        const layerView = globalResources.shadowAtlas.createView({
          dimension: "2d",
          baseArrayLayer: cascade,
          arrayLayerCount: 1
        });
        const passEncoder = commandEncoder.beginRenderPass({
          label: `Shadow Pass - Cascade ${cascade}`,
          colorAttachments: [],
          depthStencilAttachment: {
            view: layerView,
            depthClearValue: 1,
            depthLoadOp: "clear",
            depthStoreOp: "store"
          }
        });
        this.drawMeshesToShadowMap(passEncoder, context, globalResources, cascade, viewProjArray);
        passEncoder.end();
      }
      directionalLight.shadowAtlasIndex = 0;
      layerIndex = CASCADE_COUNT;
      for (let i = 0;i < this.cascadeSplits.length; i++) {
        this.cascadeSplitsArray[i] = this.cascadeSplits[i];
      }
      globalResources.updateCascadeUniforms(this.device, this.cascadeViewProjArrays, this.cascadeSplitsArray, this.cascadeBiases);
    }
    const spotLightData = [];
    for (let i = 0;i < spotLights.length && layerIndex < globalResources.shadowAtlas.depthOrArrayLayers; i++) {
      const light = spotLights[i];
      light.shadowAtlasIndex = i;
      const lightViewProj = ShadowUtils.getLightShadowViewProj(light, context.camera);
      const viewProjArray = this.spotLightViewProjArrays[i];
      viewProjArray.set(lightViewProj.elements);
      this.device.queue.writeBuffer(this.shadowUniformBuffers[layerIndex], 0, viewProjArray.buffer);
      spotLightData.push({
        viewProj: viewProjArray,
        atlasLayer: layerIndex,
        bias: light.shadow.bias,
        normalBias: light.shadow.normalBias
      });
      const layerView = globalResources.shadowAtlas.createView({
        dimension: "2d",
        baseArrayLayer: layerIndex,
        arrayLayerCount: 1
      });
      const passEncoder = commandEncoder.beginRenderPass({
        label: `Shadow Pass - Spot Light ${i}`,
        colorAttachments: [],
        depthStencilAttachment: {
          view: layerView,
          depthClearValue: 1,
          depthLoadOp: "clear",
          depthStoreOp: "store"
        }
      });
      this.drawMeshesToShadowMap(passEncoder, context, globalResources, layerIndex, viewProjArray);
      passEncoder.end();
      layerIndex++;
    }
    for (const light of context.scene.lights) {
      if (!shadowLights.includes(light) && light.type !== 1 /* Point */) {
        light.shadowAtlasIndex = -1;
      }
    }
    globalResources.updateShadowUniforms(this.device, spotLightData, globalResources.shadowAtlas.width);
    const shouldLog = this.frameCount === 1 || shadowLights.length !== this.lastLoggedLightCount || this.frameCount % 300 === 0;
    if (shouldLog) {
      this.lastLoggedLightCount = shadowLights.length;
    }
  }
  updateCascades(camera, light, maxShadowDistance) {
    this.cascadeSplits = this.calculateSplitDepths(camera, maxShadowDistance);
    const lightDir = light.transform.getForwardVector().normalize();
    let prevSplit = camera.near;
    for (let i = 0;i < CASCADE_COUNT; i++) {
      const split = this.cascadeSplits[i];
      this.cascadeViewProjs[i] = this.calculateLightMatrix(camera, lightDir, prevSplit, split);
      prevSplit = split;
    }
  }
  calculateSplitDepths(camera, maxShadowDistance) {
    const splits = [];
    const near = camera.near;
    const far = Math.min(camera.far, maxShadowDistance);
    const range = far - near;
    const ratio = far / near;
    for (let i = 0;i < CASCADE_COUNT; i++) {
      const p = (i + 1) / CASCADE_COUNT;
      const log = near * Math.pow(ratio, p);
      const uniform = near + range * p;
      const d = this.lambda * log + (1 - this.lambda) * uniform;
      splits.push(d);
    }
    return splits;
  }
  calculateLightMatrix(camera, lightDir, near, far) {
    const corners = this.getFrustumCorners(camera, near, far);
    let center = new Vector3(0, 0, 0);
    for (const c of corners)
      center = center.add(c);
    center = center.divide(corners.length);
    let radius = 0;
    for (const c of corners) {
      const dist = c.distanceTo(center);
      radius = Math.max(radius, dist);
    }
    radius *= 1.5;
    const minRadius = 100;
    radius = Math.max(radius, minRadius);
    const up = Math.abs(lightDir.y) > 0.9 ? new Vector3(0, 0, 1) : Vector3.up;
    const lightZ = lightDir.clone().normalize();
    let lightX = up.clone().cross(lightZ).normalize();
    if (lightX.magnitude() < 0.001) {
      const altUp = new Vector3(1, 0, 0);
      lightX = altUp.clone().cross(lightZ).normalize();
    }
    const lightY = lightZ.clone().cross(lightX).normalize();
    const worldUnitsPerTexel = 2 * radius / this.shadowMapSize;
    const centerDotX = center.dot(lightX);
    const centerDotY = center.dot(lightY);
    const centerDotZ = center.dot(lightZ);
    const snappedX = Math.floor(centerDotX / worldUnitsPerTexel) * worldUnitsPerTexel;
    const snappedY = Math.floor(centerDotY / worldUnitsPerTexel) * worldUnitsPerTexel;
    const snappedCenter = lightX.clone().multiply(snappedX).add(lightY.clone().multiply(snappedY)).add(lightZ.clone().multiply(centerDotZ));
    const lightDistance = radius + 200;
    const lightPos = snappedCenter.clone().subtract(lightDir.clone().multiply(lightDistance));
    const lightView = new Matrix4().lookAt(lightPos, snappedCenter, up);
    const minX = -radius;
    const maxX = radius;
    const minY = -radius;
    const maxY = radius;
    const orthoNear = 0.1;
    const orthoFar = lightDistance + radius + 200;
    const lightProj = new Matrix4().makeOrthographic(minX, maxX, maxY, minY, orthoNear, orthoFar);
    return lightProj.multiply(lightView);
  }
  getFrustumCorners(camera, near, far) {
    const aspect = camera.aspect;
    const fov = camera.fov;
    const tanHalfFov = Math.tan(fov * Math.PI / 180 * 0.5);
    const nearH = 2 * tanHalfFov * near;
    const nearW = nearH * aspect;
    const farH = 2 * tanHalfFov * far;
    const farW = farH * aspect;
    const viewInv = camera.viewMatrix.clone().invert();
    const cornersCam = [
      new Vector3(-nearW / 2, nearH / 2, -near),
      new Vector3(nearW / 2, nearH / 2, -near),
      new Vector3(-nearW / 2, -nearH / 2, -near),
      new Vector3(nearW / 2, -nearH / 2, -near),
      new Vector3(-farW / 2, farH / 2, -far),
      new Vector3(farW / 2, farH / 2, -far),
      new Vector3(-farW / 2, -farH / 2, -far),
      new Vector3(farW / 2, -farH / 2, -far)
    ];
    return cornersCam.map((c) => viewInv.transformVector(c));
  }
}

// ../../src/core/renderer/PointShadowPass.ts
class PointShadowPass {
  depthStencilState;
  pipeline = null;
  shadowUniformBuffer = null;
  device = null;
  depthTexture = null;
  faceDirections = [
    new Vector3(1, 0, 0),
    new Vector3(-1, 0, 0),
    new Vector3(0, 1, 0),
    new Vector3(0, -1, 0),
    new Vector3(0, 0, 1),
    new Vector3(0, 0, -1)
  ];
  faceUps = [
    new Vector3(0, -1, 0),
    new Vector3(0, -1, 0),
    new Vector3(0, 0, 1),
    new Vector3(0, 0, -1),
    new Vector3(0, -1, 0),
    new Vector3(0, -1, 0)
  ];
  constructor() {
    this.depthStencilState = {
      depthWriteEnabled: true,
      depthCompare: "less",
      format: "depth32float"
    };
  }
  init(device, context, presentationFormat) {
    this.device = device;
    const shaderCode = `
      struct ObjectData {
        modelMatrix : mat4x4<f32>,
        normalMatrix : mat4x4<f32>,
        aabbMin : vec3f,
        _pad1 : f32,
        aabbMax : vec3f,
        _pad2 : f32,
        prevModelMatrix : mat4x4<f32>,
        _pad3 : vec4<f32>,
        _pad4 : vec4<f32>,
      }
      @binding(1) @group(0) var<storage, read> objects : array<ObjectData>;

      struct VertexInput {
        @location(0) position : vec3<f32>,
      }

      struct VertexOutput {
        @builtin(position) position : vec4<f32>,
        @location(0) worldPos : vec3<f32>,
      }

      struct LightUniforms {
        lightViewProj : mat4x4<f32>,
        lightPos : vec3<f32>,
        far : f32,
      }
      @binding(0) @group(0) var<uniform> lightUniforms : LightUniforms;

      @vertex
      fn vs_main(input : VertexInput, @builtin(instance_index) instanceIndex : u32) -> VertexOutput {
        let model = objects[instanceIndex].modelMatrix;
        var output : VertexOutput;
        let worldPos4 = model * vec4<f32>(input.position, 1.0);
        output.position = lightUniforms.lightViewProj * worldPos4;
        output.worldPos = worldPos4.xyz;
        return output;
      }

      @fragment
      fn fs_main(input : VertexOutput) -> @location(0) f32 {
        // Calculate linear distance from light and normalize to [0,1]
        let lightToFrag = input.worldPos - lightUniforms.lightPos;
        let dist = length(lightToFrag);
        return dist / lightUniforms.far;
      }
    `;
    this.pipeline = device.createRenderPipeline({
      label: "Point Shadow Pipeline",
      layout: "auto",
      vertex: {
        module: createShaderModuleSafe(device, { code: shaderCode }),
        entryPoint: "vs_main",
        buffers: [
          {
            arrayStride: 12,
            attributes: [{ shaderLocation: 0, offset: 0, format: "float32x3" }]
          }
        ]
      },
      fragment: {
        module: createShaderModuleSafe(device, { code: shaderCode }),
        entryPoint: "fs_main",
        targets: [{ format: "r32float" }]
      },
      primitive: {
        topology: "triangle-list",
        cullMode: "none"
      },
      depthStencil: this.depthStencilState
    });
    this.shadowUniformBuffer = device.createBuffer({
      label: "Point Shadow Uniform Buffer",
      size: 256 * 6 * MAX_SHADOW_LIGHTS,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.depthTexture = device.createTexture({
      label: "Point Shadow Depth Buffer",
      size: [1024, 1024],
      format: "depth32float",
      usage: GPUTextureUsage.RENDER_ATTACHMENT
    });
  }
  resize(width, height) {}
  execute(commandEncoder, context, globalResources) {
    if (!this.pipeline || !this.shadowUniformBuffer || !this.device || !globalResources.pointShadowAtlas || !this.depthTexture)
      return;
    if (!context.scene.shadows.enabled)
      return;
    const activeLights = context.scene.getClosestLights(context.camera.transform.position, 256);
    const pointLights = activeLights.filter((l) => l.type === 1 /* Point */ && l.shadow.castShadow);
    if (pointLights.length === 0)
      return;
    const depthView = this.depthTexture.createView();
    for (const light of pointLights) {
      if (light.shadowAtlasIndex < 0 || light.shadowAtlasIndex >= MAX_SHADOW_LIGHTS)
        continue;
      const lightIndex = light.shadowAtlasIndex;
      const near = 0.1;
      const far = 100;
      const fovRadians = 90 * Math.PI / 180;
      const projection = new Matrix4().makePerspective(fovRadians, 1, near, far);
      const lightPos = light.transform.position;
      for (let face = 0;face < 6; face++) {
        const lookTarget = lightPos.clone().add(this.faceDirections[face]);
        const view = new Matrix4().lookAt(lightPos, lookTarget, this.faceUps[face]);
        const viewProj = projection.clone().multiply(view);
        const offset = (lightIndex * 6 + face) * 256;
        const uniformData = new Float32Array(20);
        uniformData.set(viewProj.elements, 0);
        uniformData[16] = lightPos.x;
        uniformData[17] = lightPos.y;
        uniformData[18] = lightPos.z;
        uniformData[19] = far;
        this.device.queue.writeBuffer(this.shadowUniformBuffer, offset, uniformData);
        const layer = lightIndex * 6 + face;
        const colorView = globalResources.pointShadowAtlas.createView({
          dimension: "2d",
          baseArrayLayer: layer,
          arrayLayerCount: 1
        });
        const bindGroup = this.device.createBindGroup({
          label: `Point Shadow BindGroup L${lightIndex} F${face}`,
          layout: this.pipeline.getBindGroupLayout(0),
          entries: [
            { binding: 0, resource: { buffer: this.shadowUniformBuffer, offset, size: 80 } },
            { binding: 1, resource: { buffer: globalResources.objectBuffer.buffer } }
          ]
        });
        const passEncoder = commandEncoder.beginRenderPass({
          label: `Point Shadow L${lightIndex} F${face}`,
          colorAttachments: [{
            view: colorView,
            clearValue: { r: 1, g: 0, b: 0, a: 1 },
            loadOp: "clear",
            storeOp: "store"
          }],
          depthStencilAttachment: {
            view: depthView,
            depthClearValue: 1,
            depthLoadOp: "clear",
            depthStoreOp: "discard"
          }
        });
        passEncoder.setPipeline(this.pipeline);
        passEncoder.setBindGroup(0, bindGroup);
        context.scene.traverse((node) => {
          if (!node.visible)
            return false;
          if (node instanceof Mesh && node.material instanceof Material) {
            if (node.geometry.buffersDirty) {
              return;
            }
            if (node.geometry.vertexBuffers["position"]) {
              passEncoder.setVertexBuffer(0, node.geometry.vertexBuffers["position"]);
              const instanceIndex = node.renderIndex;
              if (node.geometry.indexBuffer) {
                const indexFormat = node.geometry.indices instanceof Uint32Array ? "uint32" : "uint16";
                passEncoder.setIndexBuffer(node.geometry.indexBuffer, indexFormat);
                passEncoder.drawIndexed(node.geometry.indexCount, 1, 0, 0, instanceIndex);
              } else {
                passEncoder.draw(node.geometry.vertexCount, 1, 0, instanceIndex);
              }
            }
          }
        });
        passEncoder.end();
      }
    }
  }
}

// ../../src/core/renderer/shaders/AtmosphereCommon.ts
var AtmosphereCommonWGSL = `
// Constants
const PI: f32 = 3.14159265358979323846;
const rad: f32 = 1.0;
const m: f32 = 1.0;
const km: f32 = 1000.0 * m;
const m2: f32 = m * m;
const m3: f32 = m * m * m;
const pi: f32 = PI * rad;
const deg: f32 = pi / 180.0;
const watt: f32 = 1.0;
const lm: f32 = 1.0;
const sr: f32 = 1.0;
const nm: f32 = 1.0;

// Units
const watt_per_square_meter: f32 = watt / m2;
const watt_per_square_meter_per_sr: f32 = watt / (m2 * sr);
const watt_per_square_meter_per_nm: f32 = watt / (m2 * nm);
const watt_per_square_meter_per_sr_per_nm: f32 = watt / (m2 * sr * nm);
const watt_per_cubic_meter_per_sr_per_nm: f32 = watt / (m3 * sr * nm);
const cd: f32 = lm / sr;
const kcd: f32 = 1000.0 * cd;
const cd_per_square_meter: f32 = cd / m2;
const kcd_per_square_meter: f32 = kcd / m2;

struct DensityProfileLayer {
    width: f32,
    exp_term: f32,
    exp_scale: f32,
    linear_term: f32,
    constant_term: f32,
}

struct DensityProfile {
    layers: array<DensityProfileLayer, 2>,
}

struct AtmosphereParameters {
    solar_irradiance: vec3f,
    sun_angular_radius: f32,
    absorption_extinction: vec3f,
    mu_s_min: f32,
    rayleigh_scattering: vec3f,
    mie_phase_function_g: f32,
    mie_scattering: vec3f,
    bottom_radius: f32,
    mie_extinction: vec3f,
    top_radius: f32,
    mie_absorption: vec3f,
    pad00: f32,
    ground_albedo: vec3f,
    pad0: f32,
    // Densities are flattened in Uniform Buffer, but we reconstruct them or access via array
    // We will use a helper to unpack or access directly from the uniform buffer structure 
    // defined in the main shader. 
    // For now, let's assume we pass the struct or use global access.
}

// Uniform Buffer Definition (Must match AtmospherePass.ts)
struct AtmosphereUniforms {
    solar_irradiance: vec3f,
    sun_angular_radius: f32,
    absorption_extinction: vec3f,
    mu_s_min: f32,
    rayleigh_scattering: vec3f,
    mie_phase_function_g: f32,
    mie_scattering: vec3f,
    bottom_radius: f32,
    mie_extinction: vec3f,
    top_radius: f32,
    mie_absorption: vec3f,
    pad00: f32,
    ground_albedo: vec3f,
    pad0: f32,

    // Arrays flattened as vec4s
    rayleigh_density: array<vec4f, 3>,
    mie_density: array<vec4f, 3>,
    absorption_density: array<vec4f, 3>,

    // Dynamic Params
    sun_direction: vec3f,
    pad1: f32,
    camera_position: vec3f,
    pad2: f32,

    // === Celestial Configuration ===
    // Sun disk: enabled, scale, pad, pad
    sun_disk_enabled: f32,
    sun_disk_scale: f32,
    pad3: f32,
    pad4: f32,

    // Moon: direction + enabled
    moon_direction: vec3f,
    moon_enabled: f32,

    // Moon: phase, scale, angular_radius, pad
    moon_phase: f32,
    moon_scale: f32,
    moon_angular_radius: f32,
    pad5: f32,

    // Moon color + pad
    moon_color: vec3f,
    pad6: f32,

    // Stars: enabled, intensity, twinkle, time
    stars_enabled: f32,
    stars_intensity: f32,
    stars_twinkle: f32,
    stars_time: f32,

    // Custom skybox: enabled, blend, pad, pad
    custom_skybox_enabled: f32,
    custom_skybox_blend: f32,
    pad7: f32,
    pad8: f32,

    // Clouds
    cloud_color: vec3f,
    cloud_enabled: f32,
    
    cloud_wind_direction: vec3f,
    cloud_coverage: f32,

    cloud_altitude: f32,
    cloud_height: f32,
    cloud_density: f32,
    cloud_speed: f32,

    cloud_quality: u32,  // 0=low (2D plane), 1=medium (12 steps), 2=high (32 steps)
    pad9: u32,
    pad10: u32,
    pad11: u32,
}

// @group(0) @binding(0) var<uniform> atmosphere : AtmosphereUniforms; // Removed, must be declared by user

// Helper to unpack DensityProfile from Uniforms
fn GetRayleighDensityProfile() -> DensityProfile {
    var p: DensityProfile;
    // Layer 0
    p.layers[0].width = atmosphere.rayleigh_density[0].x;
    p.layers[0].exp_term = atmosphere.rayleigh_density[0].y;
    p.layers[0].exp_scale = atmosphere.rayleigh_density[0].z;
    p.layers[0].linear_term = atmosphere.rayleigh_density[0].w;
    p.layers[0].constant_term = atmosphere.rayleigh_density[1].x;
    // Layer 1
    p.layers[1].width = atmosphere.rayleigh_density[1].y;
    p.layers[1].exp_term = atmosphere.rayleigh_density[1].z;
    p.layers[1].exp_scale = atmosphere.rayleigh_density[1].w;
    p.layers[1].linear_term = atmosphere.rayleigh_density[2].x;
    p.layers[1].constant_term = atmosphere.rayleigh_density[2].y;
    return p;
}

fn GetMieDensityProfile() -> DensityProfile {
    var p: DensityProfile;
    p.layers[0].width = atmosphere.mie_density[0].x;
    p.layers[0].exp_term = atmosphere.mie_density[0].y;
    p.layers[0].exp_scale = atmosphere.mie_density[0].z;
    p.layers[0].linear_term = atmosphere.mie_density[0].w;
    p.layers[0].constant_term = atmosphere.mie_density[1].x;
    p.layers[1].width = atmosphere.mie_density[1].y;
    p.layers[1].exp_term = atmosphere.mie_density[1].z;
    p.layers[1].exp_scale = atmosphere.mie_density[1].w;
    p.layers[1].linear_term = atmosphere.mie_density[2].x;
    p.layers[1].constant_term = atmosphere.mie_density[2].y;
    return p;
}

fn GetAbsorptionDensityProfile() -> DensityProfile {
    var p: DensityProfile;
    p.layers[0].width = atmosphere.absorption_density[0].x;
    p.layers[0].exp_term = atmosphere.absorption_density[0].y;
    p.layers[0].exp_scale = atmosphere.absorption_density[0].z;
    p.layers[0].linear_term = atmosphere.absorption_density[0].w;
    p.layers[0].constant_term = atmosphere.absorption_density[1].x;
    p.layers[1].width = atmosphere.absorption_density[1].y;
    p.layers[1].exp_term = atmosphere.absorption_density[1].z;
    p.layers[1].exp_scale = atmosphere.absorption_density[1].w;
    p.layers[1].linear_term = atmosphere.absorption_density[2].x;
    p.layers[1].constant_term = atmosphere.absorption_density[2].y;
    return p;
}

// Math Functions
fn ClampCosine(mu: f32) -> f32 {
    return clamp(mu, -1.0, 1.0);
}

fn ClampDistance(d: f32) -> f32 {
    return max(d, 0.0 * m);
}

fn ClampRadius(r: f32) -> f32 {
    return clamp(r, atmosphere.bottom_radius, atmosphere.top_radius);
}

fn SafeSqrt(a: f32) -> f32 {
    return sqrt(max(a, 0.0));
}

fn DistanceToTopAtmosphereBoundary(r: f32, mu: f32) -> f32 {
    let discriminant = r * r * (mu * mu - 1.0) + atmosphere.top_radius * atmosphere.top_radius;
    return ClampDistance(-r * mu + SafeSqrt(discriminant));
}

fn DistanceToBottomAtmosphereBoundary(r: f32, mu: f32) -> f32 {
    let discriminant = r * r * (mu * mu - 1.0) + atmosphere.bottom_radius * atmosphere.bottom_radius;
    return ClampDistance(-r * mu - SafeSqrt(discriminant));
}

fn RayIntersectsGround(r: f32, mu: f32) -> bool {
    // Check if ray starts inside ground? (r < bottom) -> assume not possible or handled
    // Check if line intersects sphere
    return mu < 0.0 && (r * r * (mu * mu - 1.0) + atmosphere.bottom_radius * atmosphere.bottom_radius) >= 0.0;
}

fn GetLayerDensity(layer: DensityProfileLayer, altitude: f32) -> f32 {
    let density = layer.exp_term * exp(layer.exp_scale * altitude) + layer.linear_term * altitude + layer.constant_term;
    return clamp(density, 0.0, 1.0);
}

fn GetProfileDensity(profile: DensityProfile, altitude: f32) -> f32 {
    // Layer 0 is [bottom, bottom + width]
    // Layer 1 is [bottom + width, top] (width ignored/infinite)
    if (altitude < profile.layers[0].width) {
        return GetLayerDensity(profile.layers[0], altitude);
    }
    return GetLayerDensity(profile.layers[1], altitude);
}

fn ComputeOpticalLengthToTopAtmosphereBoundary(profile: DensityProfile, r: f32, mu: f32) -> f32 {
    let SAMPLE_COUNT = 500u;
    let dx = DistanceToTopAtmosphereBoundary(r, mu) / f32(SAMPLE_COUNT);
    var result = 0.0;
    for (var i = 0u; i <= SAMPLE_COUNT; i++) {
        let d_i = f32(i) * dx;
        let r_i = sqrt(d_i * d_i + 2.0 * r * mu * d_i + r * r);
        let y_i = GetProfileDensity(profile, r_i - atmosphere.bottom_radius);
        let weight_i = select(1.0, 0.5, i == 0u || i == SAMPLE_COUNT);
        result += y_i * weight_i * dx;
    }
    return result;
}

fn ComputeTransmittanceToTopAtmosphereBoundary(r: f32, mu: f32) -> vec3f {
    let rayleigh = GetRayleighDensityProfile();
    let mie = GetMieDensityProfile();
    let absorption = GetAbsorptionDensityProfile();

    let rayleigh_length = ComputeOpticalLengthToTopAtmosphereBoundary(rayleigh, r, mu);
    let mie_length = ComputeOpticalLengthToTopAtmosphereBoundary(mie, r, mu);
    let absorption_length = ComputeOpticalLengthToTopAtmosphereBoundary(absorption, r, mu);
    
    return exp(-(
        atmosphere.rayleigh_scattering * rayleigh_length +
        atmosphere.mie_extinction * mie_length +
        atmosphere.absorption_extinction * absorption_length
    ));
}

// LUT Mapping Constants
const TRANSMITTANCE_TEXTURE_WIDTH: f32 = 256.0;
const TRANSMITTANCE_TEXTURE_HEIGHT: f32 = 64.0;

fn GetTextureCoordFromUnitRange(x: f32, texture_size: f32) -> f32 {
    return 0.5 / texture_size + x * (1.0 - 1.0 / texture_size);
}

fn GetUnitRangeFromTextureCoord(u: f32, texture_size: f32) -> f32 {
    return (u - 0.5 / texture_size) / (1.0 - 1.0 / texture_size);
}

fn GetTransmittanceTextureUvFromRMu(r: f32, mu: f32) -> vec2f {
    // r in [bottom, top]
    // mu in [-1, 1]
    
    let H = sqrt(atmosphere.top_radius * atmosphere.top_radius - atmosphere.bottom_radius * atmosphere.bottom_radius);
    let rho = SafeSqrt(r * r - atmosphere.bottom_radius * atmosphere.bottom_radius);
    
    let d = DistanceToTopAtmosphereBoundary(r, mu);
    let d_min = atmosphere.top_radius - r;
    let d_max = rho + H;
    
    let x_mu = (d - d_min) / (d_max - d_min);
    let x_r = rho / H;
    
    return vec2f(
        GetTextureCoordFromUnitRange(x_mu, TRANSMITTANCE_TEXTURE_WIDTH),
        GetTextureCoordFromUnitRange(x_r, TRANSMITTANCE_TEXTURE_HEIGHT)
    );
}

fn GetRMuFromTransmittanceTextureUv(uv: vec2f) -> vec2f {
    let x_mu = GetUnitRangeFromTextureCoord(uv.x, TRANSMITTANCE_TEXTURE_WIDTH);
    let x_r = GetUnitRangeFromTextureCoord(uv.y, TRANSMITTANCE_TEXTURE_HEIGHT);
    
    let H = sqrt(atmosphere.top_radius * atmosphere.top_radius - atmosphere.bottom_radius * atmosphere.bottom_radius);
    let rho = x_r * H;
    
    let r = sqrt(rho * rho + atmosphere.bottom_radius * atmosphere.bottom_radius);
    
    let d_min = atmosphere.top_radius - r;
    let d_max = rho + H;
    let d = d_min + x_mu * (d_max - d_min);
    
    let mu = select((H * H - rho * rho - d * d) / (2.0 * r * d), 1.0, d == 0.0);
    
    return vec2f(ClampRadius(r), ClampCosine(mu));
}

// Compute Shader Entry Logic Wrapper
fn ComputeTransmittanceToTopAtmosphereBoundaryTexture(global_id: vec3u) -> vec3f {
    let uv = vec2f(f32(global_id.x) + 0.5, f32(global_id.y) + 0.5) / vec2f(TRANSMITTANCE_TEXTURE_WIDTH, TRANSMITTANCE_TEXTURE_HEIGHT);
    
    let r_mu = GetRMuFromTransmittanceTextureUv(uv);
    let r = r_mu.x;
    let mu = r_mu.y;
    
    return ComputeTransmittanceToTopAtmosphereBoundary(r, mu);
}

// Phase Functions
fn RayleighPhaseFunction(nu: f32) -> f32 {
    let k = 3.0 / (16.0 * PI);
    return k * (1.0 + nu * nu);
}

// Original Henyey-Greenstein phase function
fn MiePhaseFunction(g: f32, nu: f32) -> f32 {
    let k = 3.0 / (8.0 * PI) * (1.0 - g * g) / (2.0 + g * g);
    return k * (1.0 + nu * nu) / pow(1.0 + g * g - 2.0 * g * nu, 1.5);
}

// Cornette-Shanks phase function - more physically accurate for Mie scattering
// Better handles the forward scattering peak and rainbow angles
fn CornetteShanksPhaseFunction(g: f32, nu: f32) -> f32 {
    let k = 3.0 / (8.0 * PI) * (1.0 - g * g) / (2.0 + g * g);
    let denom = pow(1.0 + g * g - 2.0 * g * nu, 1.5);
    return k * (1.0 + nu * nu) / denom;
}

// Schlick approximation - faster than HG but similar result
fn SchlickPhaseFunction(g: f32, nu: f32) -> f32 {
    let k = (1.0 - g * g) / (4.0 * PI * pow(1.0 + g * (g - 2.0 * nu), 2.0));
    return k;
}

// Compute ground irradiance contribution (light scattered from atmosphere to ground)
fn ComputeGroundIrradiance(
    transmittance_texture: texture_2d<f32>,
    transmittance_sampler: sampler,
    r: f32,
    mu_s: f32
) -> vec3f {
    // Direct irradiance from sun
    let transmittanceToSun = GetTransmittance(transmittance_texture, transmittance_sampler, r, mu_s);
    let directIrradiance = atmosphere.solar_irradiance * transmittanceToSun * max(0.0, mu_s);

    return directIrradiance;
}

// Compute ground-reflected contribution to sky radiance
// This adds the "bounce light" from the ground back into the atmosphere
fn ComputeGroundReflectedRadiance(
    groundAlbedo: vec3f,
    groundIrradiance: vec3f,
    transmittanceToGround: vec3f
) -> vec3f {
    // Ground reflects irradiance isotropically (Lambertian)
    // The factor 1/PI comes from Lambertian BRDF normalization
    return groundAlbedo * groundIrradiance * transmittanceToGround / PI;
}

// Improved horizon blending factor
// Creates smooth transition at horizon with proper atmospheric darkening
fn ComputeHorizonBlendFactor(viewZenithCos: f32, r: f32) -> f32 {
    // Compute horizon angle based on altitude
    let horizonCos = -SafeSqrt(1.0 - (atmosphere.bottom_radius * atmosphere.bottom_radius) / (r * r));

    // Smooth transition zone around horizon
    let transitionWidth = 0.05;
    let aboveHorizon = smoothstep(horizonCos - transitionWidth, horizonCos + transitionWidth, viewZenithCos);

    // Additional darkening at exact horizon (limb darkening effect)
    let horizonDarkening = 1.0 - exp(-abs(viewZenithCos - horizonCos) * 30.0) * 0.3;

    return aboveHorizon * horizonDarkening;
}

// Aerial perspective contribution - adds atmospheric haze based on path length
fn ComputeAerialPerspective(
    transmittance: vec3f,
    inscatter: vec3f,
    pathLength: f32
) -> vec3f {
    // Blend between object color and atmosphere based on transmittance
    // Longer paths = more atmospheric contribution
    let atmosphericBlend = 1.0 - (transmittance.r + transmittance.g + transmittance.b) / 3.0;
    return inscatter * atmosphericBlend;
}

// Texture Lookups
fn GetTransmittance(tex: texture_2d<f32>, sam: sampler, r: f32, mu: f32) -> vec3f {
    let uv = GetTransmittanceTextureUvFromRMu(r, mu);
    return textureSampleLevel(tex, sam, uv, 0.0).rgb;
}

fn GetTransmittanceToSun(tex: texture_2d<f32>, sam: sampler, r: f32, mu_s: f32) -> vec3f {
    let sin_theta_h = atmosphere.bottom_radius / r;
    let cos_theta_h = -sqrt(max(1.0 - sin_theta_h * sin_theta_h, 0.0));
    
    // If ray intersects ground, return 0 (shadow) - handled by horizon check mostly?
    // But for transmittance to sun, we just check mu_s vs horizon?
    // The reference uses GetTransmittanceToTopAtmosphereBoundary logic.
    return GetTransmittance(tex, sam, r, mu_s);
}

fn DistanceToNearestAtmosphereBoundary(r: f32, mu: f32, ray_r_mu_intersects_ground: bool) -> f32 {
    if (ray_r_mu_intersects_ground) {
        return DistanceToBottomAtmosphereBoundary(r, mu);
    }
    return DistanceToTopAtmosphereBoundary(r, mu);
}

fn GetTransmittanceToBoundary(tex: texture_2d<f32>, sam: sampler, r: f32, mu: f32) -> vec3f {
    // Helper to call GetTransmittance (Top)
    // Note: The original GetTransmittance assumes Top Boundary.
    return GetTransmittance(tex, sam, r, mu);
}

fn GetTransmittanceBetween(tex: texture_2d<f32>, sam: sampler, r: f32, mu: f32, d: f32, ray_r_mu_intersects_ground: bool) -> vec3f {
    let r_d = ClampRadius(sqrt(d * d + 2.0 * r * mu * d + r * r));
    let mu_d = ClampCosine((r * mu + d) / r_d);

    if (ray_r_mu_intersects_ground) {
        return min(
            GetTransmittanceToBoundary(tex, sam, r_d, -mu_d) /
            GetTransmittanceToBoundary(tex, sam, r, -mu),
            vec3f(1.0)
        );
    } else {
        return min(
            GetTransmittanceToBoundary(tex, sam, r, mu) /
            GetTransmittanceToBoundary(tex, sam, r_d, mu_d),
            vec3f(1.0)
        );
    }
}

// 3D LUT Constants
const SCATTERING_TEXTURE_R_SIZE: f32 = 32.0;
const SCATTERING_TEXTURE_MU_SIZE: f32 = 128.0;
const SCATTERING_TEXTURE_MU_S_SIZE: f32 = 32.0;
const SCATTERING_TEXTURE_NU_SIZE: f32 = 8.0;

fn GetScatteringTextureUvwzFromRMuMuSNu(r: f32, mu: f32, mu_s: f32, nu: f32, ray_r_mu_intersects_ground: bool) -> vec4f {
    let H = sqrt(atmosphere.top_radius * atmosphere.top_radius - atmosphere.bottom_radius * atmosphere.bottom_radius);
    let rho = SafeSqrt(r * r - atmosphere.bottom_radius * atmosphere.bottom_radius);
    let u_r = GetTextureCoordFromUnitRange(rho / H, SCATTERING_TEXTURE_R_SIZE);
    
    let r_mu = r * mu;
    let discriminant = r_mu * r_mu - r * r + atmosphere.bottom_radius * atmosphere.bottom_radius;
    var u_mu = 0.0;
    
    if (ray_r_mu_intersects_ground) {
        let d = -r_mu - SafeSqrt(discriminant);
        let d_min = r - atmosphere.bottom_radius;
        let d_max = rho;
        u_mu = 0.5 - 0.5 * GetTextureCoordFromUnitRange(
             select((d - d_min) / (d_max - d_min), 0.0, d_max == d_min), 
             SCATTERING_TEXTURE_MU_SIZE / 2.0
        );
    } else {
        let d = -r_mu + SafeSqrt(discriminant + H * H);
        let d_min = atmosphere.top_radius - r;
        let d_max = rho + H;
        u_mu = 0.5 + 0.5 * GetTextureCoordFromUnitRange(
            (d - d_min) / (d_max - d_min), 
            SCATTERING_TEXTURE_MU_SIZE / 2.0
        );
    }
    
    let d = DistanceToTopAtmosphereBoundary(atmosphere.bottom_radius, mu_s);
    let d_min = atmosphere.top_radius - atmosphere.bottom_radius;
    let d_max = H;
    let a = (d - d_min) / (d_max - d_min);
    let A = -2.0 * atmosphere.mu_s_min * atmosphere.bottom_radius / (d_max - d_min);
    let u_mu_s = GetTextureCoordFromUnitRange(
        max(1.0 - a / A, 0.0) / (1.0 + a), SCATTERING_TEXTURE_MU_S_SIZE
    );
    
    let u_nu = (nu + 1.0) / 2.0;
    return vec4f(u_nu, u_mu_s, u_mu, u_r);
}

fn GetRMuMuSNuFromScatteringTextureFragCoord(frag_coord: vec3f) -> vec4f {
    // Returns vec4(r, mu, mu_s, nu)
    // We also need ray_r_mu_intersects_ground, but return generic vector for now.
    // Wait, the logic is complex and returns multiple values.
    // I'll implement a specific struct or update usage.
    // For now, let's implement the internal logic to extract U, V, W, Z.
    
    let SCATTERING_TEXTURE_SIZE = vec4f(
        SCATTERING_TEXTURE_NU_SIZE - 1.0,
        SCATTERING_TEXTURE_MU_S_SIZE,
        SCATTERING_TEXTURE_MU_SIZE,
        SCATTERING_TEXTURE_R_SIZE
    );
    
    let frag_coord_nu = floor(frag_coord.x / SCATTERING_TEXTURE_MU_S_SIZE);
    let frag_coord_mu_s = frag_coord.x - frag_coord_nu * SCATTERING_TEXTURE_MU_S_SIZE; // mod
    
    let uvwz = vec4f(frag_coord_nu, frag_coord_mu_s, frag_coord.y, frag_coord.z) / SCATTERING_TEXTURE_SIZE;
    
    var r = 0.0;
    var mu = 0.0;
    var mu_s = 0.0;
    var nu = 0.0;
    
    // Inverse Mapping
    let H = sqrt(atmosphere.top_radius * atmosphere.top_radius - atmosphere.bottom_radius * atmosphere.bottom_radius);
    let rho = H * GetUnitRangeFromTextureCoord(uvwz.w, SCATTERING_TEXTURE_R_SIZE);
    r = sqrt(rho * rho + atmosphere.bottom_radius * atmosphere.bottom_radius);
    
    if (uvwz.z < 0.5) {
        let d_min = r - atmosphere.bottom_radius;
        let d_max = rho;
        let d = d_min + (d_max - d_min) * GetUnitRangeFromTextureCoord(1.0 - 2.0 * uvwz.z, SCATTERING_TEXTURE_MU_SIZE / 2.0);
        mu = select(ClampCosine(-(rho * rho + d * d) / (2.0 * r * d)), -1.0, d == 0.0);
    } else {
        let d_min = atmosphere.top_radius - r;
        let d_max = rho + H;
        let d = d_min + (d_max - d_min) * GetUnitRangeFromTextureCoord(2.0 * uvwz.z - 1.0, SCATTERING_TEXTURE_MU_SIZE / 2.0);
        mu = select(ClampCosine((H * H - rho * rho - d * d) / (2.0 * r * d)), 1.0, d == 0.0);
    }
    
    let x_mu_s = GetUnitRangeFromTextureCoord(uvwz.y, SCATTERING_TEXTURE_MU_S_SIZE);
    let d_min = atmosphere.top_radius - atmosphere.bottom_radius;
    let d_max = H;
    let A = -2.0 * atmosphere.mu_s_min * atmosphere.bottom_radius / (d_max - d_min);
    let a = (A - x_mu_s * A) / (1.0 + x_mu_s * A);
    let d = d_min + min(a, A) * (d_max - d_min);
    mu_s = select(ClampCosine((H * H - d * d) / (2.0 * atmosphere.bottom_radius * d)), 1.0, d == 0.0);
    
    nu = ClampCosine(uvwz.x * 2.0 - 1.0);
    
    // Clamp nu
    nu = clamp(nu, mu * mu_s - sqrt((1.0 - mu * mu) * (1.0 - mu_s * mu_s)), mu * mu_s + sqrt((1.0 - mu * mu) * (1.0 - mu_s * mu_s)));
    
    return vec4f(r, mu, mu_s, nu);
}

// Single Scattering Integrator
fn ComputeSingleScatteringTexture(
    transmittance_texture: texture_2d<f32>, 
    transmittance_sampler: sampler, 
    frag_coord: vec3f
) -> vec4f { // Returns Rayleigh (rgb) + Mie (r in alpha?)
    let params = GetRMuMuSNuFromScatteringTextureFragCoord(frag_coord);
    let r = params.x;
    let mu = params.y;
    let mu_s = params.z;
    let nu = params.w;
    
    let ray_r_mu_intersects_ground = RayIntersectsGround(r, mu);
    
    let SAMPLE_COUNT = 50u;
    let dx = DistanceToNearestAtmosphereBoundary(r, mu, ray_r_mu_intersects_ground) / f32(SAMPLE_COUNT);
    
    var rayleigh_sum = vec3f(0.0);
    var mie_sum = vec3f(0.0);
    
    for (var i = 0u; i <= SAMPLE_COUNT; i++) {
        let d_i = f32(i) * dx;
        let r_d = ClampRadius(sqrt(d_i * d_i + 2.0 * r * mu * d_i + r * r));
        let mu_s_d = ClampCosine((r * mu_s + d_i * nu) / r_d);
        
        let transmittance = GetTransmittanceBetween(transmittance_texture, transmittance_sampler, r, mu, d_i, ray_r_mu_intersects_ground) *
            GetTransmittanceToSun(transmittance_texture, transmittance_sampler, r_d, mu_s_d);
            
        let rayleigh_density = GetProfileDensity(GetRayleighDensityProfile(), r_d - atmosphere.bottom_radius);
        let mie_density = GetProfileDensity(GetMieDensityProfile(), r_d - atmosphere.bottom_radius);
        
        let rayleigh_i = transmittance * rayleigh_density;
        let mie_i = transmittance * mie_density;
        
        let weight_i = select(1.0, 0.5, i == 0u || i == SAMPLE_COUNT);
        rayleigh_sum += rayleigh_i * weight_i;
        mie_sum += mie_i * weight_i;
    }
    
    let rayleigh = rayleigh_sum * dx * atmosphere.solar_irradiance * atmosphere.rayleigh_scattering;
    let mie = mie_sum * dx * atmosphere.solar_irradiance * atmosphere.mie_scattering;
    
    // Store Rayleigh in RGB, Mie Red in Alpha (Standard Bruneton packing)
    return vec4f(rayleigh, mie.r); 
}

// SkyViewLUT Mapping
const SKY_VIEW_W = 192.0;
const SKY_VIEW_H = 108.0;

fn raySphereIntersectNearest(r0: vec3f, rd: vec3f, s0: vec3f, sR: f32) -> f32 {
    let a = dot(rd, rd);
    let s0_r0 = r0 - s0;
    let b = 2.0 * dot(rd, s0_r0);
    let c = dot(s0_r0, s0_r0) - (sR * sR);
    let delta = b * b - 4.0 * a * c;
    if (delta < 0.0 || a == 0.0) {
        return -1.0;
    }
    let sol0 = (-b - sqrt(delta)) / (2.0 * a);
    let sol1 = (-b + sqrt(delta)) / (2.0 * a);
    if (sol0 < 0.0 && sol1 < 0.0) {
        return -1.0;
    }
    if (sol0 < 0.0) { return max(0.0, sol1); }
    else if (sol1 < 0.0) { return max(0.0, sol0); }
    return max(0.0, min(sol0, sol1));
}

fn UvToSkyViewLutParams(uv: vec2f, viewHeight: f32) -> vec2f {
    // Returns vec2(viewZenithCosAngle, lightViewCosAngle)
    // Constrain UVs
    let uv_sub = vec2f(fromSubUvsToUnit(uv.x, SKY_VIEW_W), fromSubUvsToUnit(uv.y, SKY_VIEW_H));
    
    let Vhorizon = SafeSqrt(viewHeight * viewHeight - atmosphere.bottom_radius * atmosphere.bottom_radius);
    let CosBeta = Vhorizon / viewHeight;
    let Beta = acos(CosBeta);
    let ZenithHorizonAngle = PI - Beta;
    
    var viewZenithCosAngle = 0.0;
    if (uv_sub.y < 0.5) {
        var coord = 2.0 * uv_sub.y;
        coord = 1.0 - coord;
        coord *= coord; // Non-linear
        coord = 1.0 - coord;
        viewZenithCosAngle = cos(ZenithHorizonAngle * coord);
    } else {
        var coord = uv_sub.y * 2.0 - 1.0;
        coord *= coord; // Non-linear
        viewZenithCosAngle = cos(ZenithHorizonAngle + Beta * coord);
    }
    
    var coord = uv_sub.x;
    coord *= coord;
    let lightViewCosAngle = -(coord * 2.0 - 1.0);
    
    return vec2f(viewZenithCosAngle, lightViewCosAngle);
}

fn SkyViewLutParamsToUv(viewZenithCosAngle: f32, lightViewCosAngle: f32, viewHeight: f32) -> vec2f {
    let Vhorizon = SafeSqrt(viewHeight * viewHeight - atmosphere.bottom_radius * atmosphere.bottom_radius);
    let CosBeta = Vhorizon / viewHeight;
    let Beta = acos(CosBeta);
    let ZenithHorizonAngle = PI - Beta;
    
    var v = 0.0;
    let IntersectGround = raySphereIntersectNearest(vec3f(0.0, viewHeight, 0.0), vec3f(sqrt(max(0.0, 1.0 - viewZenithCosAngle*viewZenithCosAngle)), viewZenithCosAngle, 0.0), vec3f(0.0), atmosphere.bottom_radius) >= 0.0;
    // Or simpler check: viewZenithCosAngle < CosBeta? No, CosBeta is positive.
    // If angle > ZenithHorizonAngle?
    
    if (!IntersectGround) {
        var coord = acos(viewZenithCosAngle) / ZenithHorizonAngle;
        coord = 1.0 - coord;
        coord = SafeSqrt(coord);
        coord = 1.0 - coord;
        v = coord * 0.5;
    } else {
        var coord = (acos(viewZenithCosAngle) - ZenithHorizonAngle) / Beta;
        coord = SafeSqrt(coord);
        v = coord * 0.5 + 0.5;
    }
    
    var coord = -lightViewCosAngle * 0.5 + 0.5;
    coord = SafeSqrt(coord);
    let u = coord;
    
    return vec2f(fromUnitToSubUvs(u, SKY_VIEW_W), fromUnitToSubUvs(v, SKY_VIEW_H));
}

fn fromSubUvsToUnit(u: f32, resolution: f32) -> f32 {
    return (u - 0.5 / resolution) * (resolution / (resolution - 1.0));
}

fn fromUnitToSubUvs(u: f32, resolution: f32) -> f32 {
    return (u + 0.5 / resolution) * (resolution / (resolution + 1.0));
}
`;

// ../../src/core/renderer/SkyboxPass.ts
class SkyboxPass {
  pipeline = null;
  atmospherePipeline = null;
  gBuffer = null;
  context = null;
  presentationFormat = null;
  constructor(gBuffer = null) {
    this.gBuffer = gBuffer;
  }
  init(device, context, presentationFormat) {
    this.context = context;
    this.presentationFormat = presentationFormat;
    const format = this.gBuffer ? "rgba16float" : presentationFormat;
    this.createCubemapPipeline(device, format);
  }
  initAtmosphere(device, renderBindGroupLayout, atmosphereBindGroupLayout) {
    if (this.atmospherePipeline)
      return;
    const format = this.gBuffer ? "rgba16float" : this.presentationFormat || "bgra8unorm";
    this.createAtmospherePipeline(device, format, renderBindGroupLayout, atmosphereBindGroupLayout);
  }
  resize(width, height) {}
  execute(commandEncoder, context, globalResources) {
    if (!this.pipeline || !this.context || !this.presentationFormat)
      return;
    let textureView;
    if (this.gBuffer && this.gBuffer.accumulationTexture) {
      textureView = this.gBuffer.accumulationTexture.createView();
    } else {
      textureView = this.context.getCurrentTexture().createView();
    }
    const depthTexture = this.gBuffer ? this.gBuffer.depthTexture : null;
    if (!depthTexture)
      return;
    const renderPassDescriptor = {
      colorAttachments: [
        {
          view: textureView,
          loadOp: "load",
          storeOp: "store"
        }
      ],
      depthStencilAttachment: {
        view: depthTexture.createView({ aspect: "depth-only" }),
        depthLoadOp: "load",
        depthStoreOp: "store"
      }
    };
    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
    if (context.scene.atmosphere.enabled && this.atmospherePipeline && globalResources.atmosphereBindGroup) {
      passEncoder.setPipeline(this.atmospherePipeline);
      passEncoder.setBindGroup(0, globalResources.renderBindGroup);
      passEncoder.setBindGroup(1, globalResources.atmosphereBindGroup);
    } else if (globalResources.environmentMap) {
      passEncoder.setPipeline(this.pipeline);
      passEncoder.setBindGroup(0, globalResources.renderBindGroup);
    } else {
      passEncoder.end();
      return;
    }
    passEncoder.draw(36);
    passEncoder.end();
  }
  createCubemapPipeline(device, format) {
    const code = `
      struct SceneUniforms {
        viewMatrix : mat4x4<f32>,
        projectionMatrix : mat4x4<f32>,
        lightViewProj : mat4x4<f32>,
        prevViewProj : mat4x4<f32>,
        inverseProjectionMatrix : mat4x4<f32>,
        cameraPosition : vec3f,
        time : f32,
        lightCount : u32,
        debugMode : u32,
        shadowsEnabled : u32,
        environmentIntensity : f32,
        fogColor: vec3f,
        fogDensity: f32,
        fogParams: vec4f,     // x=start, y=end, z=height, w=heightFalloff
        fogSettings: vec4u,   // x=type, y=enabled, z=pad, w=pad
        cloudShadowParams: vec4f,  // x=enabled, y=intensity, z=scale, w=speed
        cloudShadowParams2: vec4f, // x=coverage, y=softness, z=windDirX, w=windDirZ
        // Fog2 (Three.js-style fog)
        fog2Color: vec3f,     // Fog color
        fog2Density: f32,     // FogExp2 density for objects
        fog2Params: vec4f,    // x=near, y=far, z=type (0=LINEAR, 1=EXP2), w=enabled
        fog2SkyFalloff: f32,  // How high fog extends into sky (0=none, 1=zenith)
        _fog2Pad1: f32,       // padding
        _fog2Pad2: f32,       // padding
        _fog2Pad3: f32,       // padding
      }

      @group(0) @binding(0) var<uniform> scene : SceneUniforms;
      @group(0) @binding(6) var envMap: texture_cube<f32>;
      @group(0) @binding(7) var envSamp: sampler;

      struct VertexOutput {
        @builtin(position) position : vec4f,
        @location(0) uv : vec3f,
      }

      @vertex
      fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
        var output : VertexOutput;
        let pos = array<vec3f, 36>(
            vec3f(-1,  1, -1), vec3f(-1, -1, -1), vec3f( 1, -1, -1),
            vec3f( 1, -1, -1), vec3f( 1,  1, -1), vec3f(-1,  1, -1),
            vec3f(-1, -1,  1), vec3f(-1, -1, -1), vec3f(-1,  1, -1),
            vec3f(-1,  1, -1), vec3f(-1,  1,  1), vec3f(-1, -1,  1),
            vec3f( 1, -1, -1), vec3f( 1, -1,  1), vec3f( 1,  1,  1),
            vec3f( 1,  1,  1), vec3f( 1,  1, -1), vec3f( 1, -1, -1),
            vec3f(-1, -1,  1), vec3f(-1,  1,  1), vec3f( 1,  1,  1),
            vec3f( 1,  1,  1), vec3f( 1, -1,  1), vec3f(-1, -1,  1),
            vec3f(-1,  1, -1), vec3f( 1,  1, -1), vec3f( 1,  1,  1),
            vec3f( 1,  1,  1), vec3f(-1,  1,  1), vec3f(-1,  1, -1),
            vec3f(-1, -1, -1), vec3f(-1, -1,  1), vec3f( 1, -1, -1),
            vec3f( 1, -1, -1), vec3f(-1, -1,  1), vec3f( 1, -1,  1)
        );

        let p = pos[vertexIndex];
        output.uv = p;

        var view = scene.viewMatrix;
        view[3] = vec4f(0.0, 0.0, 0.0, 1.0);

        let clipPos = scene.projectionMatrix * view * vec4f(p, 1.0);
        output.position = clipPos.xyww;
        return output;
      }

      @fragment
      fn fs_main(@location(0) uv : vec3f) -> @location(0) vec4f {
        var color = textureSample(envMap, envSamp, normalize(uv));
        let viewDir = normalize(uv);

        // Fog for cubemap skybox - uses uniform fog color
        let fog2Enabled = scene.fog2Params.w;
        if (fog2Enabled >= 0.5) {
            let fog2Type = scene.fog2Params.z;
            let upFactor = abs(viewDir.y);

            var fogFactor = 0.0;
            if (fog2Type < 0.5) {
                let fogNear = scene.fog2Params.x;
                let fogFar = scene.fog2Params.y;
                let skyDistance = mix(fogFar, fogNear, upFactor);
                fogFactor = smoothstep(fogNear, fogFar, skyDistance);
            } else {
                let fogDensity = scene.fog2Density;
                let horizonDistance = 500.0;
                if (viewDir.y <= 0.0) {
                    fogFactor = 1.0 - exp(-fogDensity * fogDensity * horizonDistance * horizonDistance);
                } else {
                    let skyDistance = mix(horizonDistance, 10.0, viewDir.y);
                    let baseFogFactor = 1.0 - exp(-fogDensity * fogDensity * skyDistance * skyDistance);
                    let heightFade = 1.0 - smoothstep(0.0, max(scene.fog2SkyFalloff, 0.001), viewDir.y);
                    fogFactor = baseFogFactor * heightFade;
                }
            }
            fogFactor = clamp(fogFactor, 0.0, 1.0);
            color = vec4f(mix(color.rgb, scene.fog2Color, fogFactor), color.a);
        }

        return color;
      }
      `;
    const bindGroupLayout = device.createBindGroupLayout({
      label: "Global Render Bind Group Layout (Skybox Copy)",
      entries: [
        { binding: 0, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
        { binding: 1, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: "read-only-storage" } },
        { binding: 3, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: "read-only-storage" } },
        { binding: 4, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "depth", viewDimension: "2d-array" } },
        { binding: 5, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "comparison" } },
        { binding: 6, visibility: GPUShaderStage.FRAGMENT, texture: { viewDimension: "cube" } },
        { binding: 7, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "filtering" } },
        { binding: 8, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
        { binding: 9, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "unfilterable-float", viewDimension: "2d-array" } },
        { binding: 10, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "non-filtering" } },
        { binding: 11, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } }
      ]
    });
    const pipelineLayout = device.createPipelineLayout({
      bindGroupLayouts: [bindGroupLayout]
    });
    this.pipeline = device.createRenderPipeline({
      label: "Skybox Pipeline",
      layout: pipelineLayout,
      vertex: {
        module: createShaderModuleSafe(device, { code }),
        entryPoint: "vs_main"
      },
      fragment: {
        module: createShaderModuleSafe(device, { code }),
        entryPoint: "fs_main",
        targets: [{ format }]
      },
      primitive: {
        topology: "triangle-list",
        cullMode: "none"
      },
      depthStencil: {
        depthWriteEnabled: false,
        depthCompare: "less-equal",
        format: this.gBuffer?.depthTexture?.format || "depth24plus"
      }
    });
  }
  createAtmospherePipeline(device, format, renderBindGroupLayout, atmosphereBindGroupLayout) {
    const code = `
      ${AtmosphereCommonWGSL}

      // Group 0: Core scene resources
      struct SceneUniforms {
        viewMatrix : mat4x4<f32>,
        projectionMatrix : mat4x4<f32>,
        lightViewProj : mat4x4<f32>,
        prevViewProj : mat4x4<f32>,
        inverseProjectionMatrix : mat4x4<f32>,
        cameraPosition : vec3f,
        time : f32,
        lightCount : u32,
        debugMode : u32,
        shadowsEnabled : u32,
        environmentIntensity : f32,
        fogColor: vec3f,
        fogDensity: f32,
        fogParams: vec4f,     // x=start, y=end, z=height, w=heightFalloff
        fogSettings: vec4u,   // x=type, y=enabled, z=pad, w=pad
        cloudShadowParams: vec4f,  // x=enabled, y=intensity, z=scale, w=speed
        cloudShadowParams2: vec4f, // x=coverage, y=softness, z=windDirX, w=windDirZ
        // Fog2 (Three.js-style fog)
        fog2Color: vec3f,     // Fog color
        fog2Density: f32,     // FogExp2 density for objects
        fog2Params: vec4f,    // x=near, y=far, z=type (0=LINEAR, 1=EXP2), w=enabled
        fog2SkyFalloff: f32,  // How high fog extends into sky (0=none, 1=zenith)
        _fog2Pad1: f32,       // padding
        _fog2Pad2: f32,       // padding
        _fog2Pad3: f32,       // padding
      }
      @group(0) @binding(0) var<uniform> scene : SceneUniforms;

      // Group 1: Atmosphere resources (simplified for Safari - consecutive bindings 0-5)
      @group(1) @binding(0) var transmittanceLUT : texture_2d<f32>;
      @group(1) @binding(1) var skyViewLUT : texture_2d<f32>;
      @group(1) @binding(2) var<uniform> atmosphere : AtmosphereUniforms;
      @group(1) @binding(3) var samp : sampler;
      @group(1) @binding(4) var cloudNoiseLUT : texture_3d<f32>;
      @group(1) @binding(5) var linearSamp : sampler;

      struct VertexOutput {
        @builtin(position) position : vec4f,
        @location(0) uv : vec3f,
      }

      @vertex
      fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
        var output : VertexOutput;
        let pos = array<vec3f, 36>(
            vec3f(-1,  1, -1), vec3f(-1, -1, -1), vec3f( 1, -1, -1),
            vec3f( 1, -1, -1), vec3f( 1,  1, -1), vec3f(-1,  1, -1),
            vec3f(-1, -1,  1), vec3f(-1, -1, -1), vec3f(-1,  1, -1),
            vec3f(-1,  1, -1), vec3f(-1,  1,  1), vec3f(-1, -1,  1),
            vec3f( 1, -1, -1), vec3f( 1, -1,  1), vec3f( 1,  1,  1),
            vec3f( 1,  1,  1), vec3f( 1,  1, -1), vec3f( 1, -1, -1),
            vec3f(-1, -1,  1), vec3f(-1,  1,  1), vec3f( 1,  1,  1),
            vec3f( 1,  1,  1), vec3f( 1, -1,  1), vec3f(-1, -1,  1),
            vec3f(-1,  1, -1), vec3f( 1,  1, -1), vec3f( 1,  1,  1),
            vec3f( 1,  1,  1), vec3f(-1,  1,  1), vec3f(-1,  1, -1),
            vec3f(-1, -1, -1), vec3f(-1, -1,  1), vec3f( 1, -1, -1),
            vec3f( 1, -1, -1), vec3f(-1, -1,  1), vec3f( 1, -1,  1)
        );

        let p = pos[vertexIndex];
        output.uv = p;

        var view = scene.viewMatrix;
        view[3] = vec4f(0.0, 0.0, 0.0, 1.0);

        let clipPos = scene.projectionMatrix * view * vec4f(p, 1.0);
        output.position = clipPos.xyww;
        return output;
      }

      // Sky View LUT UV mapping with improved horizon handling
      fn directionToSkyViewUV(dir: vec3f, cameraAltitude: f32) -> vec2f {
          let up = vec3f(0.0, 1.0, 0.0);
          let viewZenithCos = dot(dir, up);
          let lightDir = normalize(atmosphere.sun_direction.xyz);
          let lightViewCos = dot(lightDir, dir);

          // Compute horizon angle (angle from zenith where ground becomes visible)
          let horizonCos = sqrt(max(0.0, cameraAltitude * cameraAltitude - atmosphere.bottom_radius * atmosphere.bottom_radius)) / cameraAltitude;
          let horizonAngle = acos(horizonCos);
          let viewZenith = acos(clamp(viewZenithCos, -1.0, 1.0));

          var u: f32;
          var v: f32;

          // Improved non-linear UV mapping for better resolution near horizon
          // This gives more texel precision where we need it most
          if viewZenith < horizonAngle {
              // Above horizon - use quadratic mapping for smooth gradients
              let normalizedAngle = viewZenith / horizonAngle;
              // Use power curve for more resolution near horizon
              let horizonBias = pow(normalizedAngle, 0.7);
              v = 0.5 - 0.5 * (1.0 - horizonBias);
          } else {
              // Below horizon (looking at ground)
              let belowHorizonAngle = viewZenith - horizonAngle;
              let maxBelowAngle = 3.14159265 - horizonAngle;
              let t = belowHorizonAngle / maxBelowAngle;
              // Square root for more resolution near horizon
              v = 0.5 + 0.5 * sqrt(t);
          }

          // Light view cosine mapping with slight non-linearity for sun/anti-sun
          // This improves color accuracy around sun and opposite direction
          let lightViewNorm = (lightViewCos + 1.0) * 0.5;
          u = sqrt(lightViewNorm); // More resolution toward sun

          return vec2f(u, v);
      }

      // Compute horizon glow contribution for golden hour
      fn computeHorizonGlow(dir: vec3f, sunDir: vec3f, cameraAltitude: f32) -> vec3f {
          let viewZenithCos = dir.y;
          let horizonCos = sqrt(max(0.0, cameraAltitude * cameraAltitude - atmosphere.bottom_radius * atmosphere.bottom_radius)) / cameraAltitude;

          // Distance from horizon (0 = at horizon, 1 = far from horizon)
          let horizonDist = abs(viewZenithCos - (-horizonCos));

          // Sharp falloff from horizon
          let horizonFactor = exp(-horizonDist * 8.0);

          // Sun contribution - glow depends on sun being near horizon
          let sunNearHorizon = 1.0 - smoothstep(-0.1, 0.3, sunDir.y);

          // Color gradient from deep red to orange at horizon during sunset
          var glowColor = vec3f(0.0);
          if sunNearHorizon > 0.0 {
              let sunSide = dot(normalize(vec3f(dir.x, 0.0, dir.z)), normalize(vec3f(sunDir.x, 0.0, sunDir.z)));
              let sunInfluence = smoothstep(-0.3, 0.8, sunSide);

              // Deep orange-red glow near horizon at sunset
              let warmGlow = vec3f(1.0, 0.3, 0.05) * sunInfluence;
              // Purple-blue anti-sun glow
              let coolGlow = vec3f(0.2, 0.1, 0.4) * (1.0 - sunInfluence);

              glowColor = (warmGlow + coolGlow) * horizonFactor * sunNearHorizon * 0.3;
          }

          return glowColor;
      }

      // Compute ground reflection ambient contribution
      fn computeGroundAmbient(dir: vec3f, sunDir: vec3f, groundAlbedo: vec3f) -> vec3f {
          // Only applies when looking toward ground
          if dir.y > 0.0 { return vec3f(0.0); }

          // Ground ambient is stronger when sun is up
          let sunUp = max(0.0, sunDir.y);

          // Ground reflects sky light back up - this creates the subtle
          // brightening of the lower sky from ground bounce
          let groundBrightness = groundAlbedo * sunUp * 0.15;

          // Fade based on how far below horizon we're looking
          // Note: smoothstep requires low < high per WGSL spec (Dawn is strict about this)
          let belowHorizonFactor = 1.0 - smoothstep(-0.5, 0.0, dir.y);

          return groundBrightness * belowHorizonFactor;
      }

      fn getTransmittanceToSun(altitude: f32, sunZenithCos: f32) -> vec3f {
          let H = sqrt(max(0.0, atmosphere.top_radius * atmosphere.top_radius - atmosphere.bottom_radius * atmosphere.bottom_radius));
          let rho = sqrt(max(0.0, altitude * altitude - atmosphere.bottom_radius * atmosphere.bottom_radius));
          let d = max(0.0, altitude * altitude - atmosphere.bottom_radius * atmosphere.bottom_radius);

          let u_mu = 0.5 + 0.5 * sunZenithCos;
          let u_r = rho / H;

          return textureLoad(transmittanceLUT, vec2i(vec2f(u_mu, u_r) * vec2f(256.0, 64.0)), 0).rgb;
      }

      fn renderSunDisk(dir: vec3f, sunDir: vec3f, transmittanceToSun: vec3f) -> vec3f {
          // Hide if below horizon (with small buffer for grazing angles)
          if (sunDir.y < -0.05) { return vec3f(0.0); }

          // Use atmosphere uniform for sun size, with scale multiplier
          let baseSunAngularRadius = atmosphere.sun_angular_radius;
          let sunAngularRadius = baseSunAngularRadius * atmosphere.sun_disk_scale;
          let cosAngle = dot(dir, sunDir);
          let sunCosAngle = cos(sunAngularRadius);

          if cosAngle >= sunCosAngle {
              let sunIntensity = atmosphere.solar_irradiance.xyz;
              let limbDarkening = sqrt(1.0 - pow((1.0 - cosAngle) / (1.0 - sunCosAngle), 2.0));
              return sunIntensity * transmittanceToSun * limbDarkening * 10.0;
          }
          return vec3f(0.0);
      }

      fn renderMoonDisk(dir: vec3f, moonDir: vec3f, transmittanceToMoon: vec3f, moonPhase: f32) -> vec3f {
          // Hide if below horizon
          if (moonDir.y < -0.05) { return vec3f(0.0); }

          // Use atmosphere uniform for moon size, with scale multiplier
          let baseMoonAngularRadius = atmosphere.moon_angular_radius;
          let moonAngularRadius = baseMoonAngularRadius * atmosphere.moon_scale;
          let cosAngle = dot(dir, moonDir);
          let moonCosAngle = cos(moonAngularRadius);

          if cosAngle >= moonCosAngle {
              // Moon color: pure white (no atmospheric tinting)
              let moonColor = vec3f(1.0, 1.0, 1.0);
              let moonIntensity = 3.0;  // Lower intensity to reduce bloom

              // Calculate position on moon disk in local 2D coordinates
              let toCenter = normalize(dir - moonDir * dot(dir, moonDir));
              let upDir = normalize(cross(cross(moonDir, vec3f(0.0, 1.0, 0.0)), moonDir));
              let rightDir = normalize(cross(moonDir, upDir));

              let distFromCenter = acos(clamp(cosAngle, -1.0, 1.0)) / moonAngularRadius;

              // Get x,y coordinates on the moon disk (-1 to 1)
              let localX = dot(toCenter, rightDir) * distFromCenter;
              let localY = dot(toCenter, upDir) * distFromCenter;

              // Moon phase creates a CURVED terminator (ellipse on sphere)
              // moonPhase: 0 = new moon, 0.5 = full moon, 1 = new moon
              // The terminator curves: at height y, the edge is at x = t * sqrt(1 - y²)

              // Calculate terminator position (t) that moves continuously
              // For waxing (0 to 0.5): t goes from 1 (right edge) to -1 (left edge)
              // For waning (0.5 to 1): t goes from 1 (right edge) to -1 (left edge)
              // The key insight: at phase 0.5, BOTH formulas should give a fully lit moon
              var t: f32;
              if moonPhase <= 0.5 {
                  // Waxing: shadow recedes from right to left
                  t = 1.0 - 4.0 * moonPhase;  // 1 at phase 0, -1 at phase 0.5
              } else {
                  // Waning: shadow advances from right to left
                  t = 1.0 - 4.0 * (moonPhase - 0.5);  // 1 at phase 0.5, -1 at phase 1
              }

              // The terminator is an ellipse: at this y position, the terminator x is:
              let ellipseFactor = sqrt(max(0.0, 1.0 - localY * localY));
              let terminatorAtY = t * ellipseFactor;

              // Determine illumination based on which side of curved terminator we're on
              var illumination = 0.0;
              if moonPhase <= 0.5 {
                  // Waxing: right side is lit (x > terminatorAtY means lit)
                  illumination = smoothstep(terminatorAtY - 0.05, terminatorAtY + 0.05, localX);
              } else {
                  // Waning: left side is lit (x < terminatorAtY means lit)
                  // Note: smoothstep requires low < high per WGSL spec
                  illumination = 1.0 - smoothstep(terminatorAtY - 0.05, terminatorAtY + 0.05, localX);
              }

              // Subtle limb darkening
              let limbDarkening = 0.7 + 0.3 * sqrt(max(0.0, 1.0 - distFromCenter * distFromCenter));

              // Return pure moon color without atmospheric tinting
              return moonColor * moonIntensity * illumination * limbDarkening;
          }
          return vec3f(0.0);
      }

      // --- Cloud Sampling ---

      // Optimized: Two-sample noise blending to hide tiling
      fn sampleCloudNoiseMultiScale(pos: vec3f, lod: f32) -> vec4f {
          // First sample - base
          let n1 = textureSampleLevel(cloudNoiseLUT, linearSamp, pos, lod);

          // Second sample - rotated 60° and offset to break patterns
          let c = 0.5; let s = 0.866; // cos/sin(60°) - larger angle for more separation
          let rotated = vec3f(pos.x * c - pos.z * s, pos.y, pos.x * s + pos.z * c);
          let n2 = textureSampleLevel(cloudNoiseLUT, linearSamp, rotated * 2.1 + 0.33, lod);

          // Blend samples
          return n1 * 0.65 + n2 * 0.35;
      }

      // Screen-space jitter to break up horizontal banding (called once per pixel)
      fn getScreenJitter(fragCoord: vec2f, time: f32) -> f32 {
          // Interleaved gradient noise with temporal variation
          let t = fract(time * 5.0);
          return fract(52.9829189 * fract(0.06711056 * fragCoord.x + 0.00583715 * fragCoord.y + t * 0.1));
      }

      // Sample cloud noise with detail erosion
      // Returns vec2f: x=density, y=detail for lighting
      fn sampleCloudNoise(pos: vec3f, heightFraction: f32, lod: f32) -> vec2f {
          // Animate clouds with wind
          let wind = atmosphere.cloud_wind_direction * atmosphere.cloud_speed * scene.time * 0.1;

          // Base scale for large cloud shapes
          let baseScale = 0.00002;
          let baseUvw = (pos + wind) * baseScale;

          // Sample with multi-scale blending to hide tiling
          let noise = sampleCloudNoiseMultiScale(baseUvw, lod);
          let baseShape = noise.r;
          let detailNoise = noise.g;
          let wispyNoise = noise.b;
          let coverageVar = noise.a;

          // Use noise to perturb height thresholds - this breaks up horizontal banding
          // The variation is small but enough to blur the hard edges
          let heightVar = (detailNoise - 0.5) * 0.15 + (wispyNoise - 0.5) * 0.1;
          let perturbedHeight = clamp(heightFraction + heightVar, 0.0, 1.0);

          // Height gradient with perturbed thresholds and wider transitions
          // Note: smoothstep requires low < high per WGSL spec
          let heightGradient = smoothstep(0.0, 0.25, perturbedHeight) *
                               (1.0 - smoothstep(0.5, 1.0, perturbedHeight));

          // Round bottom, flat top profile with noise variation
          let roundBottom = smoothstep(0.0, 0.3, perturbedHeight);
          let flatTop = 1.0 - smoothstep(0.6, 1.0, perturbedHeight) * 0.5;
          let anvilShape = roundBottom * flatTop;

          // Apply coverage variation and base threshold
          let cov = atmosphere.cloud_coverage;
          var density = baseShape * coverageVar;

          // Coverage remapping with smooth falloff
          density = smoothstep(1.0 - cov, 1.0 - cov * 0.5, density);

          // Apply height shaping
          density *= anvilShape * heightGradient;

          // Erode edges with detail noise (more erosion at edges)
          let erosion = detailNoise * 0.35 * (1.0 - density * 0.5);
          density = max(0.0, density - erosion);

          // Add wispy tendrils at top of clouds
          let wispyContrib = wispyNoise * smoothstep(0.4, 0.85, perturbedHeight) * 0.2;
          density = max(density, wispyContrib * cov);

          return vec2f(density, detailNoise);
      }

      fn getCloudDensity(pos: vec3f) -> f32 {
          // Legacy function for compatibility
          let wind = atmosphere.cloud_wind_direction * atmosphere.cloud_speed * scene.time * 0.1;
          let scale = 0.00002;
          let baseUvw = (pos + wind) * scale;
          let noise = sampleCloudNoiseMultiScale(baseUvw, 0.0);
          return noise.r;
      }

      fn intersectSphere(ro: vec3f, rd: vec3f, r: f32) -> vec2f {
          let b = dot(ro, rd);
          let c = dot(ro, ro) - r * r;
          let h = b * b - c;
          if (h < 0.0) { return vec2f(-1.0); }
          let h_sqrt = sqrt(h);
          return vec2f(-b - h_sqrt, -b + h_sqrt);
      }

      // Height gradient function: 0 at bottom/top, 1 in middle
      fn getCloudHeightGradient(heightFraction: f32) -> f32 {
          // Note: smoothstep requires low < high per WGSL spec
          return smoothstep(0.0, 0.2, heightFraction) * (1.0 - smoothstep(0.8, 1.0, heightFraction));
      }
      
      // Interleaved Gradient Noise for dithering
      fn ign(pixel: vec2f) -> f32 {
          return fract(52.9829189 * fract(0.06711056 * pixel.x + 0.00583715 * pixel.y));
      }

      // ============================================
      // LOW QUALITY: 2D Plane Clouds (very fast)
      // Multi-sample at plane intersection with parallax
      // ============================================
      fn renderCloudsLow(rayOrigin: vec3f, rayDir: vec3f, skyColor: vec3f, sunDir: vec3f, lightColor: vec3f, fragCoord: vec2f) -> vec3f {
          if (atmosphere.cloud_enabled == 0.0) { return skyColor; }

          // Skip if looking down
          if (rayDir.y < 0.01) { return skyColor; }

          let earthRadius = atmosphere.bottom_radius;
          let cloudPlaneHeight = earthRadius + atmosphere.cloud_altitude + atmosphere.cloud_height * 0.5;

          // Simple plane intersection (camera relative to earth center)
          let camHeight = earthRadius + rayOrigin.y;
          let t = (cloudPlaneHeight - camHeight) / rayDir.y;

          if (t < 0.0 || t > 500000.0) { return skyColor; }

          // World position at intersection
          let hitPos = vec3f(rayOrigin.x, camHeight, rayOrigin.z) + rayDir * t;

          // Sample noise at hit point with wind animation
          let wind = atmosphere.cloud_wind_direction * atmosphere.cloud_speed * scene.time * 0.1;
          let scale = 0.00002;
          let baseUvw = (hitPos + wind) * scale;

          // Add parallax offset based on view angle for fake depth
          let parallax = (rayDir.xz / max(rayDir.y, 0.1)) * atmosphere.cloud_height * 0.0001;
          let uvwParallax = baseUvw + vec3f(parallax.x, 0.0, parallax.y);

          // Sample with multi-scale blending to hide tiling
          let noise = sampleCloudNoiseMultiScale(uvwParallax, 0.0);
          var density = noise.r * noise.a; // Base shape * coverage variation
          let detail = noise.g;

          // Coverage threshold with smooth falloff
          let cov = atmosphere.cloud_coverage;
          density = smoothstep(1.0 - cov, 1.0 - cov * 0.4, density);

          // Add slight detail erosion
          density = max(0.0, density - detail * 0.15);

          if (density < 0.01) { return skyColor; }

          // Improved lighting with smooth color transitions
          let sunElevation = sunDir.y;
          let sunFade = smoothstep(-0.1, 0.15, sunElevation);

          // Smooth sun color gradient
          var sunTint = vec3f(1.0);
          {
              let redOrangeT = smoothstep(-0.05, 0.05, sunElevation);
              let orangeGoldenT = smoothstep(0.05, 0.2, sunElevation);
              let goldenWhiteT = smoothstep(0.2, 0.5, sunElevation);

              sunTint = mix(vec3f(1.0, 0.15, 0.03), vec3f(1.0, 0.5, 0.15), redOrangeT);
              sunTint = mix(sunTint, vec3f(1.0, 0.9, 0.7), orangeGoldenT);
              sunTint = mix(sunTint, vec3f(1.0, 1.0, 1.0), goldenWhiteT);
          }

          // Simple phase approximation for silver lining
          let cosThetaSun = dot(rayDir, sunDir);
          let silverLining = pow(max(0.0, cosThetaSun), 3.0) * detail * sunFade * 0.3;

          // Ambient based on time of day
          var ambient = vec3f(0.3, 0.4, 0.5);
          {
              let nightSunsetT = smoothstep(-0.1, 0.05, sunElevation);
              let sunsetDayT = smoothstep(0.05, 0.3, sunElevation);
              ambient = mix(vec3f(0.02, 0.03, 0.06), vec3f(0.2, 0.1, 0.12), nightSunsetT);
              ambient = mix(ambient, vec3f(0.3, 0.4, 0.5), sunsetDayT);
          }

          let cloudLit = lightColor * sunTint * sunFade * 0.9 + ambient;
          var cloudColor = cloudLit * atmosphere.cloud_color;

          // Add silver lining
          cloudColor += lightColor * sunTint * silverLining;

          // Soft edges with horizon fade
          let horizonFade = smoothstep(0.0, 0.15, rayDir.y);
          let alpha = density * horizonFade * 0.9;

          // Enhanced dithering
          let frameOffset = fract(scene.time * 5.17);
          let ditherR = (ign(fragCoord + vec2f(frameOffset * 50.0, 0.0)) - 0.5) * 0.025;
          let ditherG = (ign(fragCoord + vec2f(37.0 + frameOffset * 30.0, 17.0)) - 0.5) * 0.025;
          let ditherB = (ign(fragCoord + vec2f(59.0, 83.0 + frameOffset * 40.0)) - 0.5) * 0.025;
          cloudColor += vec3f(ditherR, ditherG, ditherB);

          return mix(skyColor, cloudColor, alpha);
      }

      // ============================================
      // VOLUMETRIC CLOUDS (medium/high quality)
      // ============================================
      fn renderClouds(rayOrigin: vec3f, rayDir: vec3f, skyColor: vec3f, sunDir: vec3f, lightColor: vec3f, fragCoord: vec2f) -> vec3f {
          if (atmosphere.cloud_enabled == 0.0) { return skyColor; }

          let earthRadius = atmosphere.bottom_radius;
          let cloudBottom = earthRadius + atmosphere.cloud_altitude;
          let cloudTop = cloudBottom + atmosphere.cloud_height;

          // Camera relative to Earth Center
          let camPosFromCenter = vec3f(0.0, earthRadius + scene.cameraPosition.y, 0.0);

          // Intersect Cloud Layer
          let tBottom = intersectSphere(camPosFromCenter, rayDir, cloudBottom);
          let tTop = intersectSphere(camPosFromCenter, rayDir, cloudTop);

          var tStart = 0.0;
          var tEnd = 0.0;

          // Assuming camera is below clouds (Ground)
          if (length(camPosFromCenter) < cloudBottom) {
               if (tBottom.y < 0.0) { return skyColor; } // Looking down/horizon miss
               tStart = tBottom.y;
               tEnd = tTop.y;
          } else if (length(camPosFromCenter) > cloudTop) {
               // Space/Above
               if (tTop.x < 0.0) { return skyColor; }
               tStart = tTop.x;
               tEnd = tBottom.x;
          } else {
               // Inside
               tStart = 0.0;
               tEnd = tTop.y; // Simplified
          }

          if (tEnd <= tStart) { return skyColor; }

          // Horizon Culling / Fade
          if (tStart > 400000.0) { return skyColor; }

          let thickness = tEnd - tStart;

          // Step count based on quality setting
          // High (2): 32 base steps with distance adaptation
          // Medium (1): 12 fixed steps
          var numSteps = 12u;
          if (atmosphere.cloud_quality == 2u) {
              // High quality with distance-based reduction
              numSteps = 32u;
              if (tStart > 120000.0) {
                  numSteps = 16u;
              } else if (tStart > 60000.0) {
                  numSteps = 24u;
              }
          }

          let stepSize = thickness / f32(numSteps);

          // Enhanced dithering with temporal offset to reduce banding
          // Use interleaved gradient noise with frame-based offset
          let frameOffset = fract(scene.time * 7.23); // Temporal variation
          let dither = ign(fragCoord + vec2f(frameOffset * 100.0, frameOffset * 57.0));
          let tOffset = stepSize * dither;

          var totalDensity = 0.0;
          var cloudScatter = vec3f(0.0);
          var transmittance = 1.0;

          // Phase functions (Henyey-Greenstein)
          // Use two-lobe phase function for more realistic scattering
          let gForward = 0.8;  // Strong forward scattering
          let gBack = -0.3;    // Weak back scattering for silver lining

          // --- Lighting Setup ---

          // 1. Sun
          let sunElevation = sunDir.y;
          // Smooth fade with extended range for better sunset/sunrise transitions
          let sunFade = smoothstep(-0.15, 0.15, sunElevation);

          // Continuous sun color gradient using smooth interpolation
          // This eliminates hard thresholds that cause banding
          var sunTint = vec3f(1.0);
          {
              // Elevation-based color: Deep Red -> Orange -> Golden -> White
              let redOrangeT = smoothstep(-0.05, 0.05, sunElevation);
              let orangeGoldenT = smoothstep(0.05, 0.2, sunElevation);
              let goldenWhiteT = smoothstep(0.2, 0.5, sunElevation);

              let sunColorRed = vec3f(1.0, 0.1, 0.02);
              let sunColorOrange = vec3f(1.0, 0.45, 0.12);
              let sunColorGolden = vec3f(1.0, 0.85, 0.6);
              let sunColorWhite = vec3f(1.0, 0.98, 0.95);

              // Smooth multi-stage blend
              sunTint = mix(sunColorRed, sunColorOrange, redOrangeT);
              sunTint = mix(sunTint, sunColorGolden, orangeGoldenT);
              sunTint = mix(sunTint, sunColorWhite, goldenWhiteT);
          }

          // Sunset intensity boost (more gradual)
          // Note: smoothstep requires low < high per WGSL spec
          let sunsetBoost = 1.0 + 1.5 * (1.0 - smoothstep(0.0, 0.3, abs(sunElevation)));
          let sunLightColor = lightColor * sunTint * sunFade * sunsetBoost;

          // Phase function calculation
          let cosThetaSun = dot(rayDir, sunDir);
          // Two-lobe phase: forward + back scattering (silver lining)
          let phaseForward = (1.0 - gForward*gForward) / pow(1.0 + gForward*gForward - 2.0*gForward*cosThetaSun, 1.5);
          let phaseBack = (1.0 - gBack*gBack) / pow(1.0 + gBack*gBack - 2.0*gBack*cosThetaSun, 1.5);
          let phaseSun = (phaseForward * 0.7 + phaseBack * 0.3) / (4.0 * 3.14159);

          // Silver lining factor (bright edges when backlit)
          let silverLining = pow(max(0.0, cosThetaSun), 4.0) * 2.0;

          // 2. Moon
          let moonDir = normalize(atmosphere.moon_direction.xyz);
          let moonElevation = moonDir.y;
          let moonFade = smoothstep(-0.05, 0.15, moonElevation);
          let moonTint = vec3f(0.65, 0.75, 1.0);
          let moonLightColor = atmosphere.moon_color * moonTint * 2.5 * moonFade;
          let cosThetaMoon = dot(rayDir, moonDir);
          let phaseMoon = (1.0 - gForward*gForward) / pow(1.0 + gForward*gForward - 2.0*gForward*cosThetaMoon, 1.5) / (4.0 * 3.14159);

          // 3. Ambient (smooth gradient based on sun elevation)
          var ambientColor = vec3f(0.0);
          {
              let ambientNight = vec3f(0.015, 0.02, 0.04);
              let ambientSunset = vec3f(0.25, 0.12, 0.15);
              let ambientDay = vec3f(0.25, 0.35, 0.55);

              let nightSunsetT = smoothstep(-0.15, 0.05, sunElevation);
              let sunsetDayT = smoothstep(0.05, 0.35, sunElevation);

              ambientColor = mix(ambientNight, ambientSunset, nightSunsetT);
              ambientColor = mix(ambientColor, ambientDay, sunsetDayT);
          }

          // Horizon Fade Factor (smoother)
          let horizonFade = smoothstep(0.0, 0.15, rayDir.y);

          // LOD for distant clouds (reduces aliasing)
          let distanceLOD = smoothstep(0.0, 200000.0, tStart) * 2.0;

          // Screen-space jitter to break horizontal banding (computed once per pixel)
          let screenJitter = getScreenJitter(fragCoord, scene.time);
          let jitterOffset = (screenJitter - 0.5) * 500.0; // Small world-space offset

          // Empty space skipping state
          var emptyStepCount = 0u;
          var currentStep = 0.0;

          for (var i = 0u; i < numSteps; i++) {
              // Adaptive step size: larger steps when in empty space
              var adaptiveStep = stepSize;
              if (emptyStepCount > 2u) {
                  adaptiveStep = stepSize * 2.0; // Double step in empty regions
              }

              let t = tStart + tOffset + currentStep;
              currentStep += adaptiveStep;

              if (t > tEnd) { break; }

              let pos = camPosFromCenter + rayDir * t;
              // Add jitter to break horizontal banding
              let jitteredPos = pos + vec3f(jitterOffset * 0.3, jitterOffset, jitterOffset * 0.3);
              let height = length(pos) - cloudBottom;
              let heightFraction = clamp(height / atmosphere.cloud_height, 0.0, 1.0);

              // Soft bounds falloff (smoothstep requires low < high per WGSL spec)
              let boundsFalloff = smoothstep(-0.05, 0.05, heightFraction) *
                                  (1.0 - smoothstep(0.95, 1.05, heightFraction));
              if (boundsFalloff < 0.001) {
                  emptyStepCount += 1u;
                  continue;
              }

              // Sample cloud density using enhanced multi-channel noise
              let noiseSample = sampleCloudNoise(jitteredPos, heightFraction, distanceLOD);
              var d = noiseSample.x * horizonFade * boundsFalloff;

              // Track empty space for adaptive stepping
              if (d < 0.01) {
                  emptyStepCount += 1u;
              } else {
                  emptyStepCount = 0u;
              }

              if (d > 0.005) {
                  let stepDensity = d * atmosphere.cloud_density;
                  let extinction = stepDensity * stepSize * 0.0008;
                  let stepTransmittance = exp(-extinction);

                  // Beer-Powder approximation for realistic light transport
                  // Beer's law (absorption) + Powder effect (multiple scattering)
                  let beerLaw = exp(-extinction * 2.0);
                  let powder = 1.0 - exp(-extinction * 4.0);
                  let beerPowder = beerLaw * powder * 2.0;

                  // Self-shadowing based on accumulated density
                  let shadow = exp(-totalDensity * 0.3);

                  // Height-based ambient variation (brighter at top)
                  let heightAmbient = 0.4 + 0.6 * heightFraction;

                  // Silver lining at cloud edges (based on detail noise = edges)
                  let edgeFactor = noiseSample.y;
                  let silverContrib = silverLining * edgeFactor * sunFade * 0.5;

                  // Compute scattering
                  let sunScatter = sunLightColor * phaseSun * shadow * beerPowder;
                  let moonScatter = moonLightColor * phaseMoon * shadow * beerPowder * 0.5;
                  let ambientScatter = ambientColor * heightAmbient * (0.6 + 0.4 * shadow);

                  // Add silver lining contribution
                  let silverColor = sunLightColor * silverContrib * transmittance;

                  let scattering = (sunScatter + moonScatter + ambientScatter + silverColor) * atmosphere.cloud_color;

                  // Energy-conserving integration
                  let absorbed = transmittance * (1.0 - stepTransmittance);
                  cloudScatter += scattering * absorbed;

                  transmittance *= stepTransmittance;
                  totalDensity += stepDensity * stepSize;

                  // Early termination
                  if (transmittance < 0.01) { break; }
              }
          }

          // Atmospheric perspective (distant clouds fade to sky)
          let atmosphericFade = 1.0 - exp(-tStart * 0.000003);
          transmittance = max(transmittance, atmosphericFade * 0.5);

          var finalCloudColor = mix(cloudScatter, skyColor, transmittance);

          // Enhanced dithering to combat banding
          // Use different offset for RGB to break up color banding
          let ditherR = (ign(fragCoord) - 0.5) * 0.025;
          let ditherG = (ign(fragCoord + vec2f(37.0, 17.0)) - 0.5) * 0.025;
          let ditherB = (ign(fragCoord + vec2f(59.0, 83.0)) - 0.5) * 0.025;
          let cloudAlpha = 1.0 - transmittance;
          finalCloudColor += vec3f(ditherR, ditherG, ditherB) * cloudAlpha;

          return finalCloudColor;
      }

      // Bilinear sample from SkyView LUT (textureLoad doesn't filter, causing banding)
      fn sampleSkyViewBilinear(uv: vec2f) -> vec3f {
          let texSize = vec2f(192.0, 108.0);
          let texCoord = uv * texSize - 0.5;
          let baseCoord = floor(texCoord);
          let f = texCoord - baseCoord;

          let c00 = textureLoad(skyViewLUT, vec2i(clamp(baseCoord, vec2f(0.0), texSize - 1.0)), 0).rgb;
          let c10 = textureLoad(skyViewLUT, vec2i(clamp(baseCoord + vec2f(1.0, 0.0), vec2f(0.0), texSize - 1.0)), 0).rgb;
          let c01 = textureLoad(skyViewLUT, vec2i(clamp(baseCoord + vec2f(0.0, 1.0), vec2f(0.0), texSize - 1.0)), 0).rgb;
          let c11 = textureLoad(skyViewLUT, vec2i(clamp(baseCoord + vec2f(1.0, 1.0), vec2f(0.0), texSize - 1.0)), 0).rgb;

          let c0 = mix(c00, c10, f.x);
          let c1 = mix(c01, c11, f.x);
          return mix(c0, c1, f.y);
      }

      @fragment
      fn fs_main(@location(0) uv : vec3f, @builtin(position) fragCoord : vec4f) -> @location(0) vec4f {
          let dir = normalize(uv);

          let cameraAltitude = atmosphere.bottom_radius + max(scene.cameraPosition.y * 0.001, 0.001);
          let skyUV = directionToSkyViewUV(dir, cameraAltitude);

          // Use bilinear filtering to reduce banding in sky gradients
          var skyColor = sampleSkyViewBilinear(skyUV);

          let sunDir = normalize(atmosphere.sun_direction.xyz);

          // Add horizon glow for golden hour/sunset
          let horizonGlow = computeHorizonGlow(dir, sunDir, cameraAltitude);
          skyColor += horizonGlow;

          // Add ground ambient contribution (bounce light from ground to sky)
          let groundAmbient = computeGroundAmbient(dir, sunDir, atmosphere.ground_albedo);
          skyColor += groundAmbient;

          // Enhanced dithering for sky gradients with per-channel offset
          // Use temporal variation to further break up banding
          let frameOffset = fract(scene.time * 3.71);
          let skyDitherR = (ign(fragCoord.xy + vec2f(frameOffset * 50.0, 0.0)) - 0.5) * 0.02;
          let skyDitherG = (ign(fragCoord.xy + vec2f(23.0 + frameOffset * 30.0, 41.0)) - 0.5) * 0.02;
          let skyDitherB = (ign(fragCoord.xy + vec2f(67.0, 89.0 + frameOffset * 40.0)) - 0.5) * 0.02;
          skyColor += vec3f(skyDitherR, skyDitherG, skyDitherB);

          let sunZenithCos = sunDir.y;
          let transmittanceToSun = getTransmittanceToSun(cameraAltitude, sunZenithCos);
          let sunDisk = renderSunDisk(dir, sunDir, transmittanceToSun);

          let moonDir = normalize(atmosphere.moon_direction.xyz);
          let moonZenithCos = moonDir.y;
          let transmittanceToMoon = getTransmittanceToSun(cameraAltitude, moonZenithCos);
          let moonDisk = renderMoonDisk(dir, moonDir, transmittanceToMoon, atmosphere.moon_phase);

          // Render order: Sky -> Stars -> Sun/Moon -> Clouds -> Fog
          var finalColor = skyColor;

          // Add Stars (only at night when sky is dark AND looking UP)
          // Don't render stars below the horizon (dir.y < 0)
          if (length(skyColor) < 0.1 && dir.y > 0.0) {
              let starIntensity = 1.0 - smoothstep(-0.1, 0.3, sunDir.y);
              if (starIntensity > 0.0) {
                  let starDir = dir * 1000.0;
                  let starHash = fract(sin(dot(floor(starDir), vec3f(12.9898, 78.233, 45.164))) * 43758.5453);
                  if (starHash > 0.997) {
                      let starBrightness = (starHash - 0.997) / 0.003;
                      let twinkle = 0.7 + 0.3 * sin(scene.time * 3.0 + starHash * 100.0);
                      finalColor += vec3f(starBrightness * starIntensity * twinkle * 2.0);
                  }
              }
          }

          // Add Celestial Bodies
          finalColor += sunDisk + moonDisk;

          // Clouds (rendered once, on top of sky+stars+bodies)
          // Quality: 0=low (2D plane), 1=medium (12 steps), 2=high (32 steps)
          if (atmosphere.cloud_quality == 0u) {
              finalColor = renderCloudsLow(scene.cameraPosition, dir, finalColor, sunDir, atmosphere.solar_irradiance.xyz, fragCoord.xy);
          } else {
              finalColor = renderClouds(scene.cameraPosition, dir, finalColor, sunDir, atmosphere.solar_irradiance.xyz, fragCoord.xy);
          }

          // Fog on skybox: sample the ACTUAL horizon color from the sky
          // This ensures the sky's fog matches what objects fade toward
          let fog2Enabled = scene.fog2Params.w;
          if (fog2Enabled >= 0.5) {
              let fog2Type = scene.fog2Params.z; // 0 = LINEAR, 1 = EXP2

              let upFactor = abs(dir.y);

              var fogFactor = 0.0;
              if (fog2Type < 0.5) {
                  // LINEAR fog
                  let fogNear = scene.fog2Params.x;
                  let fogFar = scene.fog2Params.y;
                  let skyDistance = mix(fogFar, fogNear, upFactor);
                  fogFactor = smoothstep(fogNear, fogFar, skyDistance);
              } else {
                  // EXP2 fog with height falloff
                  let fogDensity = scene.fog2Density;
                  let horizonDistance = 500.0;

                  if (dir.y <= 0.0) {
                      // Looking DOWN - full fog
                      let skyDistance = horizonDistance;
                      fogFactor = 1.0 - exp(-fogDensity * fogDensity * skyDistance * skyDistance);
                  } else {
                      // Looking UP - apply height falloff
                      let skyDistance = mix(horizonDistance, 10.0, dir.y);
                      let baseFogFactor = 1.0 - exp(-fogDensity * fogDensity * skyDistance * skyDistance);
                      let heightFade = 1.0 - smoothstep(0.0, max(scene.fog2SkyFalloff, 0.001), dir.y);
                      fogFactor = baseFogFactor * heightFade;
                  }
              }

              fogFactor = clamp(fogFactor, 0.0, 1.0);

              // Use the SAME fog color as objects (uniform)
              // This guarantees sky horizon matches what objects fade toward
              // Just like Three.js where fog.color === sky.bottomColor
              finalColor = mix(finalColor, scene.fog2Color, fogFactor);
          }

          return vec4f(finalColor, 1.0);
      }
      `;
    const pipelineLayout = device.createPipelineLayout({
      bindGroupLayouts: [renderBindGroupLayout, atmosphereBindGroupLayout]
    });
    this.atmospherePipeline = device.createRenderPipeline({
      label: "Atmosphere Skybox Pipeline",
      layout: pipelineLayout,
      vertex: {
        module: createShaderModuleSafe(device, { code }),
        entryPoint: "vs_main"
      },
      fragment: {
        module: createShaderModuleSafe(device, { code }),
        entryPoint: "fs_main",
        targets: [{ format }]
      },
      primitive: {
        topology: "triangle-list",
        cullMode: "none"
      },
      depthStencil: {
        depthWriteEnabled: false,
        depthCompare: "less-equal",
        format: this.gBuffer?.depthTexture?.format || "depth24plus"
      }
    });
  }
}

// ../../src/core/renderer/SSAOPass.ts
class SSAOPass {
  gBuffer;
  pipeline = null;
  bindGroup = null;
  ssaoKernelBuffer = null;
  ssaoParamsBuffer = null;
  noiseTexture = null;
  sampler = null;
  noiseSampler = null;
  kernelSize = 32;
  kernel;
  enabled = true;
  constructor(gBuffer) {
    this.gBuffer = gBuffer;
    this.kernel = this.generateKernel();
  }
  init(device, context, presentationFormat) {
    this.generateNoiseTexture(device);
    this.createKernelBuffer(device);
    this.ssaoParamsBuffer = device.createBuffer({
      label: "SSAO Params Buffer",
      size: 16,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.sampler = device.createSampler({
      magFilter: "linear",
      minFilter: "linear",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    });
    this.noiseSampler = device.createSampler({
      magFilter: "nearest",
      minFilter: "nearest",
      addressModeU: "repeat",
      addressModeV: "repeat"
    });
  }
  resize(width, height) {
    this.bindGroup = null;
  }
  execute(commandEncoder, context, globalResources) {
    const device = this.gBuffer.device;
    if (!device || !this.gBuffer.ssaoTexture)
      return;
    if (!this.enabled) {
      const renderPassDescriptor2 = {
        label: "SSAO Clear Pass",
        colorAttachments: [{
          view: this.gBuffer.ssaoTexture.createView(),
          clearValue: { r: 1, g: 1, b: 1, a: 1 },
          loadOp: "clear",
          storeOp: "store"
        }]
      };
      const pass = commandEncoder.beginRenderPass(renderPassDescriptor2);
      pass.end();
      return;
    }
    if (this.ssaoParamsBuffer) {
      const params = new Float32Array([
        context.scene.postProcessing.ssao.radius,
        context.scene.postProcessing.ssao.bias
      ]);
      device.queue.writeBuffer(this.ssaoParamsBuffer, 0, params);
    }
    if (!this.pipeline) {
      this.createPipeline(device, globalResources);
    }
    if (!this.bindGroup) {
      this.createBindGroup(device, globalResources);
    }
    const renderPassDescriptor = {
      label: "SSAO Pass",
      colorAttachments: [{
        view: this.gBuffer.ssaoTexture.createView(),
        clearValue: { r: 1, g: 1, b: 1, a: 1 },
        loadOp: "clear",
        storeOp: "store"
      }]
    };
    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
    passEncoder.setPipeline(this.pipeline);
    passEncoder.setBindGroup(0, globalResources.renderBindGroup);
    passEncoder.setBindGroup(1, this.bindGroup);
    passEncoder.draw(3);
    passEncoder.end();
  }
  generateKernel() {
    const kernel = new Float32Array(this.kernelSize * 4);
    for (let i = 0;i < this.kernelSize; i++) {
      let sample = new Vector3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random());
      sample = sample.normalize();
      let scale = i / this.kernelSize;
      scale = 0.1 + 0.9 * (scale * scale);
      sample = sample.multiply(scale);
      kernel[i * 4] = sample.x;
      kernel[i * 4 + 1] = sample.y;
      kernel[i * 4 + 2] = sample.z;
      kernel[i * 4 + 3] = 0;
    }
    return kernel;
  }
  createKernelBuffer(device) {
    this.ssaoKernelBuffer = device.createBuffer({
      label: "SSAO Kernel Buffer",
      size: this.kernel.byteLength,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
      mappedAtCreation: true
    });
    new Float32Array(this.ssaoKernelBuffer.getMappedRange()).set(this.kernel);
    this.ssaoKernelBuffer.unmap();
  }
  generateNoiseTexture(device) {
    const size = 4;
    const data = new Uint8Array(size * size * 4);
    for (let i = 0;i < size * size; i++) {
      data[i * 4] = Math.floor((Math.random() * 2 - 1) * 0.5 + 0.5 * 255);
      data[i * 4 + 1] = Math.floor((Math.random() * 2 - 1) * 0.5 + 0.5 * 255);
      data[i * 4 + 2] = 0;
      data[i * 4 + 3] = 0;
    }
    this.noiseTexture = device.createTexture({
      label: "SSAO Noise Texture",
      size: [size, size],
      format: "rgba8unorm",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
    });
    device.queue.writeTexture({ texture: this.noiseTexture }, data, { bytesPerRow: size * 4 }, { width: size, height: size });
  }
  createPipeline(device, globalResources) {
    const code = `
        struct SceneUniforms {
            viewMatrix : mat4x4<f32>,
            projectionMatrix : mat4x4<f32>,
            lightViewProj : mat4x4<f32>,
            prevViewProj : mat4x4<f32>,
            inverseProjectionMatrix : mat4x4<f32>,
            cameraPosition : vec3f,
            time : f32,
            _pad : vec3f,
        }

        struct SSAOUniforms {
             kernel : array<vec4f, ${this.kernelSize}>,
        }

        struct SSAOParams {
            radius: f32,
            bias: f32,
        }

        @group(0) @binding(0) var<uniform> scene : SceneUniforms;

        @group(1) @binding(0) var positionTex : texture_2d<f32>;
        @group(1) @binding(1) var normalTex : texture_2d<f32>;
        @group(1) @binding(2) var noiseTex : texture_2d<f32>;
        @group(1) @binding(3) var<uniform> ssaoConfig : SSAOUniforms;
        @group(1) @binding(4) var samp : sampler;
        @group(1) @binding(5) var noiseSamp : sampler;
        @group(1) @binding(6) var<uniform> params : SSAOParams;

        @vertex
        fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> @builtin(position) vec4f {
            let pos = array(
              vec2f(-1.0, -1.0),
              vec2f( 3.0, -1.0),
              vec2f(-1.0,  3.0)
            );
            return vec4f(pos[vertexIndex], 0.0, 1.0);
        }

        @fragment
        fn fs_main(@builtin(position) fragCoord : vec4f) -> @location(0) f32 {
            let uv = fragCoord.xy / vec2f(textureDimensions(positionTex));
            let noiseScale = vec2f(textureDimensions(positionTex)) / 4.0;
            
            // Get World Space Position and Normal
            let worldPos = textureSample(positionTex, samp, uv).xyz;
            let worldNormal = normalize(textureSample(normalTex, samp, uv).xyz * 2.0 - 1.0);
            
            // Convert to View Space
            let viewPos = (scene.viewMatrix * vec4f(worldPos, 1.0)).xyz;
            let viewNormal = (scene.viewMatrix * vec4f(worldNormal, 0.0)).xyz;

            let randomVec = textureSample(noiseTex, noiseSamp, uv * noiseScale).xyz * 2.0 - 1.0;
            let tangent = normalize(randomVec - viewNormal * dot(randomVec, viewNormal));
            let bitangent = cross(viewNormal, tangent);
            let TBN = mat3x3f(tangent, bitangent, viewNormal);

            var occlusion : f32 = 0.0;
            
            for (var i = 0u; i < ${this.kernelSize}u; i++) {
                // Kernel samples are in Tangent Space
                let sampleDir = TBN * ssaoConfig.kernel[i].xyz;
                let samplePos = viewPos + sampleDir * params.radius; // View Space Sample Position

                // Project sample position to Clip Space -> UV
                let offset = scene.projectionMatrix * vec4f(samplePos, 1.0);
                let offsetPos = offset.xyz / offset.w; // NDC
                let offsetUV = vec2f(offsetPos.x, -offsetPos.y) * 0.5 + 0.5;

                // Sample geometry at the kernel sample's screen location
                let geomWorldPos = textureSample(positionTex, samp, offsetUV).xyz;
                let geomViewPos = (scene.viewMatrix * vec4f(geomWorldPos, 1.0)).xyz;
                
                // Depth Check
                let rangeCheck = smoothstep(0.0, 1.0, params.radius / abs(viewPos.z - geomViewPos.z));
                
                // Bias check:
                if (geomViewPos.z >= samplePos.z + params.bias) {
                    occlusion += 1.0 * rangeCheck;
                }
            }
            
            occlusion = 1.0 - (occlusion / f32(${this.kernelSize}));
            return occlusion;
        }
      `;
    this.pipeline = device.createRenderPipeline({
      label: "SSAO Pipeline",
      layout: device.createPipelineLayout({
        bindGroupLayouts: [
          globalResources.renderBindGroupLayout,
          device.createBindGroupLayout({
            entries: [
              { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: {} },
              { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: {} },
              { binding: 2, visibility: GPUShaderStage.FRAGMENT, texture: {} },
              { binding: 3, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
              { binding: 4, visibility: GPUShaderStage.FRAGMENT, sampler: {} },
              { binding: 5, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "non-filtering" } },
              { binding: 6, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } }
            ]
          })
        ]
      }),
      vertex: {
        module: createShaderModuleSafe(device, { code }),
        entryPoint: "vs_main"
      },
      fragment: {
        module: createShaderModuleSafe(device, { code }),
        entryPoint: "fs_main",
        targets: [{ format: "r8unorm" }]
      },
      primitive: { topology: "triangle-list" }
    });
  }
  createBindGroup(device, globalResources) {
    if (!this.pipeline)
      return;
    this.bindGroup = device.createBindGroup({
      label: "SSAO Bind Group",
      layout: this.pipeline.getBindGroupLayout(1),
      entries: [
        { binding: 0, resource: this.gBuffer.positionTexture.createView() },
        { binding: 1, resource: this.gBuffer.normalTexture.createView() },
        { binding: 2, resource: this.noiseTexture.createView() },
        { binding: 3, resource: { buffer: this.ssaoKernelBuffer } },
        { binding: 4, resource: this.sampler },
        { binding: 5, resource: this.noiseSampler },
        { binding: 6, resource: { buffer: this.ssaoParamsBuffer } }
      ]
    });
  }
}

// ../../src/core/renderer/denoise/SSGIDenoisePass.ts
class SSGIDenoisePass {
  device = null;
  denoisePipeline = null;
  denoiseLayout = null;
  sampler = null;
  linearSampler = null;
  gBuffer;
  constructor(gBuffer) {
    this.gBuffer = gBuffer;
  }
  init(device, context, presentationFormat) {
    this.device = device;
    this.sampler = device.createSampler({
      minFilter: "nearest",
      magFilter: "nearest",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    });
    this.linearSampler = device.createSampler({
      minFilter: "linear",
      magFilter: "linear",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    });
    this.createLayouts(device);
    this.createPipelines(device);
  }
  resize(width, height) {}
  execute(commandEncoder, context, globalResources) {
    if (!this.device || !this.denoisePipeline || !this.denoiseLayout)
      return;
    if (!this.gBuffer.ssgiRawTexture || !this.gBuffer.ssgiTexture)
      return;
    const bindGroup = this.device.createBindGroup({
      layout: this.denoiseLayout,
      entries: [
        { binding: 0, resource: this.gBuffer.ssgiRawTexture.createView() },
        { binding: 1, resource: this.linearSampler },
        { binding: 2, resource: this.gBuffer.normalTexture.createView() },
        { binding: 3, resource: this.gBuffer.depthTexture.createView({ aspect: "depth-only" }) },
        { binding: 4, resource: { buffer: globalResources.sceneUniforms.buffer } },
        { binding: 5, resource: this.sampler }
      ]
    });
    const pass = commandEncoder.beginRenderPass({
      label: "SSGI Spatial Denoise",
      colorAttachments: [{
        view: this.gBuffer.ssgiTexture.createView(),
        loadOp: "clear",
        storeOp: "store",
        clearValue: { r: 0, g: 0, b: 0, a: 0 }
      }]
    });
    pass.setPipeline(this.denoisePipeline);
    pass.setBindGroup(0, bindGroup);
    pass.draw(3);
    pass.end();
  }
  createLayouts(device) {
    this.denoiseLayout = device.createBindGroupLayout({
      label: "SSGI Denoise Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, sampler: {} },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 3, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "depth" } },
        { binding: 4, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
        { binding: 5, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "non-filtering" } }
      ]
    });
  }
  createPipelines(device) {
    const fullVS = `
            struct VertexOutput {
                @builtin(position) position : vec4f,
                @location(0) uv : vec2f,
            }
            @vertex
            fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                var output : VertexOutput;
                let pos = array(vec2f(-1.0, -1.0), vec2f(3.0, -1.0), vec2f(-1.0, 3.0));
                let p = pos[vertexIndex];
                output.position = vec4f(p, 0.0, 1.0);
                output.uv = p * 0.5 + 0.5;
                output.uv.y = 1.0 - output.uv.y;
                return output;
            }
        `;
    const denoiseFS = `
            @group(0) @binding(0) var srcTex : texture_2d<f32>;
            @group(0) @binding(1) var samp : sampler;
            @group(0) @binding(2) var normalTex : texture_2d<f32>;
            @group(0) @binding(3) var depthTex : texture_depth_2d;
            
            struct SceneUniforms {
                viewMatrix : mat4x4<f32>,
                projectionMatrix : mat4x4<f32>,
                lightViewProj : mat4x4<f32>,
                prevViewProj : mat4x4<f32>,
                inverseProjectionMatrix : mat4x4<f32>,
            }
            @group(0) @binding(4) var<uniform> scene : SceneUniforms;
            @group(0) @binding(5) var depthSamp : sampler;

            fn linearizeDepth(depth: f32, uv: vec2f) -> f32 {
                let clipXY = vec2f(uv.x * 2.0 - 1.0, (1.0 - uv.y) * 2.0 - 1.0);
                let clipPos = vec4f(clipXY, depth, 1.0);
                let viewPos = scene.inverseProjectionMatrix * clipPos;
                return abs(viewPos.z / viewPos.w);
            }

            @fragment
            fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {
                let centerDepthNDC = textureSampleLevel(depthTex, depthSamp, uv, 0);
                if (centerDepthNDC >= 1.0) { return vec4f(0.0); } 
                
                let centerDepth = linearizeDepth(centerDepthNDC, uv);
                let centerNormal = normalize(textureSampleLevel(normalTex, depthSamp, uv, 0.0).xyz * 2.0 - 1.0);
                
                let texSize = vec2f(textureDimensions(srcTex));
                let onePixel = 1.0 / texSize;
                
                var totalColor = vec3f(0.0);
                var totalWeight = 0.0;
                
                // 5x5 Kernel with Stride 2 = Effective Area 9x9 pixels
                let radius = 2; 
                let stride = 2.0;

                for (var y = -radius; y <= radius; y++) {
                    for (var x = -radius; x <= radius; x++) {
                        let offset = vec2f(f32(x), f32(y)) * onePixel * stride;
                        let sampleUV = uv + offset;
                        
                        let rawSampleColor = textureSampleLevel(srcTex, samp, sampleUV, 0.0).rgb;
                        let sampleColor = clamp(rawSampleColor, vec3f(0.0), vec3f(100.0));

                        let sampleDepthNDC = textureSampleLevel(depthTex, depthSamp, sampleUV, 0);
                        let sampleDepth = linearizeDepth(sampleDepthNDC, sampleUV);
                        let sampleNormal = normalize(textureSampleLevel(normalTex, depthSamp, sampleUV, 0.0).xyz * 2.0 - 1.0);
                        
                        // 1. Spatial Weight
                        let dist = length(vec2f(f32(x), f32(y)));
                        let wSpatial = exp(-dist * dist / (2.0 * f32(radius) * f32(radius))); 
                        
                        // 2. Depth Weight (Relative)
                        // Relaxed tolerance to fill holes in IGN pattern
                        // Was 10.0, now 1.0 to allow blending across slight depth changes
                        let diffDepth = abs(centerDepth - sampleDepth) / max(centerDepth, 0.001);
                        let wDepth = exp(-diffDepth * 1.0); 
                        
                        // 3. Normal Weight
                        // Relaxed to 1.0 (was 4.0) to handle normal maps/curvature better
                        let dotNormal = max(0.0, dot(centerNormal, sampleNormal));
                        let wNormal = pow(dotNormal, 1.0);
                        
                        let weight = wSpatial * wDepth * wNormal;
                        
                        totalColor += sampleColor * weight;
                        totalWeight += weight;
                    }
                }
                
                if (totalWeight > 0.001) {
                    return vec4f(clamp(totalColor / totalWeight, vec3f(0.0), vec3f(100.0)), 1.0);
                }
                
                return textureSampleLevel(srcTex, samp, uv, 0.0);
            }
        `;
    this.denoisePipeline = device.createRenderPipeline({
      label: "SSGI Denoise Pipeline",
      layout: device.createPipelineLayout({ bindGroupLayouts: [this.denoiseLayout] }),
      vertex: { module: createShaderModuleSafe(device, { code: fullVS }), entryPoint: "vs_main" },
      fragment: { module: createShaderModuleSafe(device, { code: denoiseFS }), entryPoint: "fs_main", targets: [{ format: "rgba16float" }] },
      primitive: { topology: "triangle-list" }
    });
  }
}

// ../../src/core/renderer/SSGIPass.ts
class SSGIPass {
  device = null;
  enabled = true;
  stepSize = 1;
  maxSteps = 24;
  thickness = 2;
  intensity = 1;
  fallbackAmbient = [0.03, 0.03, 0.05];
  spatialRadius = 4;
  temporalAlpha = 0.1;
  enableSpatialDenoise = true;
  enableTemporalDenoise = true;
  tracePipeline = null;
  temporalAccumPipeline = null;
  traceBindGroupLayout = null;
  temporalBindGroupLayout = null;
  sampler = null;
  depthSampler = null;
  traceParamsBuffer = null;
  temporalParamsBuffer = null;
  gBuffer;
  denoisePass;
  historyIndex = 0;
  constructor(gBuffer) {
    this.gBuffer = gBuffer;
    this.denoisePass = new SSGIDenoisePass(gBuffer);
  }
  init(device, context, presentationFormat) {
    this.device = device;
    this.sampler = device.createSampler({
      minFilter: "linear",
      magFilter: "linear",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    });
    this.depthSampler = device.createSampler({
      minFilter: "nearest",
      magFilter: "nearest",
      mipmapFilter: "nearest",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    });
    this.traceParamsBuffer = device.createBuffer({
      label: "SSGI Trace Params",
      size: 32,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.temporalParamsBuffer = device.createBuffer({
      label: "SSGI Temporal Params",
      size: 16,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.createBindGroupLayouts(device);
    this.denoisePass.init(device, context, presentationFormat);
  }
  resize(width, height) {
    this.historyIndex = 0;
    this.denoisePass.resize(width, height);
  }
  getOutputTexture() {
    return this.gBuffer.ssgiTexture;
  }
  previousFrameTexture = null;
  setPreviousFrameTexture(tex) {
    this.previousFrameTexture = tex;
  }
  execute(commandEncoder, context, globalResources) {
    if (!this.gBuffer.ssgiTexture || !this.gBuffer.ssgiRawTexture || !this.device)
      return;
    if (!this.enabled) {
      const pass = commandEncoder.beginRenderPass({
        label: "SSGI Clear",
        colorAttachments: [{
          view: this.gBuffer.ssgiTexture.createView(),
          loadOp: "clear",
          storeOp: "store",
          clearValue: { r: 0, g: 0, b: 0, a: 0 }
        }]
      });
      pass.end();
      return;
    }
    if (!globalResources.sceneUniforms?.buffer)
      return;
    this.ensurePipelines(this.device, globalResources);
    this.executeTracePass(commandEncoder, globalResources);
    if (this.enableSpatialDenoise) {
      this.denoisePass.execute(commandEncoder, context, globalResources);
    } else {
      commandEncoder.copyTextureToTexture({ texture: this.gBuffer.ssgiRawTexture }, { texture: this.gBuffer.ssgiTexture }, [this.gBuffer.width, this.gBuffer.height]);
    }
    if (this.enableTemporalDenoise) {
      this.executeTemporalAccumPass(commandEncoder, globalResources);
    }
  }
  executeTracePass(commandEncoder, globalResources) {
    if (!this.device || !this.traceBindGroupLayout || !this.sampler || !this.depthSampler)
      return;
    const sceneUniformBuffer = globalResources.sceneUniforms.buffer;
    const paramsData = new Float32Array([
      this.maxSteps,
      this.stepSize,
      this.thickness,
      this.intensity,
      this.fallbackAmbient[0],
      this.fallbackAmbient[1],
      this.fallbackAmbient[2],
      0
    ]);
    this.device.queue.writeBuffer(this.traceParamsBuffer, 0, paramsData);
    const sourceView = this.previousFrameTexture ? this.previousFrameTexture.createView() : this.gBuffer.albedoTexture.createView();
    const defaultEnv = CubeTexture.getDefault(this.device);
    const envMap = globalResources.environmentMap || defaultEnv;
    const hiZView = globalResources.hiZBuffer.texture ? globalResources.hiZBuffer.texture.createView() : this.gBuffer.depthTexture.createView({ aspect: "depth-only" });
    const bindGroup = this.device.createBindGroup({
      layout: this.traceBindGroupLayout,
      entries: [
        { binding: 0, resource: this.gBuffer.normalTexture.createView() },
        { binding: 1, resource: this.gBuffer.depthTexture.createView({ aspect: "depth-only" }) },
        { binding: 2, resource: sourceView },
        { binding: 3, resource: this.sampler },
        { binding: 4, resource: { buffer: sceneUniformBuffer } },
        { binding: 5, resource: { buffer: this.traceParamsBuffer } },
        { binding: 6, resource: this.gBuffer.albedoTexture.createView() },
        { binding: 7, resource: this.depthSampler },
        { binding: 8, resource: envMap.view },
        { binding: 9, resource: envMap.sampler },
        { binding: 10, resource: hiZView }
      ]
    });
    const pass = commandEncoder.beginRenderPass({
      label: "SSGI Trace",
      colorAttachments: [{
        view: this.gBuffer.ssgiRawTexture.createView(),
        loadOp: "clear",
        storeOp: "store",
        clearValue: { r: 0, g: 0, b: 0, a: 0 }
      }]
    });
    pass.setPipeline(this.tracePipeline);
    pass.setBindGroup(0, bindGroup);
    pass.draw(3);
    pass.end();
  }
  executeTemporalAccumPass(commandEncoder, globalResources) {
    if (!this.device || !this.temporalBindGroupLayout || !this.sampler)
      return;
    if (!this.gBuffer.ssgiHistoryA || !this.gBuffer.ssgiHistoryB || !this.gBuffer.velocityTexture)
      return;
    const historyRead = this.historyIndex === 0 ? this.gBuffer.ssgiHistoryA : this.gBuffer.ssgiHistoryB;
    const historyWrite = this.historyIndex === 0 ? this.gBuffer.ssgiHistoryB : this.gBuffer.ssgiHistoryA;
    const paramsData = new Float32Array([
      this.temporalAlpha,
      0,
      0,
      0
    ]);
    this.device.queue.writeBuffer(this.temporalParamsBuffer, 0, paramsData);
    const bindGroup = this.device.createBindGroup({
      layout: this.temporalBindGroupLayout,
      entries: [
        { binding: 0, resource: this.gBuffer.ssgiTexture.createView() },
        { binding: 1, resource: historyRead.createView() },
        { binding: 2, resource: this.gBuffer.velocityTexture.createView() },
        { binding: 3, resource: this.gBuffer.normalTexture.createView() },
        { binding: 4, resource: this.sampler },
        { binding: 5, resource: { buffer: this.temporalParamsBuffer } }
      ]
    });
    const pass = commandEncoder.beginRenderPass({
      label: "SSGI Temporal Accumulation",
      colorAttachments: [{
        view: historyWrite.createView(),
        loadOp: "clear",
        storeOp: "store",
        clearValue: { r: 0, g: 0, b: 0, a: 0 }
      }]
    });
    pass.setPipeline(this.temporalAccumPipeline);
    pass.setBindGroup(0, bindGroup);
    pass.draw(3);
    pass.end();
    commandEncoder.copyTextureToTexture({ texture: historyWrite }, { texture: this.gBuffer.ssgiTexture }, [this.gBuffer.width, this.gBuffer.height]);
    this.historyIndex = 1 - this.historyIndex;
  }
  createBindGroupLayouts(device) {
    this.traceBindGroupLayout = device.createBindGroupLayout({
      label: "SSGI Trace Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "depth" } },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 3, visibility: GPUShaderStage.FRAGMENT, sampler: {} },
        { binding: 4, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
        { binding: 5, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
        { binding: 6, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 7, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "non-filtering" } },
        { binding: 8, visibility: GPUShaderStage.FRAGMENT, texture: { viewDimension: "cube" } },
        { binding: 9, visibility: GPUShaderStage.FRAGMENT, sampler: {} },
        { binding: 10, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "unfilterable-float" } }
      ]
    });
    this.temporalBindGroupLayout = device.createBindGroupLayout({
      label: "SSGI Temporal Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 3, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 4, visibility: GPUShaderStage.FRAGMENT, sampler: {} },
        { binding: 5, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } }
      ]
    });
  }
  ensurePipelines(device, globalResources) {
    if (!this.tracePipeline) {
      this.createTracePipeline(device);
    }
    if (!this.temporalAccumPipeline) {
      this.createTemporalAccumPipeline(device);
    }
  }
  createTracePipeline(device) {
    const fullscreenVS = `
        struct VertexOutput {
            @builtin(position) position : vec4f,
            @location(0) uv : vec2f,
        }
        @vertex
        fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
            var output : VertexOutput;
            let pos = array(vec2f(-1.0, -1.0), vec2f(3.0, -1.0), vec2f(-1.0, 3.0));
            let p = pos[vertexIndex];
            output.position = vec4f(p, 0.0, 1.0);
            output.uv = p * 0.5 + 0.5;
            output.uv.y = 1.0 - output.uv.y;
            return output;
        }
      `;
    const traceFS = `
        @group(0) @binding(0) var normalTex : texture_2d<f32>;
        @group(0) @binding(1) var depthTex : texture_depth_2d;
        @group(0) @binding(2) var sceneColorTex : texture_2d<f32>;
        @group(0) @binding(3) var samp : sampler;

        struct SceneUniforms {
            viewMatrix : mat4x4<f32>,
            projectionMatrix : mat4x4<f32>,
            lightViewProj : mat4x4<f32>,
            prevViewProj : mat4x4<f32>,
            inverseProjectionMatrix : mat4x4<f32>,
            cameraPosition : vec3f,
            time : f32,
        }
        @group(0) @binding(4) var<uniform> scene : SceneUniforms;

        struct SSGIParams {
            maxSteps: f32,
            stepSize: f32,
            thickness: f32,
            intensity: f32,
            fallbackR: f32,
            fallbackG: f32,
            fallbackB: f32,
            pad: f32,
        }
        @group(0) @binding(5) var<uniform> params : SSGIParams;
        @group(0) @binding(6) var albedoTex : texture_2d<f32>;
        @group(0) @binding(7) var depthSamp : sampler;
        @group(0) @binding(8) var envMap : texture_cube<f32>;
        @group(0) @binding(9) var envSamp : sampler;
        @group(0) @binding(10) var hiZTex : texture_2d<f32>;

        const PI = 3.14159265359;
        const HIZ_MAX_LEVEL = 6;  // Maximum mip level to use for Hi-Z

        // Convert view-space direction to world-space for environment sampling
        fn viewToWorldDir(viewDir: vec3f) -> vec3f {
            // View matrix is world-to-view, so we need to transpose the 3x3 rotation part
            // to get view-to-world (transpose of rotation = inverse for orthonormal matrices)
            let invView = transpose(mat3x3f(
                scene.viewMatrix[0].xyz,
                scene.viewMatrix[1].xyz,
                scene.viewMatrix[2].xyz
            ));
            return normalize(invView * viewDir);
        }

        fn getViewPosition(uv: vec2f, depth: f32) -> vec3f {
            let clipXY = vec2f(uv.x * 2.0 - 1.0, (1.0 - uv.y) * 2.0 - 1.0);
            let clipPos = vec4f(clipXY, depth, 1.0);
            let viewPos = scene.inverseProjectionMatrix * clipPos;
            return viewPos.xyz / viewPos.w;
        }

        // Interleaved Gradient Noise (IGN)
        // Generates a specific high-frequency pattern that TAA handles well
        fn ign(pixel: vec2f, frame: f32) -> f32 {
            // frame is needed to rotate the noise over time for integration
            // But for TAA-compatible stable noise, we might want static or periodic?
            // Usually we want it to jitter with TAA?
            // Let's use standard IGN formula:
            let magic = vec3f(0.06711056, 0.00583715, 52.9829189);
            // Add frame offset to x/y to animate noise? 
            // Or just add frame to result?
            // "Animated IGN" usually just adds a golden ratio offset per frame
            let val = dot(pixel, magic.xy) + frame * 0.61803398;
            return fract(magic.z * fract(val));
        }

        fn hash2(p: vec2f) -> vec2f {
             // Fallback/Variation
             return vec2f(fract(sin(dot(p, vec2f(12.9898, 78.233))) * 43758.5453),
                          fract(sin(dot(p, vec2f(39.7867, 12.345))) * 43758.5453));
        }

        @fragment
        fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {
             let depth = textureSampleLevel(depthTex, depthSamp, uv, 0);
             if (depth >= 1.0) { return vec4f(0.0); } // Sky - no GI contribution

             let rawNormal = textureSampleLevel(normalTex, samp, uv, 0.0);
             let N = normalize(rawNormal.xyz * 2.0 - 1.0);

             let viewNormal = normalize((scene.viewMatrix * vec4f(N, 0.0)).xyz);
             let viewPos = getViewPosition(uv, depth);

             // Use IGN for stable noise pattern
             // Pixel coordinates
             let dim = vec2f(textureDimensions(depthTex));
             let pixel = uv * dim;
             
             // 2D Noise from IGN
             // We need 2 numbers for Hemisphere sampling (phi, theta)
             // We can use IGN for one, and a hash or offset IGN for second?
             // Or just use IGN for both (offset pixel)?
             
             let noise0 = ign(pixel, scene.time);
             let noise1 = ign(pixel + vec2f(5.2, 1.3), scene.time);
             
             let noise = vec2f(noise0, noise1);

             let phi = 2.0 * PI * noise.x;
             let cosTheta = sqrt(1.0 - noise.y);
             let sinTheta = sqrt(noise.y);

             let tangentSample = vec3f(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);

             let up = select(vec3f(1.0, 0.0, 0.0), vec3f(0.0, 0.0, 1.0), abs(viewNormal.z) < 0.999);
             let tangent = normalize(cross(up, viewNormal));
             let bitangent = cross(viewNormal, tangent);

             let sampleDir = normalize(tangent * tangentSample.x + bitangent * tangentSample.y + viewNormal * tangentSample.z);

             // Adaptive parameters based on depth
             let linearDepth = abs(viewPos.z);
             let stepSize = params.stepSize * max(1.0, linearDepth * 0.01);
             let thickness = params.thickness * max(1.0, linearDepth * 0.01);

             var currentPos = viewPos + viewNormal * 0.01; // Small offset to avoid self-hit
             let maxSteps = i32(params.maxSteps);

             var hit = false;
             var hitUV = vec2f(0.0);

             for (var i = 0; i < maxSteps; i++) {
                 currentPos += sampleDir * stepSize;

                 let projected = scene.projectionMatrix * vec4f(currentPos, 1.0);
                 let ndc = projected.xyz / projected.w;
                 let screenUV = vec2f(ndc.x, -ndc.y) * 0.5 + 0.5;

                 if (screenUV.x < 0.0 || screenUV.x > 1.0 || screenUV.y < 0.0 || screenUV.y > 1.0) {
                     break;
                 }

                 let sampleDepth = textureSampleLevel(depthTex, depthSamp, screenUV, 0);
                 if (sampleDepth >= 1.0) { break; }

                 let sampleViewPos = getViewPosition(screenUV, sampleDepth);
                 let delta = currentPos.z - sampleViewPos.z;

                 if (delta < 0.0 && delta > -thickness) {
                     hit = true;
                     hitUV = screenUV;
                     break;
                 }
             }

             var result = vec3f(params.fallbackR, params.fallbackG, params.fallbackB);

             if (hit) {
                 let rawHitColor = textureSampleLevel(sceneColorTex, samp, hitUV, 0.0).rgb;
                 // Clamp to prevent NaNs/Infs from propagating
                 let hitColor = clamp(rawHitColor, vec3f(0.0), vec3f(100.0));
                 let edgeFade = 1.0 - max(abs(hitUV.x - 0.5), abs(hitUV.y - 0.5)) * 2.0;
                 result = hitColor * clamp(edgeFade, 0.0, 1.0) * params.intensity;
             }
             // Miss returns black - denoising will handle it

             return vec4f(result, 1.0);
        }
      `;
    this.tracePipeline = device.createRenderPipeline({
      label: "SSGI Trace Pipeline",
      layout: device.createPipelineLayout({ bindGroupLayouts: [this.traceBindGroupLayout] }),
      vertex: { module: createShaderModuleSafe(device, { code: fullscreenVS }), entryPoint: "vs_main" },
      fragment: { module: createShaderModuleSafe(device, { code: traceFS }), entryPoint: "fs_main", targets: [{ format: "rgba16float" }] },
      primitive: { topology: "triangle-list" }
    });
  }
  createTemporalAccumPipeline(device) {
    const fullscreenVS = `
        struct VertexOutput {
            @builtin(position) position : vec4f,
            @location(0) uv : vec2f,
        }
        @vertex
        fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
            var output : VertexOutput;
            let pos = array(vec2f(-1.0, -1.0), vec2f(3.0, -1.0), vec2f(-1.0, 3.0));
            let p = pos[vertexIndex];
            output.position = vec4f(p, 0.0, 1.0);
            output.uv = p * 0.5 + 0.5;
            output.uv.y = 1.0 - output.uv.y;
            return output;
        }
      `;
    const temporalFS = `
        @group(0) @binding(0) var currentTex : texture_2d<f32>;
        @group(0) @binding(1) var historyTex : texture_2d<f32>;
        @group(0) @binding(2) var velocityTex : texture_2d<f32>;
        @group(0) @binding(3) var normalTex : texture_2d<f32>;
        @group(0) @binding(4) var samp : sampler;

        struct TemporalParams {
            alpha: f32,
            pad1: f32,
            pad2: f32,
            pad3: f32,
        }
        @group(0) @binding(5) var<uniform> params : TemporalParams;

        fn luminance(c: vec3f) -> f32 {
            return dot(c, vec3f(0.299, 0.587, 0.114));
        }

        @fragment
        fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {
            let current = textureSampleLevel(currentTex, samp, uv, 0.0);
            let velocity = textureSampleLevel(velocityTex, samp, uv, 0.0).xy;

            // Reproject to previous frame
            let prevUV = uv - velocity;

            // Out of bounds - use current frame only
            if (prevUV.x < 0.0 || prevUV.x > 1.0 || prevUV.y < 0.0 || prevUV.y > 1.0) {
                return current;
            }

            let history = textureSampleLevel(historyTex, samp, prevUV, 0.0);

            // Variance-based neighborhood clamping
            // Compute mean and variance of neighborhood
            let texSize = vec2f(textureDimensions(currentTex));
            let onePixel = 1.0 / texSize;

            var mean = vec3f(0.0);
            var meanSq = vec3f(0.0);
            var minColor = current.rgb;
            var maxColor = current.rgb;

            // 3x3 neighborhood
            for (var y = -1; y <= 1; y++) {
                for (var x = -1; x <= 1; x++) {
                    let offset = vec2f(f32(x), f32(y)) * onePixel;
                    let neighborColor = textureSampleLevel(currentTex, samp, uv + offset, 0.0).rgb;
                    mean += neighborColor;
                    meanSq += neighborColor * neighborColor;
                    minColor = min(minColor, neighborColor);
                    maxColor = max(maxColor, neighborColor);
                }
            }

            mean /= 9.0;
            meanSq /= 9.0;
            let variance = max(meanSq - mean * mean, vec3f(0.0));
            let stdDev = sqrt(variance);

            // Variance-based clamping: expand bounds when variance is low (sparse/dark areas)
            // This prevents aggressive rejection of valid history in dark regions
            let gamma = 1.5;  // How many std devs to allow
            let varianceMin = mean - stdDev * gamma;
            let varianceMax = mean + stdDev * gamma;

            // Use the more permissive of min/max clamping and variance clamping
            // When neighborhood is dark/sparse, variance clamping allows more history through
            let expandedMin = min(minColor, varianceMin);
            let expandedMax = max(maxColor, varianceMax);

            // Add small tolerance to prevent completely black clamping
            let tolerance = 0.02;
            let finalMin = expandedMin - tolerance;
            let finalMax = expandedMax + tolerance;

            // Clamp history with expanded bounds
            let clampedHistory = clamp(history.rgb, finalMin, finalMax);

            // Velocity-based blend factor - fast motion = trust current more
            let velMag = length(velocity * texSize);
            let velocityFactor = clamp(velMag * 0.1, 0.0, 1.0);

            // Luminance-based rejection REMOVED:
            // High noise looks like high luminance change, which caused the history to be rejected.
            // We rely on Variance Clipping (above) to handle ghosting.
            
            // Final blend: more weight to history for stable result
            // Alpha is usually 0.1 (10% new, 90% old)
            // If moving fast, we blend more new.
            let alpha = mix(params.alpha, 1.0, velocityFactor);
            let result = mix(clampedHistory, current.rgb, alpha);

            return vec4f(result, 1.0);
        }
      `;
    this.temporalAccumPipeline = device.createRenderPipeline({
      label: "SSGI Temporal Accumulation Pipeline",
      layout: device.createPipelineLayout({ bindGroupLayouts: [this.temporalBindGroupLayout] }),
      vertex: { module: createShaderModuleSafe(device, { code: fullscreenVS }), entryPoint: "vs_main" },
      fragment: { module: createShaderModuleSafe(device, { code: temporalFS }), entryPoint: "fs_main", targets: [{ format: "rgba16float" }] },
      primitive: { topology: "triangle-list" }
    });
  }
}

// ../../src/core/renderer/TAAPass.ts
class TAAPass {
  gBuffer;
  historyTextureA = null;
  historyTextureB = null;
  historyIndex = 0;
  pipeline = null;
  bindGroupLayout = null;
  sampler = null;
  width = 0;
  height = 0;
  device = null;
  alpha = 0.1;
  enabled = true;
  constructor(gBuffer) {
    this.gBuffer = gBuffer;
  }
  init(device, context, presentationFormat) {
    this.device = device;
    this.sampler = device.createSampler({
      magFilter: "linear",
      minFilter: "linear",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    });
    this.resize(this.gBuffer.width, this.gBuffer.height);
  }
  resize(width, height) {
    if (width <= 0 || height <= 0)
      return;
    this.width = width;
    this.height = height;
    if (this.device) {
      this.destroyTextures();
      this.createTextures(this.device);
    }
  }
  destroyTextures() {
    if (this.historyTextureA)
      this.historyTextureA.destroy();
    if (this.historyTextureB)
      this.historyTextureB.destroy();
  }
  createTextures(device) {
    const desc = {
      label: "TAA History",
      size: [this.width, this.height],
      format: "rgba16float",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT
    };
    this.historyTextureA = device.createTexture(desc);
    this.historyTextureB = device.createTexture(desc);
  }
  execute(commandEncoder, context, globalResources) {
    if (!this.enabled)
      return;
    if (!this.device || !this.gBuffer.accumulationTexture || !this.gBuffer.velocityTexture || !this.historyTextureA || !this.historyTextureB)
      return;
    if (!this.pipeline) {
      this.createPipeline(this.device, globalResources);
    }
    const source = this.gBuffer.accumulationTexture;
    const historyRead = this.historyIndex === 0 ? this.historyTextureA : this.historyTextureB;
    const historyWrite = this.historyIndex === 0 ? this.historyTextureB : this.historyTextureA;
    const bindGroup = this.device.createBindGroup({
      label: "TAA Bind Group",
      layout: this.bindGroupLayout,
      entries: [
        { binding: 0, resource: source.createView() },
        { binding: 1, resource: historyRead.createView() },
        { binding: 2, resource: this.gBuffer.velocityTexture.createView() },
        { binding: 3, resource: this.sampler }
      ]
    });
    const passDescriptor = {
      colorAttachments: [
        {
          view: historyWrite.createView(),
          loadOp: "clear",
          storeOp: "store"
        }
      ]
    };
    const pass = commandEncoder.beginRenderPass(passDescriptor);
    pass.setPipeline(this.pipeline);
    pass.setBindGroup(0, bindGroup);
    pass.draw(3);
    pass.end();
    this.historyIndex = 1 - this.historyIndex;
  }
  getHistoryTexture() {
    return 1 - this.historyIndex === 0 ? this.historyTextureA : this.historyTextureB;
  }
  getPreviousFrameTexture() {
    return this.historyIndex === 0 ? this.historyTextureA : this.historyTextureB;
  }
  createPipeline(device, globalResources) {
    const code = `
        @group(0) @binding(0) var currentTex : texture_2d<f32>;
        @group(0) @binding(1) var historyTex : texture_2d<f32>;
        @group(0) @binding(2) var velocityTex : texture_2d<f32>;
        @group(0) @binding(3) var samp : sampler;

        struct VertexOutput {
            @builtin(position) position : vec4f,
            @location(0) uv : vec2f,
        }

        @vertex
        fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
            var output : VertexOutput;
            let pos = array(
            vec2f(-1.0, -1.0),
            vec2f( 3.0, -1.0),
            vec2f(-1.0,  3.0)
            );
            let p = pos[vertexIndex];
            output.position = vec4f(p, 0.0, 1.0);
            output.uv = p * 0.5 + 0.5;
            output.uv.y = 1.0 - output.uv.y; 
            return output;
        }

        fn RGBToYCoCg(rgb: vec3f) -> vec3f {
            let Y  = dot(rgb, vec3f(0.25, 0.5, 0.25));
            let Co = dot(rgb, vec3f(0.5, 0.0, -0.5));
            let Cg = dot(rgb, vec3f(-0.25, 0.5, -0.25));
            return vec3f(Y, Co, Cg);
        }

        fn YCoCgToRGB(ycocg: vec3f) -> vec3f {
            let Y  = ycocg.x;
            let Co = ycocg.y;
            let Cg = ycocg.z;
            let R = Y + Co - Cg;
            let G = Y + Cg;
            let B = Y - Co - Cg;
            return vec3f(R, G, B);
        }

        @fragment
        fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {
            let velocity = textureSample(velocityTex, samp, uv).xy;
            let currentRGB = textureSample(currentTex, samp, uv).rgb;
            let current = RGBToYCoCg(currentRGB);
            
            // Reproject
            let prevUV = uv - velocity;
            
            // Bounds check
            if (prevUV.x < 0.0 || prevUV.x > 1.0 || prevUV.y < 0.0 || prevUV.y > 1.0) {
                return vec4f(currentRGB, 1.0); // No history
            }
            
            // Safe sample history with explicit LOD
            let historyRGB = textureSampleLevel(historyTex, samp, prevUV, 0.0).rgb;
            let history = RGBToYCoCg(historyRGB);
            
            // Neighborhood Statistics (Variance Clipping in YCoCg)
            let texSize = vec2f(textureDimensions(currentTex));
            let onePixel = 1.0 / texSize;
            
            var m1 = vec3f(0.0);
            var m2 = vec3f(0.0);
            
            for(var y = -1; y <= 1; y++) {
                for(var x = -1; x <= 1; x++) {
                    let offset = vec2f(f32(x), f32(y)) * onePixel;
                    let cRGB = textureSampleLevel(currentTex, samp, uv + offset, 0.0).rgb;
                    let c = RGBToYCoCg(cRGB);
                    m1 += c;
                    m2 += c * c;
                }
            }
            
            m1 /= 9.0;
            m2 /= 9.0;
            
            let sigma = sqrt(abs(m2 - m1 * m1));
            let gamma = 1.25; // Wider clipping to preserve detail (was 0.75)

            // Prevent zero-width box in perfectly uniform areas
            let minSpread = vec3f(0.01);

            let minColor = m1 - gamma * sigma - minSpread;
            let maxColor = m1 + gamma * sigma + minSpread;
            
            // Clip history to neighborhood Variance AABB (in YCoCg)
            let clampedHistory = clamp(history, minColor, maxColor);
            
            // Dynamic Feedback Factor
            // 1. Velocity Factor: If moving fast, trust history less to avoid ghosting
            let velMag = length(velocity * texSize); // Velocity in pixels
            let velWeight = clamp(velMag * 0.1, 0.0, 1.0); // Adjust scale as needed
            
            let baseAlpha = 0.15; // 15% new, 85% old (was 0.1 - increased to reduce blur)
            let targetAlpha = mix(baseAlpha, 1.0, velWeight);
            
            let resultYCoCg = mix(clampedHistory, current, targetAlpha);
            let resultRGB = YCoCgToRGB(resultYCoCg);
            
            // Clamp final result to prevent NaNs
            return vec4f(clamp(resultRGB, vec3f(0.0), vec3f(100.0)), 1.0);
        }
      `;
    this.bindGroupLayout = device.createBindGroupLayout({
      label: "TAA Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 3, visibility: GPUShaderStage.FRAGMENT, sampler: {} }
      ]
    });
    const layout = device.createPipelineLayout({
      bindGroupLayouts: [this.bindGroupLayout]
    });
    this.pipeline = device.createRenderPipeline({
      label: "TAA Pipeline",
      layout,
      vertex: {
        module: createShaderModuleSafe(device, { code }),
        entryPoint: "vs_main"
      },
      fragment: {
        module: createShaderModuleSafe(device, { code }),
        entryPoint: "fs_main",
        targets: [{ format: "rgba16float" }]
      },
      primitive: { topology: "triangle-list" }
    });
  }
}

// ../../src/core/renderer/FXAAPass.ts
class FXAAPass {
  gBuffer;
  outputTexture = null;
  inputTexture = null;
  pipeline = null;
  bindGroupLayout = null;
  sampler = null;
  width = 0;
  height = 0;
  device = null;
  contrastThreshold = 0.0312;
  relativeThreshold = 0.063;
  subpixelBlending = 0.75;
  enabled = true;
  constructor(gBuffer) {
    this.gBuffer = gBuffer;
  }
  setInputTexture(texture) {
    this.inputTexture = texture;
  }
  init(device, _context, _presentationFormat) {
    this.device = device;
    this.sampler = device.createSampler({
      minFilter: "linear",
      magFilter: "linear",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    });
    this.resize(this.gBuffer.width, this.gBuffer.height);
  }
  resize(width, height) {
    if (width <= 0 || height <= 0)
      return;
    this.width = width;
    this.height = height;
    if (this.device) {
      this.destroyTextures();
      this.createTextures(this.device);
    }
  }
  destroyTextures() {
    if (this.outputTexture)
      this.outputTexture.destroy();
  }
  createTextures(device) {
    this.outputTexture = device.createTexture({
      label: "FXAA Output",
      size: [this.width, this.height],
      format: "rgba16float",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT
    });
  }
  execute(commandEncoder, _context, _globalResources) {
    if (!this.enabled)
      return;
    const source = this.inputTexture || this.gBuffer.accumulationTexture;
    if (!this.device || !source || !this.outputTexture)
      return;
    if (!this.pipeline) {
      this.createPipeline(this.device);
    }
    const bindGroup = this.device.createBindGroup({
      label: "FXAA Bind Group",
      layout: this.bindGroupLayout,
      entries: [
        { binding: 0, resource: source.createView() },
        { binding: 1, resource: this.sampler }
      ]
    });
    const passDescriptor = {
      colorAttachments: [
        {
          view: this.outputTexture.createView(),
          loadOp: "clear",
          storeOp: "store"
        }
      ]
    };
    const pass = commandEncoder.beginRenderPass(passDescriptor);
    pass.setPipeline(this.pipeline);
    pass.setBindGroup(0, bindGroup);
    pass.draw(3);
    pass.end();
  }
  getOutputTexture() {
    return this.outputTexture;
  }
  createPipeline(device) {
    const code = `
      @group(0) @binding(0) var inputTex : texture_2d<f32>;
      @group(0) @binding(1) var samp : sampler;

      struct VertexOutput {
        @builtin(position) position : vec4f,
        @location(0) uv : vec2f,
      }

      // Fullscreen triangle vertex shader
      @vertex
      fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
        var output : VertexOutput;
        let pos = array(
          vec2f(-1.0, -1.0),
          vec2f( 3.0, -1.0),
          vec2f(-1.0,  3.0)
        );
        let p = pos[vertexIndex];
        output.position = vec4f(p, 0.0, 1.0);
        output.uv = p * 0.5 + 0.5;
        output.uv.y = 1.0 - output.uv.y;
        return output;
      }

      // Constants - hardcoded for now, could be made uniforms
      const CONTRAST_THRESHOLD: f32 = ${this.contrastThreshold};
      const RELATIVE_THRESHOLD: f32 = ${this.relativeThreshold};
      const SUBPIXEL_BLENDING: f32 = ${this.subpixelBlending};

      // Edge search steps - balance between quality and performance
      const EDGE_STEP_COUNT: i32 = 10;
      const EDGE_STEPS: array<f32, 10> = array<f32, 10>(
        1.0, 1.5, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 4.0
      );
      const EDGE_GUESS: f32 = 8.0;

      // Convert RGB to luminance using perceptual weights
      fn luminance(rgb: vec3f) -> f32 {
        return dot(rgb, vec3f(0.299, 0.587, 0.114));
      }

      // Sample luminance at offset from UV
      fn sampleLuma(uv: vec2f) -> f32 {
        return luminance(textureSampleLevel(inputTex, samp, uv, 0.0).rgb);
      }

      @fragment
      fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {
        let texSize = vec2f(textureDimensions(inputTex));
        let invSize = 1.0 / texSize;

        // Sample center and 4 neighbors
        let rgbM = textureSampleLevel(inputTex, samp, uv, 0.0).rgb;
        let lumaM = luminance(rgbM);

        let lumaN = sampleLuma(uv + vec2f(0.0, -invSize.y));
        let lumaS = sampleLuma(uv + vec2f(0.0, invSize.y));
        let lumaE = sampleLuma(uv + vec2f(invSize.x, 0.0));
        let lumaW = sampleLuma(uv + vec2f(-invSize.x, 0.0));

        // Find min/max luminance in the neighborhood
        let lumaMin = min(lumaM, min(min(lumaN, lumaS), min(lumaE, lumaW)));
        let lumaMax = max(lumaM, max(max(lumaN, lumaS), max(lumaE, lumaW)));
        let lumaRange = lumaMax - lumaMin;

        // Early exit if contrast is too low (not an edge)
        if (lumaRange < max(CONTRAST_THRESHOLD, lumaMax * RELATIVE_THRESHOLD)) {
          return vec4f(rgbM, 1.0);
        }

        // Sample diagonal neighbors for subpixel aliasing detection
        let lumaNW = sampleLuma(uv + vec2f(-invSize.x, -invSize.y));
        let lumaNE = sampleLuma(uv + vec2f(invSize.x, -invSize.y));
        let lumaSW = sampleLuma(uv + vec2f(-invSize.x, invSize.y));
        let lumaSE = sampleLuma(uv + vec2f(invSize.x, invSize.y));

        // Compute subpixel blend factor
        let lumaL = (lumaN + lumaS + lumaE + lumaW) * 0.25;
        let rangeL = abs(lumaL - lumaM);
        var blendL = max(0.0, (rangeL / lumaRange) - 0.25);
        blendL = min(SUBPIXEL_BLENDING, blendL * 1.3333333);

        // Detect edge direction (horizontal vs vertical)
        let edgeH = abs(-2.0 * lumaW + lumaNW + lumaSW) +
                    abs(-2.0 * lumaM + lumaN + lumaS) * 2.0 +
                    abs(-2.0 * lumaE + lumaNE + lumaSE);
        let edgeV = abs(-2.0 * lumaN + lumaNW + lumaNE) +
                    abs(-2.0 * lumaM + lumaW + lumaE) * 2.0 +
                    abs(-2.0 * lumaS + lumaSW + lumaSE);

        let isHorizontal = edgeH >= edgeV;

        // Choose edge direction
        var stepLength: f32;
        var luma1: f32;
        var luma2: f32;

        if (isHorizontal) {
          stepLength = invSize.y;
          luma1 = lumaN;
          luma2 = lumaS;
        } else {
          stepLength = invSize.x;
          luma1 = lumaW;
          luma2 = lumaE;
        }

        // Determine which side of the edge we're on
        let gradient1 = luma1 - lumaM;
        let gradient2 = luma2 - lumaM;
        let is1Steepest = abs(gradient1) >= abs(gradient2);
        let gradientScaled = 0.25 * max(abs(gradient1), abs(gradient2));

        // Choose step direction
        var edgeStep: f32;
        var lumaLocalAvg: f32;

        if (is1Steepest) {
          edgeStep = -stepLength;
          lumaLocalAvg = 0.5 * (luma1 + lumaM);
        } else {
          edgeStep = stepLength;
          lumaLocalAvg = 0.5 * (luma2 + lumaM);
        }

        // Compute edge UV
        var edgeUV = uv;
        if (isHorizontal) {
          edgeUV.y += edgeStep * 0.5;
        } else {
          edgeUV.x += edgeStep * 0.5;
        }

        // Step along the edge in both directions
        var uvStep: vec2f;
        if (isHorizontal) {
          uvStep = vec2f(invSize.x, 0.0);
        } else {
          uvStep = vec2f(0.0, invSize.y);
        }

        var uv1 = edgeUV - uvStep;
        var uv2 = edgeUV + uvStep;

        var lumaEnd1 = sampleLuma(uv1) - lumaLocalAvg;
        var lumaEnd2 = sampleLuma(uv2) - lumaLocalAvg;

        var reached1 = abs(lumaEnd1) >= gradientScaled;
        var reached2 = abs(lumaEnd2) >= gradientScaled;
        var reachedBoth = reached1 && reached2;

        if (!reached1) { uv1 -= uvStep; }
        if (!reached2) { uv2 += uvStep; }

        // Continue searching for edge endpoints
        if (!reachedBoth) {
          for (var i = 2; i < EDGE_STEP_COUNT; i++) {
            if (!reached1) {
              lumaEnd1 = sampleLuma(uv1) - lumaLocalAvg;
              reached1 = abs(lumaEnd1) >= gradientScaled;
            }
            if (!reached2) {
              lumaEnd2 = sampleLuma(uv2) - lumaLocalAvg;
              reached2 = abs(lumaEnd2) >= gradientScaled;
            }
            reachedBoth = reached1 && reached2;
            if (!reached1) { uv1 -= uvStep * EDGE_STEPS[i]; }
            if (!reached2) { uv2 += uvStep * EDGE_STEPS[i]; }
            if (reachedBoth) { break; }
          }
        }

        // Compute distances to edge endpoints
        var distance1: f32;
        var distance2: f32;
        if (isHorizontal) {
          distance1 = uv.x - uv1.x;
          distance2 = uv2.x - uv.x;
        } else {
          distance1 = uv.y - uv1.y;
          distance2 = uv2.y - uv.y;
        }

        let distanceToEnd = min(distance1, distance2);
        let edgeLength = distance1 + distance2;
        let pixelOffset = -distanceToEnd / edgeLength + 0.5;

        // Check if we should apply AA based on edge direction
        let isLumaCenterSmaller = lumaM < lumaLocalAvg;
        let correctVariation1 = (lumaEnd1 < 0.0) != isLumaCenterSmaller;
        let correctVariation2 = (lumaEnd2 < 0.0) != isLumaCenterSmaller;
        let correctVariation = select(correctVariation2, correctVariation1, distance1 < distance2);

        var finalPixelOffset = select(0.0, pixelOffset, correctVariation);
        finalPixelOffset = max(finalPixelOffset, blendL);

        // Apply the offset and sample the final color
        var finalUV = uv;
        if (isHorizontal) {
          finalUV.y += finalPixelOffset * edgeStep;
        } else {
          finalUV.x += finalPixelOffset * edgeStep;
        }

        let finalColor = textureSampleLevel(inputTex, samp, finalUV, 0.0).rgb;
        return vec4f(finalColor, 1.0);
      }
    `;
    this.bindGroupLayout = device.createBindGroupLayout({
      label: "FXAA Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, sampler: {} }
      ]
    });
    const layout = device.createPipelineLayout({
      bindGroupLayouts: [this.bindGroupLayout]
    });
    this.pipeline = device.createRenderPipeline({
      label: "FXAA Pipeline",
      layout,
      vertex: {
        module: createShaderModuleSafe(device, { code }),
        entryPoint: "vs_main"
      },
      fragment: {
        module: createShaderModuleSafe(device, { code }),
        entryPoint: "fs_main",
        targets: [{ format: "rgba16float" }]
      },
      primitive: { topology: "triangle-list" }
    });
  }
}

// ../../src/core/renderer/ToneMappingPass.ts
class ToneMappingPass {
  pipeline = null;
  inputTexture = null;
  bloomTexture = null;
  godRaysTexture = null;
  context = null;
  defaultTexture = null;
  sampler = null;
  uniformBuffer = null;
  bindGroup = null;
  bloomIntensity = 0.5;
  godRaysIntensity = 1;
  constructor() {}
  setInputTexture(texture) {
    this.inputTexture = texture;
    this.bindGroup = null;
  }
  setBloomTexture(texture) {
    this.bloomTexture = texture;
    this.bindGroup = null;
  }
  setGodRaysTexture(texture) {
    this.godRaysTexture = texture;
    this.bindGroup = null;
  }
  init(device, context, presentationFormat) {
    this.context = context;
    this.gDevice = device;
    this.defaultTexture = device.createTexture({
      size: [1, 1],
      format: "rgba16float",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
    });
    device.queue.writeTexture({ texture: this.defaultTexture }, new Float32Array([0, 0, 0, 0]), { bytesPerRow: 16 }, { width: 1, height: 1 });
    this.sampler = device.createSampler({ minFilter: "linear", magFilter: "linear" });
    this.uniformBuffer = device.createBuffer({
      label: "ToneMapping Uniform Buffer",
      size: 16,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.createPipeline(device, presentationFormat);
  }
  resize(width, height) {}
  execute(commandEncoder, context, globalResources) {
    if (!this.inputTexture || !this.pipeline || !this.context || !this.gDevice)
      return;
    if (this.inputTexture.width === 0 || this.inputTexture.height === 0)
      return;
    let currentTexture;
    try {
      currentTexture = this.context.getCurrentTexture();
    } catch (e) {
      return;
    }
    const textureView = currentTexture.createView();
    const uniformData = new Float32Array([this.bloomIntensity, this.godRaysIntensity, 0, 0]);
    this.gDevice.queue.writeBuffer(this.uniformBuffer, 0, uniformData);
    if (!this.bindGroup) {
      const bloomView = this.bloomTexture && this.bloomTexture.width > 0 && this.bloomTexture.height > 0 ? this.bloomTexture.createView() : this.defaultTexture.createView();
      const godRaysView = this.godRaysTexture && this.godRaysTexture.width > 0 && this.godRaysTexture.height > 0 ? this.godRaysTexture.createView() : this.defaultTexture.createView();
      this.bindGroup = this.gDevice.createBindGroup({
        label: "ToneMapping Bind Group",
        layout: this.pipeline.getBindGroupLayout(0),
        entries: [
          { binding: 0, resource: this.inputTexture.createView() },
          { binding: 1, resource: this.sampler },
          { binding: 2, resource: bloomView },
          { binding: 3, resource: { buffer: this.uniformBuffer } },
          { binding: 4, resource: godRaysView }
        ]
      });
    }
    const bg = this.bindGroup;
    const passDescriptor = {
      colorAttachments: [
        {
          view: textureView,
          loadOp: "clear",
          storeOp: "store"
        }
      ]
    };
    const pass = commandEncoder.beginRenderPass(passDescriptor);
    pass.setPipeline(this.pipeline);
    pass.setBindGroup(0, bg);
    pass.draw(3);
    pass.end();
  }
  gDevice = null;
  createPipeline(device, format) {
    this.gDevice = device;
    const code = `
        @group(0) @binding(0) var inputTex : texture_2d<f32>;
        @group(0) @binding(1) var samp : sampler;
        @group(0) @binding(2) var bloomTex : texture_2d<f32>;
        struct Params {
            bloomIntensity: f32,
            godRaysIntensity: f32,
            pad1: f32,
            pad2: f32,
        }
        @group(0) @binding(3) var<uniform> params : Params;
        @group(0) @binding(4) var godRaysTex : texture_2d<f32>;

        struct VertexOutput {
            @builtin(position) position : vec4f,
            @location(0) uv : vec2f,
        }

        @vertex
        fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
            var output : VertexOutput;
            let pos = array(
            vec2f(-1.0, -1.0),
            vec2f( 3.0, -1.0),
            vec2f(-1.0,  3.0)
            );
            let p = pos[vertexIndex];
            output.position = vec4f(p, 0.0, 1.0);
            output.uv = p * 0.5 + 0.5;
            output.uv.y = 1.0 - output.uv.y;
            return output;
        }

        // Interleaved Gradient Noise for dithering (reduces banding in gradients)
        fn ign(pixel: vec2f) -> f32 {
            return fract(52.9829189 * fract(0.06711056 * pixel.x + 0.00583715 * pixel.y));
        }

        @fragment
        fn fs_main(@location(0) uv : vec2f, @builtin(position) fragCoord : vec4f) -> @location(0) vec4f {
            var color = textureSample(inputTex, samp, uv).rgb;

            // God Rays Composite (additive, before bloom)
            let godRays = textureSample(godRaysTex, samp, uv).rgb;
            color += godRays * params.godRaysIntensity;

            // Bloom Composite
            let bloom = textureSample(bloomTex, samp, uv).rgb;
            color += bloom * params.bloomIntensity;

            // ACES Tone Mapping
            let a = 2.51;
            let b = 0.03;
            let c = 2.43;
            let d = 0.59;
            let e = 0.14;
            let mapped = clamp((color * (a * color + b)) / (color * (c * color + d) + e), vec3f(0.0), vec3f(1.0));

            let gamma = 2.2;
            var finalColor = pow(mapped, vec3f(1.0 / gamma));

            // Dithering to reduce banding in gradients (especially atmosphere sunrise/sunset)
            // Apply noise in the range [-0.5/255, 0.5/255] to break up quantization bands
            let dither = (ign(fragCoord.xy) - 0.5) / 255.0;
            finalColor += vec3f(dither);

            return vec4f(finalColor, 1.0);
        }
      `;
    this.pipeline = device.createRenderPipeline({
      label: "ToneMapping Pipeline",
      layout: "auto",
      vertex: {
        module: createShaderModuleSafe(device, { code }),
        entryPoint: "vs_main"
      },
      fragment: {
        module: createShaderModuleSafe(device, { code }),
        entryPoint: "fs_main",
        targets: [{ format }]
      },
      primitive: { topology: "triangle-list" }
    });
  }
}

// ../../src/core/renderer/BloomPass.ts
class BloomPass {
  device = null;
  width = 0;
  height = 0;
  bloomTexture = null;
  enabled = true;
  threshold = 1;
  knee = 0.1;
  intensity = 1;
  prefilterPipeline = null;
  downsamplePipeline = null;
  upsamplePipeline = null;
  bindGroupLayout = null;
  sampler = null;
  uniformBuffer = null;
  targetMipLevels = 5;
  actualMipLevels = 5;
  constructor() {}
  init(device, context, presentationFormat) {
    this.device = device;
    this.sampler = device.createSampler({
      minFilter: "linear",
      magFilter: "linear",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    });
    this.uniformBuffer = device.createBuffer({
      label: "Bloom Uniform Buffer",
      size: 16,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.bindGroupLayout = device.createBindGroupLayout({
      label: "Bloom Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, sampler: {} },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } }
      ]
    });
  }
  resize(width, height) {
    if (width <= 0 || height <= 0) {
      if (this.bloomTexture) {
        this.bloomTexture.destroy();
        this.bloomTexture = null;
      }
      return;
    }
    this.width = Math.max(1, Math.floor(width / 2));
    this.height = Math.max(1, Math.floor(height / 2));
    if (this.device) {
      if (this.bloomTexture)
        this.bloomTexture.destroy();
      const maxDim = Math.max(this.width, this.height);
      const maxMipLevels = Math.floor(Math.log2(maxDim)) + 1;
      this.actualMipLevels = Math.min(this.targetMipLevels, maxMipLevels);
      this.bloomTexture = this.device.createTexture({
        label: "Bloom Texture Chain",
        size: { width: this.width, height: this.height, depthOrArrayLayers: 1 },
        format: "rgba16float",
        mipLevelCount: this.actualMipLevels,
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT
      });
    }
  }
  getOutputTexture() {
    return this.bloomTexture;
  }
  execute(commandEncoder, context, globalResources) {
    if (!this.enabled || !this.bloomTexture || !this.device || !this.bindGroupLayout || !this.sampler)
      return;
    this.executeInternal(commandEncoder);
  }
  inputTexture = null;
  setInputTexture(tex) {
    this.inputTexture = tex;
  }
  executeInternal(commandEncoder) {
    if (!this.inputTexture || !this.bloomTexture || !this.device || !this.bindGroupLayout || !this.sampler)
      return;
    this.ensurePipelines(this.device);
    const uniformData = new Float32Array([this.threshold, this.knee, this.intensity, 0]);
    this.device.queue.writeBuffer(this.uniformBuffer, 0, uniformData);
    const uniformBuffer = this.uniformBuffer;
    const prefilterBG = this.device.createBindGroup({
      layout: this.bindGroupLayout,
      entries: [
        { binding: 0, resource: this.inputTexture.createView() },
        { binding: 1, resource: this.sampler },
        { binding: 2, resource: { buffer: uniformBuffer } }
      ]
    });
    const pass0 = commandEncoder.beginRenderPass({
      colorAttachments: [{
        view: this.bloomTexture.createView({ baseMipLevel: 0, mipLevelCount: 1 }),
        loadOp: "clear",
        storeOp: "store"
      }]
    });
    pass0.setPipeline(this.prefilterPipeline);
    pass0.setBindGroup(0, prefilterBG);
    pass0.draw(3);
    pass0.end();
    for (let i = 0;i < this.actualMipLevels - 1; i++) {
      const inputView = this.bloomTexture.createView({ baseMipLevel: i, mipLevelCount: 1 });
      const outputView = this.bloomTexture.createView({ baseMipLevel: i + 1, mipLevelCount: 1 });
      const bg = this.device.createBindGroup({
        layout: this.bindGroupLayout,
        entries: [
          { binding: 0, resource: inputView },
          { binding: 1, resource: this.sampler },
          { binding: 2, resource: { buffer: uniformBuffer } }
        ]
      });
      const pass = commandEncoder.beginRenderPass({
        colorAttachments: [{
          view: outputView,
          loadOp: "clear",
          storeOp: "store"
        }]
      });
      pass.setPipeline(this.downsamplePipeline);
      pass.setBindGroup(0, bg);
      pass.draw(3);
      pass.end();
    }
    for (let i = this.actualMipLevels - 1;i > 0; i--) {
      const inputView = this.bloomTexture.createView({ baseMipLevel: i, mipLevelCount: 1 });
      const outputView = this.bloomTexture.createView({ baseMipLevel: i - 1, mipLevelCount: 1 });
      const bg = this.device.createBindGroup({
        layout: this.bindGroupLayout,
        entries: [
          { binding: 0, resource: inputView },
          { binding: 1, resource: this.sampler },
          { binding: 2, resource: { buffer: uniformBuffer } }
        ]
      });
      const pass = commandEncoder.beginRenderPass({
        colorAttachments: [{
          view: outputView,
          loadOp: "load",
          storeOp: "store"
        }]
      });
      pass.setPipeline(this.upsamplePipeline);
      pass.setBindGroup(0, bg);
      pass.draw(3);
      pass.end();
    }
  }
  ensurePipelines(device) {
    if (this.prefilterPipeline)
      return;
    const fullscreenVS = `
        struct VertexOutput {
            @builtin(position) position : vec4f,
            @location(0) uv : vec2f,
        }
        @vertex
        fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
            var output : VertexOutput;
            let pos = array(vec2f(-1.0, -1.0), vec2f(3.0, -1.0), vec2f(-1.0, 3.0));
            let p = pos[vertexIndex];
            output.position = vec4f(p, 0.0, 1.0);
            output.uv = p * 0.5 + 0.5;
            output.uv.y = 1.0 - output.uv.y;
            return output;
        }
      `;
    const prefilterFS = `
        @group(0) @binding(0) var inputTex : texture_2d<f32>;
        @group(0) @binding(1) var samp : sampler;
        struct Params {
            threshold: f32,
            knee: f32,
            intensity: f32,
            pad: f32,
        }
        @group(0) @binding(2) var<uniform> params : Params;
        
        @fragment
        fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {
            let color = textureSample(inputTex, samp, uv).rgb;
            
            // Thresholding (Quadratic Knee)
            let brightness = max(color.r, max(color.g, color.b));
            
            var soft = brightness - params.threshold + params.knee;
            soft = clamp(soft, 0.0, 2.0 * params.knee);
            soft = soft * soft / (4.0 * params.knee + 0.00001);
            
            var contribution = max(soft, brightness - params.threshold);
            contribution /= max(brightness, 0.00001);
            
            return vec4f(color * contribution, 1.0);
        }
      `;
    const downsampleFS = `
        @group(0) @binding(0) var inputTex : texture_2d<f32>;
        @group(0) @binding(1) var samp : sampler;
        @group(0) @binding(2) var<uniform> params : array<vec4f, 1>; // Dummy
        
        @fragment
        fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {
            // 13-tap filter (approximate) or just simple bilinear
            // Efficient chain: 4 bilinear samples
            let texSize = vec2f(textureDimensions(inputTex));
            let halfPixel = 0.5 / texSize;
            
            let c0 = textureSample(inputTex, samp, uv + vec2f(-halfPixel.x * 2.0, -halfPixel.y * 2.0)).rgb;
            let c1 = textureSample(inputTex, samp, uv + vec2f( halfPixel.x * 2.0, -halfPixel.y * 2.0)).rgb;
            let c2 = textureSample(inputTex, samp, uv + vec2f(-halfPixel.x * 2.0,  halfPixel.y * 2.0)).rgb;
            let c3 = textureSample(inputTex, samp, uv + vec2f( halfPixel.x * 2.0,  halfPixel.y * 2.0)).rgb;
            
            let c4 = textureSample(inputTex, samp, uv).rgb;
            
            let color = (c0 + c1 + c2 + c3 + c4) * 0.2;
            return vec4f(color, 1.0);
        }
      `;
    const upsampleFS = `
        @group(0) @binding(0) var inputTex : texture_2d<f32>;
        @group(0) @binding(1) var samp : sampler;
        @group(0) @binding(2) var<uniform> params : array<vec4f, 1>; // Dummy
        
        @fragment
        fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {
            // 3x3 Tent Filter
            let texSize = vec2f(textureDimensions(inputTex));
            let d = 1.0 / texSize; // Radius
            
            let c0 = textureSample(inputTex, samp, uv + vec2f(-d.x, -d.y));
            let c1 = textureSample(inputTex, samp, uv + vec2f( 0.0, -d.y));
            let c2 = textureSample(inputTex, samp, uv + vec2f( d.x, -d.y));
            
            let c3 = textureSample(inputTex, samp, uv + vec2f(-d.x, 0.0));
            let c4 = textureSample(inputTex, samp, uv + vec2f( 0.0, 0.0));
            let c5 = textureSample(inputTex, samp, uv + vec2f( d.x, 0.0));
            
            let c6 = textureSample(inputTex, samp, uv + vec2f(-d.x, d.y));
            let c7 = textureSample(inputTex, samp, uv + vec2f( 0.0, d.y));
            let c8 = textureSample(inputTex, samp, uv + vec2f( d.x, d.y));
            
            let color = (
                c0 * 1.0 + c1 * 2.0 + c2 * 1.0 +
                c3 * 2.0 + c4 * 4.0 + c5 * 2.0 +
                c6 * 1.0 + c7 * 2.0 + c8 * 1.0
            ) * (1.0 / 16.0);
            
            return color;
        }
      `;
    const primitive = { topology: "triangle-list" };
    const targets = [{ format: "rgba16float" }];
    this.prefilterPipeline = device.createRenderPipeline({
      label: "Bloom Prefilter",
      layout: device.createPipelineLayout({ bindGroupLayouts: [this.bindGroupLayout] }),
      vertex: { module: createShaderModuleSafe(device, { code: fullscreenVS }), entryPoint: "vs_main" },
      fragment: { module: createShaderModuleSafe(device, { code: prefilterFS }), entryPoint: "fs_main", targets },
      primitive
    });
    this.downsamplePipeline = device.createRenderPipeline({
      label: "Bloom Downsample",
      layout: device.createPipelineLayout({ bindGroupLayouts: [this.bindGroupLayout] }),
      vertex: { module: createShaderModuleSafe(device, { code: fullscreenVS }), entryPoint: "vs_main" },
      fragment: { module: createShaderModuleSafe(device, { code: downsampleFS }), entryPoint: "fs_main", targets },
      primitive
    });
    this.upsamplePipeline = device.createRenderPipeline({
      label: "Bloom Upsample",
      layout: device.createPipelineLayout({ bindGroupLayouts: [this.bindGroupLayout] }),
      vertex: { module: createShaderModuleSafe(device, { code: fullscreenVS }), entryPoint: "vs_main" },
      fragment: {
        module: createShaderModuleSafe(device, { code: upsampleFS }),
        entryPoint: "fs_main",
        targets: [{
          format: "rgba16float",
          blend: {
            color: { srcFactor: "one", dstFactor: "one", operation: "add" },
            alpha: { srcFactor: "one", dstFactor: "one", operation: "add" }
          }
        }]
      },
      primitive
    });
  }
}

// ../../src/core/renderer/SSRPass.ts
class SSRPass {
  device = null;
  ssrTexture = null;
  enabled = false;
  stepSize = 0.5;
  maxSteps = 64;
  binarySearchSteps = 8;
  thickness = 0.5;
  tracePipeline = null;
  compositePipeline = null;
  bindGroupLayout = null;
  compositeLayout = null;
  sampler = null;
  depthSampler = null;
  gBuffer;
  constructor(gBuffer) {
    this.gBuffer = gBuffer;
  }
  init(device, context, presentationFormat) {
    this.device = device;
    this.sampler = device.createSampler({
      minFilter: "linear",
      magFilter: "linear",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    });
    this.depthSampler = device.createSampler({
      minFilter: "nearest",
      magFilter: "nearest",
      mipmapFilter: "nearest",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    });
    this.bindGroupLayout = device.createBindGroupLayout({
      label: "SSR Trace Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "depth" } },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 3, visibility: GPUShaderStage.FRAGMENT, sampler: {} },
        { binding: 4, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
        { binding: 5, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
        { binding: 6, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 7, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "non-filtering" } }
      ]
    });
    this.compositeLayout = device.createBindGroupLayout({
      label: "SSR Composite Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, sampler: {} }
      ]
    });
  }
  resize(width, height) {
    if (width <= 0 || height <= 0)
      return;
    if (this.device) {
      if (this.ssrTexture)
        this.ssrTexture.destroy();
      this.ssrTexture = this.device.createTexture({
        label: "SSR Result",
        size: { width, height, depthOrArrayLayers: 1 },
        format: "rgba16float",
        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT
      });
    }
  }
  getOutputTexture() {
    return this.ssrTexture;
  }
  inputTexture = null;
  setInputTexture(tex) {
    this.inputTexture = tex;
  }
  execute(commandEncoder, context, globalResources) {
    if (!this.enabled || !this.inputTexture || !this.ssrTexture || !this.device || !this.bindGroupLayout || !this.sampler)
      return;
    if (!globalResources.sceneUniforms?.buffer)
      return;
    const sceneUniformBuffer = globalResources.sceneUniforms.buffer;
    this.ensurePipelines(this.device);
    const paramsData = new Float32Array([
      this.maxSteps,
      this.stepSize,
      this.thickness,
      0
    ]);
    const paramsBuffer = this.device.createBuffer({
      size: 16,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
      mappedAtCreation: true
    });
    new Float32Array(paramsBuffer.getMappedRange()).set(paramsData);
    paramsBuffer.unmap();
    const traceBG = this.device.createBindGroup({
      layout: this.bindGroupLayout,
      entries: [
        { binding: 0, resource: this.gBuffer.normalTexture.createView() },
        { binding: 1, resource: this.gBuffer.depthTexture.createView({ aspect: "depth-only" }) },
        { binding: 2, resource: this.inputTexture.createView() },
        { binding: 3, resource: this.sampler },
        { binding: 4, resource: { buffer: sceneUniformBuffer } },
        { binding: 5, resource: { buffer: paramsBuffer } },
        { binding: 6, resource: this.gBuffer.albedoTexture.createView() },
        { binding: 7, resource: this.depthSampler }
      ]
    });
    const pass = commandEncoder.beginRenderPass({
      label: "SSR Trace",
      colorAttachments: [{
        view: this.ssrTexture.createView(),
        loadOp: "clear",
        storeOp: "store",
        clearValue: { r: 0, g: 0, b: 0, a: 0 }
      }]
    });
    pass.setPipeline(this.tracePipeline);
    pass.setBindGroup(0, traceBG);
    pass.draw(3);
    pass.end();
    const compBG = this.device.createBindGroup({
      layout: this.compositeLayout,
      entries: [
        { binding: 0, resource: this.ssrTexture.createView() },
        { binding: 1, resource: this.sampler }
      ]
    });
    const compPass = commandEncoder.beginRenderPass({
      label: "SSR Composite",
      colorAttachments: [{
        view: this.inputTexture.createView(),
        loadOp: "load",
        storeOp: "store"
      }]
    });
    compPass.setPipeline(this.compositePipeline);
    compPass.setBindGroup(0, compBG);
    compPass.draw(3);
    compPass.end();
  }
  ensurePipelines(device) {
    if (this.tracePipeline)
      return;
    const fullscreenVS = `
        struct VertexOutput {
            @builtin(position) position : vec4f,
            @location(0) uv : vec2f,
        }
        @vertex
        fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
            var output : VertexOutput;
            let pos = array(vec2f(-1.0, -1.0), vec2f(3.0, -1.0), vec2f(-1.0, 3.0));
            let p = pos[vertexIndex];
            output.position = vec4f(p, 0.0, 1.0);
            output.uv = p * 0.5 + 0.5;
            output.uv.y = 1.0 - output.uv.y;
            return output;
        }
      `;
    const traceFS = `
        @group(0) @binding(0) var normalTex : texture_2d<f32>;
        @group(0) @binding(1) var depthTex : texture_depth_2d;
        @group(0) @binding(2) var sceneColorTex : texture_2d<f32>;
        @group(0) @binding(3) var samp : sampler;
        
        struct SceneUniforms {
            viewMatrix : mat4x4<f32>,
            projectionMatrix : mat4x4<f32>,
            lightViewProj : mat4x4<f32>,
            prevViewProj : mat4x4<f32>,
            inverseProjectionMatrix : mat4x4<f32>,
            cameraPosition : vec3f, 
            time : f32,
            // ...
        }
        @group(0) @binding(4) var<uniform> scene : SceneUniforms;
        
        struct SSRParams {
            maxSteps: f32,
            stepSize: f32,
            thickness: f32,
            pad: f32,
        }
        @group(0) @binding(5) var<uniform> params : SSRParams;
        @group(0) @binding(6) var albedoTex : texture_2d<f32>;
        @group(0) @binding(7) var depthSamp : sampler;

        fn getViewPosition(uv: vec2f, depth: f32) -> vec3f {
            let clipXY = vec2f(uv.x * 2.0 - 1.0, (1.0 - uv.y) * 2.0 - 1.0);
            let clipPos = vec4f(clipXY, depth, 1.0);
            let viewPos = scene.inverseProjectionMatrix * clipPos;
            return viewPos.xyz / viewPos.w;
        }
        
        @fragment
        fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {
             let depth = textureSampleLevel(depthTex, depthSamp, uv, 0);
             if (depth >= 1.0) { return vec4f(0.0); } // Sky
             
             let rawNormal = textureSampleLevel(normalTex, samp, uv, 0.0);
             let N = normalize(rawNormal.xyz * 2.0 - 1.0);
             let metallic = rawNormal.a;
             
             let albedoSample = textureSampleLevel(albedoTex, samp, uv, 0.0);
             let roughness = albedoSample.a;

             if (roughness > 0.8) { return vec4f(0.0); }
             
             let viewNormal = normalize((scene.viewMatrix * vec4f(N, 0.0)).xyz);
             let viewPos = getViewPosition(uv, depth);
             let viewDir = normalize(viewPos); 
             
             let reflectionDir = normalize(reflect(viewDir, viewNormal));
             
             var currentPos = viewPos;
             let stepSize = params.stepSize;
             let maxSteps = i32(params.maxSteps);
             
             var hit = false;
             var hitUV = vec2f(0.0);
             
             // Simple jitter
             let jitter = fract(sin(dot(uv, vec2f(12.9898, 78.233))) * 43758.5453);
             currentPos += reflectionDir * stepSize * jitter;
             
             for (var i = 0; i < maxSteps; i++) {
                 currentPos += reflectionDir * stepSize;
                 
                 let projected = scene.projectionMatrix * vec4f(currentPos, 1.0);
                 let projectedPos = projected.xyz / projected.w;
                 let screenUV = vec2f(projectedPos.x, -projectedPos.y) * 0.5 + 0.5;
                 
                 if (screenUV.x < 0.0 || screenUV.x > 1.0 || screenUV.y < 0.0 || screenUV.y > 1.0) {
                     break;
                 }
                 
                 // Fixed: textureSampleLevel with 0 (integer) and depthSamp
                 let sampleDepth = textureSampleLevel(depthTex, depthSamp, screenUV, 0);
                 let sampleViewPos = getViewPosition(screenUV, sampleDepth);
                 let sampleZ = sampleViewPos.z;
                 
                 let delta = currentPos.z - sampleZ; 
                 if (delta < 0.0 && delta > -params.thickness) {
                     hit = true;
                     hitUV = screenUV;
                     
                     // Binary Search
                     currentPos -= reflectionDir * stepSize;
                     let halfStep = stepSize * 0.5;
                     
                     for (var j = 0; j < 4; j++) {
                         currentPos += reflectionDir * halfStep;
                         
                         let p = scene.projectionMatrix * vec4f(currentPos, 1.0);
                         let pPos = p.xyz / p.w;
                         let sUV = vec2f(pPos.x, -pPos.y) * 0.5 + 0.5;
                         
                         let sDepth = textureSampleLevel(depthTex, depthSamp, sUV, 0);
                         let sViewPos = getViewPosition(sUV, sDepth);
                         
                         if (currentPos.z < sViewPos.z) {
                             // Still behind surface, move back
                             currentPos -= reflectionDir * halfStep;
                         }
                         // Else in front, move forward (implicit in loop start)
                     }
                     
                     // Final UV
                     let finalP = scene.projectionMatrix * vec4f(currentPos, 1.0);
                     let finalPos = finalP.xyz / finalP.w;
                     hitUV = vec2f(finalPos.x, -finalPos.y) * 0.5 + 0.5;
                     
                     break; 
                 }
             }
             
             if (hit) {
                 // Edge Fade
                 let x = 2.0 * abs(hitUV.x - 0.5);
                 let y = 2.0 * abs(hitUV.y - 0.5);
                 var screenFade = 1.0 - max(x, y);
                 screenFade = clamp(screenFade * 10.0, 0.0, 1.0);
                 
                 // Roughness Fade
                 let roughnessFade = 1.0 - roughness;
                 
                 let color = textureSampleLevel(sceneColorTex, samp, hitUV, 0.0).rgb;
                 
                 // Mix with Metallic/Fresnel approximation
                 let reflectionIntensity = 0.5 * screenFade * roughnessFade; 
                 
                 return vec4f(color * reflectionIntensity, 1.0);
             }
             
             return vec4f(0.0);
        }
      `;
    const compositeFS = `
        @group(0) @binding(0) var ssrTex : texture_2d<f32>;
        @group(0) @binding(1) var samp : sampler;
        
        @fragment
        fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {
            let ssr = textureSample(ssrTex, samp, uv);
            return ssr; // Additive blend will add this to target
        }
      `;
    const primitive = { topology: "triangle-list" };
    const targets = [{ format: "rgba16float" }];
    const compositeTargets = [{
      format: "rgba16float",
      blend: {
        color: { srcFactor: "one", dstFactor: "one", operation: "add" },
        alpha: { srcFactor: "one", dstFactor: "one", operation: "add" }
      }
    }];
    this.tracePipeline = device.createRenderPipeline({
      label: "SSR Trace Pipeline",
      layout: device.createPipelineLayout({ bindGroupLayouts: [this.bindGroupLayout] }),
      vertex: { module: createShaderModuleSafe(device, { code: fullscreenVS }), entryPoint: "vs_main" },
      fragment: { module: createShaderModuleSafe(device, { code: traceFS }), entryPoint: "fs_main", targets },
      primitive
    });
    this.compositePipeline = device.createRenderPipeline({
      label: "SSR Composite Pipeline",
      layout: device.createPipelineLayout({ bindGroupLayouts: [this.compositeLayout] }),
      vertex: { module: createShaderModuleSafe(device, { code: fullscreenVS }), entryPoint: "vs_main" },
      fragment: { module: createShaderModuleSafe(device, { code: compositeFS }), entryPoint: "fs_main", targets: compositeTargets },
      primitive
    });
  }
}

// ../../src/core/renderer/shaders/AtmosphereCompute.ts
var Uniforms = `
@group(0) @binding(0) var<uniform> atmosphere : AtmosphereUniforms;
`;
var AtmosphereTransmittanceCompute = `
${AtmosphereCommonWGSL}
${Uniforms}

@group(0) @binding(1) var transmittance_write : texture_storage_2d<rgba32float, write>;

@compute @workgroup_size(8, 8, 1)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    if (global_id.x >= u32(TRANSMITTANCE_TEXTURE_WIDTH) || global_id.y >= u32(TRANSMITTANCE_TEXTURE_HEIGHT)) {
        return;
    }
    
    let result = ComputeTransmittanceToTopAtmosphereBoundaryTexture(global_id);
    textureStore(transmittance_write, vec2<i32>(global_id.xy), vec4f(result, 1.0));
}
`;
var AtmosphereSingleScatteringCompute = `
${AtmosphereCommonWGSL}
${Uniforms}

@group(0) @binding(1) var transmittance_read : texture_2d<f32>;
@group(0) @binding(2) var transmittance_sampler : sampler;
@group(0) @binding(3) var scattering_write : texture_storage_3d<rgba32float, write>;

@compute @workgroup_size(8, 8, 1)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    // Dimensions: 256 x 128 x 32
    if (global_id.x >= 256u || global_id.y >= 128u || global_id.z >= 32u) {
        return;
    }
    
    let result = ComputeSingleScatteringTexture(transmittance_read, transmittance_sampler, vec3f(f32(global_id.x) + 0.5, f32(global_id.y) + 0.5, f32(global_id.z) + 0.5));
    textureStore(scattering_write, vec3<i32>(global_id.xyz), result);
}
`;

// ../../src/core/renderer/shaders/AtmosphereRaymarch.ts
var AtmosphereRaymarch = `
${AtmosphereCommonWGSL}

@group(0) @binding(0) var<uniform> atmosphere : AtmosphereUniforms;

// Bindings
// Group 0: Uniforms (Atmosphere)
// Group 1: Textures
@group(1) @binding(0) var transmittance_tex : texture_2d<f32>;
@group(1) @binding(1) var transmittance_samp : sampler;
@group(1) @binding(2) var multiscattering_tex : texture_2d<f32>;
@group(1) @binding(3) var multiscattering_samp : sampler;

// Output
@group(2) @binding(0) var output_tex : texture_storage_2d<rgba32float, write>;

// --- Raymarching Constants ---
const MULTISCAT_STEPS = 20.0;
const SKYVIEW_STEPS = 30.0;

struct MediumSampleRGB {
    scattering: vec3f,
    absorption: vec3f,
    extinction: vec3f,
    scatteringMie: vec3f,
    absorptionMie: vec3f,
    extinctionMie: vec3f,
    scatteringRay: vec3f,
    absorptionRay: f32, 
    extinctionRay: vec3f,
    scatteringOzo: f32,
    absorptionOzo: vec3f,
    extinctionOzo: vec3f,
    albedo: vec3f,
}

fn sampleMediumRGB(WorldPos: vec3f) -> MediumSampleRGB {
    let viewHeight = length(WorldPos) - atmosphere.bottom_radius;
    let densityMie = GetProfileDensity(GetMieDensityProfile(), viewHeight);
    let densityRay = GetProfileDensity(GetRayleighDensityProfile(), viewHeight);
    let densityOzo = GetProfileDensity(GetAbsorptionDensityProfile(), viewHeight); // Absorption profile handles ozone layers

    var s: MediumSampleRGB;
    s.scatteringMie = densityMie * atmosphere.mie_scattering;
    s.absorptionMie = densityMie * atmosphere.mie_absorption;
    s.extinctionMie = densityMie * atmosphere.mie_extinction;
    
    s.scatteringRay = densityRay * atmosphere.rayleigh_scattering;
    s.absorptionRay = 0.0;
    s.extinctionRay = s.scatteringRay; 
    
    s.scatteringOzo = 0.0;
    s.absorptionOzo = densityOzo * atmosphere.absorption_extinction;
    s.extinctionOzo = s.absorptionOzo;
    
    s.scattering = s.scatteringMie + s.scatteringRay;
    s.absorption = s.absorptionMie + s.absorptionOzo;
    s.extinction = s.extinctionMie + s.extinctionRay + s.extinctionOzo;
    
    // Albedo
    s.albedo = s.scattering / max(vec3f(0.001), s.extinction);
    
    return s;
}

// Raymarching for both MultiScattering and SkyView
// Modes:
// 0: SkyView (Full)
// 1: MultiScattering (Isotropic Phase, 2nd Order)
fn IntegrateScatteredLuminance(
    pixPos: vec2f,
    WorldPos: vec3f,
    WorldDir: vec3f,
    SunDir: vec3f,
    sampleCount: f32,
    variableSampleCount: bool,
    useMiePhase: bool,
    mode: u32
) -> vec3f {
    var L = vec3f(0.0);
    var throughput = vec3f(1.0);
    var opticalDepth = vec3f(0.0);
    var t = 0.0;
    var tPrev = 0.0;

    // Intersections
    let tBottom = raySphereIntersectNearest(WorldPos, WorldDir, vec3f(0.0), atmosphere.bottom_radius);
    let tTop = raySphereIntersectNearest(WorldPos, WorldDir, vec3f(0.0), atmosphere.top_radius);

    var tMax = 0.0;
    var hitsGround = false;
    if (tBottom < 0.0) {
        if (tTop < 0.0) { return vec3f(0.0); }
        tMax = tTop;
    } else {
        if (tTop > 0.0) {
            tMax = min(tTop, tBottom);
            hitsGround = tBottom < tTop;
        }
    }

    let dt = tMax / sampleCount;

    let cosTheta = dot(WorldDir, SunDir);

    // Use Cornette-Shanks for more accurate Mie phase (better sunset colors)
    let miePhaseValue = CornetteShanksPhaseFunction(atmosphere.mie_phase_function_g, -cosTheta);
    let rayleighPhaseValue = RayleighPhaseFunction(cosTheta);
    let uniformPhase = 1.0 / (4.0 * PI);

    // Global illuminance factor
    let globalL = vec3f(1.0);

    // Track accumulated optical depth for ground contribution
    var accumulatedOpticalDepth = vec3f(0.0);

    for (var s = 0.0; s < sampleCount; s += 1.0) {
        let newT = tMax * (s + 0.3) / sampleCount; // SampleSegmentT = 0.3
        let dt_step = newT - t;
        t = newT;

        let P = WorldPos + t * WorldDir;
        let medium = sampleMediumRGB(P);
        let sampleOpticalDepth = medium.extinction * dt_step;
        let sampleTransmittance = exp(-sampleOpticalDepth);
        accumulatedOpticalDepth += sampleOpticalDepth;

        let pHeight = length(P);
        let upVector = P / pHeight;
        let sunZenithCosAngle = dot(SunDir, upVector);
        let uv = GetTransmittanceTextureUvFromRMu(pHeight, sunZenithCosAngle);
        let transmittanceToSun = textureSampleLevel(transmittance_tex, transmittance_samp, uv, 0.0).rgb;

        var phaseTimesScattering = vec3f(0.0);
        if (useMiePhase) {
            phaseTimesScattering = medium.scatteringMie * miePhaseValue + medium.scatteringRay * rayleighPhaseValue;
        } else {
            phaseTimesScattering = medium.scattering * uniformPhase;
        }

        // Multi-scattering (Approximation from LUT)
        // If mode == 1, we are computing the LUT, so we don't sample it (2nd order only).
        // If mode == 0, we sample it.
        var multiScatteredLuminance = vec3f(0.0);
        if (mode == 0u) {
             let ms_uv = vec2f(fromUnitToSubUvs(sunZenithCosAngle * 0.5 + 0.5, 32.0),
                               fromUnitToSubUvs((pHeight - atmosphere.bottom_radius) / (atmosphere.top_radius - atmosphere.bottom_radius), 32.0));
             multiScatteredLuminance = textureSampleLevel(multiscattering_tex, multiscattering_samp, ms_uv, 0.0).rgb;
        }

        // Earth Shadow (Simple check)
        let tEarth = raySphereIntersectNearest(P, SunDir, vec3f(0.0), atmosphere.bottom_radius);
        let earthShadow = select(1.0, 0.0, tEarth >= 0.0);

        let S = globalL * (earthShadow * transmittanceToSun * phaseTimesScattering + multiScatteredLuminance * medium.scattering);

        // Integrate using improved numerical integration
        // This handles the case when extinction approaches zero more stably
        let extinctionMag = max(0.0001, (medium.extinction.r + medium.extinction.g + medium.extinction.b) / 3.0);
        let Sint = (S - S * sampleTransmittance) / max(medium.extinction, vec3f(0.0001));
        L += throughput * Sint;
        throughput *= sampleTransmittance;

        tPrev = t;
    }

    // If ground hit, add ground reflection with improved lighting
    if (mode == 0u && hitsGround && tBottom > 0.0) {
        let P = WorldPos + tBottom * WorldDir;
        let pHeight = length(P);
        let upVector = P / pHeight;
        let sunZenithCosAngle = dot(SunDir, upVector);
        let uv = GetTransmittanceTextureUvFromRMu(pHeight, sunZenithCosAngle);
        let transmittanceToSun = textureSampleLevel(transmittance_tex, transmittance_samp, uv, 0.0).rgb;

        // Direct sun contribution
        let NdotL = max(0.0, dot(upVector, SunDir));
        let directGroundLight = transmittanceToSun * NdotL;

        // Multi-scattering contribution to ground (ambient sky light on ground)
        let ms_uv = vec2f(fromUnitToSubUvs(sunZenithCosAngle * 0.5 + 0.5, 32.0),
                          fromUnitToSubUvs(0.0, 32.0)); // At ground level
        let groundMultiScatter = textureSampleLevel(multiscattering_tex, multiscattering_samp, ms_uv, 0.0).rgb;

        // Combine direct and ambient ground lighting
        let groundIrradiance = directGroundLight + groundMultiScatter * 0.5;

        // Lambertian reflection with proper normalization
        L += globalL * groundIrradiance * throughput * atmosphere.ground_albedo / PI;
    }

    // For multi-scattering LUT, include ground contribution
    if (mode == 1u) {
        // Add ground-reflected contribution to multi-scattering
        // This creates realistic sky brightening from ground bounce
        let groundNormal = vec3f(0.0, 1.0, 0.0);
        let groundSunCos = max(0.0, dot(groundNormal, SunDir));
        let groundUv = GetTransmittanceTextureUvFromRMu(atmosphere.bottom_radius, dot(groundNormal, SunDir));
        let groundTransmittance = textureSampleLevel(transmittance_tex, transmittance_samp, groundUv, 0.0).rgb;

        // Ground contribution (isotropic reflection weighted by ground albedo)
        let groundContrib = atmosphere.ground_albedo * groundTransmittance * groundSunCos * throughput * 0.5;
        L += groundContrib;

        return L * 4.0 * PI; // Normalize for isotropic phase integration
    }

    return L;
}

// Compute Shaders

// MultiScattering LUT (32x32)
// Dispatch (32, 32, 1)
@compute @workgroup_size(1, 1, 1)
fn computeMultiScattering(@builtin(global_invocation_id) id: vec3u) {
    let size = vec2f(32.0, 32.0);
    let uv = (vec2f(id.xy) + 0.5) / size;
    
    let cosSunZenithAngle = uv.x * 2.0 - 1.0;
    let sunDir = vec3f(0.0, sqrt(clamp(1.0 - cosSunZenithAngle * cosSunZenithAngle, 0.0, 1.0)), cosSunZenithAngle);
    
    let viewHeight = atmosphere.bottom_radius + uv.y * (atmosphere.top_radius - atmosphere.bottom_radius);
    
    let worldPos = vec3f(0.0, 0.0, viewHeight);
    let worldDir = vec3f(0.0, 0.0, 1.0); // Zenital view for 2nd order integration
    
    // We actually need to integrate over the sphere. The reference uses 64 threads (Z) to integrate.
    // Simplifying: Just raymarch Up? No, 2nd order is isotropic approximation.
    // For simplicity in Phase 3, I'll assume we can skip complex integration and just sample Up?
    // Reference NewMultiScattCS integrates 64 directions.
    // Let's implement a simplified version: sample 20 directions? Or just use Isotropic assumption?
    // If we assume isotropic, gathering from all directions = integrating uniform phase.
    
    // Let's stick to simple raymarch Up for now, scaling by geometric factor?
    // Actually, MultiScat LUT is about transfer factor.
    // Let's leave MultiScat basic implementation: Raymarch Up.
    
    let L = IntegrateScatteredLuminance(uv, worldPos, worldDir, sunDir, 20.0, false, false, 1u);
    
    // Store
    textureStore(output_tex, vec2i(id.xy), vec4f(L, 1.0));
}

    // SkyView LUT (192x108)

// Dispatch (192, 108, 1)

@compute @workgroup_size(8, 8, 1)

fn computeSkyView(@builtin(global_invocation_id) id: vec3u) {

    if (id.x >= 192u || id.y >= 108u) { return; }

    

    let size = vec2f(192.0, 108.0);

    let pixPos = vec2f(id.xy) + 0.5;

    let uv = pixPos / size;



    // We assume the LUT is generated for a camera at (0, viewHeight, 0) relative to planet center

    // But we need to handle the actual relative orientation of Sun vs Camera.

    // The LUT parameterizes the sky relative to Zenith and Sun.

    // So we can simulate a canonical camera frame where Up is Z (or Y), and Sun is in XZ plane?



    // Compute view height (distance from planet center)
    // Clamp to minimum of bottomRadius + 10m to prevent math issues when camera is underground
    let rawViewHeight = length(atmosphere.camera_position + vec3f(0.0, atmosphere.bottom_radius, 0.0));
    let viewHeight = max(rawViewHeight, atmosphere.bottom_radius + 10.0);

    

    let worldPos = vec3f(0.0, viewHeight, 0.0); // Canonical Up = Y

    

    let params = UvToSkyViewLutParams(uv, viewHeight);

    let viewZenithCosAngle = params.x;

    let lightViewCosAngle = params.y;

    

    // Construct SunDir in this canonical frame
    // Up is (0, 1, 0).
    let upVector = vec3f(0.0, 1.0, 0.0);
    
    // Actual Sun Zenith (from Uniforms)
    let actualSunDir = normalize(atmosphere.sun_direction);
    
    let sunZenithCosAngle = dot(upVector, actualSunDir);
    let sunDirLocal = normalize(vec3f(sqrt(max(0.0, 1.0 - sunZenithCosAngle * sunZenithCosAngle)), sunZenithCosAngle, 0.0));
    
    let viewZenithSinAngle = sqrt(max(0.0, 1.0 - viewZenithCosAngle * viewZenithCosAngle));
    
    let worldDir = normalize(vec3f(
        viewZenithSinAngle * lightViewCosAngle,
        viewZenithCosAngle,
        viewZenithSinAngle * sqrt(max(0.0, 1.0 - lightViewCosAngle * lightViewCosAngle))
    ));
    
    let L = IntegrateScatteredLuminance(pixPos, worldPos, worldDir, sunDirLocal, SKYVIEW_STEPS, true, true, 0u);
    
    textureStore(output_tex, vec2i(id.xy), vec4f(L, 1.0));
}



`;

// ../../src/core/renderer/shaders/CloudNoiseCompute.ts
var CloudNoiseCompute = `
// Enhanced Tiling 3D Cloud Noise Generator
// Stores: R=base shape, G=detail erosion, B=curl/wispy, A=coverage variation

@group(0) @binding(0) var noiseTexture : texture_storage_3d<rgba8unorm, write>;

// High quality hash function
fn hash31(p: vec3f) -> f32 {
    var p3 = fract(p * 0.1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

fn hash33(p: vec3f) -> vec3f {
    var p3 = fract(p * vec3f(0.1031, 0.1030, 0.0973));
    p3 += dot(p3, p3.yxz + 33.33);
    return fract((p3.xxy + p3.yxx) * p3.zyx);
}

// Value Noise with quintic interpolation (smoother than cubic)
fn noise(x: vec3f, period: f32) -> f32 {
    let i = floor(x);
    let f = fract(x);
    // Quintic interpolation for smoother gradients (reduces banding)
    let u = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);

    // Wrap grid coordinates for tiling
    let p000 = (i + vec3f(0,0,0)) % period;
    let p100 = (i + vec3f(1,0,0)) % period;
    let p010 = (i + vec3f(0,1,0)) % period;
    let p110 = (i + vec3f(1,1,0)) % period;
    let p001 = (i + vec3f(0,0,1)) % period;
    let p101 = (i + vec3f(1,0,1)) % period;
    let p011 = (i + vec3f(0,1,1)) % period;
    let p111 = (i + vec3f(1,1,1)) % period;

    return mix(mix(mix( hash31(p000), hash31(p100), u.x),
                   mix( hash31(p010), hash31(p110), u.x), u.y),
               mix(mix( hash31(p001), hash31(p101), u.x),
                   mix( hash31(p011), hash31(p111), u.x), u.y), u.z);
}

// Worley/Cellular noise for cloud edges
fn worley(x: vec3f, period: f32) -> f32 {
    let i = floor(x);
    let f = fract(x);

    var minDist = 1.0;

    for (var z = -1; z <= 1; z++) {
        for (var y = -1; y <= 1; y++) {
            for (var xx = -1; xx <= 1; xx++) {
                let neighbor = vec3f(f32(xx), f32(y), f32(z));
                let cellPos = (i + neighbor) % period;
                let point = hash33(cellPos);
                let diff = neighbor + point - f;
                let dist = dot(diff, diff);
                minDist = min(minDist, dist);
            }
        }
    }

    return sqrt(minDist);
}

// FBM (Fractal Brownian Motion) with persistence
fn fbm(p: vec3f, period: f32, octaves: i32) -> f32 {
    var value = 0.0;
    var amplitude = 0.5;
    var frequency = 1.0;
    var maxValue = 0.0;

    for (var i = 0; i < octaves; i++) {
        value += amplitude * noise(p * frequency, period * frequency);
        maxValue += amplitude;
        amplitude *= 0.5;
        frequency *= 2.0;
    }

    return value / maxValue;
}

// "Billowy" Noise for puffy cloud shapes
fn billowyNoise(x: vec3f, period: f32) -> f32 {
    let n = noise(x, period);
    return abs(n * 2.0 - 1.0);
}

// Ridged noise for wispy details
fn ridgedNoise(x: vec3f, period: f32) -> f32 {
    let n = noise(x, period);
    return 1.0 - abs(n * 2.0 - 1.0);
}

// Curl-like noise for wispy tendrils
fn curlNoise(p: vec3f, period: f32) -> f32 {
    let eps = 0.01;

    let n1 = noise(p + vec3f(eps, 0.0, 0.0), period);
    let n2 = noise(p - vec3f(eps, 0.0, 0.0), period);
    let n3 = noise(p + vec3f(0.0, eps, 0.0), period);
    let n4 = noise(p - vec3f(0.0, eps, 0.0), period);
    let n5 = noise(p + vec3f(0.0, 0.0, eps), period);
    let n6 = noise(p - vec3f(0.0, 0.0, eps), period);

    // Pseudo curl magnitude
    let dx = n1 - n2;
    let dy = n3 - n4;
    let dz = n5 - n6;

    return length(vec3f(dx, dy, dz)) * 10.0;
}

@compute @workgroup_size(8, 8, 4)
fn main(@builtin(global_invocation_id) global_id : vec3u) {
    let dims = vec3u(128, 128, 128);
    if (any(global_id >= dims)) { return; }

    // Normalized coordinates 0-1
    let uvw = vec3f(global_id) / vec3f(dims);

    // ============================================
    // R Channel: Base Cloud Shape (Low Frequency)
    // ============================================
    // Use Perlin-Worley combination for better cloud shapes
    let perlin = fbm(uvw * 4.0, 4.0, 4);
    let worleyVal = 1.0 - worley(uvw * 4.0, 4.0);

    // Remap Perlin-Worley: clouds have sharp edges from Worley, soft interiors from Perlin
    var baseShape = perlin * 0.625 + worleyVal * 0.375;

    // Add medium frequency detail
    baseShape = baseShape * 0.8 + fbm(uvw * 8.0, 8.0, 3) * 0.2;

    // Apply subtle shaping curve
    baseShape = smoothstep(0.25, 0.75, baseShape);

    // ============================================
    // G Channel: Detail/Erosion (High Frequency)
    // ============================================
    // High frequency billowy noise to erode cloud edges
    var detail = billowyNoise(uvw * 16.0, 16.0) * 0.5;
    detail += billowyNoise(uvw * 32.0, 32.0) * 0.35;
    detail += billowyNoise(uvw * 64.0, 64.0) * 0.15;

    // Add some Worley for edge definition
    let worleyDetail = 1.0 - worley(uvw * 16.0, 16.0);
    detail = detail * 0.7 + worleyDetail * 0.3;

    // ============================================
    // B Channel: Curl/Wispy Tendrils
    // ============================================
    var wispy = curlNoise(uvw * 8.0, 8.0);
    wispy += ridgedNoise(uvw * 24.0, 24.0) * 0.5;
    wispy = clamp(wispy, 0.0, 1.0);

    // ============================================
    // A Channel: Coverage Variation
    // ============================================
    // Large scale variation for cloud clusters
    var coverage = fbm(uvw * 2.0, 2.0, 3);
    coverage = smoothstep(0.3, 0.7, coverage);

    textureStore(noiseTexture, global_id, vec4f(baseShape, detail, wispy, coverage));
}
`;

// ../../src/core/renderer/AtmospherePass.ts
class AtmospherePass {
  transmittancePipeline = null;
  scatteringPipeline = null;
  multiScatteringPipeline = null;
  skyViewPipeline = null;
  cloudNoisePipeline = null;
  sampler = null;
  transmittanceTexture = null;
  scatteringTexture = null;
  multiScatteringTexture = null;
  irradianceTexture = null;
  skyViewTexture = null;
  cloudNoiseTexture = null;
  transmittanceBindGroup = null;
  scatteringBindGroup = null;
  cloudNoiseBindGroup = null;
  dirty = true;
  noiseDirty = true;
  TRANSMITTANCE_W = 256;
  TRANSMITTANCE_H = 64;
  SCATTERING_R = 32;
  SCATTERING_MU = 128;
  SCATTERING_MU_S = 32;
  SCATTERING_NU = 8;
  get SCATTERING_W() {
    return this.SCATTERING_NU * this.SCATTERING_MU_S;
  }
  get SCATTERING_H() {
    return this.SCATTERING_MU;
  }
  get SCATTERING_D() {
    return this.SCATTERING_R;
  }
  IRRADIANCE_W = 64;
  IRRADIANCE_H = 16;
  MULTISCAT_W = 32;
  MULTISCAT_H = 32;
  SKYVIEW_W = 192;
  SKYVIEW_H = 108;
  constructor() {}
  init(device, context, presentationFormat) {
    this.device = device;
    this.sampler = device.createSampler({
      minFilter: "nearest",
      magFilter: "nearest",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge",
      addressModeW: "clamp-to-edge"
    });
    this.transmittanceTexture = device.createTexture({
      label: "Transmittance LUT",
      size: [this.TRANSMITTANCE_W, this.TRANSMITTANCE_H, 1],
      format: "rgba32float",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING
    });
    this.scatteringTexture = device.createTexture({
      label: "Scattering LUT",
      size: [this.SCATTERING_W, this.SCATTERING_H, this.SCATTERING_D],
      dimension: "3d",
      format: "rgba32float",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING
    });
    this.multiScatteringTexture = device.createTexture({
      label: "MultiScattering LUT",
      size: [this.MULTISCAT_W, this.MULTISCAT_H, 1],
      format: "rgba32float",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING
    });
    this.irradianceTexture = device.createTexture({
      label: "Irradiance LUT",
      size: [this.IRRADIANCE_W, this.IRRADIANCE_H, 1],
      format: "rgba32float",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING
    });
    this.skyViewTexture = device.createTexture({
      label: "SkyView LUT",
      size: [this.SKYVIEW_W, this.SKYVIEW_H, 1],
      format: "rgba32float",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING
    });
    this.cloudNoiseTexture = device.createTexture({
      label: "Cloud Noise 3D",
      size: [128, 128, 128],
      dimension: "3d",
      format: "rgba8unorm",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.STORAGE_BINDING
    });
    this.placeholderTexture = device.createTexture({
      label: "Atmosphere Placeholder",
      size: [1, 1, 1],
      format: "rgba32float",
      usage: GPUTextureUsage.TEXTURE_BINDING
    });
    const transmittanceLayout = device.createBindGroupLayout({
      label: "Transmittance BG Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: "uniform" } },
        { binding: 1, visibility: GPUShaderStage.COMPUTE, storageTexture: { access: "write-only", format: "rgba32float", viewDimension: "2d" } }
      ]
    });
    const transmittancePipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [transmittanceLayout] });
    this.transmittancePipeline = device.createComputePipeline({
      label: "Atmosphere Transmittance Pipeline",
      layout: transmittancePipelineLayout,
      compute: { module: createShaderModuleSafe(device, { code: AtmosphereTransmittanceCompute }), entryPoint: "main" }
    });
    const scatteringLayout = device.createBindGroupLayout({
      label: "Atmosphere Scattering Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: "uniform" } },
        { binding: 1, visibility: GPUShaderStage.COMPUTE, texture: { sampleType: "unfilterable-float", viewDimension: "2d" } },
        { binding: 2, visibility: GPUShaderStage.COMPUTE, sampler: { type: "non-filtering" } },
        { binding: 3, visibility: GPUShaderStage.COMPUTE, storageTexture: { access: "write-only", format: "rgba32float", viewDimension: "3d" } }
      ]
    });
    const scatteringPipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [scatteringLayout] });
    this.scatteringPipeline = device.createComputePipeline({
      label: "Atmosphere Scattering Pipeline",
      layout: scatteringPipelineLayout,
      compute: { module: createShaderModuleSafe(device, { code: AtmosphereSingleScatteringCompute }), entryPoint: "main" }
    });
    const raymarchModule = createShaderModuleSafe(device, { code: AtmosphereRaymarch });
    const raymarchUniformsLayout = device.createBindGroupLayout({
      entries: [{ binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: "uniform" } }]
    });
    const raymarchTexturesLayout = device.createBindGroupLayout({
      entries: [
        { binding: 0, visibility: GPUShaderStage.COMPUTE, texture: { sampleType: "unfilterable-float", viewDimension: "2d" } },
        { binding: 1, visibility: GPUShaderStage.COMPUTE, sampler: { type: "non-filtering" } },
        { binding: 2, visibility: GPUShaderStage.COMPUTE, texture: { sampleType: "unfilterable-float", viewDimension: "2d" } },
        { binding: 3, visibility: GPUShaderStage.COMPUTE, sampler: { type: "non-filtering" } }
      ]
    });
    const msOutputLayout = device.createBindGroupLayout({
      entries: [{ binding: 0, visibility: GPUShaderStage.COMPUTE, storageTexture: { access: "write-only", format: "rgba32float", viewDimension: "2d" } }]
    });
    const msPipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [raymarchUniformsLayout, raymarchTexturesLayout, msOutputLayout] });
    this.multiScatteringPipeline = device.createComputePipeline({
      label: "Atmosphere MultiScattering Pipeline",
      layout: msPipelineLayout,
      compute: { module: raymarchModule, entryPoint: "computeMultiScattering" }
    });
    const skyViewPipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [raymarchUniformsLayout, raymarchTexturesLayout, msOutputLayout] });
    this.skyViewPipeline = device.createComputePipeline({
      label: "Atmosphere SkyView Pipeline",
      layout: skyViewPipelineLayout,
      compute: { module: raymarchModule, entryPoint: "computeSkyView" }
    });
    const cloudNoiseLayout = device.createBindGroupLayout({
      entries: [{ binding: 0, visibility: GPUShaderStage.COMPUTE, storageTexture: { access: "write-only", format: "rgba8unorm", viewDimension: "3d" } }]
    });
    const cloudNoisePipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [cloudNoiseLayout] });
    this.cloudNoisePipeline = device.createComputePipeline({
      label: "Cloud Noise Pipeline",
      layout: cloudNoisePipelineLayout,
      compute: { module: createShaderModuleSafe(device, { code: CloudNoiseCompute }), entryPoint: "main" }
    });
    this.dirty = true;
    this.noiseDirty = true;
  }
  multiScatteringBindGroup0 = null;
  multiScatteringBindGroup1 = null;
  multiScatteringBindGroup2 = null;
  skyViewBindGroup0 = null;
  skyViewBindGroup1 = null;
  skyViewBindGroup2 = null;
  device = null;
  placeholderTexture = null;
  time = 0;
  resize(width, height) {}
  updateUniforms(device, buffer, config, camera) {
    const data = new Float32Array(128);
    let offset = 0;
    const setVec3 = (v) => {
      data[offset++] = v.x;
      data[offset++] = v.y;
      data[offset++] = v.z;
    };
    const setFloat = (f) => {
      data[offset++] = f;
    };
    setVec3(config.sunIlluminance);
    setFloat(config.sunDiskHalfAngle);
    setVec3(config.absorptionExtinction);
    const maxSunZenith = Math.PI * 120 / 180;
    setFloat(Math.cos(maxSunZenith));
    setVec3(config.rayleighScattering);
    setFloat(config.miePhaseG);
    setVec3(config.mieScattering);
    setFloat(config.bottomRadius);
    setVec3(config.mieExtinction);
    setFloat(config.topRadius);
    setVec3(config.mieAbsorption);
    setFloat(0);
    setVec3(config.groundAlbedo);
    setFloat(0);
    setFloat(0);
    setFloat(0);
    setFloat(0);
    setFloat(0);
    setFloat(0);
    setFloat(0);
    setFloat(1);
    setFloat(config.rayleighDensityExpScale);
    setFloat(0);
    setFloat(0);
    setFloat(0);
    setFloat(0);
    setFloat(0);
    setFloat(0);
    setFloat(0);
    setFloat(0);
    setFloat(0);
    setFloat(0);
    setFloat(1);
    setFloat(config.mieDensityExpScale);
    setFloat(0);
    setFloat(0);
    setFloat(0);
    setFloat(0);
    setFloat(config.absorptionDensity0LayerWidth);
    setFloat(0);
    setFloat(0);
    setFloat(config.absorptionDensity0LinearTerm);
    setFloat(config.absorptionDensity0ConstantTerm);
    setFloat(0);
    setFloat(0);
    setFloat(0);
    setFloat(config.absorptionDensity1LinearTerm);
    setFloat(config.absorptionDensity1ConstantTerm);
    setFloat(0);
    setFloat(0);
    setVec3(config.sunDirection);
    setFloat(0);
    setVec3(camera);
    setFloat(0);
    setFloat(config.sunDiskEnabled ? 1 : 0);
    setFloat(config.sunDiskScale);
    setFloat(0);
    setFloat(0);
    setVec3(config.moonDirection);
    setFloat(config.moonEnabled ? 1 : 0);
    setFloat(config.moonPhase);
    setFloat(config.moonScale);
    setFloat(config.moonAngularRadius);
    setFloat(0);
    setVec3(config.moonColor);
    setFloat(0);
    setFloat(config.starsEnabled ? 1 : 0);
    setFloat(config.starsIntensity);
    setFloat(config.starsTwinkle);
    setFloat(this.time);
    setFloat(config.useCustomSkybox ? 1 : 0);
    setFloat(config.customSkyboxBlend);
    setFloat(0);
    setFloat(0);
    setVec3(config.cloudColor);
    setFloat(config.cloudsEnabled ? 1 : 0);
    setVec3(config.cloudWindDirection);
    setFloat(config.cloudCoverage);
    setFloat(config.cloudAltitude);
    setFloat(config.cloudHeight);
    setFloat(config.cloudDensity);
    setFloat(config.cloudSpeed);
    const qualityMap = { low: 0, medium: 1, high: 2 };
    const uintView = new Uint32Array(data.buffer);
    uintView[offset] = qualityMap[config.cloudQuality] ?? 2;
    offset += 4;
    device.queue.writeBuffer(buffer, 0, data);
  }
  execute(commandEncoder, context, globalResources) {
    if (!context.scene.atmosphere.enabled || !this.device)
      return;
    this.time += 0.016;
    const buffer = globalResources.atmosphereUniformsBuffer;
    if (!buffer)
      return;
    if (!this.transmittanceBindGroup && this.transmittancePipeline && this.scatteringPipeline && this.multiScatteringPipeline && this.skyViewPipeline && this.transmittanceTexture && this.scatteringTexture && this.multiScatteringTexture && this.skyViewTexture && this.placeholderTexture && this.sampler) {
      this.transmittanceBindGroup = this.device.createBindGroup({
        label: "Transmittance Bind Group",
        layout: this.transmittancePipeline.getBindGroupLayout(0),
        entries: [
          { binding: 0, resource: { buffer } },
          { binding: 1, resource: this.transmittanceTexture.createView() }
        ]
      });
      this.scatteringBindGroup = this.device.createBindGroup({
        label: "Scattering Bind Group",
        layout: this.scatteringPipeline.getBindGroupLayout(0),
        entries: [
          { binding: 0, resource: { buffer } },
          { binding: 1, resource: this.transmittanceTexture.createView() },
          { binding: 2, resource: this.sampler },
          { binding: 3, resource: this.scatteringTexture.createView() }
        ]
      });
      this.multiScatteringBindGroup0 = this.device.createBindGroup({
        label: "MultiScattering Bind Group",
        layout: this.multiScatteringPipeline.getBindGroupLayout(0),
        entries: [{ binding: 0, resource: { buffer } }]
      });
      this.multiScatteringBindGroup1 = this.device.createBindGroup({
        label: "MultiScat Texture Bind Group",
        layout: this.multiScatteringPipeline.getBindGroupLayout(1),
        entries: [
          { binding: 0, resource: this.transmittanceTexture.createView() },
          { binding: 1, resource: this.sampler },
          { binding: 2, resource: this.placeholderTexture.createView() },
          { binding: 3, resource: this.sampler }
        ]
      });
      this.multiScatteringBindGroup2 = this.device.createBindGroup({
        label: "MultiScat Output Bind Group",
        layout: this.multiScatteringPipeline.getBindGroupLayout(2),
        entries: [{ binding: 0, resource: this.multiScatteringTexture.createView() }]
      });
      this.skyViewBindGroup0 = this.device.createBindGroup({
        layout: this.skyViewPipeline.getBindGroupLayout(0),
        entries: [{ binding: 0, resource: { buffer } }]
      });
      this.skyViewBindGroup1 = this.device.createBindGroup({
        layout: this.skyViewPipeline.getBindGroupLayout(1),
        entries: [
          { binding: 0, resource: this.transmittanceTexture.createView() },
          { binding: 1, resource: this.sampler },
          { binding: 2, resource: this.multiScatteringTexture.createView() },
          { binding: 3, resource: this.sampler }
        ]
      });
      this.skyViewBindGroup2 = this.device.createBindGroup({
        layout: this.skyViewPipeline.getBindGroupLayout(2),
        entries: [{ binding: 0, resource: this.skyViewTexture.createView() }]
      });
      if (this.cloudNoisePipeline && this.cloudNoiseTexture) {
        this.cloudNoiseBindGroup = this.device.createBindGroup({
          layout: this.cloudNoisePipeline.getBindGroupLayout(0),
          entries: [{ binding: 0, resource: this.cloudNoiseTexture.createView() }]
        });
      }
    }
    this.updateUniforms(this.device, buffer, context.scene.atmosphere, context.camera.transform.position);
    if (this.noiseDirty && this.cloudNoisePipeline && this.cloudNoiseBindGroup) {
      console.log("AtmospherePass: Generating 3D Cloud Noise...");
      const pass = commandEncoder.beginComputePass({ label: "Cloud Noise Gen" });
      pass.setPipeline(this.cloudNoisePipeline);
      pass.setBindGroup(0, this.cloudNoiseBindGroup);
      pass.dispatchWorkgroups(128 / 8, 128 / 8, 128 / 4);
      pass.end();
      this.noiseDirty = false;
    }
    if (this.dirty) {
      console.log("AtmospherePass: Dispatching Compute Shaders (Dirty State)");
      if (this.transmittancePipeline && this.transmittanceBindGroup) {
        const pass = commandEncoder.beginComputePass({ label: "Atmosphere Transmittance Pass" });
        pass.setPipeline(this.transmittancePipeline);
        pass.setBindGroup(0, this.transmittanceBindGroup);
        pass.dispatchWorkgroups(Math.ceil(this.TRANSMITTANCE_W / 8), Math.ceil(this.TRANSMITTANCE_H / 8), 1);
        pass.end();
      }
      if (this.multiScatteringPipeline && this.multiScatteringBindGroup0 && this.multiScatteringBindGroup1 && this.multiScatteringBindGroup2) {
        const pass = commandEncoder.beginComputePass({ label: "Atmosphere MultiScattering Pass" });
        pass.setPipeline(this.multiScatteringPipeline);
        pass.setBindGroup(0, this.multiScatteringBindGroup0);
        pass.setBindGroup(1, this.multiScatteringBindGroup1);
        pass.setBindGroup(2, this.multiScatteringBindGroup2);
        pass.dispatchWorkgroups(Math.ceil(this.MULTISCAT_W / 1), Math.ceil(this.MULTISCAT_H / 1), 1);
        pass.end();
      }
      if (this.scatteringPipeline && this.scatteringBindGroup) {
        const pass = commandEncoder.beginComputePass({ label: "Atmosphere Scattering Pass" });
        pass.setPipeline(this.scatteringPipeline);
        pass.setBindGroup(0, this.scatteringBindGroup);
        pass.dispatchWorkgroups(Math.ceil(this.SCATTERING_W / 8), Math.ceil(this.SCATTERING_H / 8), Math.ceil(this.SCATTERING_D / 1));
        pass.end();
      }
      this.dirty = false;
    }
    if (this.skyViewPipeline && this.skyViewBindGroup0 && this.skyViewBindGroup1 && this.skyViewBindGroup2) {
      const pass = commandEncoder.beginComputePass({ label: "Atmosphere SkyView Pass" });
      pass.setPipeline(this.skyViewPipeline);
      pass.setBindGroup(0, this.skyViewBindGroup0);
      pass.setBindGroup(1, this.skyViewBindGroup1);
      pass.setBindGroup(2, this.skyViewBindGroup2);
      pass.dispatchWorkgroups(Math.ceil(this.SKYVIEW_W / 8), Math.ceil(this.SKYVIEW_H / 8), 1);
      pass.end();
    }
  }
}

// ../../src/core/renderer/VelocityFromDepthPass.ts
class VelocityFromDepthPass {
  gBuffer;
  pipeline = null;
  bindGroupLayout = null;
  device = null;
  constructor(gBuffer) {
    this.gBuffer = gBuffer;
  }
  init(device, context, presentationFormat) {
    this.device = device;
  }
  resize(width, height) {}
  execute(commandEncoder, context, globalResources) {
    if (!this.gBuffer.useComputedVelocity)
      return;
    if (!this.device || !this.gBuffer.depthTexture || !this.gBuffer.velocityTexture)
      return;
    if (!this.pipeline) {
      this.createPipeline(this.device, globalResources);
    }
    const bindGroup = this.device.createBindGroup({
      label: "Velocity From Depth Bind Group",
      layout: this.bindGroupLayout,
      entries: [
        { binding: 0, resource: { buffer: globalResources.sceneUniforms.buffer } },
        { binding: 1, resource: this.gBuffer.depthTexture.createView() }
      ]
    });
    const passDescriptor = {
      colorAttachments: [
        {
          view: this.gBuffer.velocityTexture.createView(),
          clearValue: { r: 0, g: 0, b: 0, a: 0 },
          loadOp: "clear",
          storeOp: "store"
        }
      ]
    };
    const pass = commandEncoder.beginRenderPass(passDescriptor);
    pass.setPipeline(this.pipeline);
    pass.setBindGroup(0, bindGroup);
    pass.draw(3);
    pass.end();
  }
  createPipeline(device, globalResources) {
    const code = `
      struct SceneUniforms {
        viewMatrix : mat4x4<f32>,
        projectionMatrix : mat4x4<f32>,
        lightViewProj : mat4x4<f32>,
        prevViewProj : mat4x4<f32>,
        inverseProjectionMatrix : mat4x4<f32>,
        cameraPosition : vec3<f32>,
        time : f32,
        lightCount : u32,
        debugMode : u32,
        shadowsEnabled : u32,
        environmentIntensity : f32,
      }

      @group(0) @binding(0) var<uniform> scene : SceneUniforms;
      @group(0) @binding(1) var depthTex : texture_depth_2d;

      struct VertexOutput {
        @builtin(position) position : vec4f,
        @location(0) uv : vec2f,
        @location(1) @interpolate(flat) invViewProj0 : vec4f,
        @location(2) @interpolate(flat) invViewProj1 : vec4f,
        @location(3) @interpolate(flat) invViewProj2 : vec4f,
        @location(4) @interpolate(flat) invViewProj3 : vec4f,
      }

      // Invert 4x4 matrix (for inverse view-projection)
      fn inverse(m: mat4x4f) -> mat4x4f {
        let a00 = m[0][0]; let a01 = m[0][1]; let a02 = m[0][2]; let a03 = m[0][3];
        let a10 = m[1][0]; let a11 = m[1][1]; let a12 = m[1][2]; let a13 = m[1][3];
        let a20 = m[2][0]; let a21 = m[2][1]; let a22 = m[2][2]; let a23 = m[2][3];
        let a30 = m[3][0]; let a31 = m[3][1]; let a32 = m[3][2]; let a33 = m[3][3];

        let b00 = a00 * a11 - a01 * a10;
        let b01 = a00 * a12 - a02 * a10;
        let b02 = a00 * a13 - a03 * a10;
        let b03 = a01 * a12 - a02 * a11;
        let b04 = a01 * a13 - a03 * a11;
        let b05 = a02 * a13 - a03 * a12;
        let b06 = a20 * a31 - a21 * a30;
        let b07 = a20 * a32 - a22 * a30;
        let b08 = a20 * a33 - a23 * a30;
        let b09 = a21 * a32 - a22 * a31;
        let b10 = a21 * a33 - a23 * a31;
        let b11 = a22 * a33 - a23 * a32;

        let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        let invDet = 1.0 / det;

        return mat4x4f(
          vec4f((a11 * b11 - a12 * b10 + a13 * b09) * invDet, (a02 * b10 - a01 * b11 - a03 * b09) * invDet, (a31 * b05 - a32 * b04 + a33 * b03) * invDet, (a22 * b04 - a21 * b05 - a23 * b03) * invDet),
          vec4f((a12 * b08 - a10 * b11 - a13 * b07) * invDet, (a00 * b11 - a02 * b08 + a03 * b07) * invDet, (a32 * b02 - a30 * b05 - a33 * b01) * invDet, (a20 * b05 - a22 * b02 + a23 * b01) * invDet),
          vec4f((a10 * b10 - a11 * b08 + a13 * b06) * invDet, (a01 * b08 - a00 * b10 - a03 * b06) * invDet, (a30 * b04 - a31 * b02 + a33 * b00) * invDet, (a21 * b02 - a20 * b04 - a23 * b00) * invDet),
          vec4f((a11 * b07 - a10 * b09 - a12 * b06) * invDet, (a00 * b09 - a01 * b07 + a02 * b06) * invDet, (a31 * b01 - a30 * b03 - a32 * b00) * invDet, (a20 * b03 - a21 * b01 + a22 * b00) * invDet)
        );
      }

      @vertex
      fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
        var output : VertexOutput;

        // Full-screen triangle
        let x = f32((vertexIndex << 1u) & 2u);
        let y = f32(vertexIndex & 2u);
        output.position = vec4f(x * 2.0 - 1.0, y * 2.0 - 1.0, 0.0, 1.0);
        output.uv = vec2f(x, 1.0 - y);

        // Compute inverse view-projection matrix
        let viewProj = scene.projectionMatrix * scene.viewMatrix;
        let invViewProj = inverse(viewProj);
        output.invViewProj0 = invViewProj[0];
        output.invViewProj1 = invViewProj[1];
        output.invViewProj2 = invViewProj[2];
        output.invViewProj3 = invViewProj[3];

        return output;
      }

      fn worldFromDepth(depth: f32, uv: vec2f, invViewProj: mat4x4f) -> vec3f {
        let ndc = vec2f(uv.x * 2.0 - 1.0, (1.0 - uv.y) * 2.0 - 1.0);
        let clipPos = vec4f(ndc, depth, 1.0);
        let worldPos = invViewProj * clipPos;
        return worldPos.xyz / worldPos.w;
      }

      @fragment
      fn fs_main(
        @location(0) uv : vec2f,
        @location(1) @interpolate(flat) invViewProj0: vec4f,
        @location(2) @interpolate(flat) invViewProj1: vec4f,
        @location(3) @interpolate(flat) invViewProj2: vec4f,
        @location(4) @interpolate(flat) invViewProj3: vec4f
      ) -> @location(0) vec2f {
        let invViewProj = mat4x4f(invViewProj0, invViewProj1, invViewProj2, invViewProj3);

        // Sample depth
        let texSize = vec2f(textureDimensions(depthTex));
        let fragCoord = uv * texSize;
        let depth = textureLoad(depthTex, vec2i(floor(fragCoord)), 0);

        // Skip sky pixels (depth = 1.0)
        if (depth >= 1.0) {
          return vec2f(0.0, 0.0);
        }

        // Reconstruct world position from depth
        let worldPos = worldFromDepth(depth, uv, invViewProj);

        // Project to previous frame's clip space
        let prevClip = scene.prevViewProj * vec4f(worldPos, 1.0);
        let prevNDC = prevClip.xy / prevClip.w;

        // Current NDC
        let currentNDC = vec2f(uv.x * 2.0 - 1.0, (1.0 - uv.y) * 2.0 - 1.0);

        // Velocity = current - previous (in NDC space, scaled to 0.5)
        let velocity = (currentNDC - prevNDC) * 0.5;

        // Invert Y to match texture UV space (Y down)
        return vec2f(velocity.x, -velocity.y);
      }
    `;
    const module = createShaderModuleSafe(device, {
      label: "Velocity From Depth Shader",
      code
    });
    this.bindGroupLayout = device.createBindGroupLayout({
      label: "Velocity From Depth Bind Group Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "depth" } }
      ]
    });
    const pipelineLayout = device.createPipelineLayout({
      label: "Velocity From Depth Pipeline Layout",
      bindGroupLayouts: [this.bindGroupLayout]
    });
    this.pipeline = device.createRenderPipeline({
      label: "Velocity From Depth Pipeline",
      layout: pipelineLayout,
      vertex: {
        module,
        entryPoint: "vs_main"
      },
      fragment: {
        module,
        entryPoint: "fs_main",
        targets: [{ format: "rg16float" }]
      },
      primitive: {
        topology: "triangle-list"
      }
    });
  }
}

// ../../src/core/renderer/DepthOfFieldPass.ts
class DepthOfFieldPass {
  gBuffer;
  device = null;
  width = 0;
  height = 0;
  cocPipeline = null;
  blurPipeline = null;
  compositePipeline = null;
  bindGroupLayout = null;
  sampler = null;
  cocTexture = null;
  blurTextureA = null;
  blurTextureB = null;
  uniformBuffer = null;
  inputTexture = null;
  enabled = false;
  focusDistance = 10;
  cocScale = 0.01;
  maxBlur = 8;
  intensity = 1;
  samples = 32;
  bokehShape = "circle";
  nearPlane = 0.1;
  farPlane = 1000;
  constructor(gBuffer) {
    this.gBuffer = gBuffer;
  }
  setInputTexture(texture) {
    this.inputTexture = texture;
  }
  getOutputTexture() {
    return this.blurTextureA;
  }
  init(device, context, presentationFormat) {
    this.device = device;
    this.sampler = device.createSampler({
      minFilter: "linear",
      magFilter: "linear",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    });
    this.bindGroupLayout = device.createBindGroupLayout({
      label: "DOF Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "depth" } },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, sampler: {} },
        { binding: 3, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
        { binding: 4, visibility: GPUShaderStage.FRAGMENT, texture: {} }
      ]
    });
    this.uniformBuffer = device.createBuffer({
      label: "DOF Uniform Buffer",
      size: 48,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.createPipelines(device);
  }
  resize(width, height) {
    if (width <= 0 || height <= 0)
      return;
    this.width = width;
    this.height = height;
    if (this.device) {
      this.destroyTextures();
      this.createTextures(this.device);
    }
  }
  destroyTextures() {
    if (this.cocTexture)
      this.cocTexture.destroy();
    if (this.blurTextureA)
      this.blurTextureA.destroy();
    if (this.blurTextureB)
      this.blurTextureB.destroy();
  }
  createTextures(device) {
    this.cocTexture = device.createTexture({
      label: "DOF CoC",
      size: [this.width, this.height],
      format: "r16float",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT
    });
    const blurDesc = {
      label: "DOF Blur",
      size: [this.width, this.height],
      format: "rgba16float",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT
    };
    this.blurTextureA = device.createTexture(blurDesc);
    this.blurTextureB = device.createTexture(blurDesc);
  }
  execute(commandEncoder, context, globalResources) {
    if (!this.enabled)
      return;
    if (!this.device || !this.inputTexture || !this.cocTexture || !this.blurTextureA || !this.blurTextureB)
      return;
    if (!this.gBuffer.depthTexture)
      return;
    const camera = context.camera;
    this.focusDistance = camera.physicalCamera.focusDistance;
    this.cocScale = camera.getCoCScale() * camera.depthOfField.intensity;
    this.maxBlur = camera.depthOfField.maxBlur;
    this.intensity = camera.depthOfField.intensity;
    this.samples = camera.depthOfField.samples;
    this.bokehShape = camera.depthOfField.bokehShape;
    this.nearPlane = camera.near;
    this.farPlane = camera.far;
    const uniformData = new Float32Array([
      this.focusDistance,
      this.cocScale,
      this.maxBlur,
      this.intensity,
      this.nearPlane,
      this.farPlane,
      this.width,
      this.height,
      this.samples,
      this.bokehShape === "hexagon" ? 1 : 0,
      0,
      0
    ]);
    this.device.queue.writeBuffer(this.uniformBuffer, 0, uniformData);
    this.executeCoCPass(commandEncoder, this.uniformBuffer);
    this.executeBlurPass(commandEncoder, this.uniformBuffer, true);
    this.executeBlurPass(commandEncoder, this.uniformBuffer, false);
    this.executeCompositePass(commandEncoder, this.uniformBuffer);
  }
  executeCoCPass(commandEncoder, uniformBuffer) {
    if (!this.device || !this.cocPipeline || !this.inputTexture || !this.gBuffer.depthTexture || !this.cocTexture || !this.blurTextureA)
      return;
    const bindGroup = this.device.createBindGroup({
      layout: this.bindGroupLayout,
      entries: [
        { binding: 0, resource: this.inputTexture.createView() },
        { binding: 1, resource: this.gBuffer.depthTexture.createView() },
        { binding: 2, resource: this.sampler },
        { binding: 3, resource: { buffer: uniformBuffer } },
        { binding: 4, resource: this.blurTextureA.createView() }
      ]
    });
    const pass = commandEncoder.beginRenderPass({
      colorAttachments: [{
        view: this.cocTexture.createView(),
        loadOp: "clear",
        storeOp: "store"
      }]
    });
    pass.setPipeline(this.cocPipeline);
    pass.setBindGroup(0, bindGroup);
    pass.draw(3);
    pass.end();
  }
  executeBlurPass(commandEncoder, uniformBuffer, horizontal) {
    if (!this.device || !this.blurPipeline || !this.inputTexture || !this.cocTexture || !this.blurTextureA || !this.blurTextureB)
      return;
    const source = horizontal ? this.inputTexture : this.blurTextureA;
    const target = horizontal ? this.blurTextureA : this.blurTextureB;
    const bindGroup = this.device.createBindGroup({
      layout: this.bindGroupLayout,
      entries: [
        { binding: 0, resource: source.createView() },
        { binding: 1, resource: this.gBuffer.depthTexture.createView() },
        { binding: 2, resource: this.sampler },
        { binding: 3, resource: { buffer: uniformBuffer } },
        { binding: 4, resource: this.cocTexture.createView() }
      ]
    });
    const pass = commandEncoder.beginRenderPass({
      colorAttachments: [{
        view: target.createView(),
        loadOp: "clear",
        storeOp: "store"
      }]
    });
    pass.setPipeline(this.blurPipeline);
    pass.setBindGroup(0, bindGroup);
    pass.draw(3);
    pass.end();
  }
  executeCompositePass(commandEncoder, uniformBuffer) {
    if (!this.device || !this.compositePipeline || !this.inputTexture || !this.blurTextureB || !this.blurTextureA || !this.cocTexture)
      return;
    const bindGroup = this.device.createBindGroup({
      layout: this.bindGroupLayout,
      entries: [
        { binding: 0, resource: this.blurTextureB.createView() },
        { binding: 1, resource: this.gBuffer.depthTexture.createView() },
        { binding: 2, resource: this.sampler },
        { binding: 3, resource: { buffer: uniformBuffer } },
        { binding: 4, resource: this.cocTexture.createView() }
      ]
    });
    const pass = commandEncoder.beginRenderPass({
      colorAttachments: [{
        view: this.blurTextureA.createView(),
        loadOp: "clear",
        storeOp: "store"
      }]
    });
    pass.setPipeline(this.compositePipeline);
    pass.setBindGroup(0, bindGroup);
    pass.draw(3);
    pass.end();
  }
  createPipelines(device) {
    const fullscreenVS = `
      struct VertexOutput {
        @builtin(position) position : vec4f,
        @location(0) uv : vec2f,
      }
      @vertex
      fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
        var output : VertexOutput;
        let pos = array(vec2f(-1.0, -1.0), vec2f(3.0, -1.0), vec2f(-1.0, 3.0));
        let p = pos[vertexIndex];
        output.position = vec4f(p, 0.0, 1.0);
        output.uv = p * 0.5 + 0.5;
        output.uv.y = 1.0 - output.uv.y;
        return output;
      }
    `;
    const cocFS = `
      @group(0) @binding(0) var colorTex : texture_2d<f32>;
      @group(0) @binding(1) var depthTex : texture_depth_2d;
      @group(0) @binding(2) var samp : sampler;
      struct Params {
        focusDistance: f32,
        cocScale: f32,
        maxBlur: f32,
        intensity: f32,
        nearPlane: f32,
        farPlane: f32,
        width: f32,
        height: f32,
        samples: f32,
        bokehShape: f32,
        pad1: f32,
        pad2: f32,
      }
      @group(0) @binding(3) var<uniform> params : Params;

      fn linearizeDepth(depth: f32) -> f32 {
        let near = params.nearPlane;
        let far = params.farPlane;
        return near * far / (far - depth * (far - near));
      }

      @fragment
      fn fs_main(@location(0) uv : vec2f) -> @location(0) f32 {
        // Use textureLoad for depth texture (requires integer coordinates)
        let texCoord = vec2i(vec2f(params.width, params.height) * uv);
        let depth = textureLoad(depthTex, texCoord, 0);
        let linearDepth = linearizeDepth(depth);

        // Calculate signed CoC (negative = foreground blur, positive = background blur)
        let coc = (linearDepth - params.focusDistance) * params.cocScale;

        // Clamp to max blur radius
        return clamp(coc, -params.maxBlur, params.maxBlur);
      }
    `;
    const blurFS = `
      @group(0) @binding(0) var colorTex : texture_2d<f32>;
      @group(0) @binding(1) var depthTex : texture_depth_2d;
      @group(0) @binding(2) var samp : sampler;
      struct Params {
        focusDistance: f32,
        cocScale: f32,
        maxBlur: f32,
        intensity: f32,
        nearPlane: f32,
        farPlane: f32,
        width: f32,
        height: f32,
        samples: f32,
        bokehShape: f32,
        pad1: f32,
        pad2: f32,
      }
      @group(0) @binding(3) var<uniform> params : Params;
      @group(0) @binding(4) var cocTex : texture_2d<f32>;

      const PI = 3.14159265359;
      const GOLDEN_ANGLE = 2.39996323;

      @fragment
      fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {
        let centerColor = textureSampleLevel(colorTex, samp, uv, 0.0);
        let centerCoc = textureSampleLevel(cocTex, samp, uv, 0.0).r;
        let absCoC = abs(centerCoc);

        // Always compute blur, then blend based on CoC
        let texelSize = vec2f(1.0 / params.width, 1.0 / params.height);
        var color = vec3f(0.0);
        var totalWeight = 0.0;

        let sampleCount = i32(params.samples);

        // Disc blur using golden angle spiral
        for (var i = 0; i < sampleCount; i++) {
          let fi = f32(i);
          let r = sqrt(fi / f32(sampleCount)) * absCoC;
          let theta = fi * GOLDEN_ANGLE;

          let offset = vec2f(cos(theta), sin(theta)) * r * texelSize;
          let sampleUV = uv + offset;

          let sampleColor = textureSampleLevel(colorTex, samp, sampleUV, 0.0).rgb;
          let sampleCoc = textureSampleLevel(cocTex, samp, sampleUV, 0.0).r;

          // Weight based on CoC similarity and distance
          // Foreground samples should not bleed into background
          let cocDiff = sampleCoc - centerCoc;
          let weight = select(1.0, smoothstep(0.0, 2.0, abs(sampleCoc)), cocDiff < 0.0);

          color += sampleColor * weight;
          totalWeight += weight;
        }

        color /= max(totalWeight, 1.0);

        // Blend between original and blurred based on CoC magnitude
        let blendFactor = smoothstep(0.0, 1.0, absCoC);
        let finalColor = mix(centerColor.rgb, color, blendFactor);

        return vec4f(finalColor, 1.0);
      }
    `;
    const compositeFS = `
      @group(0) @binding(0) var blurredTex : texture_2d<f32>;
      @group(0) @binding(1) var depthTex : texture_depth_2d;
      @group(0) @binding(2) var samp : sampler;
      struct Params {
        focusDistance: f32,
        cocScale: f32,
        maxBlur: f32,
        intensity: f32,
        nearPlane: f32,
        farPlane: f32,
        width: f32,
        height: f32,
        samples: f32,
        bokehShape: f32,
        pad1: f32,
        pad2: f32,
      }
      @group(0) @binding(3) var<uniform> params : Params;
      @group(0) @binding(4) var cocTex : texture_2d<f32>;

      @fragment
      fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {
        let blurred = textureSampleLevel(blurredTex, samp, uv, 0.0).rgb;
        let coc = abs(textureSampleLevel(cocTex, samp, uv, 0.0).r);

        // Smooth transition based on CoC
        let blendFactor = smoothstep(0.0, 2.0, coc) * params.intensity;

        return vec4f(blurred, 1.0);
      }
    `;
    const primitive = { topology: "triangle-list" };
    const layout = device.createPipelineLayout({ bindGroupLayouts: [this.bindGroupLayout] });
    this.cocPipeline = device.createRenderPipeline({
      label: "DOF CoC Pipeline",
      layout,
      vertex: { module: createShaderModuleSafe(device, { code: fullscreenVS }), entryPoint: "vs_main" },
      fragment: { module: createShaderModuleSafe(device, { code: cocFS }), entryPoint: "fs_main", targets: [{ format: "r16float" }] },
      primitive
    });
    this.blurPipeline = device.createRenderPipeline({
      label: "DOF Blur Pipeline",
      layout,
      vertex: { module: createShaderModuleSafe(device, { code: fullscreenVS }), entryPoint: "vs_main" },
      fragment: { module: createShaderModuleSafe(device, { code: blurFS }), entryPoint: "fs_main", targets: [{ format: "rgba16float" }] },
      primitive
    });
    this.compositePipeline = device.createRenderPipeline({
      label: "DOF Composite Pipeline",
      layout,
      vertex: { module: createShaderModuleSafe(device, { code: fullscreenVS }), entryPoint: "vs_main" },
      fragment: { module: createShaderModuleSafe(device, { code: compositeFS }), entryPoint: "fs_main", targets: [{ format: "rgba16float" }] },
      primitive
    });
  }
}

// ../../src/core/renderer/MotionBlurPass.ts
class MotionBlurPass {
  gBuffer;
  device = null;
  width = 0;
  height = 0;
  pipeline = null;
  tileMaxPipeline = null;
  neighborMaxPipeline = null;
  bindGroupLayout = null;
  sampler = null;
  outputTexture = null;
  tileMaxTexture = null;
  neighborMaxTexture = null;
  inputTexture = null;
  enabled = false;
  intensity = 1;
  samples = 16;
  maxBlur = 32;
  shutterAngle = 0.5;
  tileSize = 20;
  constructor(gBuffer) {
    this.gBuffer = gBuffer;
  }
  setInputTexture(texture) {
    this.inputTexture = texture;
  }
  getOutputTexture() {
    return this.outputTexture;
  }
  init(device, context, presentationFormat) {
    this.device = device;
    this.sampler = device.createSampler({
      minFilter: "linear",
      magFilter: "linear",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    });
    this.bindGroupLayout = device.createBindGroupLayout({
      label: "Motion Blur Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "depth" } },
        { binding: 3, visibility: GPUShaderStage.FRAGMENT, sampler: {} },
        { binding: 4, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } },
        { binding: 5, visibility: GPUShaderStage.FRAGMENT, texture: {} }
      ]
    });
    this.createPipelines(device);
  }
  resize(width, height) {
    if (width <= 0 || height <= 0)
      return;
    this.width = width;
    this.height = height;
    if (this.device) {
      this.destroyTextures();
      this.createTextures(this.device);
    }
  }
  destroyTextures() {
    if (this.outputTexture)
      this.outputTexture.destroy();
    if (this.tileMaxTexture)
      this.tileMaxTexture.destroy();
    if (this.neighborMaxTexture)
      this.neighborMaxTexture.destroy();
  }
  createTextures(device) {
    this.outputTexture = device.createTexture({
      label: "Motion Blur Output",
      size: [this.width, this.height],
      format: "rgba16float",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT
    });
    const tileWidth = Math.ceil(this.width / this.tileSize);
    const tileHeight = Math.ceil(this.height / this.tileSize);
    this.tileMaxTexture = device.createTexture({
      label: "Motion Blur Tile Max",
      size: [tileWidth, tileHeight],
      format: "rg16float",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT
    });
    this.neighborMaxTexture = device.createTexture({
      label: "Motion Blur Neighbor Max",
      size: [tileWidth, tileHeight],
      format: "rg16float",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT
    });
  }
  execute(commandEncoder, context, globalResources) {
    if (!this.enabled)
      return;
    if (!this.device || !this.inputTexture || !this.outputTexture || !this.gBuffer.velocityTexture)
      return;
    if (!this.gBuffer.depthTexture)
      return;
    const camera = context.camera;
    this.intensity = camera.motionBlur.intensity * camera.getMotionBlurScale();
    this.samples = camera.motionBlur.samples;
    this.maxBlur = camera.motionBlur.maxBlur;
    if (this.intensity < 0.01) {
      return;
    }
    const uniformData = new Float32Array([
      this.intensity,
      this.maxBlur,
      this.samples,
      this.shutterAngle,
      this.width,
      this.height,
      this.tileSize,
      0
    ]);
    const uniformBuffer = this.device.createBuffer({
      size: 32,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
      mappedAtCreation: true
    });
    new Float32Array(uniformBuffer.getMappedRange()).set(uniformData);
    uniformBuffer.unmap();
    this.executeTileMaxPass(commandEncoder, uniformBuffer);
    this.executeNeighborMaxPass(commandEncoder, uniformBuffer);
    this.executeBlurPass(commandEncoder, uniformBuffer);
  }
  executeTileMaxPass(commandEncoder, uniformBuffer) {
    if (!this.device || !this.tileMaxPipeline || !this.gBuffer.velocityTexture || !this.tileMaxTexture)
      return;
    const layout = this.device.createBindGroupLayout({
      label: "Tile Max Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, sampler: {} },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } }
      ]
    });
    const bindGroup = this.device.createBindGroup({
      layout,
      entries: [
        { binding: 0, resource: this.gBuffer.velocityTexture.createView() },
        { binding: 1, resource: this.sampler },
        { binding: 2, resource: { buffer: uniformBuffer } }
      ]
    });
    const pass = commandEncoder.beginRenderPass({
      colorAttachments: [{
        view: this.tileMaxTexture.createView(),
        loadOp: "clear",
        storeOp: "store"
      }]
    });
    pass.setPipeline(this.tileMaxPipeline);
    pass.setBindGroup(0, bindGroup);
    pass.draw(3);
    pass.end();
  }
  executeNeighborMaxPass(commandEncoder, uniformBuffer) {
    if (!this.device || !this.neighborMaxPipeline || !this.tileMaxTexture || !this.neighborMaxTexture)
      return;
    const layout = this.device.createBindGroupLayout({
      label: "Neighbor Max Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, sampler: {} },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } }
      ]
    });
    const bindGroup = this.device.createBindGroup({
      layout,
      entries: [
        { binding: 0, resource: this.tileMaxTexture.createView() },
        { binding: 1, resource: this.sampler },
        { binding: 2, resource: { buffer: uniformBuffer } }
      ]
    });
    const pass = commandEncoder.beginRenderPass({
      colorAttachments: [{
        view: this.neighborMaxTexture.createView(),
        loadOp: "clear",
        storeOp: "store"
      }]
    });
    pass.setPipeline(this.neighborMaxPipeline);
    pass.setBindGroup(0, bindGroup);
    pass.draw(3);
    pass.end();
  }
  executeBlurPass(commandEncoder, uniformBuffer) {
    if (!this.device || !this.pipeline || !this.inputTexture || !this.gBuffer.velocityTexture || !this.outputTexture || !this.neighborMaxTexture)
      return;
    const bindGroup = this.device.createBindGroup({
      layout: this.bindGroupLayout,
      entries: [
        { binding: 0, resource: this.inputTexture.createView() },
        { binding: 1, resource: this.gBuffer.velocityTexture.createView() },
        { binding: 2, resource: this.gBuffer.depthTexture.createView() },
        { binding: 3, resource: this.sampler },
        { binding: 4, resource: { buffer: uniformBuffer } },
        { binding: 5, resource: this.neighborMaxTexture.createView() }
      ]
    });
    const pass = commandEncoder.beginRenderPass({
      colorAttachments: [{
        view: this.outputTexture.createView(),
        loadOp: "clear",
        storeOp: "store"
      }]
    });
    pass.setPipeline(this.pipeline);
    pass.setBindGroup(0, bindGroup);
    pass.draw(3);
    pass.end();
  }
  createPipelines(device) {
    const fullscreenVS = `
      struct VertexOutput {
        @builtin(position) position : vec4f,
        @location(0) uv : vec2f,
      }
      @vertex
      fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
        var output : VertexOutput;
        let pos = array(vec2f(-1.0, -1.0), vec2f(3.0, -1.0), vec2f(-1.0, 3.0));
        let p = pos[vertexIndex];
        output.position = vec4f(p, 0.0, 1.0);
        output.uv = p * 0.5 + 0.5;
        output.uv.y = 1.0 - output.uv.y;
        return output;
      }
    `;
    const tileMaxFS = `
      @group(0) @binding(0) var velocityTex : texture_2d<f32>;
      @group(0) @binding(1) var samp : sampler;
      struct Params {
        intensity: f32,
        maxBlur: f32,
        samples: f32,
        shutterAngle: f32,
        width: f32,
        height: f32,
        tileSize: f32,
        pad: f32,
      }
      @group(0) @binding(2) var<uniform> params : Params;

      @fragment
      fn fs_main(@location(0) uv : vec2f) -> @location(0) vec2f {
        let texSize = vec2f(textureDimensions(velocityTex));
        let tileCoord = vec2i(uv * texSize / params.tileSize);

        var maxVel = vec2f(0.0);
        var maxLen = 0.0;

        let startX = i32(f32(tileCoord.x) * params.tileSize);
        let startY = i32(f32(tileCoord.y) * params.tileSize);
        let endX = min(startX + i32(params.tileSize), i32(texSize.x));
        let endY = min(startY + i32(params.tileSize), i32(texSize.y));

        for (var y = startY; y < endY; y++) {
          for (var x = startX; x < endX; x++) {
            let pixelUV = (vec2f(f32(x), f32(y)) + 0.5) / texSize;
            let vel = textureSampleLevel(velocityTex, samp, pixelUV, 0.0).xy;
            let len = length(vel);
            if (len > maxLen) {
              maxLen = len;
              maxVel = vel;
            }
          }
        }

        return maxVel * params.intensity;
      }
    `;
    const neighborMaxFS = `
      @group(0) @binding(0) var tileMaxTex : texture_2d<f32>;
      @group(0) @binding(1) var samp : sampler;
      struct Params {
        intensity: f32,
        maxBlur: f32,
        samples: f32,
        shutterAngle: f32,
        width: f32,
        height: f32,
        tileSize: f32,
        pad: f32,
      }
      @group(0) @binding(2) var<uniform> params : Params;

      @fragment
      fn fs_main(@location(0) uv : vec2f) -> @location(0) vec2f {
        let texSize = vec2f(textureDimensions(tileMaxTex));
        let texelSize = 1.0 / texSize;

        var maxVel = vec2f(0.0);
        var maxLen = 0.0;

        for (var y = -1; y <= 1; y++) {
          for (var x = -1; x <= 1; x++) {
            let offset = vec2f(f32(x), f32(y)) * texelSize;
            let vel = textureSampleLevel(tileMaxTex, samp, uv + offset, 0.0).xy;
            let len = length(vel);
            if (len > maxLen) {
              maxLen = len;
              maxVel = vel;
            }
          }
        }

        return maxVel;
      }
    `;
    const blurFS = `
      @group(0) @binding(0) var colorTex : texture_2d<f32>;
      @group(0) @binding(1) var velocityTex : texture_2d<f32>;
      @group(0) @binding(2) var depthTex : texture_depth_2d;
      @group(0) @binding(3) var samp : sampler;
      struct Params {
        intensity: f32,
        maxBlur: f32,
        samples: f32,
        shutterAngle: f32,
        width: f32,
        height: f32,
        tileSize: f32,
        pad: f32,
      }
      @group(0) @binding(4) var<uniform> params : Params;
      @group(0) @binding(5) var neighborMaxTex : texture_2d<f32>;

      fn softDepthCompare(depth0: f32, depth1: f32) -> f32 {
        return clamp(1.0 - (depth0 - depth1) / 0.01, 0.0, 1.0);
      }

      fn cone(dist: f32, vel: f32) -> f32 {
        return clamp(1.0 - dist / max(vel, 0.001), 0.0, 1.0);
      }

      fn cylinder(dist: f32, vel: f32) -> f32 {
        return 1.0 - smoothstep(0.95 * max(vel, 0.001), 1.05 * max(vel, 0.001), dist);
      }

      fn loadDepth(coord: vec2i) -> f32 {
        return textureLoad(depthTex, coord, 0);
      }

      @fragment
      fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {
        let texelSize = vec2f(1.0 / params.width, 1.0 / params.height);
        let texSize = vec2f(params.width, params.height);
        let centerCoord = vec2i(uv * texSize);

        // Get center sample
        let centerColor = textureSampleLevel(colorTex, samp, uv, 0.0).rgb;
        let centerVel = textureSampleLevel(velocityTex, samp, uv, 0.0).xy * params.intensity;
        let centerDepth = loadDepth(centerCoord);

        // Get neighbor max velocity for this tile
        let neighborMaxVel = textureSampleLevel(neighborMaxTex, samp, uv, 0.0).xy;
        let neighborMaxLen = length(neighborMaxVel);

        // Compute motion blur even if low motion (avoid non-uniform control flow)
        let centerVelLen = length(centerVel);

        // Clamp velocity to max blur
        let maxVelPixels = params.maxBlur;
        let velScale = min(1.0, maxVelPixels / max(neighborMaxLen, 0.001));
        let scaledVel = centerVel * velScale;
        let scaledVelLen = length(scaledVel);

        var color = vec3f(0.0);
        var totalWeight = 0.0;

        let sampleCount = i32(params.samples);
        let jitter = fract(sin(dot(uv, vec2f(12.9898, 78.233))) * 43758.5453);

        for (var i = 0; i < sampleCount; i++) {
          let t = (f32(i) + jitter) / f32(sampleCount) - 0.5;
          let sampleOffset = scaledVel * t * texelSize * 2.0;
          let sampleUV = uv + sampleOffset;

          // Clamp to screen
          let clampedUV = clamp(sampleUV, vec2f(0.0), vec2f(1.0));
          let sampleCoord = vec2i(clampedUV * texSize);

          let sampleColor = textureSampleLevel(colorTex, samp, clampedUV, 0.0).rgb;
          let sampleVel = textureSampleLevel(velocityTex, samp, clampedUV, 0.0).xy * params.intensity;
          let sampleDepth = loadDepth(sampleCoord);
          let sampleVelLen = length(sampleVel);

          let dist = length(sampleOffset / texelSize);

          // Foreground/background weighting
          let foreground = softDepthCompare(sampleDepth, centerDepth);
          let background = softDepthCompare(centerDepth, sampleDepth);

          // Cone weight from sample's velocity
          let sampleCone = cone(dist, sampleVelLen);
          // Cylinder weight from center's velocity
          let centerCyl = cylinder(dist, scaledVelLen);

          var weight = foreground * sampleCone + background * centerCyl;
          weight = max(weight, 0.001);

          color += sampleColor * weight;
          totalWeight += weight;
        }

        color /= max(totalWeight, 0.001);

        // Blend with original based on motion amount (smooth falloff for low motion)
        let motionAmount = max(neighborMaxLen, centerVelLen);
        let blendFactor = smoothstep(0.0, 1.0, motionAmount);
        let finalColor = mix(centerColor, color, blendFactor);

        return vec4f(finalColor, 1.0);
      }
    `;
    const primitive = { topology: "triangle-list" };
    const tileMaxLayout = device.createBindGroupLayout({
      label: "Tile Max Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, sampler: {} },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } }
      ]
    });
    this.tileMaxPipeline = device.createRenderPipeline({
      label: "Motion Blur Tile Max",
      layout: device.createPipelineLayout({ bindGroupLayouts: [tileMaxLayout] }),
      vertex: { module: createShaderModuleSafe(device, { code: fullscreenVS }), entryPoint: "vs_main" },
      fragment: { module: createShaderModuleSafe(device, { code: tileMaxFS }), entryPoint: "fs_main", targets: [{ format: "rg16float" }] },
      primitive
    });
    this.neighborMaxPipeline = device.createRenderPipeline({
      label: "Motion Blur Neighbor Max",
      layout: device.createPipelineLayout({ bindGroupLayouts: [tileMaxLayout] }),
      vertex: { module: createShaderModuleSafe(device, { code: fullscreenVS }), entryPoint: "vs_main" },
      fragment: { module: createShaderModuleSafe(device, { code: neighborMaxFS }), entryPoint: "fs_main", targets: [{ format: "rg16float" }] },
      primitive
    });
    this.pipeline = device.createRenderPipeline({
      label: "Motion Blur Pipeline",
      layout: device.createPipelineLayout({ bindGroupLayouts: [this.bindGroupLayout] }),
      vertex: { module: createShaderModuleSafe(device, { code: fullscreenVS }), entryPoint: "vs_main" },
      fragment: { module: createShaderModuleSafe(device, { code: blurFS }), entryPoint: "fs_main", targets: [{ format: "rgba16float" }] },
      primitive
    });
  }
}

// ../../src/core/renderer/LensEffectsPass.ts
class LensEffectsPass {
  device = null;
  width = 0;
  height = 0;
  pipeline = null;
  tiltShiftPipeline = null;
  bindGroupLayout = null;
  sampler = null;
  outputTexture = null;
  tiltShiftTempTexture = null;
  inputTexture = null;
  distortionEnabled = false;
  distortionAmount = 0;
  chromaticAberrationEnabled = false;
  chromaticAberrationIntensity = 0.005;
  vignetteEnabled = false;
  vignetteIntensity = 0.3;
  vignetteSmoothness = 0.5;
  tiltShiftEnabled = false;
  tiltShiftFocusPosition = 0.5;
  tiltShiftFocusWidth = 0.2;
  tiltShiftBlurAmount = 4;
  tiltShiftGradientSize = 0.3;
  tiltShiftHorizontal = true;
  constructor(_gBuffer) {}
  setInputTexture(texture) {
    this.inputTexture = texture;
  }
  getOutputTexture() {
    return this.outputTexture;
  }
  get enabled() {
    return this.distortionEnabled || this.chromaticAberrationEnabled || this.vignetteEnabled || this.tiltShiftEnabled;
  }
  init(device, context, presentationFormat) {
    this.device = device;
    this.sampler = device.createSampler({
      minFilter: "linear",
      magFilter: "linear",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    });
    this.bindGroupLayout = device.createBindGroupLayout({
      label: "Lens Effects Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, sampler: {} },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } }
      ]
    });
    this.createPipelines(device);
  }
  resize(width, height) {
    if (width <= 0 || height <= 0)
      return;
    this.width = width;
    this.height = height;
    if (this.device) {
      this.destroyTextures();
      this.createTextures(this.device);
    }
  }
  destroyTextures() {
    if (this.outputTexture)
      this.outputTexture.destroy();
    if (this.tiltShiftTempTexture)
      this.tiltShiftTempTexture.destroy();
  }
  createTextures(device) {
    const desc = {
      label: "Lens Effects Output",
      size: [this.width, this.height],
      format: "rgba16float",
      usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT
    };
    this.outputTexture = device.createTexture(desc);
    this.tiltShiftTempTexture = device.createTexture({ ...desc, label: "Tilt Shift Temp" });
  }
  execute(commandEncoder, context, globalResources) {
    if (!this.device || !this.inputTexture || !this.outputTexture)
      return;
    const camera = context.camera;
    const lens = camera.lensEffects;
    const tilt = camera.tiltShift;
    this.distortionEnabled = lens.distortionEnabled;
    this.distortionAmount = lens.distortionAmount;
    this.chromaticAberrationEnabled = lens.chromaticAberrationEnabled;
    this.chromaticAberrationIntensity = lens.chromaticAberrationIntensity;
    this.vignetteEnabled = lens.vignetteEnabled;
    this.vignetteIntensity = lens.vignetteIntensity;
    this.vignetteSmoothness = lens.vignetteSmoothness;
    this.tiltShiftEnabled = tilt.enabled;
    this.tiltShiftFocusPosition = tilt.focusPosition;
    this.tiltShiftFocusWidth = tilt.focusWidth;
    this.tiltShiftBlurAmount = tilt.blurAmount;
    this.tiltShiftGradientSize = tilt.gradientSize;
    this.tiltShiftHorizontal = tilt.direction === "horizontal";
    if (!this.enabled)
      return;
    const uniformData = new Float32Array([
      this.distortionEnabled ? 1 : 0,
      this.distortionAmount,
      this.chromaticAberrationEnabled ? 1 : 0,
      this.chromaticAberrationIntensity,
      this.vignetteEnabled ? 1 : 0,
      this.vignetteIntensity,
      this.vignetteSmoothness,
      0,
      this.tiltShiftEnabled ? 1 : 0,
      this.tiltShiftFocusPosition,
      this.tiltShiftFocusWidth,
      this.tiltShiftBlurAmount,
      this.tiltShiftGradientSize,
      this.tiltShiftHorizontal ? 1 : 0,
      this.width,
      this.height
    ]);
    const uniformBuffer = this.device.createBuffer({
      size: 64,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
      mappedAtCreation: true
    });
    new Float32Array(uniformBuffer.getMappedRange()).set(uniformData);
    uniformBuffer.unmap();
    if (this.distortionEnabled || this.chromaticAberrationEnabled || this.vignetteEnabled) {
      this.executeLensPass(commandEncoder, uniformBuffer);
    }
    if (this.tiltShiftEnabled) {
      const source = this.distortionEnabled || this.chromaticAberrationEnabled || this.vignetteEnabled ? this.outputTexture : this.inputTexture;
      this.executeTiltShiftPass(commandEncoder, uniformBuffer, source);
    }
  }
  executeLensPass(commandEncoder, uniformBuffer) {
    if (!this.device || !this.pipeline || !this.inputTexture || !this.outputTexture)
      return;
    const bindGroup = this.device.createBindGroup({
      layout: this.bindGroupLayout,
      entries: [
        { binding: 0, resource: this.inputTexture.createView() },
        { binding: 1, resource: this.sampler },
        { binding: 2, resource: { buffer: uniformBuffer } }
      ]
    });
    const target = this.tiltShiftEnabled ? this.tiltShiftTempTexture : this.outputTexture;
    const pass = commandEncoder.beginRenderPass({
      colorAttachments: [{
        view: target.createView(),
        loadOp: "clear",
        storeOp: "store"
      }]
    });
    pass.setPipeline(this.pipeline);
    pass.setBindGroup(0, bindGroup);
    pass.draw(3);
    pass.end();
  }
  executeTiltShiftPass(commandEncoder, uniformBuffer, source) {
    if (!this.device || !this.tiltShiftPipeline || !this.outputTexture || !this.tiltShiftTempTexture)
      return;
    const actualSource = this.distortionEnabled || this.chromaticAberrationEnabled || this.vignetteEnabled ? this.tiltShiftTempTexture : source;
    const bindGroup = this.device.createBindGroup({
      layout: this.bindGroupLayout,
      entries: [
        { binding: 0, resource: actualSource.createView() },
        { binding: 1, resource: this.sampler },
        { binding: 2, resource: { buffer: uniformBuffer } }
      ]
    });
    const pass = commandEncoder.beginRenderPass({
      colorAttachments: [{
        view: this.outputTexture.createView(),
        loadOp: "clear",
        storeOp: "store"
      }]
    });
    pass.setPipeline(this.tiltShiftPipeline);
    pass.setBindGroup(0, bindGroup);
    pass.draw(3);
    pass.end();
  }
  createPipelines(device) {
    const fullscreenVS = `
      struct VertexOutput {
        @builtin(position) position : vec4f,
        @location(0) uv : vec2f,
      }
      @vertex
      fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
        var output : VertexOutput;
        let pos = array(vec2f(-1.0, -1.0), vec2f(3.0, -1.0), vec2f(-1.0, 3.0));
        let p = pos[vertexIndex];
        output.position = vec4f(p, 0.0, 1.0);
        output.uv = p * 0.5 + 0.5;
        output.uv.y = 1.0 - output.uv.y;
        return output;
      }
    `;
    const lensFS = `
      @group(0) @binding(0) var inputTex : texture_2d<f32>;
      @group(0) @binding(1) var samp : sampler;
      struct Params {
        distortionEnabled: f32,
        distortionAmount: f32,
        caEnabled: f32,
        caIntensity: f32,
        vignetteEnabled: f32,
        vignetteIntensity: f32,
        vignetteSmoothness: f32,
        pad1: f32,
        tiltShiftEnabled: f32,
        tiltShiftFocusPos: f32,
        tiltShiftFocusWidth: f32,
        tiltShiftBlurAmount: f32,
        tiltShiftGradient: f32,
        tiltShiftHorizontal: f32,
        width: f32,
        height: f32,
      }
      @group(0) @binding(2) var<uniform> params : Params;

      // Barrel/pincushion distortion
      fn distort(uv: vec2f, amount: f32) -> vec2f {
        let centered = uv - 0.5;
        let r2 = dot(centered, centered);
        let distorted = centered * (1.0 + amount * r2);
        return distorted + 0.5;
      }

      @fragment
      fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {
        // Apply distortion (always compute, blend based on enabled)
        let distortedUV = distort(uv, params.distortionAmount);
        let finalUV = select(uv, distortedUV, params.distortionEnabled > 0.5);

        // Check if UV is out of bounds after distortion
        let outOfBounds = finalUV.x < 0.0 || finalUV.x > 1.0 || finalUV.y < 0.0 || finalUV.y > 1.0;

        // Clamp UV for sampling (avoid artifacts at edges)
        let clampedUV = clamp(finalUV, vec2f(0.001), vec2f(0.999));

        // Always compute both paths, select based on CA enabled
        // Chromatic aberration path
        let centered = clampedUV - 0.5;
        let r = length(centered);
        let caOffset = centered * r * params.caIntensity;
        let rUV = clamp(clampedUV + caOffset, vec2f(0.0), vec2f(1.0));
        let bUV = clamp(clampedUV - caOffset, vec2f(0.0), vec2f(1.0));

        let caColor = vec3f(
          textureSampleLevel(inputTex, samp, rUV, 0.0).r,
          textureSampleLevel(inputTex, samp, clampedUV, 0.0).g,
          textureSampleLevel(inputTex, samp, bUV, 0.0).b
        );

        // Non-CA path
        let normalColor = textureSampleLevel(inputTex, samp, clampedUV, 0.0).rgb;

        // Select based on CA enabled
        var color = select(normalColor, caColor, params.caEnabled > 0.5);

        // Vignette (always compute, multiply by 1.0 if disabled)
        let vignetteCentered = uv - 0.5;
        let vignetteDist = length(vignetteCentered) * 2.0;
        let vignetteBase = 1.0 - smoothstep(1.0 - params.vignetteSmoothness, 1.0, vignetteDist);
        let vignetteValue = mix(1.0, vignetteBase, params.vignetteIntensity);
        let vignetteFactor = select(1.0, vignetteValue, params.vignetteEnabled > 0.5);
        color *= vignetteFactor;

        // Black out if out of bounds
        color = select(color, vec3f(0.0), outOfBounds);

        return vec4f(color, 1.0);
      }
    `;
    const tiltShiftFS = `
      @group(0) @binding(0) var inputTex : texture_2d<f32>;
      @group(0) @binding(1) var samp : sampler;
      struct Params {
        distortionEnabled: f32,
        distortionAmount: f32,
        caEnabled: f32,
        caIntensity: f32,
        vignetteEnabled: f32,
        vignetteIntensity: f32,
        vignetteSmoothness: f32,
        pad1: f32,
        tiltShiftEnabled: f32,
        tiltShiftFocusPos: f32,
        tiltShiftFocusWidth: f32,
        tiltShiftBlurAmount: f32,
        tiltShiftGradient: f32,
        tiltShiftHorizontal: f32,
        width: f32,
        height: f32,
      }
      @group(0) @binding(2) var<uniform> params : Params;

      const PI = 3.14159265359;
      const GOLDEN_ANGLE = 2.39996323;

      @fragment
      fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {
        let texelSize = vec2f(1.0 / params.width, 1.0 / params.height);

        // Calculate position based on direction (use select instead of if)
        let pos = select(uv.x, uv.y, params.tiltShiftHorizontal > 0.5);

        let focusCenter = params.tiltShiftFocusPos;
        let halfWidth = params.tiltShiftFocusWidth * 0.5;
        let gradient = max(params.tiltShiftGradient, 0.001); // Prevent division by zero

        // Distance from focus band (compute all cases, use math instead of branches)
        let belowFocus = focusCenter - halfWidth;
        let aboveFocus = focusCenter + halfWidth;

        // Signed distance from focus band edges
        let distBelow = (belowFocus - pos) / gradient;
        let distAbove = (pos - aboveFocus) / gradient;

        // Use max of both distances (one will be negative when inside)
        let distFromFocus = max(max(distBelow, distAbove), 0.0);

        let blurFactor = clamp(distFromFocus, 0.0, 1.0);
        let blurRadius = blurFactor * params.tiltShiftBlurAmount;

        // Always sample original color
        let originalColor = textureSampleLevel(inputTex, samp, uv, 0.0).rgb;

        // Always compute blur (even if blurRadius is small, the blend will handle it)
        var blurredColor = vec3f(0.0);
        let samples = 16;

        for (var i = 0; i < samples; i++) {
          let fi = f32(i);
          let r = sqrt(fi / f32(samples)) * max(blurRadius, 0.001);
          let theta = fi * GOLDEN_ANGLE;
          let offset = vec2f(cos(theta), sin(theta)) * r * texelSize;
          blurredColor += textureSampleLevel(inputTex, samp, uv + offset, 0.0).rgb;
        }
        blurredColor /= f32(samples);

        // Blend between original and blurred based on blur amount
        let blendFactor = smoothstep(0.0, 1.0, blurRadius);
        let finalColor = mix(originalColor, blurredColor, blendFactor);

        return vec4f(finalColor, 1.0);
      }
    `;
    const primitive = { topology: "triangle-list" };
    const layout = device.createPipelineLayout({ bindGroupLayouts: [this.bindGroupLayout] });
    const targets = [{ format: "rgba16float" }];
    this.pipeline = device.createRenderPipeline({
      label: "Lens Effects Pipeline",
      layout,
      vertex: { module: createShaderModuleSafe(device, { code: fullscreenVS }), entryPoint: "vs_main" },
      fragment: { module: createShaderModuleSafe(device, { code: lensFS }), entryPoint: "fs_main", targets },
      primitive
    });
    this.tiltShiftPipeline = device.createRenderPipeline({
      label: "Tilt-Shift Pipeline",
      layout,
      vertex: { module: createShaderModuleSafe(device, { code: fullscreenVS }), entryPoint: "vs_main" },
      fragment: { module: createShaderModuleSafe(device, { code: tiltShiftFS }), entryPoint: "fs_main", targets },
      primitive
    });
  }
}

// ../../src/core/renderer/GodRaysPass.ts
class GodRaysPass {
  device = null;
  gBuffer;
  width = 0;
  height = 0;
  godRaysTexture = null;
  pipeline = null;
  bindGroupLayout = null;
  bindGroup = null;
  uniformBuffer = null;
  sampler = null;
  depthSampler = null;
  enabled = false;
  intensity = 1;
  decay = 0.96;
  density = 0.96;
  weight = 0.4;
  exposure = 0.2;
  samples = 64;
  maxDistance = 1;
  inputTexture = null;
  constructor(gBuffer) {
    this.gBuffer = gBuffer;
  }
  init(device, context, presentationFormat) {
    this.device = device;
    this.sampler = device.createSampler({
      minFilter: "linear",
      magFilter: "linear",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    });
    this.depthSampler = device.createSampler({
      minFilter: "nearest",
      magFilter: "nearest"
    });
    this.uniformBuffer = device.createBuffer({
      label: "GodRays Uniform Buffer",
      size: 80,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    this.bindGroupLayout = device.createBindGroupLayout({
      label: "GodRays Bind Group Layout",
      entries: [
        { binding: 0, visibility: GPUShaderStage.FRAGMENT, texture: {} },
        { binding: 1, visibility: GPUShaderStage.FRAGMENT, texture: { sampleType: "depth" } },
        { binding: 2, visibility: GPUShaderStage.FRAGMENT, sampler: {} },
        { binding: 3, visibility: GPUShaderStage.FRAGMENT, sampler: { type: "non-filtering" } },
        { binding: 4, visibility: GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } }
      ]
    });
    this.createPipeline(device);
  }
  resize(width, height) {
    this.width = width;
    this.height = height;
    if (this.device) {
      if (this.godRaysTexture) {
        this.godRaysTexture.destroy();
        this.godRaysTexture = null;
      }
      if (width <= 0 || height <= 0) {
        return;
      }
      this.godRaysTexture = this.device.createTexture({
        label: "God Rays Texture",
        size: [width, height],
        format: "rgba16float",
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
      });
      this.bindGroup = null;
    }
  }
  setInputTexture(texture) {
    this.inputTexture = texture;
    this.bindGroup = null;
  }
  getOutputTexture() {
    return this.godRaysTexture;
  }
  execute(commandEncoder, context, globalResources) {
    if (!this.enabled || !this.device || !this.pipeline || !this.godRaysTexture || !this.inputTexture) {
      return;
    }
    const sunLight = context.scene.lights.find((l) => l.type === 0 /* Directional */);
    if (!sunLight) {
      return;
    }
    const lightDir = sunLight.transform.getForwardVector().clone().multiplyScalar(-1);
    const sunWorldPos = context.camera.transform.position.clone().add(lightDir.clone().multiplyScalar(1000));
    const viewProj = context.camera.projectionMatrix.clone().multiply(context.camera.viewMatrix);
    const ndcPos = sunWorldPos.clone().applyMatrix4(viewProj);
    const screenX = ndcPos.x * 0.5 + 0.5;
    const screenY = 1 - (ndcPos.y * 0.5 + 0.5);
    const isOnScreen = screenX >= 0 && screenX <= 1 && screenY >= 0 && screenY <= 1;
    const clampedX = Math.max(0, Math.min(1, screenX));
    const clampedY = Math.max(0, Math.min(1, screenY));
    const offScreenDist = Math.sqrt(Math.pow(screenX - clampedX, 2) + Math.pow(screenY - clampedY, 2));
    const offScreenFalloff = Math.max(0, 1 - offScreenDist / this.maxDistance);
    const uniformData = new Float32Array([
      screenX,
      screenY,
      this.intensity,
      this.decay,
      this.density,
      this.weight,
      this.exposure,
      this.samples,
      sunLight.color.x * sunLight.intensity,
      sunLight.color.y * sunLight.intensity,
      sunLight.color.z * sunLight.intensity,
      offScreenFalloff,
      this.width,
      this.height,
      this.maxDistance,
      isOnScreen ? 1 : 0,
      clampedX,
      clampedY,
      0,
      0
    ]);
    this.device.queue.writeBuffer(this.uniformBuffer, 0, uniformData);
    if (!this.bindGroup) {
      this.createBindGroup();
    }
    if (!this.bindGroup)
      return;
    const passEncoder = commandEncoder.beginRenderPass({
      colorAttachments: [{
        view: this.godRaysTexture.createView(),
        loadOp: "clear",
        storeOp: "store",
        clearValue: { r: 0, g: 0, b: 0, a: 0 }
      }]
    });
    passEncoder.setPipeline(this.pipeline);
    passEncoder.setBindGroup(0, this.bindGroup);
    passEncoder.draw(3);
    passEncoder.end();
  }
  createPipeline(device) {
    const shaderCode = `
      struct Params {
        lightScreenPos: vec2f,      // Original light position (can be off-screen)
        intensity: f32,
        decay: f32,
        density: f32,
        weight: f32,
        exposure: f32,
        numSamples: f32,
        lightColor: vec3f,
        offScreenFalloff: f32,      // Intensity falloff for off-screen light
        resolution: vec2f,
        maxDistance: f32,
        isOnScreen: f32,
        clampedLightPos: vec2f,     // Light position clamped to screen edge
        _pad: vec2f,
      }

      @group(0) @binding(0) var colorTex: texture_2d<f32>;
      @group(0) @binding(1) var depthTex: texture_depth_2d;
      @group(0) @binding(2) var colorSamp: sampler;
      @group(0) @binding(3) var depthSamp: sampler;
      @group(0) @binding(4) var<uniform> params: Params;

      struct VertexOutput {
        @builtin(position) position: vec4f,
        @location(0) uv: vec2f,
      }

      @vertex
      fn vs_main(@builtin(vertex_index) vertexIndex: u32) -> VertexOutput {
        var output: VertexOutput;
        let pos = array(
          vec2f(-1.0, -1.0),
          vec2f(3.0, -1.0),
          vec2f(-1.0, 3.0)
        );
        let p = pos[vertexIndex];
        output.position = vec4f(p, 0.0, 1.0);
        output.uv = p * 0.5 + 0.5;
        output.uv.y = 1.0 - output.uv.y;
        return output;
      }

      // Hash function for dithering (removes banding artifacts)
      fn hash(p: vec2f) -> f32 {
        var p3 = fract(vec3f(p.xyx) * 0.1031);
        p3 += dot(p3, p3.yzx + 33.33);
        return fract((p3.x + p3.y) * p3.z);
      }

      @fragment
      fn fs_main(@builtin(position) fragCoord: vec4f, @location(0) uv: vec2f) -> @location(0) vec4f {
        // Use original light position for direction, but allow off-screen
        let lightPos = params.lightScreenPos;

        // Distance from pixel to light in screen space
        let toLight = lightPos - uv;
        let distToLight = length(toLight);

        // Skip if light is exactly at pixel (shouldn't happen normally)
        if (distToLight < 0.001) {
          return vec4f(0.0, 0.0, 0.0, 1.0);
        }

        // Dithering offset to reduce banding (based on screen position)
        let dither = hash(fragCoord.xy) * 0.5;

        // Vector from current pixel toward light
        let rayDir = normalize(toLight);

        // For off-screen lights, use extended ray distance based on maxDistance
        // This allows rays to appear even when looking away from the light
        let maxRayDist = params.maxDistance + 1.0;
        let rayDist = min(distToLight, maxRayDist);
        let stepSize = rayDist / params.numSamples * params.density;
        let deltaTexCoord = rayDir * stepSize;

        var sampleCoord = uv;
        var accumulatedLight = 0.0;
        var illuminationDecay = 1.0;

        let numSamples = i32(params.numSamples);
        let texSize = vec2i(textureDimensions(depthTex));

        // Apply initial dither offset to stagger samples and reduce banding
        sampleCoord += deltaTexCoord * dither;

        // March toward the light source
        for (var i = 0; i < numSamples; i++) {
          sampleCoord += deltaTexCoord;

          // Clamp to valid range for sampling
          let clampedCoord = clamp(sampleCoord, vec2f(0.001), vec2f(0.999));

          // Check if sample is still on screen
          let inBounds = sampleCoord.x >= 0.0 && sampleCoord.x <= 1.0 &&
                         sampleCoord.y >= 0.0 && sampleCoord.y <= 1.0;

          // Sample depth at this position
          let samplePixel = vec2i(clampedCoord * vec2f(texSize));
          let depth = textureLoad(depthTex, samplePixel, 0);

          // Only accumulate light from unoccluded areas (sky/background)
          // depth >= 0.9999 means nothing was rendered there (background/sky)
          let isSky = depth >= 0.9999;

          // Accumulate if in bounds and sky visible
          if (inBounds && isSky) {
            accumulatedLight += params.weight * illuminationDecay;
          }

          illuminationDecay *= params.decay;
        }

        // Apply light color, exposure and intensity
        // Use distance falloff based on actual light distance, with extended range
        let normalizedDist = distToLight / maxRayDist;
        let distanceFalloff = 1.0 - smoothstep(0.0, 1.0, normalizedDist);

        // Apply off-screen falloff if light is not on screen
        let screenFalloff = select(params.offScreenFalloff, 1.0, params.isOnScreen > 0.5);

        let finalColor = params.lightColor * accumulatedLight * params.exposure * params.intensity * distanceFalloff * screenFalloff;

        return vec4f(finalColor, 1.0);
      }
    `;
    const shaderModule = createShaderModuleSafe(device, { code: shaderCode });
    const pipelineLayout = device.createPipelineLayout({
      bindGroupLayouts: [this.bindGroupLayout]
    });
    this.pipeline = device.createRenderPipeline({
      label: "God Rays Pipeline",
      layout: pipelineLayout,
      vertex: {
        module: shaderModule,
        entryPoint: "vs_main"
      },
      fragment: {
        module: shaderModule,
        entryPoint: "fs_main",
        targets: [{ format: "rgba16float" }]
      },
      primitive: { topology: "triangle-list" }
    });
  }
  createBindGroup() {
    if (!this.device || !this.bindGroupLayout || !this.inputTexture || !this.gBuffer.depthTexture || !this.sampler || !this.uniformBuffer) {
      return;
    }
    const depthView = this.gBuffer.depthTexture.createView({
      aspect: "depth-only"
    });
    this.bindGroup = this.device.createBindGroup({
      label: "God Rays Bind Group",
      layout: this.bindGroupLayout,
      entries: [
        { binding: 0, resource: this.inputTexture.createView() },
        { binding: 1, resource: depthView },
        { binding: 2, resource: this.sampler },
        { binding: 3, resource: this.depthSampler },
        { binding: 4, resource: { buffer: this.uniformBuffer } }
      ]
    });
  }
}

// ../../src/core/Engine.ts
class Engine {
  canvas;
  device = null;
  context = null;
  presentationFormat = null;
  renderGraph;
  gBuffer = null;
  taaPass = null;
  fxaaPass = null;
  ssgiPass = null;
  ssaoPass = null;
  bloomPass = null;
  ssrPass = null;
  toneMappingPass = null;
  depthOfFieldPass = null;
  motionBlurPass = null;
  lensEffectsPass = null;
  godRaysPass = null;
  geometryPass = null;
  frameIndex = 0;
  statsReadBuffer = null;
  static STATS_ZERO_BUFFER = new Uint32Array([0, 0, 0, 0]);
  currentDeltaTime = 0.016;
  totalTime = 0;
  lastRenderTime = 0;
  debugger = null;
  gpuProfiler;
  selectionRenderer;
  config;
  softwareConfig = {};
  rendererCapabilities = null;
  constructor(canvas, config) {
    this.canvas = canvas;
    this.config = config ?? {};
    if (!this.config.disableDebugger) {
      this.debugger = new Debugger(canvas.parentElement);
    }
    this.gpuProfiler = getGPUProfiler();
    this.selectionRenderer = new SelectionRenderer;
    this.renderGraph = new RenderGraph;
  }
  async init() {
    if (!navigator.gpu) {
      throw new Error("WebGPU not supported on this browser.");
    }
    const adapter = await navigator.gpu.requestAdapter();
    if (!adapter) {
      throw new Error("No appropriate GPUAdapter found.");
    }
    this.rendererCapabilities = await detectRendererCapabilities(adapter);
    this.softwareConfig = getEffectiveSoftwareConfig({
      ...this.config.softwareRendering,
      forceSoftwareMode: this.config.softwareRendering?.forceSoftwareMode || this.rendererCapabilities.isSoftwareRenderer
    });
    if (this.rendererCapabilities.isSoftwareRenderer || this.config.softwareRendering?.forceSoftwareMode) {
      console.log("Engine: Running in software rendering mode. Some features will be disabled.");
      console.log("Engine: Software config:", this.softwareConfig);
    }
    this.presentationFormat = navigator.gpu.getPreferredCanvasFormat();
    console.log(`Configuring context: ${this.canvas.width}x${this.canvas.height}, format: ${this.presentationFormat}`);
    this.canvas.width = this.canvas.clientWidth || 800;
    this.canvas.height = this.canvas.clientHeight || 600;
    console.log(`Engine: Initial canvas size: ${this.canvas.width}x${this.canvas.height} (Client: ${this.canvas.clientWidth}x${this.canvas.clientHeight})`);
    const requiredLimits = {};
    if (adapter.limits.maxColorAttachmentBytesPerSample >= 64) {
      requiredLimits.maxColorAttachmentBytesPerSample = adapter.limits.maxColorAttachmentBytesPerSample;
    }
    if (adapter.limits.maxTextureDimension2D > 8192) {
      requiredLimits.maxTextureDimension2D = adapter.limits.maxTextureDimension2D;
      console.log(`Engine: Requesting maxTextureDimension2D: ${adapter.limits.maxTextureDimension2D}`);
    }
    const requiredFeatures = [];
    if (adapter.features.has("indirect-first-instance")) {
      requiredFeatures.push("indirect-first-instance");
      console.log("Engine: indirect-first-instance feature enabled");
    } else {
      console.warn("Engine: indirect-first-instance feature not available - indirect draws may not work correctly");
    }
    if (adapter.features.has("timestamp-query")) {
      requiredFeatures.push("timestamp-query");
      console.log("Engine: timestamp-query feature enabled for GPU profiling");
    } else {
      console.warn("Engine: timestamp-query feature not available - GPU timing will not be available");
    }
    console.log("Engine: Available adapter features:", [...adapter.features]);
    console.log("Engine: Adapter limits:", {
      maxBindGroups: adapter.limits.maxBindGroups,
      maxBindingsPerBindGroup: adapter.limits.maxBindingsPerBindGroup,
      maxUniformBufferBindingSize: adapter.limits.maxUniformBufferBindingSize,
      maxStorageBufferBindingSize: adapter.limits.maxStorageBufferBindingSize,
      maxSampledTexturesPerShaderStage: adapter.limits.maxSampledTexturesPerShaderStage,
      maxSamplersPerShaderStage: adapter.limits.maxSamplersPerShaderStage,
      maxStorageTexturesPerShaderStage: adapter.limits.maxStorageTexturesPerShaderStage,
      maxUniformBuffersPerShaderStage: adapter.limits.maxUniformBuffersPerShaderStage,
      maxStorageBuffersPerShaderStage: adapter.limits.maxStorageBuffersPerShaderStage,
      maxDynamicUniformBuffersPerPipelineLayout: adapter.limits.maxDynamicUniformBuffersPerPipelineLayout,
      maxDynamicStorageBuffersPerPipelineLayout: adapter.limits.maxDynamicStorageBuffersPerPipelineLayout
    });
    this.device = await adapter.requestDevice({ requiredLimits, requiredFeatures });
    this.gpuProfiler.init(this.device, adapter);
    this.selectionRenderer.init(this.device);
    if (this.device.addEventListener) {
      this.device.addEventListener("uncapturederror", (event) => {
        const error = event.error;
        console.error("WebGPU uncaptured error:", error.message);
        if (!this.config?.disableErrorOverlay) {
          ErrorOverlay.getInstance().reportError(error.message, "Uncaptured WebGPU Error");
        }
      });
    }
    this.context = this.canvas.getContext("webgpu");
    this.statsReadBuffer = this.device.createBuffer({
      size: 16,
      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
    });
    if (!this.context) {
      throw new Error("Could not get WebGPU context.");
    }
    this.context.configure({
      device: this.device,
      format: this.presentationFormat,
      alphaMode: "opaque"
    });
    this.gBuffer = new GBuffer(this.device, this.canvas.width, this.canvas.height);
    const gBuffer = this.gBuffer;
    const atmosphereEnabled = !this.softwareConfig.disableAtmosphere;
    const atmospherePass = atmosphereEnabled ? new AtmospherePass : null;
    const hiZPass = new HiZGenerationPass(gBuffer);
    const cullingPass = new GPUCullingPass(gBuffer);
    const shadowPass = new ShadowPass;
    const pointShadowPass = new PointShadowPass;
    const geometryPass = new GeometryPass(gBuffer);
    this.geometryPass = geometryPass;
    const ssaoPass = new SSAOPass(gBuffer);
    this.ssaoPass = ssaoPass;
    if (this.softwareConfig.disableSSAO) {
      ssaoPass.enabled = false;
    }
    const ssgiPass = new SSGIPass(gBuffer);
    this.ssgiPass = ssgiPass;
    if (this.softwareConfig.disableSSGI) {
      ssgiPass.enabled = false;
      console.log("Engine: SSGI disabled for software rendering compatibility");
    }
    const lightingPass = new DeferredLightingPass(gBuffer);
    const skyboxPass = new SkyboxPass(gBuffer);
    const forwardPass = new ForwardRenderPass(gBuffer);
    const ssrPass = new SSRPass(gBuffer);
    this.ssrPass = ssrPass;
    if (this.softwareConfig.disableSSR) {
      ssrPass.enabled = false;
      console.log("Engine: SSR disabled for software rendering compatibility");
    }
    const taaPass = new TAAPass(gBuffer);
    this.taaPass = taaPass;
    if (this.softwareConfig.disableTAA) {
      taaPass.enabled = false;
    }
    const fxaaPass = new FXAAPass(gBuffer);
    this.fxaaPass = fxaaPass;
    fxaaPass.enabled = false;
    const depthOfFieldPass = new DepthOfFieldPass(gBuffer);
    this.depthOfFieldPass = depthOfFieldPass;
    if (this.softwareConfig.disableDoF) {
      depthOfFieldPass.enabled = false;
      console.log("Engine: Depth of Field disabled for software rendering compatibility");
    }
    const motionBlurPass = new MotionBlurPass(gBuffer);
    this.motionBlurPass = motionBlurPass;
    if (this.softwareConfig.disableMotionBlur) {
      motionBlurPass.enabled = false;
      console.log("Engine: Motion Blur disabled for software rendering compatibility");
    }
    const lensEffectsPass = new LensEffectsPass(gBuffer);
    this.lensEffectsPass = lensEffectsPass;
    const godRaysPass = new GodRaysPass(gBuffer);
    this.godRaysPass = godRaysPass;
    const bloomPass = new BloomPass;
    this.bloomPass = bloomPass;
    if (this.softwareConfig.disableBloom) {
      bloomPass.enabled = false;
    }
    const toneMappingPass = new ToneMappingPass;
    this.toneMappingPass = toneMappingPass;
    if (atmospherePass) {
      this.renderGraph.addPass(atmospherePass);
    }
    this.renderGraph.addPass(cullingPass);
    this.renderGraph.addPass(shadowPass);
    this.renderGraph.addPass(pointShadowPass);
    this.renderGraph.addPass(geometryPass);
    this.renderGraph.addPass(hiZPass);
    const velocityFromDepthPass = new VelocityFromDepthPass(gBuffer);
    this.renderGraph.addPass(velocityFromDepthPass);
    this.renderGraph.addPass(ssaoPass);
    this.renderGraph.addPass(ssgiPass);
    this.renderGraph.addPass(lightingPass);
    this.renderGraph.addPass(skyboxPass);
    this.renderGraph.addPass(forwardPass);
    this.renderGraph.addPass(ssrPass);
    this.renderGraph.addPass(godRaysPass);
    this.renderGraph.addPass(taaPass);
    this.renderGraph.addPass(fxaaPass);
    this.renderGraph.addPass(depthOfFieldPass);
    this.renderGraph.addPass(motionBlurPass);
    this.renderGraph.addPass(lensEffectsPass);
    this.renderGraph.addPass(bloomPass);
    this.renderGraph.addPass(toneMappingPass);
    this.renderGraph.init(this.device, this.context, this.presentationFormat);
    this.renderGraph.resize(this.canvas.width, this.canvas.height);
    if (atmospherePass) {
      const globalRes = this.renderGraph.getGlobalResources();
      if (globalRes && atmospherePass.transmittanceTexture && atmospherePass.scatteringTexture && atmospherePass.irradianceTexture && atmospherePass.skyViewTexture) {
        globalRes.setAtmosphereLUTs(atmospherePass.transmittanceTexture, atmospherePass.scatteringTexture, atmospherePass.irradianceTexture, atmospherePass.skyViewTexture, atmospherePass.cloudNoiseTexture);
        globalRes.createBindGroup(this.device);
        if (globalRes.renderBindGroupLayout && globalRes.atmosphereBindGroupLayout) {
          skyboxPass.initAtmosphere(this.device, globalRes.renderBindGroupLayout, globalRes.atmosphereBindGroupLayout);
        }
      }
    }
    console.log("Mystral Engine Initialized");
  }
  getDevice() {
    return this.device;
  }
  getGlobalResources() {
    return this.renderGraph.getGlobalResources();
  }
  getRenderGraph() {
    return this.renderGraph;
  }
  getRendererCapabilities() {
    return this.rendererCapabilities;
  }
  isSoftwareRenderingMode() {
    return this.softwareConfig.forceSoftwareMode || this.rendererCapabilities?.isSoftwareRenderer || false;
  }
  getSoftwareRenderingConfig() {
    return { ...this.softwareConfig };
  }
  addRenderPass(pass) {
    if (!this.device || !this.context || !this.presentationFormat) {
      console.warn("Engine.addRenderPass: Engine not initialized yet");
      return;
    }
    this.renderGraph.addPass(pass);
    pass.init(this.device, this.context, this.presentationFormat);
    pass.resize(this.canvas.width, this.canvas.height);
    if (pass instanceof UIRenderPass) {
      this.debugger?.registerUIManager(pass.getUIManager());
      this.debugger?.registerCanvas(this.canvas, this.device);
    }
  }
  removeRenderPass(pass) {
    return this.renderGraph.removePass(pass);
  }
  addGBufferRenderPass(pass) {
    if (!this.device || !this.context || !this.presentationFormat) {
      console.warn("Engine.addGBufferRenderPass: Engine not initialized yet");
      return;
    }
    const passes = this.renderGraph.getPasses();
    const geometryIndex = passes.indexOf(this.geometryPass);
    if (geometryIndex !== -1) {
      this.renderGraph.insertPassAt(geometryIndex + 1, pass);
    } else {
      console.warn("Engine.addGBufferRenderPass: GeometryPass not found, appending to end");
      this.renderGraph.addPass(pass);
    }
    pass.init(this.device, this.context, this.presentationFormat);
    pass.resize(this.canvas.width, this.canvas.height);
  }
  getGBuffer() {
    return this.gBuffer;
  }
  getDebugOverlay() {
    return this.debugger;
  }
  getDebugger() {
    return this.debugger;
  }
  setDebugMode(mode) {
    this.renderGraph.setDebugMode(mode);
  }
  getGPUProfiler() {
    return this.gpuProfiler;
  }
  logGPUTimes() {
    this.gpuProfiler.logTimes();
  }
  async readDepthTexture(numSamples = 100) {
    if (!this.device || !this.gBuffer) {
      console.error("Engine or GBuffer not initialized");
      return;
    }
    const commandEncoder = this.device.createCommandEncoder({ label: "Depth Readback" });
    await this.gBuffer.readDepthValues(commandEncoder, numSamples);
    this.device.queue.submit([commandEncoder.finish()]);
  }
  render(scene, camera) {
    if (!this.device || !this.context || !this.presentationFormat)
      return;
    if (this.canvas.width === 0 || this.canvas.height === 0)
      return;
    const now = performance.now();
    if (this.lastRenderTime > 0) {
      const dt = (now - this.lastRenderTime) / 1000;
      if (dt >= 0.001 && dt < 1) {
        this.currentDeltaTime = dt;
        this.totalTime += dt;
      }
    }
    this.lastRenderTime = now;
    this.processSceneUpdates(scene, this.currentDeltaTime);
    if (this.taaPass) {
      this.taaPass.enabled = scene.postProcessing.aa.enabled;
    }
    if (this.fxaaPass) {
      this.fxaaPass.enabled = scene.postProcessing.fxaa.enabled;
    }
    if (this.ssaoPass) {
      this.ssaoPass.enabled = scene.postProcessing.ssao.enabled;
    }
    if (this.ssgiPass) {
      this.ssgiPass.enabled = scene.globalIllumination.enabled && !this.softwareConfig.disableSSGI;
      this.ssgiPass.intensity = scene.globalIllumination.intensity;
      this.ssgiPass.enableSpatialDenoise = scene.globalIllumination.spatialDenoise;
      this.ssgiPass.enableTemporalDenoise = scene.globalIllumination.temporalDenoise;
    }
    if (this.ssrPass) {
      this.ssrPass.enabled = scene.postProcessing.ssr.enabled && !this.softwareConfig.disableSSR;
    }
    if (this.bloomPass) {
      this.bloomPass.enabled = scene.postProcessing.bloom.enabled;
      this.bloomPass.threshold = scene.postProcessing.bloom.threshold;
      this.bloomPass.intensity = scene.postProcessing.bloom.intensity;
    }
    if (this.toneMappingPass) {
      this.toneMappingPass.bloomIntensity = scene.postProcessing.bloom.intensity;
      this.toneMappingPass.godRaysIntensity = scene.postProcessing.godRays.intensity;
    }
    if (this.godRaysPass) {
      this.godRaysPass.enabled = scene.postProcessing.godRays.enabled;
      this.godRaysPass.intensity = scene.postProcessing.godRays.intensity;
      this.godRaysPass.decay = scene.postProcessing.godRays.decay;
      this.godRaysPass.density = scene.postProcessing.godRays.density;
      this.godRaysPass.weight = scene.postProcessing.godRays.weight;
      this.godRaysPass.exposure = scene.postProcessing.godRays.exposure;
      this.godRaysPass.samples = scene.postProcessing.godRays.samples;
      this.godRaysPass.maxDistance = scene.postProcessing.godRays.maxDistance;
    }
    if (this.depthOfFieldPass) {
      this.depthOfFieldPass.enabled = camera.depthOfField.enabled && !this.softwareConfig.disableDoF;
    }
    if (this.motionBlurPass) {
      this.motionBlurPass.enabled = camera.motionBlur.enabled && !this.softwareConfig.disableMotionBlur;
    }
    if (this.lensEffectsPass) {
      this.lensEffectsPass.distortionEnabled = camera.lensEffects.distortionEnabled;
      this.lensEffectsPass.chromaticAberrationEnabled = camera.lensEffects.chromaticAberrationEnabled;
      this.lensEffectsPass.vignetteEnabled = camera.lensEffects.vignetteEnabled;
      this.lensEffectsPass.tiltShiftEnabled = camera.tiltShift.enabled;
    }
    this.debugger?.registerScene(scene);
    this.debugger?.registerCamera(camera);
    this.frameIndex++;
    if (this.taaPass && this.taaPass.enabled) {
      const width = this.canvas.width;
      const height = this.canvas.height;
      const halton = (index, base) => {
        let result = 0;
        let f = 1 / base;
        let i = index;
        while (i > 0) {
          result = result + f * (i % base);
          i = Math.floor(i / base);
          f = f / base;
        }
        return result;
      };
      const jitterX = halton(this.frameIndex % 16 + 1, 2) - 0.5;
      const jitterY = halton(this.frameIndex % 16 + 1, 3) - 0.5;
      camera.projectionJitter.set(2 * jitterX / width, 2 * jitterY / height);
    } else {
      camera.projectionJitter.set(0, 0);
    }
    camera.updateProjectionMatrix();
    camera.updateViewMatrix();
    if (this.canvas.width !== this.canvas.clientWidth || this.canvas.height !== this.canvas.clientHeight) {
      if (this.canvas.clientWidth === 0 || this.canvas.clientHeight === 0) {
        return;
      }
      console.log(`Engine: Resizing from ${this.canvas.width}x${this.canvas.height} to ${this.canvas.clientWidth}x${this.canvas.clientHeight}`);
      this.canvas.width = this.canvas.clientWidth;
      this.canvas.height = this.canvas.clientHeight;
      this.renderGraph.resize(this.canvas.width, this.canvas.height);
      camera.aspect = this.canvas.width / this.canvas.height;
      console.log(`Engine: Camera aspect updated to ${camera.aspect}`);
    }
    let currentSource = null;
    if (this.gBuffer && this.gBuffer.accumulationTexture) {
      currentSource = this.gBuffer.accumulationTexture;
    }
    if (this.ssrPass && this.ssrPass.enabled && currentSource) {
      this.ssrPass.setInputTexture(currentSource);
    }
    let godRaysOutput = null;
    if (this.godRaysPass && this.godRaysPass.enabled && currentSource) {
      this.godRaysPass.setInputTexture(currentSource);
      godRaysOutput = this.godRaysPass.getOutputTexture();
    }
    if (this.taaPass && this.taaPass.enabled) {
      const taaHistory = this.taaPass.getHistoryTexture();
      if (taaHistory) {
        currentSource = taaHistory;
      }
      if (this.ssgiPass) {
        const prevFrame = this.taaPass.getPreviousFrameTexture();
        if (prevFrame) {
          this.ssgiPass.setPreviousFrameTexture(prevFrame);
        }
      }
    }
    if (this.fxaaPass && this.fxaaPass.enabled && currentSource) {
      this.fxaaPass.setInputTexture(currentSource);
      const fxaaOutput = this.fxaaPass.getOutputTexture();
      if (fxaaOutput) {
        currentSource = fxaaOutput;
      }
    }
    if (this.depthOfFieldPass && this.depthOfFieldPass.enabled && currentSource) {
      this.depthOfFieldPass.setInputTexture(currentSource);
      const dofOutput = this.depthOfFieldPass.getOutputTexture();
      if (dofOutput) {
        currentSource = dofOutput;
      }
    }
    if (this.motionBlurPass && this.motionBlurPass.enabled && currentSource) {
      this.motionBlurPass.setInputTexture(currentSource);
      const motionBlurOutput = this.motionBlurPass.getOutputTexture();
      if (motionBlurOutput) {
        currentSource = motionBlurOutput;
      }
    }
    if (this.lensEffectsPass && this.lensEffectsPass.enabled && currentSource) {
      this.lensEffectsPass.setInputTexture(currentSource);
      const lensOutput = this.lensEffectsPass.getOutputTexture();
      if (lensOutput) {
        currentSource = lensOutput;
      }
    }
    let bloomOutput = null;
    if (this.bloomPass && this.bloomPass.enabled && currentSource) {
      this.bloomPass.setInputTexture(currentSource);
      bloomOutput = this.bloomPass.getOutputTexture();
    }
    if (this.toneMappingPass && currentSource) {
      this.toneMappingPass.setInputTexture(currentSource);
      this.toneMappingPass.setBloomTexture(bloomOutput);
      this.toneMappingPass.setGodRaysTexture(godRaysOutput);
    }
    const activeSubScene = scene.findActiveSubScene();
    const effectiveCamera = activeSubScene?.activeCamera ?? camera;
    const effectiveLights = activeSubScene?.lights ?? scene.lights;
    const context = {
      scene,
      camera: effectiveCamera,
      activeSubScene,
      modelMatrix: effectiveCamera.viewMatrix,
      lights: effectiveLights,
      deltaTime: this.currentDeltaTime,
      time: this.totalTime,
      frameStats: {
        triangles: 0,
        drawCalls: 0
      }
    };
    const globalRes = this.renderGraph.getGlobalResources();
    if (globalRes) {
      globalRes.updateLightBuffer(this.device, scene, camera);
      this.device.queue.writeBuffer(globalRes.statsBuffer, 0, Engine.STATS_ZERO_BUFFER);
    }
    this.renderGraph.execute(this.device, context);
    const selectedNode = this.debugger?.getSelectedNode();
    if (selectedNode && this.gBuffer && this.gBuffer.depthTexture && this.context) {
      this.selectionRenderer.setSelectedNode(selectedNode);
      const selectionEncoder = this.device.createCommandEncoder({ label: "Selection Render" });
      const colorView = this.context.getCurrentTexture().createView();
      const depthView = this.gBuffer.depthTexture.createView();
      this.selectionRenderer.render(selectionEncoder, colorView, depthView, camera);
      this.device.queue.submit([selectionEncoder.finish()]);
    }
    if (globalRes && this.statsReadBuffer && this.statsReadBuffer.mapState === "unmapped") {
      const copyEncoder = this.device.createCommandEncoder();
      copyEncoder.copyBufferToBuffer(globalRes.statsBuffer, 0, this.statsReadBuffer, 0, 16);
      this.device.queue.submit([copyEncoder.finish()]);
      this.statsReadBuffer.mapAsync(GPUMapMode.READ).then(() => {
        if (!this.statsReadBuffer)
          return;
        const arrayBuffer = this.statsReadBuffer.getMappedRange();
        const data = new Uint32Array(arrayBuffer);
        this.debugger?.setGpuStats(data[0], data[1]);
        this.statsReadBuffer.unmap();
      }).catch(() => {});
    }
    scene.updatePreviousFrame();
    camera.updatePreviousMatrices();
    this.debugger?.setFrameTriangles(context.frameStats.triangles);
    this.debugger?.setSceneTriangles(scene.totalTriangleCount);
    this.debugger?.update(performance.now());
  }
  preparedScenes = new WeakSet;
  initializingNodes = new WeakSet;
  async prepareScene(scene) {
    if (!this.device)
      return;
    if (this.preparedScenes.has(scene))
      return;
    const device = this.device;
    const pendingInits = [];
    scene.traverse((node) => {
      if (node.needsInit && !this.initializingNodes.has(node)) {
        this.initializingNodes.add(node);
        node._initState = "initializing";
        const initPromise = node.onInit(device).then(() => {
          node._initState = "ready";
          this.initializingNodes.delete(node);
        }).catch((err) => {
          console.error(`Failed to initialize ${node.name}:`, err);
          node._initState = "error";
          this.initializingNodes.delete(node);
        });
        pendingInits.push(initPromise);
      }
    });
    if (pendingInits.length > 0) {
      console.log(`Engine: Initializing ${pendingInits.length} nodes...`);
      await Promise.all(pendingInits);
      console.log(`Engine: Scene preparation complete`);
    }
    this.preparedScenes.add(scene);
  }
  processSceneUpdates(scene, deltaTime) {
    scene.traverse((node) => {
      if (node.needsUpdate && node.initState === "ready") {
        node.onUpdate(deltaTime);
      }
    });
  }
  run(callback) {
    let lastTime = performance.now();
    const loop = (time) => {
      if (!this.device)
        return;
      const dt = (time - lastTime) / 1000;
      lastTime = time;
      this.currentDeltaTime = dt;
      this.totalTime += dt;
      this.lastRenderTime = time;
      callback(dt);
      requestAnimationFrame(loop);
    };
    requestAnimationFrame(loop);
  }
  cleanup() {
    this.debugger?.cleanup();
    this.selectionRenderer.cleanup();
    const device = this.device;
    const context = this.context;
    this.device = null;
    this.context = null;
    try {
      this.statsReadBuffer?.destroy();
    } catch (e) {}
    this.statsReadBuffer = null;
    this.gBuffer = null;
    this.taaPass = null;
    this.ssgiPass = null;
    this.ssaoPass = null;
    this.bloomPass = null;
    this.ssrPass = null;
    this.toneMappingPass = null;
    this.depthOfFieldPass = null;
    this.motionBlurPass = null;
    this.lensEffectsPass = null;
    this.godRaysPass = null;
    if (context) {
      try {
        context.unconfigure();
      } catch (e) {}
    }
    if (device) {
      setTimeout(() => {
        try {
          device.destroy();
        } catch (e) {}
      }, 100);
    }
  }
}

// ../../src/core/InputManager.ts
class InputManager {
  digital = {
    forward: false,
    backward: false,
    left: false,
    right: false,
    up: false,
    down: false
  };
  keys = new Set;
  analog = {
    x: 0,
    y: 0,
    zoom: 0,
    touching: false
  };
  lastPinchDistance = null;
  element;
  handlers = {};
  constructor(element) {
    this.element = element;
    this.setupListeners();
  }
  setupListeners() {
    this.handlers.keydown = (e) => {
      this.keys.add(e.code);
      this.setDigital(e, true);
    };
    this.handlers.keyup = (e) => {
      this.keys.delete(e.code);
      this.setDigital(e, false);
    };
    this.handlers.pointerdown = (e) => {
      this.analog.touching = true;
      try {
        this.element.setPointerCapture(e.pointerId);
      } catch {}
    };
    this.handlers.pointerup = (e) => {
      this.analog.touching = false;
      try {
        this.element.releasePointerCapture(e.pointerId);
      } catch {}
      this.lastPinchDistance = null;
    };
    this.handlers.pointermove = (e) => {
      if (!e.isPrimary && e.pointerType === "touch")
        return;
      const isMouseDown = e.pointerType === "mouse" ? (e.buttons & 1) !== 0 : true;
      if (this.analog.touching || isMouseDown) {
        this.analog.x += e.movementX;
        this.analog.y += e.movementY;
      }
    };
    this.handlers.touchstart = (e) => {
      if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        this.lastPinchDistance = Math.sqrt(dx * dx + dy * dy);
      }
    };
    this.handlers.touchmove = (e) => {
      if (e.touches.length === 2 && this.lastPinchDistance !== null) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const delta = distance - this.lastPinchDistance;
        this.analog.zoom -= delta * 0.05;
        this.lastPinchDistance = distance;
        if (e.cancelable)
          e.preventDefault();
      }
    };
    this.handlers.touchend = (e) => {
      if (e.touches.length < 2) {
        this.lastPinchDistance = null;
      }
    };
    this.handlers.wheel = (e) => {
      e.preventDefault();
      this.analog.zoom += Math.sign(e.deltaY);
    };
    this.handlers.contextmenu = (e) => e.preventDefault();
    window.addEventListener("keydown", this.handlers.keydown);
    window.addEventListener("keyup", this.handlers.keyup);
    this.element.style.touchAction = "none";
    this.element.addEventListener("pointerdown", this.handlers.pointerdown);
    this.element.addEventListener("pointerup", this.handlers.pointerup);
    this.element.addEventListener("pointermove", this.handlers.pointermove);
    this.element.addEventListener("touchstart", this.handlers.touchstart, { passive: false });
    this.element.addEventListener("touchmove", this.handlers.touchmove, { passive: false });
    this.element.addEventListener("touchend", this.handlers.touchend);
    this.element.addEventListener("wheel", this.handlers.wheel, { passive: false });
    this.element.addEventListener("contextmenu", this.handlers.contextmenu);
  }
  dispose() {
    window.removeEventListener("keydown", this.handlers.keydown);
    window.removeEventListener("keyup", this.handlers.keyup);
    this.element.removeEventListener("pointerdown", this.handlers.pointerdown);
    this.element.removeEventListener("pointerup", this.handlers.pointerup);
    this.element.removeEventListener("pointermove", this.handlers.pointermove);
    this.element.removeEventListener("touchstart", this.handlers.touchstart);
    this.element.removeEventListener("touchmove", this.handlers.touchmove);
    this.element.removeEventListener("touchend", this.handlers.touchend);
    this.element.removeEventListener("wheel", this.handlers.wheel);
    this.element.removeEventListener("contextmenu", this.handlers.contextmenu);
  }
  setDigital(e, value) {
    switch (e.code) {
      case "KeyW":
      case "ArrowUp":
        this.digital.forward = value;
        break;
      case "KeyS":
      case "ArrowDown":
        this.digital.backward = value;
        break;
      case "KeyA":
      case "ArrowLeft":
        this.digital.left = value;
        break;
      case "KeyD":
      case "ArrowRight":
        this.digital.right = value;
        break;
      case "Space":
        this.digital.up = value;
        break;
      case "ControlLeft":
      case "KeyC":
        this.digital.down = value;
        break;
    }
  }
  update() {
    const state = {
      digital: { ...this.digital },
      keys: new Set(this.keys),
      analog: { ...this.analog }
    };
    this.analog.x = 0;
    this.analog.y = 0;
    this.analog.zoom = 0;
    return state;
  }
}

// ../../src/core/controllers/CameraController.ts
class CameraController {
  camera;
  constructor(camera) {
    this.camera = camera;
  }
}

// ../../src/core/controllers/WASDController.ts
class WASDController extends CameraController {
  pitch = 0;
  yaw = 0;
  velocity = Vector3.zero;
  movementSpeed = 10;
  rotationSpeed = 1;
  frictionCoefficient = 0.99;
  zoomSpeedMultiplier = 25;
  constructor(camera) {
    super(camera);
    const forward = this.camera.transform.getForwardVector();
    this.pitch = Math.asin(forward.y);
    this.yaw = Math.atan2(-forward.x, -forward.z);
  }
  update(deltaTime, input) {
    this.yaw -= input.analog.x * deltaTime * this.rotationSpeed;
    this.pitch -= input.analog.y * deltaTime * this.rotationSpeed;
    this.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.pitch));
    this.yaw = this.yaw % (Math.PI * 2);
    this.camera.transform.rotation = Quaternion.fromEuler(new Vector3(this.pitch, this.yaw, 0), "YXZ");
    const forward = this.camera.transform.getForwardVector();
    const right = this.camera.transform.getRightVector();
    const up = this.camera.transform.getUpVector();
    let keyboardDir = Vector3.zero;
    if (input.digital.forward)
      keyboardDir = keyboardDir.add(forward);
    if (input.digital.backward)
      keyboardDir = keyboardDir.subtract(forward);
    if (input.digital.right)
      keyboardDir = keyboardDir.add(right);
    if (input.digital.left)
      keyboardDir = keyboardDir.subtract(right);
    if (input.digital.up)
      keyboardDir = keyboardDir.add(up);
    if (input.digital.down)
      keyboardDir = keyboardDir.subtract(up);
    let moveDir = Vector3.zero;
    if (keyboardDir.magnitudeSquared() > 0) {
      moveDir = keyboardDir.normalize().multiply(this.movementSpeed);
    }
    if (input.analog.zoom !== 0) {
      const zoomSpeed = this.movementSpeed * this.zoomSpeedMultiplier;
      moveDir = moveDir.subtract(forward.multiply(input.analog.zoom * zoomSpeed));
    }
    const frictionFactor = Math.pow(1 - this.frictionCoefficient, deltaTime);
    this.velocity = moveDir.lerp(this.velocity, frictionFactor);
    this.camera.transform.position = this.camera.transform.position.add(this.velocity.multiply(deltaTime));
  }
}

// ../../src/geometries/SphereGeometry.ts
class SphereGeometry extends Geometry {
  constructor(radius = 1, widthSegments = 32, heightSegments = 16) {
    super();
    const r = Math.max(0, radius);
    const widthSegs = Math.max(3, Math.floor(widthSegments));
    const heightSegs = Math.max(2, Math.floor(heightSegments));
    const vertices = [];
    const normals = [];
    const uvs = [];
    const indices = [];
    for (let y = 0;y <= heightSegs; y++) {
      const phi = Math.acos(-1 + 2 * y / heightSegs);
      const sinPhi = Math.sin(phi);
      const cosPhi = Math.cos(phi);
      const v = y / heightSegs;
      for (let x = 0;x <= widthSegs; x++) {
        const u = x / widthSegs;
        const theta = u * Math.PI * 2;
        const sinTheta = Math.sin(theta);
        const cosTheta = Math.cos(theta);
        const nx = cosTheta * sinPhi;
        const ny = cosPhi;
        const nz = sinTheta * sinPhi;
        vertices.push(r * nx, r * ny, r * nz);
        normals.push(nx, ny, nz);
        uvs.push(u, 1 - v);
      }
    }
    for (let y = 0;y < heightSegs; y++) {
      for (let x = 0;x < widthSegs; x++) {
        const a = x + (widthSegs + 1) * y;
        const b = x + (widthSegs + 1) * (y + 1);
        const c = x + 1 + (widthSegs + 1) * (y + 1);
        const d = x + 1 + (widthSegs + 1) * y;
        if (y !== 0) {
          indices.push(a, b, d);
        }
        if (y !== heightSegs - 1) {
          indices.push(b, c, d);
        }
      }
    }
    this.setAttribute("position", new Float32Array(vertices));
    this.setAttribute("normal", new Float32Array(normals));
    this.setAttribute("uv", new Float32Array(uvs));
    this.setIndices(new Uint16Array(indices));
  }
}

// examples/internal/mystral-test/sponza-native.ts
async function main() {
  console.log("Mystral Native - Sponza Demo Starting");
  const canvas = document.getElementById("canvas");
  if (!canvas) {
    throw new Error("No canvas found");
  }
  console.log("Creating Engine...");
  const engine = new Engine(canvas, { disableDebugger: true });
  await engine.init();
  console.log("Engine initialized");
  const scene = new Scene(engine);
  console.log("Scene created");
  scene.shadows.resolution = 2048;
  scene.shadows.maxLights = 2;
  scene.render.occlusionCulling = false;
  scene.postProcessing.aa.enabled = true;
  scene.postProcessing.bloom.enabled = true;
  scene.postProcessing.bloom.threshold = 1.5;
  scene.postProcessing.bloom.intensity = 1;
  scene.postProcessing.tonemapping.enabled = true;
  scene.postProcessing.tonemapping.exposure = 1;
  scene.postProcessing.ssao.enabled = false;
  scene.postProcessing.fxaa.enabled = false;
  scene.postProcessing.ssr.enabled = false;
  scene.globalIllumination.enabled = false;
  scene.globalIllumination.intensity = 0.2;
  scene.postProcessing.godRays.enabled = true;
  scene.postProcessing.godRays.intensity = 0.3;
  scene.postProcessing.godRays.decay = 0.97;
  scene.postProcessing.godRays.density = 0.5;
  scene.postProcessing.godRays.weight = 0.1;
  scene.postProcessing.godRays.exposure = 0.3;
  scene.postProcessing.godRays.samples = 80;
  scene.postProcessing.godRays.maxDistance = 1.5;
  scene.atmosphere.enabled = true;
  scene.atmosphere.sunIlluminance = new Vector3(10, 10, 10);
  scene.atmosphere.sunDiskEnabled = true;
  scene.atmosphere.sunDiskScale = 2.5;
  scene.atmosphere.moonEnabled = true;
  scene.atmosphere.moonPhase = 0.5;
  scene.atmosphere.moonScale = 1.8;
  scene.atmosphere.starsEnabled = true;
  scene.atmosphere.starsIntensity = 1;
  scene.atmosphere.starsTwinkle = 0.3;
  scene.fog.enabled = true;
  scene.fog.type = "EXP2";
  scene.fog.density = 0.002;
  scene.fog.color = new Vector3(0.5, 0.6, 0.7);
  console.log("Scene settings configured");
  const device = engine.getDevice();
  const sponzaPath = "./examples/assets/Sponza.glb";
  console.log("Loading Sponza...");
  let sponzaNode = null;
  try {
    const loader = new GLBLoader(device, { dracoDecoderPath: "./draco/" });
    const result = await loader.load(sponzaPath);
    sponzaNode = result.rootNode;
    if (sponzaNode) {
      sponzaNode.transform.scale = new Vector3(1, 1, 1);
      scene.addChild(sponzaNode);
      console.log("Sponza loaded and added to scene");
    }
  } catch (e) {
    console.log("Failed to load Sponza:", e.message || e);
  }
  const sunLight = new DirectionalLight(new Vector3(1, 0.95, 0.8), 4);
  sunLight.transform.position = new Vector3(20, 50, 10);
  sunLight.transform.lookAt(new Vector3(0, 0, 0));
  sunLight.shadow.castShadow = true;
  sunLight.shadow.bias = 0.001;
  sunLight.shadow.normalBias = 0.02;
  scene.addLight(sunLight);
  console.log("Sun light added");
  const moonLight = new DirectionalLight(new Vector3(0.6, 0.7, 0.9), 0);
  moonLight.transform.position = new Vector3(-20, 50, -10);
  moonLight.transform.lookAt(new Vector3(0, 0, 0));
  moonLight.shadow.castShadow = true;
  moonLight.shadow.bias = 0.001;
  moonLight.shadow.normalBias = 0.02;
  moonLight.shadow.intensity = 0.95;
  scene.addLight(moonLight);
  console.log("Moon light added");
  const ambientLight = new AmbientLight(new Vector3(1, 1, 1), 0.6);
  scene.addLight(ambientLight);
  console.log("Ambient light added");
  const torchPositions = [
    new Vector3(-10, 1, 0),
    new Vector3(10, 1, 0),
    new Vector3(-10, 1, -5),
    new Vector3(10, 1, -5),
    new Vector3(0, 1, 5)
  ];
  const torchLights = [];
  const torchFlameMaterials = [];
  torchPositions.forEach((pos) => {
    const light = new PointLight(new Vector3(1, 0.6, 0.2), 0, 30, 1.5);
    light.transform.position = pos.clone();
    light.transform.position.y += 0.5;
    scene.addLight(light);
    torchLights.push(light);
    const flameMat = new StandardMaterial;
    flameMat.albedo = new Vector3(0.3, 0.3, 0.3);
    flameMat.emissive = new Vector3(0, 0, 0);
    torchFlameMaterials.push(flameMat);
  });
  console.log("Torch lights added:", torchLights.length);
  const fireflies = [];
  const fireflyColors = [
    new Vector3(1, 0.9, 0.5),
    new Vector3(0.5, 1, 0.8),
    new Vector3(1, 0.5, 0.8),
    new Vector3(0.8, 0.6, 1),
    new Vector3(0.5, 0.8, 1),
    new Vector3(1, 0.7, 0.4),
    new Vector3(0.6, 1, 0.6),
    new Vector3(1, 0.4, 0.4)
  ];
  for (let i = 0;i < 10; i++) {
    const basePos = new Vector3((Math.random() - 0.5) * 20, 1.5 + Math.random() * 3, (Math.random() - 0.5) * 10);
    const color = fireflyColors[i % fireflyColors.length].clone();
    const light = new PointLight(color.clone(), 0, 8, 1.5);
    light.transform.position = basePos.clone();
    scene.addLight(light);
    const mat = new StandardMaterial;
    mat.albedo = new Vector3(0.3, 0.3, 0.3);
    mat.emissive = new Vector3(0, 0, 0);
    const mesh = new Mesh(new SphereGeometry(0.08, 8, 4), mat);
    mesh.transform.position = basePos.clone();
    scene.addChild(mesh);
    fireflies.push({
      light,
      mesh,
      material: mat,
      basePos,
      color,
      phase: new Vector3(Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, Math.random() * Math.PI * 2),
      speed: new Vector3(0.08 + Math.random() * 0.12, 0.06 + Math.random() * 0.08, 0.08 + Math.random() * 0.12),
      amplitude: new Vector3(1.5 + Math.random() * 2, 0.5 + Math.random() * 1, 1.5 + Math.random() * 2)
    });
  }
  console.log("Fireflies added:", fireflies.length);
  const camera = new Camera(60, canvas.width / canvas.height, 0.1, 1000);
  camera.transform.position = new Vector3(0.5, 2, -0.75);
  camera.transform.rotation = Quaternion.fromAxisAngle(new Vector3(0, 1, 0), Math.PI / 2);
  const inputManager = new InputManager(canvas);
  const controller = new WASDController(camera);
  controller.movementSpeed = 10;
  console.log("WASD Controller initialized - use WASD to move, mouse to look");
  let timeOfDay = 12;
  const cycleSpeed = 1;
  let fireflyTime = 0;
  const moonPhase = 0.5;
  function timeToSunAngle(hours) {
    return (hours - 6) / 24 * Math.PI * 2;
  }
  function updateCelestials() {
    const angle = timeToSunAngle(timeOfDay);
    const sunY = Math.sin(angle);
    const sunX = Math.cos(angle);
    const sunDir = new Vector3(sunX, sunY, 0.2).normalize();
    scene.atmosphere.sunDirection.copy(sunDir);
    const moonAngle = angle + Math.PI + (moonPhase - 0.5) * 0.3;
    const moonY = Math.sin(moonAngle);
    const moonX = Math.cos(moonAngle);
    const moonDir = new Vector3(moonX, moonY, -0.1).normalize();
    scene.atmosphere.moonDirection.copy(moonDir);
    sunLight.transform.position = sunDir.multiplyScalar(100);
    sunLight.transform.lookAt(new Vector3(0, 0, 0));
    const elevation = Math.max(0, sunDir.y);
    const isDaytime = sunDir.y > 0.1;
    sunLight.intensity = 3 * elevation;
    sunLight.color = new Vector3(1, Math.min(1, 0.5 + 0.5 * elevation), Math.min(1, 0.2 + 0.8 * elevation));
    sunLight.shadow.castShadow = isDaytime;
    scene.atmosphere.sunIlluminance.copy(sunLight.color.clone().multiplyScalar(10));
    moonLight.transform.position = moonDir.multiplyScalar(100);
    moonLight.transform.lookAt(new Vector3(0, 0, 0));
    const moonElevation = Math.max(0, moonDir.y);
    const isNightTime = sunDir.y < 0.1;
    const phaseBrightness = 0.5 + 0.5 * Math.abs(moonPhase - 0.5) * 2;
    const moonIntensity = isNightTime ? 0.4 * moonElevation * phaseBrightness : 0;
    moonLight.intensity = moonIntensity;
    moonLight.shadow.castShadow = isNightTime && moonElevation > 0.1;
    const torchFactor = isNightTime ? 1 - Math.max(0, (sunDir.y + 0.2) / 0.3) : 0;
    const torchActive = torchFactor > 0.01;
    torchLights.forEach((light, i) => {
      if (torchActive) {
        light.intensity = 5 * torchFactor;
        torchFlameMaterials[i].emissive = new Vector3(1.5 * torchFactor, 0.8 * torchFactor, 0.2 * torchFactor);
        torchFlameMaterials[i].albedo = new Vector3(0, 0, 0);
      } else {
        light.intensity = 0;
        torchFlameMaterials[i].emissive = new Vector3(0, 0, 0);
        torchFlameMaterials[i].albedo = new Vector3(0.3, 0.3, 0.3);
      }
    });
    return { isNightTime, nightFactor: torchFactor };
  }
  function updateFireflies(dt, isNight, nightFactor) {
    fireflyTime += dt;
    fireflies.forEach((firefly) => {
      if (!isNight || nightFactor < 0.01) {
        firefly.light.intensity = 0;
        firefly.material.emissive = new Vector3(0, 0, 0);
        firefly.material.albedo = new Vector3(0, 0, 0);
        firefly.mesh.visible = false;
        return;
      }
      firefly.mesh.visible = true;
      const offset = new Vector3(Math.sin(fireflyTime * firefly.speed.x + firefly.phase.x) * firefly.amplitude.x, Math.sin(fireflyTime * firefly.speed.y + firefly.phase.y) * firefly.amplitude.y, Math.sin(fireflyTime * firefly.speed.z + firefly.phase.z) * firefly.amplitude.z);
      const newPos = firefly.basePos.add(offset);
      firefly.light.transform.position = newPos;
      firefly.mesh.transform.position = newPos;
      firefly.light.intensity = 8 * nightFactor;
      firefly.light.color = firefly.color.clone();
      const emissiveStrength = 5 * nightFactor;
      firefly.material.emissive = firefly.color.multiplyScalar(emissiveStrength);
      firefly.material.albedo = new Vector3(0, 0, 0);
    });
  }
  function updateFog(sunDir) {
    let targetFogColor;
    if (sunDir.y > 0.2) {
      targetFogColor = new Vector3(0.5, 0.6, 0.7);
    } else if (sunDir.y > -0.1) {
      const dayColor = new Vector3(0.5, 0.6, 0.7);
      const sunsetColor = new Vector3(0.8, 0.5, 0.2);
      const nightColor = new Vector3(0.05, 0.05, 0.1);
      if (sunDir.y > 0) {
        targetFogColor = sunsetColor.lerp(dayColor, sunDir.y / 0.2);
      } else {
        targetFogColor = nightColor.lerp(sunsetColor, (sunDir.y + 0.1) / 0.1);
      }
    } else {
      targetFogColor = new Vector3(0.02, 0.02, 0.05);
    }
    scene.fog.color.copy(targetFogColor);
  }
  updateCelestials();
  let frame = 0;
  let lastTime = performance.now();
  function render() {
    const now = performance.now();
    const dt = (now - lastTime) / 1000;
    lastTime = now;
    const hoursPerSecond = cycleSpeed / 6;
    timeOfDay += dt * hoursPerSecond;
    if (timeOfDay >= 24) {
      timeOfDay -= 24;
    }
    const { isNightTime, nightFactor } = updateCelestials();
    updateFireflies(dt, isNightTime, nightFactor);
    const angle = timeToSunAngle(timeOfDay);
    const sunY = Math.sin(angle);
    const sunX = Math.cos(angle);
    const sunDir = new Vector3(sunX, sunY, 0.2).normalize();
    updateFog(sunDir);
    const inputState = inputManager.update();
    controller.update(dt, inputState);
    if (frame % 120 === 0) {
      const pos = camera.transform.position;
      const hours = Math.floor(timeOfDay);
      const mins = Math.floor((timeOfDay - hours) * 60);
      console.log(`Frame ${frame}: Time ${hours.toString().padStart(2, "0")}:${mins.toString().padStart(2, "0")}, Camera at (${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)})`);
    }
    engine.render(scene, camera);
    frame++;
    requestAnimationFrame(render);
  }
  console.log("Starting render loop with day/night cycle...");
  console.log("Time cycles from sunrise (6am) through day, sunset, night, and back");
  render();
}
main().catch((e) => {
  console.log("Error:", e.message || e);
});
